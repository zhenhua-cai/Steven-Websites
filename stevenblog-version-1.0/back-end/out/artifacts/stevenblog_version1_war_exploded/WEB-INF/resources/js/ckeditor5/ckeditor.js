/*!
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */
(function (t) {
    const e = t["en"] = t["en"] || {};
    e.dictionary = Object.assign(e.dictionary || {}, {
        "%0 of %1": "%0 of %1",
        "Align cell text to the bottom": "Align cell text to the bottom",
        "Align cell text to the center": "Align cell text to the center",
        "Align cell text to the left": "Align cell text to the left",
        "Align cell text to the middle": "Align cell text to the middle",
        "Align cell text to the right": "Align cell text to the right",
        "Align cell text to the top": "Align cell text to the top",
        "Align center": "Align center",
        "Align left": "Align left",
        "Align right": "Align right",
        "Align table to the left": "Align table to the left",
        "Align table to the right": "Align table to the right",
        Alignment: "Alignment",
        "Almost equal to": "Almost equal to",
        Angle: "Angle",
        "Approximately equal to": "Approximately equal to",
        Aquamarine: "Aquamarine",
        "Asterisk operator": "Asterisk operator",
        "Austral sign": "Austral sign",
        "back with leftwards arrow above": "back with leftwards arrow above",
        Background: "Background",
        Big: "Big",
        "Bitcoin sign": "Bitcoin sign",
        Black: "Black",
        "Block quote": "Block quote",
        Blue: "Blue",
        "Blue marker": "Blue marker",
        Bold: "Bold",
        Border: "Border",
        "Bulleted List": "Bulleted List",
        "Bulleted list styles toolbar": "Bulleted list styles toolbar",
        Cancel: "Cancel",
        "Cedi sign": "Cedi sign",
        "Cell properties": "Cell properties",
        "Cent sign": "Cent sign",
        "Center table": "Center table",
        "Centered image": "Centered image",
        "Change image text alternative": "Change image text alternative",
        "Character categories": "Character categories",
        "Choose heading": "Choose heading",
        Circle: "Circle",
        Code: "Code",
        "Colon sign": "Colon sign",
        Color: "Color",
        "Color picker": "Color picker",
        Column: "Column",
        "Contains as member": "Contains as member",
        "Copyright sign": "Copyright sign",
        "Cruzeiro sign": "Cruzeiro sign",
        "Currency sign": "Currency sign",
        Dashed: "Dashed",
        Decimal: "Decimal",
        "Decimal with leading zero": "Decimal with leading zero",
        "Decrease indent": "Decrease indent",
        Default: "Default",
        "Degree sign": "Degree sign",
        "Delete column": "Delete column",
        "Delete row": "Delete row",
        "Dim grey": "Dim grey",
        Dimensions: "Dimensions",
        Disc: "Disc",
        "Division sign": "Division sign",
        "Document colors": "Document colors",
        "Dollar sign": "Dollar sign",
        "Dong sign": "Dong sign",
        Dotted: "Dotted",
        Double: "Double",
        "Double dagger": "Double dagger",
        "Double exclamation mark": "Double exclamation mark",
        "Double low-9 quotation mark": "Double low-9 quotation mark",
        "Double question mark": "Double question mark",
        Downloadable: "Downloadable",
        "downwards arrow to bar": "downwards arrow to bar",
        "downwards dashed arrow": "downwards dashed arrow",
        "downwards double arrow": "downwards double arrow",
        "Drachma sign": "Drachma sign",
        "Dropdown toolbar": "Dropdown toolbar",
        "Edit link": "Edit link",
        "Edit source": "Edit source",
        "Editor toolbar": "Editor toolbar",
        "Element of": "Element of",
        "Em dash": "Em dash",
        "Empty set": "Empty set",
        "En dash": "En dash",
        "end with leftwards arrow above": "end with leftwards arrow above",
        "Enter image caption": "Enter image caption",
        "Euro sign": "Euro sign",
        "Euro-currency sign": "Euro-currency sign",
        "Exclamation question mark": "Exclamation question mark",
        "Font Background Color": "Font Background Color",
        "Font Color": "Font Color",
        "Font Family": "Font Family",
        "Font Size": "Font Size",
        "For all": "For all",
        "Fraction slash": "Fraction slash",
        "French franc sign": "French franc sign",
        "Full size image": "Full size image",
        "German penny sign": "German penny sign",
        "Greater-than or equal to": "Greater-than or equal to",
        "Greater-than sign": "Greater-than sign",
        Green: "Green",
        "Green marker": "Green marker",
        "Green pen": "Green pen",
        Grey: "Grey",
        Groove: "Groove",
        "Guarani sign": "Guarani sign",
        "Header column": "Header column",
        "Header row": "Header row",
        Heading: "Heading",
        "Heading 1": "Heading 1",
        "Heading 2": "Heading 2",
        "Heading 3": "Heading 3",
        "Heading 4": "Heading 4",
        "Heading 5": "Heading 5",
        "Heading 6": "Heading 6",
        Height: "Height",
        Highlight: "Highlight",
        "Horizontal ellipsis": "Horizontal ellipsis",
        "Horizontal line": "Horizontal line",
        "Horizontal text alignment toolbar": "Horizontal text alignment toolbar",
        "Hryvnia sign": "Hryvnia sign",
        "HTML snippet": "HTML snippet",
        Huge: "Huge",
        "Identical to": "Identical to",
        "Image resize list": "Image resize list",
        "Image toolbar": "Image toolbar",
        "image widget": "image widget",
        "Increase indent": "Increase indent",
        "Indian rupee sign": "Indian rupee sign",
        Infinity: "Infinity",
        Insert: "Insert",
        "Insert code block": "Insert code block",
        "Insert column left": "Insert column left",
        "Insert column right": "Insert column right",
        "Insert HTML": "Insert HTML",
        "Insert image": "Insert image",
        "Insert image via URL": "Insert image via URL",
        "Insert media": "Insert media",
        "Insert paragraph after block": "Insert paragraph after block",
        "Insert paragraph before block": "Insert paragraph before block",
        "Insert row above": "Insert row above",
        "Insert row below": "Insert row below",
        "Insert table": "Insert table",
        Inset: "Inset",
        Integral: "Integral",
        Intersection: "Intersection",
        "Inverted exclamation mark": "Inverted exclamation mark",
        "Inverted question mark": "Inverted question mark",
        Italic: "Italic",
        Justify: "Justify",
        "Justify cell text": "Justify cell text",
        "Kip sign": "Kip sign",
        "Latin capital letter a with breve": "Latin capital letter a with breve",
        "Latin capital letter a with macron": "Latin capital letter a with macron",
        "Latin capital letter a with ogonek": "Latin capital letter a with ogonek",
        "Latin capital letter c with acute": "Latin capital letter c with acute",
        "Latin capital letter c with caron": "Latin capital letter c with caron",
        "Latin capital letter c with circumflex": "Latin capital letter c with circumflex",
        "Latin capital letter c with dot above": "Latin capital letter c with dot above",
        "Latin capital letter d with caron": "Latin capital letter d with caron",
        "Latin capital letter d with stroke": "Latin capital letter d with stroke",
        "Latin capital letter e with breve": "Latin capital letter e with breve",
        "Latin capital letter e with caron": "Latin capital letter e with caron",
        "Latin capital letter e with dot above": "Latin capital letter e with dot above",
        "Latin capital letter e with macron": "Latin capital letter e with macron",
        "Latin capital letter e with ogonek": "Latin capital letter e with ogonek",
        "Latin capital letter eng": "Latin capital letter eng",
        "Latin capital letter g with breve": "Latin capital letter g with breve",
        "Latin capital letter g with cedilla": "Latin capital letter g with cedilla",
        "Latin capital letter g with circumflex": "Latin capital letter g with circumflex",
        "Latin capital letter g with dot above": "Latin capital letter g with dot above",
        "Latin capital letter h with circumflex": "Latin capital letter h with circumflex",
        "Latin capital letter h with stroke": "Latin capital letter h with stroke",
        "Latin capital letter i with breve": "Latin capital letter i with breve",
        "Latin capital letter i with dot above": "Latin capital letter i with dot above",
        "Latin capital letter i with macron": "Latin capital letter i with macron",
        "Latin capital letter i with ogonek": "Latin capital letter i with ogonek",
        "Latin capital letter i with tilde": "Latin capital letter i with tilde",
        "Latin capital letter j with circumflex": "Latin capital letter j with circumflex",
        "Latin capital letter k with cedilla": "Latin capital letter k with cedilla",
        "Latin capital letter l with acute": "Latin capital letter l with acute",
        "Latin capital letter l with caron": "Latin capital letter l with caron",
        "Latin capital letter l with cedilla": "Latin capital letter l with cedilla",
        "Latin capital letter l with middle dot": "Latin capital letter l with middle dot",
        "Latin capital letter l with stroke": "Latin capital letter l with stroke",
        "Latin capital letter n with acute": "Latin capital letter n with acute",
        "Latin capital letter n with caron": "Latin capital letter n with caron",
        "Latin capital letter n with cedilla": "Latin capital letter n with cedilla",
        "Latin capital letter o with breve": "Latin capital letter o with breve",
        "Latin capital letter o with double acute": "Latin capital letter o with double acute",
        "Latin capital letter o with macron": "Latin capital letter o with macron",
        "Latin capital letter r with acute": "Latin capital letter r with acute",
        "Latin capital letter r with caron": "Latin capital letter r with caron",
        "Latin capital letter r with cedilla": "Latin capital letter r with cedilla",
        "Latin capital letter s with acute": "Latin capital letter s with acute",
        "Latin capital letter s with caron": "Latin capital letter s with caron",
        "Latin capital letter s with cedilla": "Latin capital letter s with cedilla",
        "Latin capital letter s with circumflex": "Latin capital letter s with circumflex",
        "Latin capital letter t with caron": "Latin capital letter t with caron",
        "Latin capital letter t with cedilla": "Latin capital letter t with cedilla",
        "Latin capital letter t with stroke": "Latin capital letter t with stroke",
        "Latin capital letter u with breve": "Latin capital letter u with breve",
        "Latin capital letter u with double acute": "Latin capital letter u with double acute",
        "Latin capital letter u with macron": "Latin capital letter u with macron",
        "Latin capital letter u with ogonek": "Latin capital letter u with ogonek",
        "Latin capital letter u with ring above": "Latin capital letter u with ring above",
        "Latin capital letter u with tilde": "Latin capital letter u with tilde",
        "Latin capital letter w with circumflex": "Latin capital letter w with circumflex",
        "Latin capital letter y with circumflex": "Latin capital letter y with circumflex",
        "Latin capital letter y with diaeresis": "Latin capital letter y with diaeresis",
        "Latin capital letter z with acute": "Latin capital letter z with acute",
        "Latin capital letter z with caron": "Latin capital letter z with caron",
        "Latin capital letter z with dot above": "Latin capital letter z with dot above",
        "Latin capital ligature ij": "Latin capital ligature ij",
        "Latin capital ligature oe": "Latin capital ligature oe",
        "Latin small letter a with breve": "Latin small letter a with breve",
        "Latin small letter a with macron": "Latin small letter a with macron",
        "Latin small letter a with ogonek": "Latin small letter a with ogonek",
        "Latin small letter c with acute": "Latin small letter c with acute",
        "Latin small letter c with caron": "Latin small letter c with caron",
        "Latin small letter c with circumflex": "Latin small letter c with circumflex",
        "Latin small letter c with dot above": "Latin small letter c with dot above",
        "Latin small letter d with caron": "Latin small letter d with caron",
        "Latin small letter d with stroke": "Latin small letter d with stroke",
        "Latin small letter dotless i": "Latin small letter dotless i",
        "Latin small letter e with breve": "Latin small letter e with breve",
        "Latin small letter e with caron": "Latin small letter e with caron",
        "Latin small letter e with dot above": "Latin small letter e with dot above",
        "Latin small letter e with macron": "Latin small letter e with macron",
        "Latin small letter e with ogonek": "Latin small letter e with ogonek",
        "Latin small letter eng": "Latin small letter eng",
        "Latin small letter f with hook": "Latin small letter f with hook",
        "Latin small letter g with breve": "Latin small letter g with breve",
        "Latin small letter g with cedilla": "Latin small letter g with cedilla",
        "Latin small letter g with circumflex": "Latin small letter g with circumflex",
        "Latin small letter g with dot above": "Latin small letter g with dot above",
        "Latin small letter h with circumflex": "Latin small letter h with circumflex",
        "Latin small letter h with stroke": "Latin small letter h with stroke",
        "Latin small letter i with breve": "Latin small letter i with breve",
        "Latin small letter i with macron": "Latin small letter i with macron",
        "Latin small letter i with ogonek": "Latin small letter i with ogonek",
        "Latin small letter i with tilde": "Latin small letter i with tilde",
        "Latin small letter j with circumflex": "Latin small letter j with circumflex",
        "Latin small letter k with cedilla": "Latin small letter k with cedilla",
        "Latin small letter kra": "Latin small letter kra",
        "Latin small letter l with acute": "Latin small letter l with acute",
        "Latin small letter l with caron": "Latin small letter l with caron",
        "Latin small letter l with cedilla": "Latin small letter l with cedilla",
        "Latin small letter l with middle dot": "Latin small letter l with middle dot",
        "Latin small letter l with stroke": "Latin small letter l with stroke",
        "Latin small letter long s": "Latin small letter long s",
        "Latin small letter n preceded by apostrophe": "Latin small letter n preceded by apostrophe",
        "Latin small letter n with acute": "Latin small letter n with acute",
        "Latin small letter n with caron": "Latin small letter n with caron",
        "Latin small letter n with cedilla": "Latin small letter n with cedilla",
        "Latin small letter o with breve": "Latin small letter o with breve",
        "Latin small letter o with double acute": "Latin small letter o with double acute",
        "Latin small letter o with macron": "Latin small letter o with macron",
        "Latin small letter r with acute": "Latin small letter r with acute",
        "Latin small letter r with caron": "Latin small letter r with caron",
        "Latin small letter r with cedilla": "Latin small letter r with cedilla",
        "Latin small letter s with acute": "Latin small letter s with acute",
        "Latin small letter s with caron": "Latin small letter s with caron",
        "Latin small letter s with cedilla": "Latin small letter s with cedilla",
        "Latin small letter s with circumflex": "Latin small letter s with circumflex",
        "Latin small letter t with caron": "Latin small letter t with caron",
        "Latin small letter t with cedilla": "Latin small letter t with cedilla",
        "Latin small letter t with stroke": "Latin small letter t with stroke",
        "Latin small letter u with breve": "Latin small letter u with breve",
        "Latin small letter u with double acute": "Latin small letter u with double acute",
        "Latin small letter u with macron": "Latin small letter u with macron",
        "Latin small letter u with ogonek": "Latin small letter u with ogonek",
        "Latin small letter u with ring above": "Latin small letter u with ring above",
        "Latin small letter u with tilde": "Latin small letter u with tilde",
        "Latin small letter w with circumflex": "Latin small letter w with circumflex",
        "Latin small letter y with circumflex": "Latin small letter y with circumflex",
        "Latin small letter z with acute": "Latin small letter z with acute",
        "Latin small letter z with caron": "Latin small letter z with caron",
        "Latin small letter z with dot above": "Latin small letter z with dot above",
        "Latin small ligature ij": "Latin small ligature ij",
        "Latin small ligature oe": "Latin small ligature oe",
        "Left aligned image": "Left aligned image",
        "Left double quotation mark": "Left double quotation mark",
        "Left single quotation mark": "Left single quotation mark",
        "Left-pointing double angle quotation mark": "Left-pointing double angle quotation mark",
        "leftwards arrow to bar": "leftwards arrow to bar",
        "leftwards dashed arrow": "leftwards dashed arrow",
        "leftwards double arrow": "leftwards double arrow",
        "Less-than or equal to": "Less-than or equal to",
        "Less-than sign": "Less-than sign",
        "Light blue": "Light blue",
        "Light green": "Light green",
        "Light grey": "Light grey",
        Link: "Link",
        "Link image": "Link image",
        "Link URL": "Link URL",
        "Lira sign": "Lira sign",
        "Livre tournois sign": "Livre tournois sign",
        "Logical and": "Logical and",
        "Logical or": "Logical or",
        "Lower-latin": "Lower-latin",
        "Lower–roman": "Lower–roman",
        Macron: "Macron",
        "Manat sign": "Manat sign",
        "Media toolbar": "Media toolbar",
        "Media URL": "Media URL",
        "media widget": "media widget",
        "Merge cell down": "Merge cell down",
        "Merge cell left": "Merge cell left",
        "Merge cell right": "Merge cell right",
        "Merge cell up": "Merge cell up",
        "Merge cells": "Merge cells",
        "Mill sign": "Mill sign",
        "Minus sign": "Minus sign",
        "Multiplication sign": "Multiplication sign",
        "N-ary product": "N-ary product",
        "N-ary summation": "N-ary summation",
        Nabla: "Nabla",
        "Naira sign": "Naira sign",
        "New sheqel sign": "New sheqel sign",
        Next: "Next",
        None: "None",
        "Nordic mark sign": "Nordic mark sign",
        "Not an element of": "Not an element of",
        "Not equal to": "Not equal to",
        "Not sign": "Not sign",
        "Numbered List": "Numbered List",
        "Numbered list styles toolbar": "Numbered list styles toolbar",
        "on with exclamation mark with left right arrow above": "on with exclamation mark with left right arrow above",
        "Open in a new tab": "Open in a new tab",
        "Open link in new tab": "Open link in new tab",
        Orange: "Orange",
        Original: "Original",
        Outset: "Outset",
        Overline: "Overline",
        Padding: "Padding",
        Paragraph: "Paragraph",
        "Paragraph sign": "Paragraph sign",
        "Partial differential": "Partial differential",
        "Paste raw HTML here...": "Paste raw HTML here...",
        "Paste the image source URL.": "Paste the image source URL.",
        "Paste the media URL in the input.": "Paste the media URL in the input.",
        "Per mille sign": "Per mille sign",
        "Per ten thousand sign": "Per ten thousand sign",
        "Peseta sign": "Peseta sign",
        "Peso sign": "Peso sign",
        "Pink marker": "Pink marker",
        "Plain text": "Plain text",
        "Plus-minus sign": "Plus-minus sign",
        "Pound sign": "Pound sign",
        Previous: "Previous",
        "Proportional to": "Proportional to",
        Purple: "Purple",
        "Question exclamation mark": "Question exclamation mark",
        Red: "Red",
        "Red pen": "Red pen",
        Redo: "Redo",
        "Registered sign": "Registered sign",
        "Remove color": "Remove color",
        "Remove Format": "Remove Format",
        "Remove highlight": "Remove highlight",
        "Resize image": "Resize image",
        "Resize image to %0": "Resize image to %0",
        "Resize image to the original size": "Resize image to the original size",
        "Reversed paragraph sign": "Reversed paragraph sign",
        "Rich Text Editor": "Rich Text Editor",
        "Rich Text Editor, %0": "Rich Text Editor, %0",
        Ridge: "Ridge",
        "Right aligned image": "Right aligned image",
        "Right double quotation mark": "Right double quotation mark",
        "Right single quotation mark": "Right single quotation mark",
        "Right-pointing double angle quotation mark": "Right-pointing double angle quotation mark",
        "rightwards arrow to bar": "rightwards arrow to bar",
        "rightwards dashed arrow": "rightwards dashed arrow",
        "rightwards double arrow": "rightwards double arrow",
        Row: "Row",
        "Ruble sign": "Ruble sign",
        "Rupee sign": "Rupee sign",
        Save: "Save",
        "Save changes": "Save changes",
        "Saving changes": "Saving changes",
        "Section sign": "Section sign",
        "Select all": "Select all",
        "Select column": "Select column",
        "Select row": "Select row",
        "Show more items": "Show more items",
        "Side image": "Side image",
        "Single left-pointing angle quotation mark": "Single left-pointing angle quotation mark",
        "Single low-9 quotation mark": "Single low-9 quotation mark",
        "Single right-pointing angle quotation mark": "Single right-pointing angle quotation mark",
        Small: "Small",
        Solid: "Solid",
        "soon with rightwards arrow above": "soon with rightwards arrow above",
        "Special characters": "Special characters",
        "Spesmilo sign": "Spesmilo sign",
        "Split cell horizontally": "Split cell horizontally",
        "Split cell vertically": "Split cell vertically",
        Square: "Square",
        "Square root": "Square root",
        Strikethrough: "Strikethrough",
        Style: "Style",
        Subscript: "Subscript",
        Superscript: "Superscript",
        "Table alignment toolbar": "Table alignment toolbar",
        "Table cell text alignment": "Table cell text alignment",
        "Table properties": "Table properties",
        "Table toolbar": "Table toolbar",
        "Tenge sign": "Tenge sign",
        "Text alignment": "Text alignment",
        "Text alignment toolbar": "Text alignment toolbar",
        "Text alternative": "Text alternative",
        "Text highlight toolbar": "Text highlight toolbar",
        'The color is invalid. Try "#FF0000" or "rgb(255,0,0)" or "red".': 'The color is invalid. Try "#FF0000" or "rgb(255,0,0)" or "red".',
        "The URL must not be empty.": "The URL must not be empty.",
        'The value is invalid. Try "10px" or "2em" or simply "2".': 'The value is invalid. Try "10px" or "2em" or simply "2".',
        "There exists": "There exists",
        "This link has no URL": "This link has no URL",
        "This media URL is not supported.": "This media URL is not supported.",
        "Tilde operator": "Tilde operator",
        Tiny: "Tiny",
        "Tip: Paste the URL into the content to embed faster.": "Tip: Paste the URL into the content to embed faster.",
        "To-do List": "To-do List",
        "Toggle the circle list style": "Toggle the circle list style",
        "Toggle the decimal list style": "Toggle the decimal list style",
        "Toggle the decimal with leading zero list style": "Toggle the decimal with leading zero list style",
        "Toggle the disc list style": "Toggle the disc list style",
        "Toggle the lower–latin list style": "Toggle the lower–latin list style",
        "Toggle the lower–roman list style": "Toggle the lower–roman list style",
        "Toggle the square list style": "Toggle the square list style",
        "Toggle the upper–latin list style": "Toggle the upper–latin list style",
        "Toggle the upper–roman list style": "Toggle the upper–roman list style",
        "top with upwards arrow above": "top with upwards arrow above",
        "Trade mark sign": "Trade mark sign",
        "Tugrik sign": "Tugrik sign",
        "Turkish lira sign": "Turkish lira sign",
        Turquoise: "Turquoise",
        "Two dot leader": "Two dot leader",
        "Type or paste your content here.": "Type or paste your content here.",
        "Type your title": "Type your title",
        Underline: "Underline",
        Undo: "Undo",
        Union: "Union",
        Unlink: "Unlink",
        "up down arrow with base": "up down arrow with base",
        Update: "Update",
        "Update image URL": "Update image URL",
        "Upload failed": "Upload failed",
        "Upload in progress": "Upload in progress",
        "Upper-latin": "Upper-latin",
        "Upper-roman": "Upper-roman",
        "upwards arrow to bar": "upwards arrow to bar",
        "upwards dashed arrow": "upwards dashed arrow",
        "upwards double arrow": "upwards double arrow",
        "Vertical text alignment toolbar": "Vertical text alignment toolbar",
        "Vulgar fraction one half": "Vulgar fraction one half",
        "Vulgar fraction one quarter": "Vulgar fraction one quarter",
        "Vulgar fraction three quarters": "Vulgar fraction three quarters",
        White: "White",
        "Widget toolbar": "Widget toolbar",
        Width: "Width",
        "Won sign": "Won sign",
        Yellow: "Yellow",
        "Yellow marker": "Yellow marker",
        "Yen sign": "Yen sign"
    })
})(window.CKEDITOR_TRANSLATIONS || (window.CKEDITOR_TRANSLATIONS = {}));
(function t(e, n) {
    if (typeof exports === "object" && typeof module === "object") module.exports = n(); else if (typeof define === "function" && define.amd) define([], n); else if (typeof exports === "object") exports["CKSource"] = n(); else e["CKSource"] = n()
})(window, (function () {
    return function (t) {
        var e = {};

        function n(i) {
            if (e[i]) {
                return e[i].exports
            }
            var o = e[i] = {i: i, l: false, exports: {}};
            t[i].call(o.exports, o, o.exports, n);
            o.l = true;
            return o.exports
        }

        n.m = t;
        n.c = e;
        n.d = function (t, e, i) {
            if (!n.o(t, e)) {
                Object.defineProperty(t, e, {enumerable: true, get: i})
            }
        };
        n.r = function (t) {
            if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
                Object.defineProperty(t, Symbol.toStringTag, {value: "Module"})
            }
            Object.defineProperty(t, "__esModule", {value: true})
        };
        n.t = function (t, e) {
            if (e & 1) t = n(t);
            if (e & 8) return t;
            if (e & 4 && typeof t === "object" && t && t.__esModule) return t;
            var i = Object.create(null);
            n.r(i);
            Object.defineProperty(i, "default", {enumerable: true, value: t});
            if (e & 2 && typeof t != "string") for (var o in t) n.d(i, o, function (e) {
                return t[e]
            }.bind(null, o));
            return i
        };
        n.n = function (t) {
            var e = t && t.__esModule ? function e() {
                return t["default"]
            } : function e() {
                return t
            };
            n.d(e, "a", e);
            return e
        };
        n.o = function (t, e) {
            return Object.prototype.hasOwnProperty.call(t, e)
        };
        n.p = "";
        return n(n.s = 87)
    }([function (t, e, n) {
        "use strict";
        n.d(e, "a", (function () {
            return o
        }));
        n.d(e, "c", (function () {
            return r
        }));
        n.d(e, "b", (function () {
            return s
        }));
        const i = "https://ckeditor.com/docs/ckeditor5/latest/framework/guides/support/error-codes.html";

        class o extends Error {
            constructor(t, e, n) {
                const i = `${t}${n ? ` ${JSON.stringify(n)}` : ""}${a(t)}`;
                super(i);
                this.name = "CKEditorError";
                this.context = e;
                this.data = n
            }

            is(t) {
                return t === "CKEditorError"
            }

            static rethrowUnexpectedError(t, e) {
                if (t.is && t.is("CKEditorError")) {
                    throw t
                }
                const n = new o(t.message, e);
                n.stack = t.stack;
                throw n
            }
        }

        function r(t, e) {
            console.warn(...c(t, e))
        }

        function s(t, e) {
            console.error(...c(t, e))
        }

        function a(t) {
            return `\nRead more: ${i}#error-${t}`
        }

        function c(t, e) {
            const n = a(t);
            return e ? [t, e, n] : [t, n]
        }
    }, function (t, e, n) {
        "use strict";
        var i = function t() {
            var e;
            return function t() {
                if (typeof e === "undefined") {
                    e = Boolean(window && document && document.all && !window.atob)
                }
                return e
            }
        }();
        var o = function t() {
            var e = {};
            return function t(n) {
                if (typeof e[n] === "undefined") {
                    var i = document.querySelector(n);
                    if (window.HTMLIFrameElement && i instanceof window.HTMLIFrameElement) {
                        try {
                            i = i.contentDocument.head
                        } catch (t) {
                            i = null
                        }
                    }
                    e[n] = i
                }
                return e[n]
            }
        }();
        var r = [];

        function s(t) {
            var e = -1;
            for (var n = 0; n < r.length; n++) {
                if (r[n].identifier === t) {
                    e = n;
                    break
                }
            }
            return e
        }

        function a(t, e) {
            var n = {};
            var i = [];
            for (var o = 0; o < t.length; o++) {
                var a = t[o];
                var c = e.base ? a[0] + e.base : a[0];
                var l = n[c] || 0;
                var d = "".concat(c, " ").concat(l);
                n[c] = l + 1;
                var u = s(d);
                var h = {css: a[1], media: a[2], sourceMap: a[3]};
                if (u !== -1) {
                    r[u].references++;
                    r[u].updater(h)
                } else {
                    r.push({identifier: d, updater: f(h, e), references: 1})
                }
                i.push(d)
            }
            return i
        }

        function c(t) {
            var e = document.createElement("style");
            var i = t.attributes || {};
            if (typeof i.nonce === "undefined") {
                var r = true ? n.nc : undefined;
                if (r) {
                    i.nonce = r
                }
            }
            Object.keys(i).forEach((function (t) {
                e.setAttribute(t, i[t])
            }));
            if (typeof t.insert === "function") {
                t.insert(e)
            } else {
                var s = o(t.insert || "head");
                if (!s) {
                    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.")
                }
                s.appendChild(e)
            }
            return e
        }

        function l(t) {
            if (t.parentNode === null) {
                return false
            }
            t.parentNode.removeChild(t)
        }

        var d = function t() {
            var e = [];
            return function t(n, i) {
                e[n] = i;
                return e.filter(Boolean).join("\n")
            }
        }();

        function u(t, e, n, i) {
            var o = n ? "" : i.media ? "@media ".concat(i.media, " {").concat(i.css, "}") : i.css;
            if (t.styleSheet) {
                t.styleSheet.cssText = d(e, o)
            } else {
                var r = document.createTextNode(o);
                var s = t.childNodes;
                if (s[e]) {
                    t.removeChild(s[e])
                }
                if (s.length) {
                    t.insertBefore(r, s[e])
                } else {
                    t.appendChild(r)
                }
            }
        }

        function h(t, e, n) {
            var i = n.css;
            var o = n.media;
            var r = n.sourceMap;
            if (o) {
                t.setAttribute("media", o)
            } else {
                t.removeAttribute("media")
            }
            if (r && typeof btoa !== "undefined") {
                i += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(r)))), " */")
            }
            if (t.styleSheet) {
                t.styleSheet.cssText = i
            } else {
                while (t.firstChild) {
                    t.removeChild(t.firstChild)
                }
                t.appendChild(document.createTextNode(i))
            }
        }

        var m = null;
        var g = 0;

        function f(t, e) {
            var n;
            var i;
            var o;
            if (e.singleton) {
                var r = g++;
                n = m || (m = c(e));
                i = u.bind(null, n, r, false);
                o = u.bind(null, n, r, true)
            } else {
                n = c(e);
                i = h.bind(null, n, e);
                o = function t() {
                    l(n)
                }
            }
            i(t);
            return function e(n) {
                if (n) {
                    if (n.css === t.css && n.media === t.media && n.sourceMap === t.sourceMap) {
                        return
                    }
                    i(t = n)
                } else {
                    o()
                }
            }
        }

        t.exports = function (t, e) {
            e = e || {};
            if (!e.singleton && typeof e.singleton !== "boolean") {
                e.singleton = i()
            }
            t = t || [];
            var n = a(t, e);
            return function t(i) {
                i = i || [];
                if (Object.prototype.toString.call(i) !== "[object Array]") {
                    return
                }
                for (var o = 0; o < n.length; o++) {
                    var c = n[o];
                    var l = s(c);
                    r[l].references--
                }
                var d = a(i, e);
                for (var u = 0; u < n.length; u++) {
                    var h = n[u];
                    var m = s(h);
                    if (r[m].references === 0) {
                        r[m].updater();
                        r.splice(m, 1)
                    }
                }
                n = d
            }
        }
    }, function (t, e, n) {
        "use strict";

        function i(t, e) {
            return c(t) || a(t, e) || r(t, e) || o()
        }

        function o() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }

        function r(t, e) {
            if (!t) return;
            if (typeof t === "string") return s(t, e);
            var n = Object.prototype.toString.call(t).slice(8, -1);
            if (n === "Object" && t.constructor) n = t.constructor.name;
            if (n === "Map" || n === "Set") return Array.from(t);
            if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return s(t, e)
        }

        function s(t, e) {
            if (e == null || e > t.length) e = t.length;
            for (var n = 0, i = new Array(e); n < e; n++) {
                i[n] = t[n]
            }
            return i
        }

        function a(t, e) {
            if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(t))) return;
            var n = [];
            var i = true;
            var o = false;
            var r = undefined;
            try {
                for (var s = t[Symbol.iterator](), a; !(i = (a = s.next()).done); i = true) {
                    n.push(a.value);
                    if (e && n.length === e) break
                }
            } catch (t) {
                o = true;
                r = t
            } finally {
                try {
                    if (!i && s["return"] != null) s["return"]()
                } finally {
                    if (o) throw r
                }
            }
            return n
        }

        function c(t) {
            if (Array.isArray(t)) return t
        }

        t.exports = function t(e) {
            var n = i(e, 4), o = n[1], r = n[3];
            if (typeof btoa === "function") {
                var s = btoa(unescape(encodeURIComponent(JSON.stringify(r))));
                var a = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(s);
                var c = "/*# ".concat(a, " */");
                var l = r.sources.map((function (t) {
                    return "/*# sourceURL=".concat(r.sourceRoot || "").concat(t, " */")
                }));
                return [o].concat(l).concat([c]).join("\n")
            }
            return [o].join("\n")
        }
    }, function (t, e, n) {
        "use strict";
        t.exports = function (t) {
            var e = [];
            e.toString = function e() {
                return this.map((function (e) {
                    var n = t(e);
                    if (e[2]) {
                        return "@media ".concat(e[2], " {").concat(n, "}")
                    }
                    return n
                })).join("")
            };
            e.i = function (t, n, i) {
                if (typeof t === "string") {
                    t = [[null, t, ""]]
                }
                var o = {};
                if (i) {
                    for (var r = 0; r < this.length; r++) {
                        var s = this[r][0];
                        if (s != null) {
                            o[s] = true
                        }
                    }
                }
                for (var a = 0; a < t.length; a++) {
                    var c = [].concat(t[a]);
                    if (i && o[c[0]]) {
                        continue
                    }
                    if (n) {
                        if (!c[2]) {
                            c[2] = n
                        } else {
                            c[2] = "".concat(n, " and ").concat(c[2])
                        }
                    }
                    e.push(c)
                }
            };
            return e
        }
    }, , function (t, e, n) {
        "use strict";
        var i = n(9);
        var o = typeof self == "object" && self && self.Object === Object && self;
        var r = i["a"] || o || Function("return this")();
        e["a"] = r
    }, function (t, e, n) {
        "use strict";
        (function (t) {
            var i = n(5);
            var o = n(84);
            var r = typeof exports == "object" && exports && !exports.nodeType && exports;
            var s = r && typeof t == "object" && t && !t.nodeType && t;
            var a = s && s.exports === r;
            var c = a ? i["a"].Buffer : undefined;
            var l = c ? c.isBuffer : undefined;
            var d = l || o["a"];
            e["a"] = d
        }).call(this, n(11)(t))
    }, function (t, e, n) {
        "use strict";
        (function (t) {
            var i = n(9);
            var o = typeof exports == "object" && exports && !exports.nodeType && exports;
            var r = o && typeof t == "object" && t && !t.nodeType && t;
            var s = r && r.exports === o;
            var a = s && i["a"].process;
            var c = function () {
                try {
                    var t = r && r.require && r.require("util").types;
                    if (t) {
                        return t
                    }
                    return a && a.binding && a.binding("util")
                } catch (t) {
                }
            }();
            e["a"] = c
        }).call(this, n(11)(t))
    }, function (t, e, n) {
        "use strict";
        (function (t) {
            var e = n(0);
            const i = "23.1.0";
            const o = typeof window === "object" ? window : t;
            if (o.CKEDITOR_VERSION) {
                throw new e["a"]("ckeditor-duplicated-modules", null)
            } else {
                o.CKEDITOR_VERSION = i
            }
        }).call(this, n(83))
    }, function (t, e, n) {
        "use strict";
        (function (t) {
            var n = typeof t == "object" && t && t.Object === Object && t;
            e["a"] = n
        }).call(this, n(83))
    }, function (t, e, n) {
        "use strict";
        (function (t) {
            var i = n(5);
            var o = typeof exports == "object" && exports && !exports.nodeType && exports;
            var r = o && typeof t == "object" && t && !t.nodeType && t;
            var s = r && r.exports === o;
            var a = s ? i["a"].Buffer : undefined, c = a ? a.allocUnsafe : undefined;

            function l(t, e) {
                if (e) {
                    return t.slice()
                }
                var n = t.length, i = c ? c(n) : new t.constructor(n);
                t.copy(i);
                return i
            }

            e["a"] = l
        }).call(this, n(11)(t))
    }, function (t, e) {
        t.exports = function (t) {
            if (!t.webpackPolyfill) {
                var e = Object.create(t);
                if (!e.children) e.children = [];
                Object.defineProperty(e, "loaded", {
                    enumerable: true, get: function () {
                        return e.l
                    }
                });
                Object.defineProperty(e, "id", {
                    enumerable: true, get: function () {
                        return e.i
                    }
                });
                Object.defineProperty(e, "exports", {enumerable: true});
                e.webpackPolyfill = 1
            }
            return e
        }
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck.ck-placeholder:before,.ck .ck-placeholder:before{content:attr(data-placeholder);pointer-events:none}.ck.ck-read-only .ck-placeholder:before{display:none}.ck.ck-placeholder:before,.ck .ck-placeholder:before{cursor:text;color:var(--ck-color-engine-placeholder-text)}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-engine/theme/placeholder.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-engine/placeholder.css"],
            names: [],
            mappings: "AAQC,qDACC,8BAA+B,CAG/B,mBACD,CAKA,wCACC,YACD,CCbA,qDACC,WAAY,CACZ,6CACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* See ckeditor/ckeditor5#936. */\n.ck.ck-placeholder,\n.ck .ck-placeholder {\n\t&::before {\n\t\tcontent: attr(data-placeholder);\n\n\t\t/* See ckeditor/ckeditor5#469. */\n\t\tpointer-events: none;\n\t}\n}\n\n/* See ckeditor/ckeditor5#1987. */\n.ck.ck-read-only .ck-placeholder {\n\t&::before {\n\t\tdisplay: none;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* See ckeditor/ckeditor5#936. */\n.ck.ck-placeholder, .ck .ck-placeholder {\n\t&::before {\n\t\tcursor: text;\n\t\tcolor: var(--ck-color-engine-placeholder-text);\n\t}\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck-hidden{display:none!important}.ck.ck-reset,.ck.ck-reset_all,.ck.ck-reset_all *{box-sizing:border-box;width:auto;height:auto;position:static}:root{--ck-z-default:1;--ck-z-modal:calc(var(--ck-z-default) + 999);--ck-color-base-foreground:#fafafa;--ck-color-base-background:#fff;--ck-color-base-border:#c4c4c4;--ck-color-base-action:#61b045;--ck-color-base-focus:#6cb5f9;--ck-color-base-text:#333;--ck-color-base-active:#198cf0;--ck-color-base-active-focus:#0e7fe1;--ck-color-base-error:#db3700;--ck-color-focus-border-coordinates:208,79%,51%;--ck-color-focus-border:hsl(var(--ck-color-focus-border-coordinates));--ck-color-focus-outer-shadow:#bcdefb;--ck-color-focus-disabled-shadow:rgba(119,186,248,0.3);--ck-color-focus-error-shadow:rgba(255,64,31,0.3);--ck-color-text:var(--ck-color-base-text);--ck-color-shadow-drop:rgba(0,0,0,0.15);--ck-color-shadow-drop-active:rgba(0,0,0,0.2);--ck-color-shadow-inner:rgba(0,0,0,0.1);--ck-color-button-default-background:transparent;--ck-color-button-default-hover-background:#e6e6e6;--ck-color-button-default-active-background:#d9d9d9;--ck-color-button-default-active-shadow:#bfbfbf;--ck-color-button-default-disabled-background:transparent;--ck-color-button-on-background:#dedede;--ck-color-button-on-hover-background:#c4c4c4;--ck-color-button-on-active-background:#bababa;--ck-color-button-on-active-shadow:#a1a1a1;--ck-color-button-on-disabled-background:#dedede;--ck-color-button-action-background:var(--ck-color-base-action);--ck-color-button-action-hover-background:#579e3d;--ck-color-button-action-active-background:#53973b;--ck-color-button-action-active-shadow:#498433;--ck-color-button-action-disabled-background:#7ec365;--ck-color-button-action-text:var(--ck-color-base-background);--ck-color-button-save:#008a00;--ck-color-button-cancel:#db3700;--ck-color-switch-button-off-background:#b0b0b0;--ck-color-switch-button-off-hover-background:#a3a3a3;--ck-color-switch-button-on-background:var(--ck-color-button-action-background);--ck-color-switch-button-on-hover-background:#579e3d;--ck-color-switch-button-inner-background:var(--ck-color-base-background);--ck-color-switch-button-inner-shadow:rgba(0,0,0,0.1);--ck-color-dropdown-panel-background:var(--ck-color-base-background);--ck-color-dropdown-panel-border:var(--ck-color-base-border);--ck-color-input-background:var(--ck-color-base-background);--ck-color-input-border:#c7c7c7;--ck-color-input-error-border:var(--ck-color-base-error);--ck-color-input-text:var(--ck-color-base-text);--ck-color-input-disabled-background:#f2f2f2;--ck-color-input-disabled-border:#c7c7c7;--ck-color-input-disabled-text:#5c5c5c;--ck-color-list-background:var(--ck-color-base-background);--ck-color-list-button-hover-background:var(--ck-color-button-default-hover-background);--ck-color-list-button-on-background:var(--ck-color-base-active);--ck-color-list-button-on-background-focus:var(--ck-color-base-active-focus);--ck-color-list-button-on-text:var(--ck-color-base-background);--ck-color-panel-background:var(--ck-color-base-background);--ck-color-panel-border:var(--ck-color-base-border);--ck-color-toolbar-background:var(--ck-color-base-foreground);--ck-color-toolbar-border:var(--ck-color-base-border);--ck-color-tooltip-background:var(--ck-color-base-text);--ck-color-tooltip-text:var(--ck-color-base-background);--ck-color-engine-placeholder-text:#707070;--ck-color-upload-bar-background:#6cb5f9;--ck-color-link-default:#0000f0;--ck-color-link-selected-background:rgba(31,177,255,0.1);--ck-color-link-fake-selection:rgba(31,177,255,0.3);--ck-disabled-opacity:.5;--ck-focus-outer-shadow-geometry:0 0 0 3px;--ck-focus-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);--ck-focus-disabled-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);--ck-focus-error-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);--ck-focus-ring:1px solid var(--ck-color-focus-border);--ck-font-size-base:13px;--ck-line-height-base:1.84615;--ck-font-face:Helvetica,Arial,Tahoma,Verdana,Sans-Serif;--ck-font-size-tiny:0.7em;--ck-font-size-small:0.75em;--ck-font-size-normal:1em;--ck-font-size-big:1.4em;--ck-font-size-large:1.8em;--ck-ui-component-min-height:2.3em}.ck.ck-reset,.ck.ck-reset_all,.ck.ck-reset_all *{margin:0;padding:0;border:0;background:transparent;text-decoration:none;vertical-align:middle;transition:none;word-wrap:break-word}.ck.ck-reset_all,.ck.ck-reset_all *{border-collapse:collapse;font:normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);color:var(--ck-color-text);text-align:left;white-space:nowrap;cursor:auto;float:none}.ck.ck-reset_all .ck-rtl *{text-align:right}.ck.ck-reset_all iframe{vertical-align:inherit}.ck.ck-reset_all textarea{white-space:pre-wrap}.ck.ck-reset_all input[type=password],.ck.ck-reset_all input[type=text],.ck.ck-reset_all textarea{cursor:text}.ck.ck-reset_all input[type=password][disabled],.ck.ck-reset_all input[type=text][disabled],.ck.ck-reset_all textarea[disabled]{cursor:default}.ck.ck-reset_all fieldset{padding:10px;border:2px groove #dfdee3}.ck.ck-reset_all button::-moz-focus-inner{padding:0;border:0}.ck[dir=rtl],.ck[dir=rtl] .ck{text-align:right}:root{--ck-border-radius:2px;--ck-inner-shadow:2px 2px 3px var(--ck-color-shadow-inner) inset;--ck-drop-shadow:0 1px 2px 1px var(--ck-color-shadow-drop);--ck-drop-shadow-active:0 3px 6px 1px var(--ck-color-shadow-drop-active);--ck-spacing-unit:0.6em;--ck-spacing-large:calc(var(--ck-spacing-unit)*1.5);--ck-spacing-standard:var(--ck-spacing-unit);--ck-spacing-medium:calc(var(--ck-spacing-unit)*0.8);--ck-spacing-small:calc(var(--ck-spacing-unit)*0.5);--ck-spacing-tiny:calc(var(--ck-spacing-unit)*0.3);--ck-spacing-extra-tiny:calc(var(--ck-spacing-unit)*0.16)}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-ui/theme/globals/_hidden.css", "webpack://node_modules/@ckeditor/ckeditor5-ui/theme/globals/_reset.css", "webpack://node_modules/@ckeditor/ckeditor5-ui/theme/globals/_zindex.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_colors.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_disabled.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_focus.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_fonts.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_reset.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_rounded.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_shadow.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_spacing.css"],
            names: [],
            mappings: "AAQA,WAGC,sBACD,CCPA,iDAGC,qBAAsB,CACtB,UAAW,CACX,WAAY,CACZ,eACD,CCPA,MACC,gBAAiB,CACjB,4CAA+C,CCD/C,kCAAmD,CACnD,+BAAoD,CACpD,8BAAgD,CAChD,8BAAmD,CACnD,6BAAmD,CACnD,yBAA+C,CAC/C,8BAAmD,CACnD,oCAAuD,CACvD,6BAAkD,CAIlD,+CAAwD,CACxD,qEAA+E,CAC/E,qCAAwD,CACxD,sDAA8D,CAC9D,iDAAyD,CACzD,yCAAqD,CACrD,uCAAsD,CACtD,6CAA0D,CAC1D,uCAAsD,CAItD,gDAAuD,CACvD,kDAA+D,CAC/D,mDAAgE,CAChE,+CAA6D,CAC7D,yDAA8D,CAE9D,uCAAuD,CACvD,6CAA4D,CAC5D,8CAA4D,CAC5D,0CAAyD,CACzD,gDAA8D,CAE9D,+DAAsE,CACtE,iDAAkE,CAClE,kDAAkE,CAClE,8CAA+D,CAC/D,oDAAoE,CACpE,6DAAsE,CAEtE,8BAAoD,CACpD,gCAAqD,CAErD,+CAA4D,CAC5D,qDAAiE,CACjE,+EAAqF,CACrF,oDAAmE,CACnE,yEAA8E,CAC9E,qDAAgE,CAIhE,oEAA2E,CAC3E,4DAAoE,CAIpE,2DAAoE,CACpE,+BAAiD,CACjD,wDAAgE,CAChE,+CAA0D,CAC1D,4CAA2D,CAC3D,wCAAwD,CACxD,sCAAsD,CAItD,0DAAmE,CACnE,uFAA6F,CAC7F,gEAAuE,CACvE,4EAAiF,CACjF,8DAAsE,CAItE,2DAAoE,CACpE,mDAA6D,CAI7D,6DAAsE,CACtE,qDAA+D,CAI/D,uDAAgE,CAChE,uDAAiE,CAIjE,0CAAyD,CAIzD,wCAA2D,CAI3D,+BAAoD,CACpD,wDAAmE,CACnE,mDAAgE,CCpGhE,wBAAyB,CCAzB,0CAA2C,CAK3C,gGAAiG,CAKjG,4GAA6G,CAK7G,sGAAuG,CAKvG,sDAAuD,CCvBvD,wBAAyB,CACzB,6BAA8B,CAC9B,wDAA6D,CAE7D,yBAA0B,CAC1B,2BAA4B,CAC5B,yBAA0B,CAC1B,wBAAyB,CACzB,0BAA2B,CCJ3B,kCLFD,CKQA,iDAIC,QAAS,CACT,SAAU,CACV,QAAS,CACT,sBAAuB,CACvB,oBAAqB,CACrB,qBAAsB,CACtB,eAAgB,CAGhB,oBACD,CAKA,oCAGC,wBAAyB,CACzB,iGAAkG,CAClG,0BAA2B,CAC3B,eAAgB,CAChB,kBAAmB,CACnB,WAAY,CACZ,UACD,CAGC,2BACC,gBACD,CAEA,wBAEC,sBACD,CAEA,0BACC,oBACD,CAEA,kGAGC,WACD,CAEA,gIAGC,cACD,CAEA,0BACC,YAAa,CACb,yBACD,CAEA,0CAEC,SAAU,CACV,QACD,CAMD,8BAEC,gBACD,CCnFA,MACC,sBAAuB,CCAvB,gEAAiE,CAKjE,0DAA2D,CAK3D,wEAAyE,CCbzE,uBAA8B,CAC9B,mDAA2D,CAC3D,4CAAkD,CAClD,oDAA4D,CAC5D,mDAA2D,CAC3D,kDAA2D,CAC3D,yDFFD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which hides an element in DOM.\n */\n.ck-hidden {\n\t/* Override selector specificity. Otherwise, all elements with some display\n\tstyle defined will override this one, which is not a desired result. */\n\tdisplay: none !important;\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-reset,\n.ck.ck-reset_all,\n.ck.ck-reset_all * {\n\tbox-sizing: border-box;\n\twidth: auto;\n\theight: auto;\n\tposition: static;\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-z-default: 1;\n\t--ck-z-modal: calc( var(--ck-z-default) + 999 );\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-base-foreground: \t\t\t\t\t\t\t\thsl(0, 0%, 98%);\n\t--ck-color-base-background: \t\t\t\t\t\t\t\thsl(0, 0%, 100%);\n\t--ck-color-base-border: \t\t\t\t\t\t\t\t\thsl(0, 0%, 77%);\n\t--ck-color-base-action: \t\t\t\t\t\t\t\t\thsl(104, 44%, 48%);\n\t--ck-color-base-focus: \t\t\t\t\t\t\t\t\t\thsl(209, 92%, 70%);\n\t--ck-color-base-text: \t\t\t\t\t\t\t\t\t\thsl(0, 0%, 20%);\n\t--ck-color-base-active: \t\t\t\t\t\t\t\t\thsl(208, 88%, 52%);\n\t--ck-color-base-active-focus:\t\t\t\t\t\t\t\thsl(208, 88%, 47%);\n\t--ck-color-base-error:\t\t\t\t\t\t\t\t\t\thsl(15, 100%, 43%);\n\n\t/* -- Generic colors ------------------------------------------------------------------------ */\n\n\t--ck-color-focus-border-coordinates: \t\t\t\t\t\t208, 79%, 51%;\n\t--ck-color-focus-border: \t\t\t\t\t\t\t\t\thsl(var(--ck-color-focus-border-coordinates));\n\t--ck-color-focus-outer-shadow:\t\t\t\t\t\t\t\thsl(207, 89%, 86%);\n\t--ck-color-focus-disabled-shadow:\t\t\t\t\t\t\thsla(209, 90%, 72%,.3);\n\t--ck-color-focus-error-shadow:\t\t\t\t\t\t\t\thsla(9,100%,56%,.3);\n\t--ck-color-text: \t\t\t\t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-shadow-drop: \t\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.15);\n\t--ck-color-shadow-drop-active:\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.2);\n\t--ck-color-shadow-inner: \t\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.1);\n\n\t/* -- Buttons ------------------------------------------------------------------------------- */\n\n\t--ck-color-button-default-background: \t\t\t\t\t\ttransparent;\n\t--ck-color-button-default-hover-background: \t\t\t\thsl(0, 0%, 90%);\n\t--ck-color-button-default-active-background: \t\t\t\thsl(0, 0%, 85%);\n\t--ck-color-button-default-active-shadow: \t\t\t\t\thsl(0, 0%, 75%);\n\t--ck-color-button-default-disabled-background: \t\t\t\ttransparent;\n\n\t--ck-color-button-on-background: \t\t\t\t\t\t\thsl(0, 0%, 87%);\n\t--ck-color-button-on-hover-background: \t\t\t\t\t\thsl(0, 0%, 77%);\n\t--ck-color-button-on-active-background: \t\t\t\t\thsl(0, 0%, 73%);\n\t--ck-color-button-on-active-shadow: \t\t\t\t\t\thsl(0, 0%, 63%);\n\t--ck-color-button-on-disabled-background: \t\t\t\t\thsl(0, 0%, 87%);\n\n\t--ck-color-button-action-background: \t\t\t\t\t\tvar(--ck-color-base-action);\n\t--ck-color-button-action-hover-background: \t\t\t\t\thsl(104, 44%, 43%);\n\t--ck-color-button-action-active-background: \t\t\t\thsl(104, 44%, 41%);\n\t--ck-color-button-action-active-shadow: \t\t\t\t\thsl(104, 44%, 36%);\n\t--ck-color-button-action-disabled-background: \t\t\t\thsl(104, 44%, 58%);\n\t--ck-color-button-action-text: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t--ck-color-button-save: \t\t\t\t\t\t\t\t\thsl(120, 100%, 27%);\n\t--ck-color-button-cancel: \t\t\t\t\t\t\t\t\thsl(15, 100%, 43%);\n\n\t--ck-color-switch-button-off-background:\t\t\t\t\thsl(0, 0%, 69%);\n\t--ck-color-switch-button-off-hover-background:\t\t\t\thsl(0, 0%, 64%);\n\t--ck-color-switch-button-on-background:\t\t\t\t\t\tvar(--ck-color-button-action-background);\n\t--ck-color-switch-button-on-hover-background:\t\t\t\thsl(104, 44%, 43%);\n\t--ck-color-switch-button-inner-background:\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-switch-button-inner-shadow:\t\t\t\t\t\thsla(0, 0%, 0%, 0.1);\n\n\t/* -- Dropdown ------------------------------------------------------------------------------ */\n\n\t--ck-color-dropdown-panel-background: \t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-dropdown-panel-border: \t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Input --------------------------------------------------------------------------------- */\n\n\t--ck-color-input-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-input-border: \t\t\t\t\t\t\t\t\thsl(0, 0%, 78%);\n\t--ck-color-input-error-border:\t\t\t\t\t\t\t\tvar(--ck-color-base-error);\n\t--ck-color-input-text: \t\t\t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-input-disabled-background: \t\t\t\t\t\thsl(0, 0%, 95%);\n\t--ck-color-input-disabled-border: \t\t\t\t\t\t\thsl(0, 0%, 78%);\n\t--ck-color-input-disabled-text: \t\t\t\t\t\t\thsl(0, 0%, 36%);\n\n\t/* -- List ---------------------------------------------------------------------------------- */\n\n\t--ck-color-list-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-list-button-hover-background: \t\t\t\t\tvar(--ck-color-button-default-hover-background);\n\t--ck-color-list-button-on-background: \t\t\t\t\t\tvar(--ck-color-base-active);\n\t--ck-color-list-button-on-background-focus: \t\t\t\tvar(--ck-color-base-active-focus);\n\t--ck-color-list-button-on-text:\t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t/* -- Panel --------------------------------------------------------------------------------- */\n\n\t--ck-color-panel-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-panel-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Toolbar ------------------------------------------------------------------------------- */\n\n\t--ck-color-toolbar-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-foreground);\n\t--ck-color-toolbar-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Tooltip ------------------------------------------------------------------------------- */\n\n\t--ck-color-tooltip-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-tooltip-text: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t/* -- Engine -------------------------------------------------------------------------------- */\n\n\t--ck-color-engine-placeholder-text: \t\t\t\t\t\thsl(0, 0%, 44%);\n\n\t/* -- Upload -------------------------------------------------------------------------------- */\n\n\t--ck-color-upload-bar-background:\t\t \t\t\t\t\thsl(209, 92%, 70%);\n\n\t/* -- Link -------------------------------------------------------------------------------- */\n\n\t--ck-color-link-default:\t\t\t\t\t\t\t\t\thsl(240, 100%, 47%);\n\t--ck-color-link-selected-background:\t\t\t\t\t\thsla(201, 100%, 56%, 0.1);\n\t--ck-color-link-fake-selection:\t\t\t\t\t\t\t\thsla(201, 100%, 56%, 0.3);\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * An opacity value of disabled UI item.\n\t */\n\t--ck-disabled-opacity: .5;\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * The geometry of the of focused element's outer shadow.\n\t */\n\t--ck-focus-outer-shadow-geometry: 0 0 0 3px;\n\n\t/**\n\t * A visual style of focused element's outer shadow.\n\t */\n\t--ck-focus-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);\n\n\t/**\n\t * A visual style of focused element's outer shadow (when disabled).\n\t */\n\t--ck-focus-disabled-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);\n\n\t/**\n\t * A visual style of focused element's outer shadow (when has errors).\n\t */\n\t--ck-focus-error-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);\n\n\t/**\n\t * A visual style of focused element's border or outline.\n\t */\n\t--ck-focus-ring: 1px solid var(--ck-color-focus-border);\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-font-size-base: 13px;\n\t--ck-line-height-base: 1.84615;\n\t--ck-font-face: Helvetica, Arial, Tahoma, Verdana, Sans-Serif;\n\n\t--ck-font-size-tiny: 0.7em;\n\t--ck-font-size-small: 0.75em;\n\t--ck-font-size-normal: 1em;\n\t--ck-font-size-big: 1.4em;\n\t--ck-font-size-large: 1.8em;\n}\n", '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/* This is super-important. This is **manually** adjusted so a button without an icon\n\tis never smaller than a button with icon, additionally making sure that text-less buttons\n\tare perfect squares. The value is also shared by other components which should stay "in-line"\n\twith buttons. */\n\t--ck-ui-component-min-height: 2.3em;\n}\n\n/**\n * Resets an element, ignoring its children.\n */\n.ck.ck-reset,\n.ck.ck-reset_all,\n.ck.ck-reset_all * {\n\t/* Do not include inheritable rules here. */\n\tmargin: 0;\n\tpadding: 0;\n\tborder: 0;\n\tbackground: transparent;\n\ttext-decoration: none;\n\tvertical-align: middle;\n\ttransition: none;\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/105 */\n\tword-wrap: break-word;\n}\n\n/**\n * Resets an element AND its children.\n */\n.ck.ck-reset_all,\n.ck.ck-reset_all * {\n\t/* These are rule inherited by all children elements. */\n\tborder-collapse: collapse;\n\tfont: normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);\n\tcolor: var(--ck-color-text);\n\ttext-align: left;\n\twhite-space: nowrap;\n\tcursor: auto;\n\tfloat: none;\n}\n\n.ck.ck-reset_all {\n\t& .ck-rtl * {\n\t\ttext-align: right;\n\t}\n\n\t& iframe {\n\t\t/* For IE */\n\t\tvertical-align: inherit;\n\t}\n\n\t& textarea {\n\t\twhite-space: pre-wrap;\n\t}\n\n\t& textarea,\n\t& input[type="text"],\n\t& input[type="password"] {\n\t\tcursor: text;\n\t}\n\n\t& textarea[disabled],\n\t& input[type="text"][disabled],\n\t& input[type="password"][disabled] {\n\t\tcursor: default;\n\t}\n\n\t& fieldset {\n\t\tpadding: 10px;\n\t\tborder: 2px groove hsl(255, 7%, 88%);\n\t}\n\n\t& button::-moz-focus-inner {\n\t\t/* See http://stackoverflow.com/questions/5517744/remove-extra-button-spacing-padding-in-firefox */\n\t\tpadding: 0;\n\t\tborder: 0\n\t}\n}\n\n/**\n * Default UI rules for RTL languages.\n */\n.ck[dir="rtl"],\n.ck[dir="rtl"] .ck {\n\ttext-align: right;\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Default border-radius value.\n */\n:root{\n\t--ck-border-radius: 2px;\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * A visual style of element's inner shadow (i.e. input).\n\t */\n\t--ck-inner-shadow: 2px 2px 3px var(--ck-color-shadow-inner) inset;\n\n\t/**\n\t * A visual style of element's drop shadow (i.e. panel).\n\t */\n\t--ck-drop-shadow: 0 1px 2px 1px var(--ck-color-shadow-drop);\n\n\t/**\n\t * A visual style of element's active shadow (i.e. comment or suggestion).\n\t */\n\t--ck-drop-shadow-active: 0 3px 6px 1px var(--ck-color-shadow-drop-active);\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-spacing-unit: \t\t\t\t\t\t0.6em;\n\t--ck-spacing-large: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 1.5);\n\t--ck-spacing-standard: \t\t\t\t\tvar(--ck-spacing-unit);\n\t--ck-spacing-medium: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.8);\n\t--ck-spacing-small: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.5);\n\t--ck-spacing-tiny: \t\t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.3);\n\t--ck-spacing-extra-tiny: \t\t\t\tcalc(var(--ck-spacing-unit) * 0.16);\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ":root{--ck-color-editable-blur-selection:#d9d9d9}.ck.ck-editor__editable:not(.ck-editor__nested-editable){border-radius:0}.ck-rounded-corners .ck.ck-editor__editable:not(.ck-editor__nested-editable),.ck.ck-editor__editable:not(.ck-editor__nested-editable).ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-editor__editable:not(.ck-editor__nested-editable).ck-focused{outline:none;border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0}.ck.ck-editor__editable_inline{overflow:auto;padding:0 var(--ck-spacing-standard);border:1px solid transparent}.ck.ck-editor__editable_inline[dir=ltr]{text-align:left}.ck.ck-editor__editable_inline[dir=rtl]{text-align:right}.ck.ck-editor__editable_inline>:first-child{margin-top:var(--ck-spacing-large)}.ck.ck-editor__editable_inline>:last-child{margin-bottom:var(--ck-spacing-large)}.ck.ck-editor__editable_inline.ck-blurred ::selection{background:var(--ck-color-editable-blur-selection)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_n]:after{border-bottom-color:var(--ck-color-base-foreground)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_s]:after{border-top-color:var(--ck-color-base-foreground)}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/editorui/editorui.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css"],
            names: [],
            mappings: "AAWA,MACC,0CACD,CAEA,yDCJC,eDWD,CAPA,yJCAE,qCDOF,CAJC,oEERA,YAAa,CACb,2BAA2B,CCF3B,qCHYA,CAGD,+BACC,aAAc,CACd,oCAAqC,CACrC,4BAwBD,CAtBC,wCACC,eACD,CAEA,wCACC,gBACD,CAGA,4CACC,kCACD,CAGA,2CACC,qCACD,CAGA,sDACC,kDACD,CAKA,gEACC,mDACD,CAIA,gEACC,gDACD",
            sourcesContent: ['/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_shadow.css";\n@import "../../../mixins/_focus.css";\n@import "../../mixins/_button.css";\n\n:root {\n\t--ck-color-editable-blur-selection: hsl(0, 0%, 85%);\n}\n\n.ck.ck-editor__editable:not(.ck-editor__nested-editable) {\n\t@mixin ck-rounded-corners;\n\n\t&.ck-focused {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-inner-shadow);\n\t}\n}\n\n.ck.ck-editor__editable_inline {\n\toverflow: auto;\n\tpadding: 0 var(--ck-spacing-standard);\n\tborder: 1px solid transparent;\n\n\t&[dir="ltr"] {\n\t\ttext-align: left;\n\t}\n\n\t&[dir="rtl"] {\n\t\ttext-align: right;\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/116 */\n\t& > *:first-child {\n\t\tmargin-top: var(--ck-spacing-large);\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5/issues/847 */\n\t& > *:last-child {\n\t\tmargin-bottom: var(--ck-spacing-large);\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5/issues/6517 */\n\t&.ck-blurred ::selection {\n\t\tbackground: var(--ck-color-editable-blur-selection);\n\t}\n}\n\n/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/111 */\n.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_n"] {\n\t&::after {\n\t\tborder-bottom-color: var(--ck-color-base-foreground);\n\t}\n}\n\n.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_s"] {\n\t&::after {\n\t\tborder-top-color: var(--ck-color-base-foreground);\n\t}\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck.ck-label{display:block}.ck.ck-voice-label{display:none}.ck.ck-label{font-weight:700}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-ui/theme/components/label/label.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/label/label.css"],
            names: [],
            mappings: "AAKA,aACC,aACD,CAEA,mBACC,YACD,CCNA,aACC,eACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-label {\n\tdisplay: block;\n}\n\n.ck.ck-voice-label {\n\tdisplay: none;\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-label {\n\tfont-weight: bold;\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck.ck-sticky-panel .ck-sticky-panel__content_sticky{z-index:var(--ck-z-modal);position:fixed;top:0}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky_bottom-limit{top:auto;position:absolute}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky{box-shadow:var(--ck-drop-shadow),0 0;border-width:0 1px 1px;border-top-left-radius:0;border-top-right-radius:0}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/stickypanel.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/stickypanel.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css"],
            names: [],
            mappings: "AAMC,qDACC,yBAA0B,CAC1B,cAAe,CACf,KACD,CAEA,kEACC,QAAS,CACT,iBACD,CCPA,qDCCA,oCAA8B,CDE7B,sBAAuB,CACvB,wBAAyB,CACzB,yBACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-sticky-panel {\n\t& .ck-sticky-panel__content_sticky {\n\t\tz-index: var(--ck-z-modal); /* #315 */\n\t\tposition: fixed;\n\t\ttop: 0;\n\t}\n\n\t& .ck-sticky-panel__content_sticky_bottom-limit {\n\t\ttop: auto;\n\t\tposition: absolute;\n\t}\n}\n", '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_shadow.css";\n\n.ck.ck-sticky-panel {\n\t& .ck-sticky-panel__content_sticky {\n\t\t@mixin ck-drop-shadow;\n\n\t\tborder-width: 0 1px 1px;\n\t\tborder-top-left-radius: 0;\n\t\tborder-top-right-radius: 0;\n\t}\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck.ck-dropdown{display:inline-block;position:relative}.ck.ck-dropdown .ck-dropdown__arrow{pointer-events:none;z-index:var(--ck-z-default)}.ck.ck-dropdown .ck-button.ck-dropdown__button{width:100%}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on .ck-tooltip{display:none}.ck.ck-dropdown .ck-dropdown__panel{-webkit-backface-visibility:hidden;display:none;z-index:var(--ck-z-modal);position:absolute}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel-visible{display:inline-block}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw{bottom:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{top:100%;bottom:auto}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se{left:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{right:0}.ck.ck-toolbar .ck-dropdown__panel{z-index:calc(var(--ck-z-modal) + 1)}:root{--ck-dropdown-arrow-size:calc(var(--ck-icon-size)*0.5)}.ck.ck-dropdown{font-size:inherit}.ck.ck-dropdown .ck-dropdown__arrow{width:var(--ck-dropdown-arrow-size)}[dir=ltr] .ck.ck-dropdown .ck-dropdown__arrow{right:var(--ck-spacing-standard);margin-left:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-dropdown .ck-dropdown__arrow{left:var(--ck-spacing-standard);margin-right:var(--ck-spacing-small)}.ck.ck-dropdown.ck-disabled .ck-dropdown__arrow{opacity:var(--ck-disabled-opacity)}[dir=ltr] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-left:var(--ck-spacing-small)}[dir=rtl] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-right:var(--ck-spacing-small)}.ck.ck-dropdown .ck-button.ck-dropdown__button .ck-button__label{width:7em;overflow:hidden;text-overflow:ellipsis}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on{border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-dropdown__button_label-width_auto .ck-button__label{width:auto}.ck.ck-dropdown__panel{border-radius:0}.ck-rounded-corners .ck.ck-dropdown__panel,.ck.ck-dropdown__panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-dropdown__panel{box-shadow:var(--ck-drop-shadow),0 0;background:var(--ck-color-dropdown-panel-background);border:1px solid var(--ck-color-dropdown-panel-border);bottom:0;min-width:100%}.ck.ck-dropdown__panel.ck-dropdown__panel_se{border-top-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_sw{border-top-right-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_ne{border-bottom-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_nw{border-bottom-right-radius:0}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/dropdown.css", "webpack://node_modules/@ckeditor/ckeditor5-ui/theme/components/tooltip/mixins/_tooltip.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/dropdown.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css"],
            names: [],
            mappings: "AAOA,gBACC,oBAAqB,CACrB,iBAyDD,CAvDC,oCACC,mBAAoB,CACpB,2BACD,CAGA,+CACC,UAOD,CCcA,iEACC,YACD,CDdA,oCAGC,kCAAmC,CAEnC,YAAa,CACb,yBAA0B,CAE1B,iBA8BD,CA5BC,+DACC,oBACD,CAEA,oHAEC,WACD,CAEA,oHAMC,QAAS,CACT,WACD,CAEA,oHAEC,MACD,CAEA,oHAEC,OACD,CAQF,mCACC,mCACD,CEhEA,MACC,sDACD,CAEA,gBAEC,iBAiED,CA/DC,oCACC,mCACD,CAGC,8CACC,gCAAiC,CAGjC,sCACD,CAIA,8CACC,+BAAgC,CAGhC,oCACD,CAGD,gDC/BA,kCDiCA,CAIE,mFAEC,oCACD,CAIA,mFAEC,qCACD,CAID,iEACC,SAAU,CACV,eAAgB,CAChB,sBACD,CAGA,6EC1DD,kCD4DC,CAGA,qDACC,2BAA4B,CAC5B,4BACD,CAEA,sGACC,UACD,CAIF,uBExEC,eFoGD,CA5BA,qFEpEE,qCFgGF,CA5BA,uBG1EC,oCAA8B,CH8E9B,oDAAqD,CACrD,sDAAuD,CACvD,QAAS,CAGT,cAmBD,CAfC,6CACC,wBACD,CAEA,6CACC,yBACD,CAEA,6CACC,2BACD,CAEA,6CACC,4BACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import \"../tooltip/mixins/_tooltip.css\";\n\n.ck.ck-dropdown {\n\tdisplay: inline-block;\n\tposition: relative;\n\n\t& .ck-dropdown__arrow {\n\t\tpointer-events: none;\n\t\tz-index: var(--ck-z-default);\n\t}\n\n\t/* Dropdown button should span horizontally, e.g. in vertical toolbars */\n\t& .ck-button.ck-dropdown__button {\n\t\twidth: 100%;\n\n\t\t/* Disable main button's tooltip when the dropdown is open. Otherwise the panel may\n\t\tpartially cover the tooltip */\n\t\t&.ck-on {\n\t\t\t@mixin ck-tooltip_disabled;\n\t\t}\n\t}\n\n\t& .ck-dropdown__panel {\n\t\t/* This is to get rid of flickering when the tooltip is shown under the panel,\n\t\twhich looks like the panel moves vertically a pixel down and up. */\n\t\t-webkit-backface-visibility: hidden;\n\n\t\tdisplay: none;\n\t\tz-index: var(--ck-z-modal);\n\n\t\tposition: absolute;\n\n\t\t&.ck-dropdown__panel-visible {\n\t\t\tdisplay: inline-block;\n\t\t}\n\n\t\t&.ck-dropdown__panel_ne,\n\t\t&.ck-dropdown__panel_nw {\n\t\t\tbottom: 100%;\n\t\t}\n\n\t\t&.ck-dropdown__panel_se,\n\t\t&.ck-dropdown__panel_sw {\n\t\t\t/*\n\t\t\t * Using transform: translate3d( 0, 100%, 0 ) causes blurry dropdown on Chrome 67-78+ on non-retina displays.\n\t\t\t * See https://github.com/ckeditor/ckeditor5/issues/1053.\n\t\t\t */\n\t\t\ttop: 100%;\n\t\t\tbottom: auto;\n\t\t}\n\n\t\t&.ck-dropdown__panel_ne,\n\t\t&.ck-dropdown__panel_se {\n\t\t\tleft: 0px;\n\t\t}\n\n\t\t&.ck-dropdown__panel_nw,\n\t\t&.ck-dropdown__panel_sw {\n\t\t\tright: 0px;\n\t\t}\n\t}\n}\n\n/*\n * Toolbar dropdown panels should be always above the UI (eg. other dropdown panels) from the editor's content.\n * See https://github.com/ckeditor/ckeditor5/issues/7874\n */\n.ck.ck-toolbar .ck-dropdown__panel {\n\tz-index: calc( var(--ck-z-modal) + 1 );\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Enables the tooltip, which is the tooltip is in DOM but\n * not yet displayed.\n */\n@define-mixin ck-tooltip_enabled {\n\t& .ck-tooltip {\n\t\tdisplay: block;\n\n\t\t/*\n\t\t * Don't display tooltips in devices which don't support :hover.\n\t\t * In fact, it's all about iOS, which forces user to click UI elements twice to execute\n\t\t * the primary action, when tooltips are enabled.\n\t\t *\n\t\t * Q: OK, but why not the following query?\n\t\t *\n\t\t *   @media (hover) {\n\t\t *       display: block;\n\t\t *   }\n\t\t *\n\t\t * A: Because FF does not support it and it would completely disable tooltips\n\t\t * in that browser.\n\t\t *\n\t\t * More in https://github.com/ckeditor/ckeditor5/issues/920.\n\t\t */\n\t\t@media (hover:none) {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n\n/**\n * Disables the tooltip making it disappear from DOM.\n */\n@define-mixin ck-tooltip_disabled {\n\t& .ck-tooltip {\n\t\tdisplay: none;\n\t}\n}\n\n/**\n * Shows the tooltip, which is already in DOM.\n * Requires `ck-tooltip_enabled` first.\n */\n@define-mixin ck-tooltip_visible {\n\t& .ck-tooltip {\n\t\tvisibility: visible;\n\t\topacity: 1;\n\t}\n}\n", '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_shadow.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n:root {\n\t--ck-dropdown-arrow-size: calc(0.5 * var(--ck-icon-size));\n}\n\n.ck.ck-dropdown {\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t& .ck-dropdown__arrow {\n\t\twidth: var(--ck-dropdown-arrow-size);\n\t}\n\n\t@mixin ck-dir ltr {\n\t\t& .ck-dropdown__arrow {\n\t\t\tright: var(--ck-spacing-standard);\n\n\t\t\t/* A space to accommodate the triangle. */\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& .ck-dropdown__arrow {\n\t\t\tleft: var(--ck-spacing-standard);\n\n\t\t\t/* A space to accommodate the triangle. */\n\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t}\n\t}\n\n\t&.ck-disabled .ck-dropdown__arrow {\n\t\t@mixin ck-disabled;\n\t}\n\n\t& .ck-button.ck-dropdown__button {\n\t\t@mixin ck-dir ltr {\n\t\t\t&:not(.ck-button_with-text) {\n\t\t\t\t/* Make sure dropdowns with just an icon have the right inner spacing */\n\t\t\t\tpadding-left: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t&:not(.ck-button_with-text) {\n\t\t\t\t/* Make sure dropdowns with just an icon have the right inner spacing */\n\t\t\t\tpadding-right: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\n\t\t/* #23 */\n\t\t& .ck-button__label {\n\t\t\twidth: 7em;\n\t\t\toverflow: hidden;\n\t\t\ttext-overflow: ellipsis;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */\n\t\t&.ck-disabled .ck-button__label {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5/issues/816 */\n\t\t&.ck-on {\n\t\t\tborder-bottom-left-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\n\t\t&.ck-dropdown__button_label-width_auto .ck-button__label {\n\t\t\twidth: auto;\n\t\t}\n\t}\n}\n\n.ck.ck-dropdown__panel {\n\t@mixin ck-rounded-corners;\n\t@mixin ck-drop-shadow;\n\n\tbackground: var(--ck-color-dropdown-panel-background);\n\tborder: 1px solid var(--ck-color-dropdown-panel-border);\n\tbottom: 0;\n\n\t/* Make sure the panel is at least as wide as the drop-down\'s button. */\n\tmin-width: 100%;\n\n\t/* Disabled corner border radius to be consistent with the .dropdown__button\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t&.ck-dropdown__panel_se {\n\t\tborder-top-left-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_sw {\n\t\tborder-top-right-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_ne {\n\t\tborder-bottom-left-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_nw {\n\t\tborder-bottom-right-radius: 0;\n\t}\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck.ck-icon{vertical-align:middle}:root{--ck-icon-size:calc(var(--ck-line-height-base)*var(--ck-font-size-normal))}.ck.ck-icon{width:var(--ck-icon-size);height:var(--ck-icon-size);font-size:.8333350694em;will-change:transform}.ck.ck-icon,.ck.ck-icon *{color:inherit;cursor:inherit}.ck.ck-icon :not([fill]){fill:currentColor}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-ui/theme/components/icon/icon.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/icon/icon.css"],
            names: [],
            mappings: "AAKA,YACC,qBACD,CCFA,MACC,0EACD,CAEA,YACC,yBAA0B,CAC1B,0BAA2B,CAG3B,uBAAwB,CAQxB,qBAcD,CAZC,0BARA,aAAc,CAGd,cAgBA,CAJC,yBAEC,iBACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-icon {\n\tvertical-align: middle;\n}\n", '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-icon-size: calc(var(--ck-line-height-base) * var(--ck-font-size-normal));\n}\n\n.ck.ck-icon {\n\twidth: var(--ck-icon-size);\n\theight: var(--ck-icon-size);\n\n\t/* Multiplied by the height of the line in "px" should give SVG "viewport" dimensions */\n\tfont-size: .8333350694em;\n\n\tcolor: inherit;\n\n\t/* Inherit cursor style (#5). */\n\tcursor: inherit;\n\n\t/* This will prevent blurry icons on Firefox. See #340. */\n\twill-change: transform;\n\n\t& * {\n\t\t/* Inherit cursor style (#5). */\n\t\tcursor: inherit;\n\n\t\t/* Allows dynamic coloring of the icons. */\n\t\tcolor: inherit;\n\n\t\t&:not([fill]) {\n\t\t\t/* Needed by FF. */\n\t\t\tfill: currentColor;\n\t\t}\n\t}\n}\n'],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, '.ck.ck-tooltip,.ck.ck-tooltip .ck-tooltip__text:after{position:absolute;pointer-events:none;-webkit-backface-visibility:hidden}.ck.ck-tooltip{visibility:hidden;opacity:0;display:none;z-index:var(--ck-z-modal)}.ck.ck-tooltip .ck-tooltip__text{display:inline-block}.ck.ck-tooltip .ck-tooltip__text:after{content:"";width:0;height:0}:root{--ck-tooltip-arrow-size:5px}.ck.ck-tooltip{left:50%;top:0;transition:opacity .2s ease-in-out .2s}.ck.ck-tooltip .ck-tooltip__text{border-radius:0}.ck-rounded-corners .ck.ck-tooltip .ck-tooltip__text,.ck.ck-tooltip .ck-tooltip__text.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-tooltip .ck-tooltip__text{font-size:.9em;line-height:1.5;color:var(--ck-color-tooltip-text);padding:var(--ck-spacing-small) var(--ck-spacing-medium);background:var(--ck-color-tooltip-background);position:relative;left:-50%}.ck.ck-tooltip .ck-tooltip__text:after{transition:opacity .2s ease-in-out .2s;border-style:solid;left:50%}.ck.ck-tooltip.ck-tooltip_s,.ck.ck-tooltip.ck-tooltip_sw{bottom:calc(var(--ck-tooltip-arrow-size)*-1);transform:translateY(100%)}.ck.ck-tooltip.ck-tooltip_s .ck-tooltip__text:after,.ck.ck-tooltip.ck-tooltip_sw .ck-tooltip__text:after{top:calc(var(--ck-tooltip-arrow-size)*-1 + 1px);transform:translateX(-50%);border-left-color:transparent;border-bottom-color:var(--ck-color-tooltip-background);border-right-color:transparent;border-top-color:transparent;border-left-width:var(--ck-tooltip-arrow-size);border-bottom-width:var(--ck-tooltip-arrow-size);border-right-width:var(--ck-tooltip-arrow-size);border-top-width:0}.ck.ck-tooltip.ck-tooltip_sw{right:50%;left:auto}.ck.ck-tooltip.ck-tooltip_sw .ck-tooltip__text{left:auto;right:calc(var(--ck-tooltip-arrow-size)*-2)}.ck.ck-tooltip.ck-tooltip_sw .ck-tooltip__text:after{left:auto;right:0}.ck.ck-tooltip.ck-tooltip_n{top:calc(var(--ck-tooltip-arrow-size)*-1);transform:translateY(-100%)}.ck.ck-tooltip.ck-tooltip_n .ck-tooltip__text:after{bottom:calc(var(--ck-tooltip-arrow-size)*-1);transform:translateX(-50%);border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;border-top-color:var(--ck-color-tooltip-background);border-left-width:var(--ck-tooltip-arrow-size);border-bottom-width:0;border-right-width:var(--ck-tooltip-arrow-size);border-top-width:var(--ck-tooltip-arrow-size)}', "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-ui/theme/components/tooltip/tooltip.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/tooltip/tooltip.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"],
            names: [],
            mappings: "AAKA,sDAEC,iBAAkB,CAGlB,mBAAoB,CAIpB,kCACD,CAEA,eAEC,iBAAkB,CAClB,SAAU,CACV,YAAa,CACb,yBAWD,CATC,iCACC,oBAOD,CALC,uCACC,UAAW,CACX,OAAQ,CACR,QACD,CCxBF,MACC,2BACD,CAEA,eACC,QAAS,CAMT,KAAM,CAON,sCA6FD,CA3FC,iCChBA,eDqCA,CArBA,yGCZC,qCDiCD,CArBA,iCAGC,cAAe,CACf,eAAgB,CAChB,kCAAmC,CACnC,wDAAyD,CACzD,6CAA8C,CAC9C,iBAAkB,CAClB,SAYD,CAVC,uCAMC,sCAAuC,CACvC,kBAAmB,CACnB,QACD,CAYD,yDAEC,4CAA+C,CAC/C,0BASD,CAPC,yGAEC,+CAAkD,CAClD,0BAA6B,CAC7B,6BAAoF,CAApF,sDAAoF,CAApF,8BAAoF,CAApF,4BAAoF,CACpF,8CAAsG,CAAtG,gDAAsG,CAAtG,+CAAsG,CAAtG,kBACD,CAaD,6BACC,SAAU,CACV,SAWD,CATC,+CACC,SAAU,CACV,2CACD,CAEA,qDACC,SAAU,CACV,OACD,CAYD,4BACC,yCAA4C,CAC5C,2BAQD,CANC,oDACC,4CAA+C,CAC/C,0BAA6B,CAC7B,6BAAoF,CAApF,+BAAoF,CAApF,8BAAoF,CAApF,mDAAoF,CACpF,8CAAsG,CAAtG,qBAAsG,CAAtG,+CAAsG,CAAtG,6CACD",
            sourcesContent: ['/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-tooltip,\n.ck.ck-tooltip .ck-tooltip__text::after {\n\tposition: absolute;\n\n\t/* Without this, hovering the tooltip could keep it visible. */\n\tpointer-events: none;\n\n\t/* This is to get rid of flickering when transitioning opacity in Chrome.\n\tIt\'s weird but it works. */\n\t-webkit-backface-visibility: hidden;\n}\n\n.ck.ck-tooltip {\n\t/* Tooltip is hidden by default. */\n\tvisibility: hidden;\n\topacity: 0;\n\tdisplay: none;\n\tz-index: var(--ck-z-modal);\n\n\t& .ck-tooltip__text {\n\t\tdisplay: inline-block;\n\n\t\t&::after {\n\t\t\tcontent: "";\n\t\t\twidth: 0;\n\t\t\theight: 0;\n\t\t}\n\t}\n}\n', '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-tooltip-arrow-size: 5px;\n}\n\n.ck.ck-tooltip {\n\tleft: 50%;\n\n\t/*\n\t * Prevent blurry tooltips in LoDPI environments.\n\t * See https://github.com/ckeditor/ckeditor5/issues/1802.\n\t */\n\ttop: 0;\n\n\t/*\n\t * For the transition to work, the tooltip must be controlled\n\t * using visibility+opacity. A delay prevents a "tooltip avalanche"\n\t * i.e. when scanning the toolbar with mouse cursor.\n\t */\n\ttransition: opacity .2s ease-in-out .2s;\n\n\t& .ck-tooltip__text {\n\t\t@mixin ck-rounded-corners;\n\n\t\tfont-size: .9em;\n\t\tline-height: 1.5;\n\t\tcolor: var(--ck-color-tooltip-text);\n\t\tpadding: var(--ck-spacing-small) var(--ck-spacing-medium);\n\t\tbackground: var(--ck-color-tooltip-background);\n\t\tposition: relative;\n\t\tleft: -50%;\n\n\t\t&::after {\n\t\t\t/*\n\t\t\t * For the transition to work, the tooltip must be controlled\n\t\t\t * using visibility+opacity. A delay prevents a "tooltip avalanche"\n\t\t\t * i.e. when scanning the toolbar with mouse cursor.\n\t\t\t */\n\t\t\ttransition: opacity .2s ease-in-out .2s;\n\t\t\tborder-style: solid;\n\t\t\tleft: 50%;\n\t\t}\n\t}\n\n\t/**\n\t * A class that displays the tooltip south of the element.\n\t *\n\t *       [element]\n\t *           ^\n\t *     +-----------+\n\t *     |  Tooltip  |\n\t *     +-----------+\n\t */\n\t&.ck-tooltip_s,\n\t&.ck-tooltip_sw {\n\t\tbottom: calc(-1 * var(--ck-tooltip-arrow-size));\n\t\ttransform: translateY( 100% );\n\n\t\t& .ck-tooltip__text::after {\n\t\t\t/* 1px addresses gliches in rendering causing gap between the triangle and the text */\n\t\t\ttop: calc(-1 * var(--ck-tooltip-arrow-size) + 1px);\n\t\t\ttransform: translateX( -50% );\n\t\t\tborder-color: transparent transparent var(--ck-color-tooltip-background) transparent;\n\t\t\tborder-width: 0 var(--ck-tooltip-arrow-size) var(--ck-tooltip-arrow-size) var(--ck-tooltip-arrow-size);\n\t\t}\n\t}\n\n\t/**\n\t * A class that displays the tooltip south-west of the element.\n\t *\n\t *        [element]\n\t *            ^\n\t *  +-----------+\n\t *  |  Tooltip  |\n\t *  +-----------+\n\t */\n\n\t&.ck-tooltip_sw {\n\t\tright: 50%;\n\t\tleft: auto;\n\n\t\t& .ck-tooltip__text {\n\t\t\tleft: auto;\n\t\t\tright: calc( -2 * var(--ck-tooltip-arrow-size));\n\t\t}\n\n\t\t& .ck-tooltip__text::after {\n\t\t\tleft: auto;\n\t\t\tright: 0;\n\t\t}\n\t}\n\n\t/**\n\t * A class that displays the tooltip north of the element.\n\t *\n\t *     +-----------+\n\t *     |  Tooltip  |\n\t *     +-----------+\n\t *           V\n\t *       [element]\n\t */\n\t&.ck-tooltip_n {\n\t\ttop: calc(-1 * var(--ck-tooltip-arrow-size));\n\t\ttransform: translateY( -100% );\n\n\t\t& .ck-tooltip__text::after {\n\t\t\tbottom: calc(-1 * var(--ck-tooltip-arrow-size));\n\t\t\ttransform: translateX( -50% );\n\t\t\tborder-color: var(--ck-color-tooltip-background) transparent transparent transparent;\n\t\t\tborder-width: var(--ck-tooltip-arrow-size) var(--ck-tooltip-arrow-size) 0 var(--ck-tooltip-arrow-size);\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck.ck-button,a.ck.ck-button{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-button .ck-tooltip,a.ck.ck-button .ck-tooltip{display:block}@media (hover:none){.ck.ck-button .ck-tooltip,a.ck.ck-button .ck-tooltip{display:none}}.ck.ck-button,a.ck.ck-button{position:relative;display:inline-flex;align-items:center;justify-content:left}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{display:none}.ck.ck-button.ck-button_with-text .ck-button__label,a.ck.ck-button.ck-button_with-text .ck-button__label{display:inline-block}.ck.ck-button:not(.ck-button_with-text),a.ck.ck-button:not(.ck-button_with-text){justify-content:center}.ck.ck-button:hover .ck-tooltip,a.ck.ck-button:hover .ck-tooltip{visibility:visible;opacity:1}.ck.ck-button:focus:not(:hover) .ck-tooltip,a.ck.ck-button:focus:not(:hover) .ck-tooltip{display:none}.ck.ck-button,a.ck.ck-button{background:var(--ck-color-button-default-background)}.ck.ck-button:not(.ck-disabled):hover,a.ck.ck-button:not(.ck-disabled):hover{background:var(--ck-color-button-default-hover-background)}.ck.ck-button:not(.ck-disabled):active,a.ck.ck-button:not(.ck-disabled):active{background:var(--ck-color-button-default-active-background);box-shadow:inset 0 2px 2px var(--ck-color-button-default-active-shadow)}.ck.ck-button.ck-disabled,a.ck.ck-button.ck-disabled{background:var(--ck-color-button-default-disabled-background)}.ck.ck-button,a.ck.ck-button{border-radius:0}.ck-rounded-corners .ck.ck-button,.ck-rounded-corners a.ck.ck-button,.ck.ck-button.ck-rounded-corners,a.ck.ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-button,a.ck.ck-button{white-space:nowrap;cursor:default;vertical-align:middle;padding:var(--ck-spacing-tiny);text-align:center;min-width:var(--ck-ui-component-min-height);min-height:var(--ck-ui-component-min-height);line-height:1;font-size:inherit;border:1px solid transparent;transition:box-shadow .2s ease-in-out,border .2s ease-in-out;-webkit-appearance:none}.ck.ck-button:active,.ck.ck-button:focus,a.ck.ck-button:active,a.ck.ck-button:focus{outline:none;border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0}.ck.ck-button .ck-button__icon use,.ck.ck-button .ck-button__icon use *,a.ck.ck-button .ck-button__icon use,a.ck.ck-button .ck-button__icon use *{color:inherit}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{font-size:inherit;font-weight:inherit;color:inherit;cursor:inherit;vertical-align:middle}[dir=ltr] .ck.ck-button .ck-button__label,[dir=ltr] a.ck.ck-button .ck-button__label{text-align:left}[dir=rtl] .ck.ck-button .ck-button__label,[dir=rtl] a.ck.ck-button .ck-button__label{text-align:right}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{color:inherit}[dir=ltr] .ck.ck-button .ck-button__keystroke,[dir=ltr] a.ck.ck-button .ck-button__keystroke{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-button .ck-button__keystroke,[dir=rtl] a.ck.ck-button .ck-button__keystroke{margin-right:var(--ck-spacing-large)}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{font-weight:700;opacity:.7}.ck.ck-button.ck-disabled:active,.ck.ck-button.ck-disabled:focus,a.ck.ck-button.ck-disabled:active,a.ck.ck-button.ck-disabled:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-button.ck-disabled .ck-button__icon,a.ck.ck-button.ck-disabled .ck-button__icon{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-disabled .ck-button__label,a.ck.ck-button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-disabled .ck-button__keystroke,a.ck.ck-button.ck-disabled .ck-button__keystroke{opacity:.3}.ck.ck-button.ck-button_with-text,a.ck.ck-button.ck-button_with-text{padding:var(--ck-spacing-tiny) var(--ck-spacing-standard)}[dir=ltr] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=ltr] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:calc(var(--ck-spacing-small)*-1);margin-right:var(--ck-spacing-small)}[dir=rtl] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=rtl] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-right:calc(var(--ck-spacing-small)*-1);margin-left:var(--ck-spacing-small)}.ck.ck-button.ck-button_with-keystroke .ck-button__label,a.ck.ck-button.ck-button_with-keystroke .ck-button__label{flex-grow:1}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{background:var(--ck-color-button-on-background)}.ck.ck-button.ck-on:not(.ck-disabled):hover,a.ck.ck-button.ck-on:not(.ck-disabled):hover{background:var(--ck-color-button-on-hover-background)}.ck.ck-button.ck-on:not(.ck-disabled):active,a.ck.ck-button.ck-on:not(.ck-disabled):active{background:var(--ck-color-button-on-active-background);box-shadow:inset 0 2px 2px var(--ck-color-button-on-active-shadow)}.ck.ck-button.ck-on.ck-disabled,a.ck.ck-button.ck-on.ck-disabled{background:var(--ck-color-button-on-disabled-background)}.ck.ck-button.ck-button-save,a.ck.ck-button.ck-button-save{color:var(--ck-color-button-save)}.ck.ck-button.ck-button-cancel,a.ck.ck-button.ck-button-cancel{color:var(--ck-color-button-cancel)}.ck.ck-button-action,a.ck.ck-button-action{background:var(--ck-color-button-action-background)}.ck.ck-button-action:not(.ck-disabled):hover,a.ck.ck-button-action:not(.ck-disabled):hover{background:var(--ck-color-button-action-hover-background)}.ck.ck-button-action:not(.ck-disabled):active,a.ck.ck-button-action:not(.ck-disabled):active{background:var(--ck-color-button-action-active-background);box-shadow:inset 0 2px 2px var(--ck-color-button-action-active-shadow)}.ck.ck-button-action.ck-disabled,a.ck.ck-button-action.ck-disabled{background:var(--ck-color-button-action-disabled-background)}.ck.ck-button-action,a.ck.ck-button-action{color:var(--ck-color-button-action-text)}.ck.ck-button-bold,a.ck.ck-button-bold{font-weight:700}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-ui/theme/components/button/button.css", "webpack://node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://node_modules/@ckeditor/ckeditor5-ui/theme/components/tooltip/mixins/_tooltip.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/button.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/mixins/_button.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css"],
            names: [],
            mappings: "AAQA,6BCCC,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBD6BD,CE/BC,qDACC,aAqBD,CAHC,oBAnBD,qDAoBE,YAEF,CADC,CFvBF,6BAKC,iBAAkB,CAClB,mBAAoB,CACpB,kBAAmB,CACnB,oBAyBD,CAvBC,iEACC,YACD,CAGC,yGACC,oBACD,CAID,iFACC,sBACD,CEkBA,iEACC,kBAAmB,CACnB,SACD,CAbA,yFACC,YACD,CC7BD,6BCAC,oDD0ID,CCvIE,6EACC,0DACD,CAEA,+EACC,2DAA4C,CAC5C,uEACD,CAID,qDACC,6DACD,CDhBD,6BEDC,eF2ID,CA1IA,wIEGE,qCFuIF,CA1IA,6BAKC,kBAAmB,CACnB,cAAe,CACf,qBAAsB,CACtB,8BAA+B,CAC/B,iBAAkB,CAGlB,2CAA4C,CAC5C,4CAA6C,CAI7C,aAAc,CAGd,iBAAkB,CAGlB,4BAA6B,CAG7B,4DAA8D,CAG9D,uBA6GD,CA3GC,oFGjCA,YAAa,CACb,2BAA2B,CCF3B,2CJsCA,CAIC,kJAEC,aACD,CAGD,iEAEC,iBAAkB,CAClB,mBAAoB,CACpB,aAAc,CACd,cAAe,CAIf,qBASD,CAlBA,qFAYE,eAMF,CAlBA,qFAgBE,gBAEF,CAEA,yEACC,aAYD,CAbA,6FAIE,mCASF,CAbA,6FAQE,oCAKF,CAbA,yEAWC,eAAiB,CACjB,UACD,CAIC,oIIrFD,oDJyFC,CAEA,uFK3FD,kCL6FC,CAGA,yFKhGD,kCLkGC,CAEA,iGACC,UACD,CAGD,qEACC,yDAcD,CAXC,2HAEE,4CAA+C,CAC/C,oCAOF,CAVA,2HAOE,6CAAgD,CAChD,mCAEF,CAKA,mHACC,WACD,CAID,yCC/HA,+CDiIA,CC9HC,yFACC,qDACD,CAEA,2FACC,sDAA4C,CAC5C,kEACD,CAID,iEACC,wDACD,CDmHA,2DACC,iCACD,CAEA,+DACC,mCACD,CAID,2CC7IC,mDDkJD,CC/IE,2FACC,yDACD,CAEA,6FACC,0DAA4C,CAC5C,sEACD,CAID,mEACC,4DACD,CD6HD,2CAIC,wCACD,CAEA,uCAEC,eACD",
            sourcesContent: ['/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n@import "../tooltip/mixins/_tooltip.css";\n\n.ck.ck-button,\na.ck.ck-button {\n\t@mixin ck-unselectable;\n\t@mixin ck-tooltip_enabled;\n\n\tposition: relative;\n\tdisplay: inline-flex;\n\talign-items: center;\n\tjustify-content: left;\n\n\t& .ck-button__label {\n\t\tdisplay: none;\n\t}\n\n\t&.ck-button_with-text {\n\t\t& .ck-button__label {\n\t\t\tdisplay: inline-block;\n\t\t}\n\t}\n\n\t/* Center the icon horizontally in a button without text. */\n\t&:not(.ck-button_with-text)  {\n\t\tjustify-content: center;\n\t}\n\n\t&:hover {\n\t\t@mixin ck-tooltip_visible;\n\t}\n\n\t/* Get rid of the native focus outline around the tooltip when focused (but not :hover). */\n\t&:focus:not(:hover) {\n\t\t@mixin ck-tooltip_disabled;\n\t}\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Enables the tooltip, which is the tooltip is in DOM but\n * not yet displayed.\n */\n@define-mixin ck-tooltip_enabled {\n\t& .ck-tooltip {\n\t\tdisplay: block;\n\n\t\t/*\n\t\t * Don't display tooltips in devices which don't support :hover.\n\t\t * In fact, it's all about iOS, which forces user to click UI elements twice to execute\n\t\t * the primary action, when tooltips are enabled.\n\t\t *\n\t\t * Q: OK, but why not the following query?\n\t\t *\n\t\t *   @media (hover) {\n\t\t *       display: block;\n\t\t *   }\n\t\t *\n\t\t * A: Because FF does not support it and it would completely disable tooltips\n\t\t * in that browser.\n\t\t *\n\t\t * More in https://github.com/ckeditor/ckeditor5/issues/920.\n\t\t */\n\t\t@media (hover:none) {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n\n/**\n * Disables the tooltip making it disappear from DOM.\n */\n@define-mixin ck-tooltip_disabled {\n\t& .ck-tooltip {\n\t\tdisplay: none;\n\t}\n}\n\n/**\n * Shows the tooltip, which is already in DOM.\n * Requires `ck-tooltip_enabled` first.\n */\n@define-mixin ck-tooltip_visible {\n\t& .ck-tooltip {\n\t\tvisibility: visible;\n\t\topacity: 1;\n\t}\n}\n", '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_focus.css";\n@import "../../../mixins/_shadow.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_rounded.css";\n@import "../../mixins/_button.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-button,\na.ck.ck-button {\n\t@mixin ck-button-colors --ck-color-button-default;\n\t@mixin ck-rounded-corners;\n\n\twhite-space: nowrap;\n\tcursor: default;\n\tvertical-align: middle;\n\tpadding: var(--ck-spacing-tiny);\n\ttext-align: center;\n\n\t/* A very important piece of styling. Go to variable declaration to learn more. */\n\tmin-width: var(--ck-ui-component-min-height);\n\tmin-height: var(--ck-ui-component-min-height);\n\n\t/* Normalize the height of the line. Removing this will break consistent height\n\tamong text and text-less buttons (with icons). */\n\tline-height: 1;\n\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t/* Avoid flickering when the foucs border shows up. */\n\tborder: 1px solid transparent;\n\n\t/* Apply some smooth transition to the box-shadow and border. */\n\ttransition: box-shadow .2s ease-in-out, border .2s ease-in-out;\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/189 */\n\t-webkit-appearance: none;\n\n\t&:active,\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t}\n\n\t/* Allow icon coloring using the text "color" property. */\n\t& .ck-button__icon {\n\t\t& use,\n\t\t& use * {\n\t\t\tcolor: inherit;\n\t\t}\n\t}\n\n\t& .ck-button__label {\n\t\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\t\tfont-size: inherit;\n\t\tfont-weight: inherit;\n\t\tcolor: inherit;\n\t\tcursor: inherit;\n\n\t\t/* Must be consistent with .ck-icon\'s vertical align. Otherwise, buttons with and\n\t\twithout labels (but with icons) have different sizes in Chrome */\n\t\tvertical-align: middle;\n\n\t\t@mixin ck-dir ltr {\n\t\t\ttext-align: left;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\ttext-align: right;\n\t\t}\n\t}\n\n\t& .ck-button__keystroke {\n\t\tcolor: inherit;\n\n\t\t@mixin ck-dir ltr {\n\t\t\tmargin-left: var(--ck-spacing-large);\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tmargin-right: var(--ck-spacing-large);\n\t\t}\n\n\t\tfont-weight: bold;\n\t\topacity: .7;\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */\n\t&.ck-disabled {\n\t\t&:active,\n\t\t&:focus {\n\t\t\t/* The disabled button should have a slightly less visible shadow when focused. */\n\t\t\t@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);\n\t\t}\n\n\t\t& .ck-button__icon {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */\n\t\t& .ck-button__label {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t& .ck-button__keystroke {\n\t\t\topacity: .3;\n\t\t}\n\t}\n\n\t&.ck-button_with-text {\n\t\tpadding: var(--ck-spacing-tiny) var(--ck-spacing-standard);\n\n\t\t/* stylelint-disable-next-line no-descending-specificity */\n\t\t& .ck-button__icon {\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: calc(-1 * var(--ck-spacing-small));\n\t\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-right: calc(-1 * var(--ck-spacing-small));\n\t\t\t\tmargin-left: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\t}\n\n\t&.ck-button_with-keystroke {\n\t\t/* stylelint-disable-next-line no-descending-specificity */\n\t\t& .ck-button__label {\n\t\t\tflex-grow: 1;\n\t\t}\n\t}\n\n\t/* A style of the button which is currently on, e.g. its feature is active. */\n\t&.ck-on {\n\t\t@mixin ck-button-colors --ck-color-button-on;\n\t}\n\n\t&.ck-button-save {\n\t\tcolor: var(--ck-color-button-save);\n\t}\n\n\t&.ck-button-cancel {\n\t\tcolor: var(--ck-color-button-cancel);\n\t}\n}\n\n/* A style of the button which handles the primary action. */\n.ck.ck-button-action,\na.ck.ck-button-action {\n\t@mixin ck-button-colors --ck-color-button-action;\n\n\tcolor: var(--ck-color-button-action-text);\n}\n\n.ck.ck-button-bold,\na.ck.ck-button-bold {\n\tfont-weight: bold;\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements a button of given background color.\n *\n * @param {String} $background - Background color of the button.\n * @param {String} $border - Border color of the button.\n */\n@define-mixin ck-button-colors $prefix {\n\tbackground: var($(prefix)-background);\n\n\t&:not(.ck-disabled) {\n\t\t&:hover {\n\t\t\tbackground: var($(prefix)-hover-background);\n\t\t}\n\n\t\t&:active {\n\t\t\tbackground: var($(prefix)-active-background);\n\t\t\tbox-shadow: inset 0 2px 2px var($(prefix)-active-shadow);\n\t\t}\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */\n\t&.ck-disabled {\n\t\tbackground: var($(prefix)-disabled-background);\n\t}\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck.ck-list{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none;display:flex;flex-direction:column}.ck.ck-list .ck-list__item,.ck.ck-list .ck-list__separator{display:block}.ck.ck-list .ck-list__item>:focus{position:relative;z-index:var(--ck-z-default)}.ck.ck-list{border-radius:0}.ck-rounded-corners .ck.ck-list,.ck.ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-list{list-style-type:none;background:var(--ck-color-list-background)}.ck.ck-list__item{cursor:default;min-width:12em}.ck.ck-list__item .ck-button{min-height:unset;width:100%;text-align:left;border-radius:0;padding:calc(var(--ck-line-height-base)*0.2*var(--ck-font-size-base)) calc(var(--ck-line-height-base)*0.4*var(--ck-font-size-base))}.ck.ck-list__item .ck-button .ck-button__label{line-height:calc(var(--ck-line-height-base)*1.2*var(--ck-font-size-base))}.ck.ck-list__item .ck-button:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on{background:var(--ck-color-list-button-on-background);color:var(--ck-color-list-button-on-text)}.ck.ck-list__item .ck-button.ck-on:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-on-background-focus)}.ck.ck-list__item .ck-button.ck-on:focus:not(.ck-disabled){border-color:var(--ck-color-base-background)}.ck.ck-list__item .ck-button:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background)}.ck.ck-list__item .ck-switchbutton.ck-on{background:var(--ck-color-list-background);color:inherit}.ck.ck-list__item .ck-switchbutton.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background);color:inherit}.ck.ck-list__separator{height:1px;width:100%;background:var(--ck-color-base-border)}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-ui/theme/components/list/list.css", "webpack://node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/list/list.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"],
            names: [],
            mappings: "AAOA,YCEC,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBAAgB,CDFhB,YAAa,CACb,qBAcD,CAZC,2DAEC,aACD,CAKA,kCACC,iBAAkB,CAClB,2BACD,CEfD,YCEC,eDGD,CALA,+DCME,qCDDF,CALA,YAGC,oBAAqB,CACrB,0CACD,CAEA,kBACC,cAAe,CACf,cA2DD,CAzDC,6BACC,gBAAiB,CACjB,UAAW,CACX,eAAgB,CAChB,eAAgB,CAKhB,mIAiCD,CA7BC,+CAEC,yEACD,CAEA,oCACC,eACD,CAEA,mCACC,oDAAqD,CACrD,yCAaD,CAXC,0CACC,eACD,CAEA,2DACC,0DACD,CAEA,2DACC,4CACD,CAGD,qDACC,uDACD,CAMA,yCACC,0CAA2C,CAC3C,aAMD,CAJC,iEACC,uDAAwD,CACxD,aACD,CAKH,uBACC,UAAW,CACX,UAAW,CACX,sCACD",
            sourcesContent: ['/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-list {\n\t@mixin ck-unselectable;\n\n\tdisplay: flex;\n\tflex-direction: column;\n\n\t& .ck-list__item,\n\t& .ck-list__separator {\n\t\tdisplay: block;\n\t}\n\n\t/* Make sure that whatever child of the list item gets focus, it remains on the\n\ttop. Thanks to that, styles like box-shadow, outline, etc. are not masked by\n\tadjacent list items. */\n\t& .ck-list__item > *:focus {\n\t\tposition: relative;\n\t\tz-index: var(--ck-z-default);\n\t}\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n", '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_shadow.css";\n\n.ck.ck-list {\n\t@mixin ck-rounded-corners;\n\n\tlist-style-type: none;\n\tbackground: var(--ck-color-list-background);\n}\n\n.ck.ck-list__item {\n\tcursor: default;\n\tmin-width: 12em;\n\n\t& .ck-button {\n\t\tmin-height: unset;\n\t\twidth: 100%;\n\t\ttext-align: left;\n\t\tborder-radius: 0;\n\n\t\t/* List items should have the same height. Use absolute units to make sure it is so\n\t\t   because e.g. different heading styles may have different height\n\t\t   https://github.com/ckeditor/ckeditor5-heading/issues/63 */\n\t\tpadding:\n\t\t\tcalc(.2 * var(--ck-line-height-base) * var(--ck-font-size-base))\n\t\t\tcalc(.4 * var(--ck-line-height-base) * var(--ck-font-size-base));\n\n\t\t& .ck-button__label {\n\t\t\t/* https://github.com/ckeditor/ckeditor5-heading/issues/63 */\n\t\t\tline-height: calc(1.2 * var(--ck-line-height-base) * var(--ck-font-size-base));\n\t\t}\n\n\t\t&:active {\n\t\t\tbox-shadow: none;\n\t\t}\n\n\t\t&.ck-on {\n\t\t\tbackground: var(--ck-color-list-button-on-background);\n\t\t\tcolor: var(--ck-color-list-button-on-text);\n\n\t\t\t&:active {\n\t\t\t\tbox-shadow: none;\n\t\t\t}\n\n\t\t\t&:hover:not(.ck-disabled) {\n\t\t\t\tbackground: var(--ck-color-list-button-on-background-focus);\n\t\t\t}\n\n\t\t\t&:focus:not(.ck-disabled) {\n\t\t\t\tborder-color: var(--ck-color-base-background);\n\t\t\t}\n\t\t}\n\n\t\t&:hover:not(.ck-disabled) {\n\t\t\tbackground: var(--ck-color-list-button-hover-background);\n\t\t}\n\t}\n\n\t/* It\'s unnecessary to change the background/text of a switch toggle; it has different ways\n\tof conveying its state (like the switcher) */\n\t& .ck-switchbutton {\n\t\t&.ck-on {\n\t\t\tbackground: var(--ck-color-list-background);\n\t\t\tcolor: inherit;\n\n\t\t\t&:hover:not(.ck-disabled) {\n\t\t\t\tbackground: var(--ck-color-list-button-hover-background);\n\t\t\t\tcolor: inherit;\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-list__separator {\n\theight: 1px;\n\twidth: 100%;\n\tbackground: var(--ck-color-base-border);\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{display:block}:root{--ck-switch-button-toggle-width:2.6153846154em;--ck-switch-button-toggle-inner-size:1.0769230769em;--ck-switch-button-toggle-spacing:1px;--ck-switch-button-translation:calc(var(--ck-switch-button-toggle-width) - var(--ck-switch-button-toggle-inner-size) - var(--ck-switch-button-toggle-spacing)*2)}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__label{margin-right:calc(var(--ck-spacing-large)*2)}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__label{margin-left:calc(var(--ck-spacing-large)*2)}.ck.ck-button.ck-switchbutton .ck-button__toggle{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle.ck-rounded-corners{border-radius:var(--ck-border-radius)}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-left:auto}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-right:auto}.ck.ck-button.ck-switchbutton .ck-button__toggle{transition:background .4s ease;width:var(--ck-switch-button-toggle-width);background:var(--ck-color-switch-button-off-background)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:calc(var(--ck-border-radius)*0.5)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{margin:var(--ck-switch-button-toggle-spacing);width:var(--ck-switch-button-toggle-inner-size);height:var(--ck-switch-button-toggle-inner-size);background:var(--ck-color-switch-button-inner-background);transition:all .3s ease}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover{background:var(--ck-color-switch-button-off-hover-background)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover .ck-button__toggle__inner{box-shadow:0 0 0 5px var(--ck-color-switch-button-inner-shadow)}.ck.ck-button.ck-switchbutton.ck-disabled .ck-button__toggle{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle{background:var(--ck-color-switch-button-on-background)}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle:hover{background:var(--ck-color-switch-button-on-hover-background)}[dir=ltr] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(var(--ck-switch-button-translation))}[dir=rtl] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(calc(var(--ck-switch-button-translation)*-1))}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-ui/theme/components/button/switchbutton.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/switchbutton.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css"],
            names: [],
            mappings: "AASE,4HACC,aACD,CCCF,MAEC,8CAA+C,CAE/C,mDAAoD,CACpD,qCAAsC,CACtC,gKAKD,CAGC,0DAGE,4CAOF,CAVA,0DAQE,2CAEF,CAEA,iDC3BA,eDoEA,CAzCA,yICvBC,qCDgED,CAzCA,2DAKE,gBAoCF,CAzCA,2DAUE,iBA+BF,CAzCA,iDAcC,8BAAiC,CAEjC,0CAA2C,CAC3C,uDAwBD,CAtBC,2EC9CD,eD2DC,CAbA,6LC1CA,qCAAsC,CD4CpC,+CAWF,CAbA,2EAMC,6CAA8C,CAC9C,+CAAgD,CAChD,gDAAiD,CACjD,yDAA0D,CAG1D,uBACD,CAEA,uDACC,6DAKD,CAHC,iFACC,+DACD,CAIF,6DExEA,kCF0EA,CAEA,uDACC,sDAkBD,CAhBC,6DACC,4DACD,CAEA,2FAKE,yDAMF,CAXA,2FASE,kEAEF",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-button.ck-switchbutton {\n\t& .ck-button__toggle {\n\t\tdisplay: block;\n\n\t\t& .ck-button__toggle__inner {\n\t\t\tdisplay: block;\n\t\t}\n\t}\n}\n", '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n/* Note: To avoid rendering issues (aliasing) but to preserve the responsive nature\nof the component, floating–point numbers have been used which, for the default font size\n(see: --ck-font-size-base), will generate simple integers. */\n:root {\n\t/* 34px at 13px font-size */\n\t--ck-switch-button-toggle-width: 2.6153846154em;\n\t/* 14px at 13px font-size */\n\t--ck-switch-button-toggle-inner-size: 1.0769230769em;\n\t--ck-switch-button-toggle-spacing: 1px;\n\t--ck-switch-button-translation: calc(\n\t\tvar(--ck-switch-button-toggle-width) -\n\t\tvar(--ck-switch-button-toggle-inner-size) -\n\t\t2 * var(--ck-switch-button-toggle-spacing)\n\t);\n}\n\n.ck.ck-button.ck-switchbutton {\n\t& .ck-button__label {\n\t\t@mixin ck-dir ltr {\n\t\t\t/* Separate the label from the switch */\n\t\t\tmargin-right: calc(2 * var(--ck-spacing-large));\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t/* Separate the label from the switch */\n\t\t\tmargin-left: calc(2 * var(--ck-spacing-large));\n\t\t}\n\t}\n\n\t& .ck-button__toggle {\n\t\t@mixin ck-rounded-corners;\n\n\t\t@mixin ck-dir ltr {\n\t\t\t/* Make sure the toggle is always to the right as far as possible. */\n\t\t\tmargin-left: auto;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t/* Make sure the toggle is always to the left as far as possible. */\n\t\t\tmargin-right: auto;\n\t\t}\n\n\t\t/* Gently animate the background color of the toggle switch */\n\t\ttransition: background 400ms ease;\n\n\t\twidth: var(--ck-switch-button-toggle-width);\n\t\tbackground: var(--ck-color-switch-button-off-background);\n\n\t\t& .ck-button__toggle__inner {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-radius: calc(.5 * var(--ck-border-radius));\n\t\t\t}\n\n\t\t\t/* Leave some tiny bit of space around the inner part of the switch */\n\t\t\tmargin: var(--ck-switch-button-toggle-spacing);\n\t\t\twidth: var(--ck-switch-button-toggle-inner-size);\n\t\t\theight: var(--ck-switch-button-toggle-inner-size);\n\t\t\tbackground: var(--ck-color-switch-button-inner-background);\n\n\t\t\t/* Gently animate the inner part of the toggle switch */\n\t\t\ttransition: all 300ms ease;\n\t\t}\n\n\t\t&:hover {\n\t\t\tbackground: var(--ck-color-switch-button-off-hover-background);\n\n\t\t\t& .ck-button__toggle__inner {\n\t\t\t\tbox-shadow: 0 0 0 5px var(--ck-color-switch-button-inner-shadow);\n\t\t\t}\n\t\t}\n\t}\n\n\t&.ck-disabled .ck-button__toggle {\n\t\t@mixin ck-disabled;\n\t}\n\n\t&.ck-on .ck-button__toggle {\n\t\tbackground: var(--ck-color-switch-button-on-background);\n\n\t\t&:hover {\n\t\t\tbackground: var(--ck-color-switch-button-on-hover-background);\n\t\t}\n\n\t\t& .ck-button__toggle__inner {\n\t\t\t/*\n\t\t\t * Move the toggle switch to the right. It will be animated.\n\t\t\t */\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\ttransform: translateX( var( --ck-switch-button-translation ) );\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\ttransform: translateX( calc( -1 * var( --ck-switch-button-translation ) ) );\n\t\t\t}\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck.ck-toolbar-dropdown .ck.ck-toolbar .ck.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar-dropdown .ck-dropdown__panel .ck-button:focus{z-index:calc(var(--ck-z-default) + 1)}.ck.ck-toolbar-dropdown .ck-toolbar{border:0}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/toolbardropdown.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/toolbardropdown.css"],
            names: [],
            mappings: "AAMC,6DACC,gBACD,CAGC,6DACC,qCACD,CCRF,oCACC,QACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-toolbar-dropdown {\n\t& .ck.ck-toolbar .ck.ck-toolbar__items {\n\t\tflex-wrap: nowrap;\n\t}\n\n\t& .ck-dropdown__panel .ck-button {\n\t\t&:focus {\n\t\t\tz-index: calc(var(--ck-z-default) + 1);\n\t\t}\n\t}\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-toolbar-dropdown .ck-toolbar {\n\tborder: 0;\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck.ck-dropdown .ck-dropdown__panel .ck-list{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list,.ck.ck-dropdown .ck-dropdown__panel .ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/listdropdown.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"],
            names: [],
            mappings: "AAOA,6CCIC,eDqBD,CAzBA,iICQE,qCAAsC,CDJtC,wBAqBF,CAfE,mFCND,eDYC,CANA,6MCFA,qCAAsC,CDIpC,wBAAyB,CACzB,2BAA4B,CAC5B,4BAEF,CAEA,kFCdD,eDmBC,CALA,2MCVA,qCAAsC,CDYpC,wBAAyB,CACzB,yBAEF",
            sourcesContent: ['/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n.ck.ck-dropdown .ck-dropdown__panel .ck-list {\n\t/* Disabled radius of top-left border to be consistent with .dropdown__button\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t@mixin ck-rounded-corners {\n\t\tborder-top-left-radius: 0;\n\t}\n\n\t/* Make sure the button belonging to the first/last child of the list goes well with the\n\tborder radius of the entire panel. */\n\t& .ck-list__item {\n\t\t&:first-child .ck-button {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-top-left-radius: 0;\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t}\n\t\t}\n\n\t\t&:last-child .ck-button {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-top-left-radius: 0;\n\t\t\t\tborder-top-right-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck.ck-toolbar{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none;display:flex;flex-flow:row nowrap;align-items:center}.ck.ck-toolbar>.ck-toolbar__items{display:flex;flex-flow:row wrap;align-items:center;flex-grow:1}.ck.ck-toolbar .ck.ck-toolbar__separator{display:inline-block}.ck.ck-toolbar .ck.ck-toolbar__separator:first-child,.ck.ck-toolbar .ck.ck-toolbar__separator:last-child{display:none}.ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items{flex-direction:column}.ck.ck-toolbar.ck-toolbar_floating>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck-dropdown__button .ck-dropdown__arrow{display:none}.ck.ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-toolbar,.ck.ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-toolbar{background:var(--ck-color-toolbar-background);padding:0 var(--ck-spacing-small);border:1px solid var(--ck-color-toolbar-border)}.ck.ck-toolbar .ck.ck-toolbar__separator{align-self:stretch;width:1px;min-width:1px;background:var(--ck-color-toolbar-border);margin-top:var(--ck-spacing-small);margin-bottom:var(--ck-spacing-small)}.ck.ck-toolbar>.ck-toolbar__items>*{margin-top:var(--ck-spacing-small);margin-bottom:var(--ck-spacing-small);margin-right:var(--ck-spacing-small)}.ck.ck-toolbar>.ck-toolbar__items:empty+.ck.ck-toolbar__separator{display:none}.ck.ck-toolbar>.ck-toolbar__items>*,.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown{margin-top:var(--ck-spacing-small);margin-bottom:var(--ck-spacing-small)}.ck.ck-toolbar.ck-toolbar_vertical{padding:0}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items>.ck{width:100%;margin:0;border-radius:0;border:0}.ck.ck-toolbar.ck-toolbar_compact{padding:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>*{margin:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>:not(:first-child):not(:last-child){border-radius:0}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck.ck-button.ck-dropdown__button{padding-left:var(--ck-spacing-tiny)}.ck-toolbar-container .ck.ck-toolbar{border:0}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck{margin-right:0}.ck.ck-toolbar[dir=rtl]:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-left:0}.ck.ck-toolbar[dir=rtl].ck-toolbar_compact>.ck-toolbar__items>.ck:first-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-top-left-radius:0;border-bottom-left-radius:0}.ck.ck-toolbar[dir=rtl].ck-toolbar_compact>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-top-right-radius:0;border-bottom-right-radius:0}.ck.ck-toolbar[dir=rtl]>.ck.ck-toolbar__separator,[dir=rtl] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=rtl].ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=rtl] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child){margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-right:0}.ck.ck-toolbar[dir=ltr].ck-toolbar_compact>.ck-toolbar__items>.ck:first-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-top-right-radius:0;border-bottom-right-radius:0}.ck.ck-toolbar[dir=ltr].ck-toolbar_compact>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-top-left-radius:0;border-bottom-left-radius:0}.ck.ck-toolbar[dir=ltr]>.ck.ck-toolbar__separator,[dir=ltr] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-right:var(--ck-spacing-small)}.ck.ck-toolbar[dir=ltr].ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=ltr] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child){margin-right:var(--ck-spacing-small)}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-ui/theme/components/toolbar/toolbar.css", "webpack://node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/toolbar.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"],
            names: [],
            mappings: "AAOA,eCEC,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBAAgB,CDFhB,YAAa,CACb,oBAAqB,CACrB,kBAyCD,CAvCC,kCACC,YAAa,CACb,kBAAmB,CACnB,kBAAmB,CACnB,WAED,CAEA,yCACC,oBAWD,CAJC,yGAEC,YACD,CAGD,sDACC,gBACD,CAEA,sDACC,qBACD,CAEA,sDACC,gBACD,CAGC,yFACC,YACD,CE3CF,eCGC,eD0FD,CA7FA,qECOE,qCDsFF,CA7FA,eAGC,6CAA8C,CAC9C,iCAAkC,CAClC,+CAwFD,CAtFC,yCACC,kBAAmB,CACnB,SAAU,CACV,aAAc,CACd,yCAA0C,CAM1C,kCAAmC,CACnC,qCACD,CAGC,oCAEC,kCAAmC,CACnC,qCAAsC,CAGtC,oCACD,CAIA,kEACC,YACD,CAGD,oFAGC,kCAAmC,CACnC,qCACD,CAEA,mCAEC,SAgBD,CAbC,0DAEC,UAAW,CAGX,QAAS,CAGT,eAAgB,CAGhB,QACD,CAGD,kCAEC,SAWD,CATC,uDAEC,QAMD,CAHC,yFACC,eACD,CASD,kFACC,mCACD,CAvFF,qCA2FE,QAEF,CAYC,+FACC,cACD,CAEA,iJAEC,mCACD,CAEA,qHACC,aACD,CAIC,6JACC,wBAAyB,CACzB,2BACD,CAGA,2JACC,yBAA0B,CAC1B,4BACD,CAID,qGACC,mCACD,CAGA,yLACC,mCACD,CAWA,qHACC,cACD,CAIC,6JACC,yBAA0B,CAC1B,4BACD,CAGA,2JACC,wBAAyB,CACzB,2BACD,CAID,qGACC,oCACD,CAGA,yLACC,oCACD",
            sourcesContent: ['/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-toolbar {\n\t@mixin ck-unselectable;\n\n\tdisplay: flex;\n\tflex-flow: row nowrap;\n\talign-items: center;\n\n\t& > .ck-toolbar__items {\n\t\tdisplay: flex;\n\t\tflex-flow: row wrap;\n\t\talign-items: center;\n\t\tflex-grow: 1;\n\n\t}\n\n\t& .ck.ck-toolbar__separator {\n\t\tdisplay: inline-block;\n\n\t\t/*\n\t\t * A leading or trailing separator makes no sense (separates from nothing on one side).\n\t\t * For instance, it can happen when toolbar items (also separators) are getting grouped one by one and\n\t\t * moved to another toolbar in the dropdown.\n\t\t */\n\t\t&:first-child,\n\t\t&:last-child {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t&.ck-toolbar_grouping > .ck-toolbar__items {\n\t\tflex-wrap: nowrap;\n\t}\n\n\t&.ck-toolbar_vertical > .ck-toolbar__items {\n\t\tflex-direction: column;\n\t}\n\n\t&.ck-toolbar_floating > .ck-toolbar__items {\n\t\tflex-wrap: nowrap;\n\t}\n\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t& > .ck-dropdown__button .ck-dropdown__arrow {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n", '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-toolbar {\n\t@mixin ck-rounded-corners;\n\n\tbackground: var(--ck-color-toolbar-background);\n\tpadding: 0 var(--ck-spacing-small);\n\tborder: 1px solid var(--ck-color-toolbar-border);\n\n\t& .ck.ck-toolbar__separator {\n\t\talign-self: stretch;\n\t\twidth: 1px;\n\t\tmin-width: 1px;\n\t\tbackground: var(--ck-color-toolbar-border);\n\n\t\t/*\n\t\t * These margins make the separators look better in balloon toolbars (when aligned with the "tip").\n\t\t * See https://github.com/ckeditor/ckeditor5/issues/7493.\n\t\t */\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t& > .ck-toolbar__items {\n\t\t& > * {\n\t\t\t/* Make sure items wrapped to the next line have v-spacing */\n\t\t\tmargin-top: var(--ck-spacing-small);\n\t\t\tmargin-bottom: var(--ck-spacing-small);\n\n\t\t\t/* (#11) Separate toolbar items. */\n\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t}\n\n\t\t/* Don\'t display a separator after an empty items container, for instance,\n\t\twhen all items were grouped */\n\t\t&:empty + .ck.ck-toolbar__separator {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t& > .ck-toolbar__items > *,\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t/* Make sure items wrapped to the next line have v-spacing */\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t&.ck-toolbar_vertical {\n\t\t/* Items in a vertical toolbar span the entire width. */\n\t\tpadding: 0;\n\n\t\t/* Specificity matters here. See https://github.com/ckeditor/ckeditor5-theme-lark/issues/168. */\n\t\t& > .ck-toolbar__items > .ck {\n\t\t\t/* Items in a vertical toolbar should span the horizontal space. */\n\t\t\twidth: 100%;\n\n\t\t\t/* Items in a vertical toolbar should have no margin. */\n\t\t\tmargin: 0;\n\n\t\t\t/* Items in a vertical toolbar span the entire width so rounded corners are pointless. */\n\t\t\tborder-radius: 0;\n\n\t\t\t/* Items in a vertical toolbar span the entire width so any border is pointless. */\n\t\t\tborder: 0;\n\t\t}\n\t}\n\n\t&.ck-toolbar_compact {\n\t\t/* No spacing around items. */\n\t\tpadding: 0;\n\n\t\t& > .ck-toolbar__items > * {\n\t\t\t/* Compact toolbar items have no spacing between them. */\n\t\t\tmargin: 0;\n\n\t\t\t/* "Middle" children should have no rounded corners. */\n\t\t\t&:not(:first-child):not(:last-child) {\n\t\t\t\tborder-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t/*\n\t\t * Dropdown button has asymmetric padding to fit the arrow.\n\t\t * This button has no arrow so let\'s revert that padding back to normal.\n\t\t */\n\t\t& > .ck.ck-button.ck-dropdown__button {\n\t\t\tpadding-left: var(--ck-spacing-tiny);\n\t\t}\n\t}\n\n\t@nest .ck-toolbar-container & {\n\t\tborder: 0;\n\t}\n}\n\n/* stylelint-disable */\n\n/*\n * Styles for RTL toolbars.\n *\n * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"\n * because its parent is not controlled by the editor framework.\n */\n[dir="rtl"] .ck.ck-toolbar,\n.ck.ck-toolbar[dir="rtl"] {\n\t& > .ck-toolbar__items > .ck {\n\t\tmargin-right: 0;\n\t}\n\n\t&:not(.ck-toolbar_compact) > .ck-toolbar__items > .ck {\n\t\t/* (#11) Separate toolbar items. */\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n\n\t& > .ck-toolbar__items > .ck:last-child {\n\t\tmargin-left: 0;\n\t}\n\n\t&.ck-toolbar_compact > .ck-toolbar__items > .ck {\n\t\t/* No rounded corners on the right side of the first child. */\n\t\t&:first-child {\n\t\t\tborder-top-left-radius: 0;\n\t\t\tborder-bottom-left-radius: 0;\n\t\t}\n\n\t\t/* No rounded corners on the left side of the last child. */\n\t\t&:last-child {\n\t\t\tborder-top-right-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\t}\n\n\t/* Separate the the separator form the grouping dropdown when some items are grouped. */\n\t& > .ck.ck-toolbar__separator {\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n\n\t/* Some spacing between the items and the separator before the grouped items dropdown. */\n\t&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n}\n\n/*\n * Styles for LTR toolbars.\n *\n * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"\n * because its parent is not controlled by the editor framework.\n */\n[dir="ltr"] .ck.ck-toolbar,\n.ck.ck-toolbar[dir="ltr"] {\n\t& > .ck-toolbar__items > .ck:last-child {\n\t\tmargin-right: 0;\n\t}\n\n\t&.ck-toolbar_compact > .ck-toolbar__items > .ck {\n\t\t/* No rounded corners on the right side of the first child. */\n\t\t&:first-child {\n\t\t\tborder-top-right-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\n\t\t/* No rounded corners on the left side of the last child. */\n\t\t&:last-child {\n\t\t\tborder-top-left-radius: 0;\n\t\t\tborder-bottom-left-radius: 0;\n\t\t}\n\t}\n\n\t/* Separate the the separator form the grouping dropdown when some items are grouped. */\n\t& > .ck.ck-toolbar__separator {\n\t\tmargin-right: var(--ck-spacing-small);\n\t}\n\n\t/* Some spacing between the items and the separator before the grouped items dropdown. */\n\t&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {\n\t\tmargin-right: var(--ck-spacing-small);\n\t}\n}\n\n/* stylelint-enable */\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck.ck-editor{position:relative}.ck.ck-editor .ck-editor__top .ck-sticky-panel .ck-toolbar{z-index:var(--ck-z-modal)}.ck.ck-editor__top .ck-sticky-panel .ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-editor__top .ck-sticky-panel .ck-toolbar,.ck.ck-editor__top .ck-sticky-panel .ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius);border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-editor__top .ck-sticky-panel .ck-toolbar{border-bottom-width:0}.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar{border-bottom-width:1px;border-radius:0}.ck-rounded-corners .ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar,.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:0}.ck.ck-editor__main>.ck-editor__editable{background:var(--ck-color-base-background);border-radius:0}.ck-rounded-corners .ck.ck-editor__main>.ck-editor__editable,.ck.ck-editor__main>.ck-editor__editable.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}.ck.ck-editor__main>.ck-editor__editable:not(.ck-focused){border-color:var(--ck-color-base-border)}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-editor-classic/theme/classiceditor.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-editor-classic/classiceditor.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"],
            names: [],
            mappings: "AAKA,cAIC,iBAMD,CAJC,2DAEC,yBACD,CCLC,gDCED,eDKC,CAPA,uICMA,qCAAsC,CDJpC,2BAA4B,CAC5B,4BAIF,CAPA,gDAMC,qBACD,CAEA,iFACC,uBAAwB,CCR1B,eDaC,CANA,yMCHA,qCAAsC,CDOpC,eAEF,CAKF,yCAEC,0CAA2C,CCpB3C,eD8BD,CAZA,yHCdE,qCAAsC,CDmBtC,wBAAyB,CACzB,yBAMF,CAHC,0DACC,wCACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor {\n\t/* All the elements within `.ck-editor` are positioned relatively to it.\n\t If any element needs to be positioned with respect to the <body>, etc.,\n\t it must land outside of the `.ck-editor` in DOM. */\n\tposition: relative;\n\n\t& .ck-editor__top .ck-sticky-panel .ck-toolbar {\n\t\t/* https://github.com/ckeditor/ckeditor5-editor-classic/issues/62 */\n\t\tz-index: var(--ck-z-modal);\n\t}\n}\n", '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../mixins/_rounded.css";\n\n.ck.ck-editor__top {\n\t& .ck-sticky-panel {\n\t\t& .ck-toolbar {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t}\n\n\t\t\tborder-bottom-width: 0;\n\t\t}\n\n\t\t& .ck-sticky-panel__content_sticky .ck-toolbar {\n\t\t\tborder-bottom-width: 1px;\n\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* Note: Use ck-editor__main to make sure these styles don\'t apply to other editor types */\n.ck.ck-editor__main > .ck-editor__editable {\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/113 */\n\tbackground: var(--ck-color-base-background);\n\n\t@mixin ck-rounded-corners {\n\t\tborder-top-left-radius: 0;\n\t\tborder-top-right-radius: 0;\n\t}\n\n\t&:not(.ck-focused) {\n\t\tborder-color: var(--ck-color-base-border);\n\t}\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck-content blockquote{overflow:hidden;padding-right:1.5em;padding-left:1.5em;margin-left:0;margin-right:0;font-style:italic;border-left:5px solid #ccc}.ck-content[dir=rtl] blockquote{border-left:0;border-right:5px solid #ccc}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-block-quote/theme/blockquote.css"],
            names: [],
            mappings: "AAKA,uBAEC,eAAgB,CAGhB,mBAAoB,CACpB,kBAAmB,CAEnB,aAAc,CACd,cAAe,CACf,iBAAkB,CAClB,0BACD,CAEA,gCACC,aAAc,CACd,2BACD",
            sourcesContent: ['/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content blockquote {\n\t/* See #12 */\n\toverflow: hidden;\n\n\t/* https://github.com/ckeditor/ckeditor5-block-quote/issues/15 */\n\tpadding-right: 1.5em;\n\tpadding-left: 1.5em;\n\n\tmargin-left: 0;\n\tmargin-right: 0;\n\tfont-style: italic;\n\tborder-left: solid 5px hsl(0, 0%, 80%);\n}\n\n.ck-content[dir="rtl"] blockquote {\n\tborder-left: 0;\n\tborder-right: solid 5px hsl(0, 0%, 80%);\n}\n'],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck-content code{background-color:hsla(0,0%,78%,.3);padding:.15em;border-radius:2px}.ck.ck-editor__editable .ck-code_selected{background-color:hsla(0,0%,78%,.5)}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-basic-styles/theme/code.css"],
            names: [],
            mappings: "AAKA,iBACC,kCAAuC,CACvC,aAAc,CACd,iBACD,CAEA,0CACC,kCACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content code {\n\tbackground-color: hsla(0, 0%, 78%, 0.3);\n\tpadding: .15em;\n\tborder-radius: 2px;\n}\n\n.ck.ck-editor__editable .ck-code_selected  {\n\tbackground-color: hsla(0, 0%, 78%, 0.5);\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck.ck-splitbutton{font-size:inherit}.ck.ck-splitbutton .ck-splitbutton__action:focus{z-index:calc(var(--ck-z-default) + 1)}.ck.ck-splitbutton.ck-splitbutton_open>.ck-button .ck-tooltip{display:none}:root{--ck-color-split-button-hover-background:#ebebeb;--ck-color-split-button-hover-border:#b3b3b3}[dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__action{border-top-right-radius:unset;border-bottom-right-radius:unset}[dir=rtl] .ck.ck-splitbutton>.ck-splitbutton__action{border-top-left-radius:unset;border-bottom-left-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow{min-width:unset}[dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-radius:0}.ck-rounded-corners [dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__arrow,[dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__arrow.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:unset;border-bottom-left-radius:unset}[dir=rtl] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-top-right-radius:unset;border-bottom-right-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow svg{width:var(--ck-dropdown-arrow-size)}.ck.ck-splitbutton.ck-splitbutton_open>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover),.ck.ck-splitbutton:hover>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover){background:var(--ck-color-split-button-hover-background)}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled),[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled){border-left-color:var(--ck-color-split-button-hover-border)}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled),[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled){border-right-color:var(--ck-color-split-button-hover-border)}.ck.ck-splitbutton.ck-splitbutton_open{border-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__action{border-bottom-left-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__arrow{border-bottom-right-radius:0}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/splitbutton.css", "webpack://node_modules/@ckeditor/ckeditor5-ui/theme/components/tooltip/mixins/_tooltip.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/splitbutton.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"],
            names: [],
            mappings: "AAOA,mBAEC,iBAUD,CARC,iDACC,qCACD,CC0BA,8DACC,YACD,CClCD,MACC,gDAAyD,CACzD,4CACD,CAMC,qDAGE,6BAA8B,CAC9B,gCAQF,CAZA,qDASE,4BAA6B,CAC7B,+BAEF,CAEA,0CAGC,eAmBD,CAtBA,oDCnBA,eDyCA,CAtBA,+ICfC,qCAAsC,CDuBpC,4BAA6B,CAC7B,+BAaH,CAtBA,oDAeE,6BAA8B,CAC9B,gCAMF,CAHC,8CACC,mCACD,CASA,0KACC,wDACD,CAGC,sKACC,2DACD,CAIA,sKACC,4DACD,CAMF,uCCpEA,eD8EA,CAVA,qHChEC,qCD0ED,CARE,qKACC,2BACD,CAEA,mKACC,4BACD",
            sourcesContent: ['/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../tooltip/mixins/_tooltip.css";\n\n.ck.ck-splitbutton {\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t& .ck-splitbutton__action:focus {\n\t\tz-index: calc(var(--ck-z-default) + 1);\n\t}\n\n\t/* Disable tooltips for the buttons when the button is "open" */\n\t&.ck-splitbutton_open > .ck-button {\n\t\t@mixin ck-tooltip_disabled;\n\t}\n}\n\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Enables the tooltip, which is the tooltip is in DOM but\n * not yet displayed.\n */\n@define-mixin ck-tooltip_enabled {\n\t& .ck-tooltip {\n\t\tdisplay: block;\n\n\t\t/*\n\t\t * Don't display tooltips in devices which don't support :hover.\n\t\t * In fact, it's all about iOS, which forces user to click UI elements twice to execute\n\t\t * the primary action, when tooltips are enabled.\n\t\t *\n\t\t * Q: OK, but why not the following query?\n\t\t *\n\t\t *   @media (hover) {\n\t\t *       display: block;\n\t\t *   }\n\t\t *\n\t\t * A: Because FF does not support it and it would completely disable tooltips\n\t\t * in that browser.\n\t\t *\n\t\t * More in https://github.com/ckeditor/ckeditor5/issues/920.\n\t\t */\n\t\t@media (hover:none) {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n\n/**\n * Disables the tooltip making it disappear from DOM.\n */\n@define-mixin ck-tooltip_disabled {\n\t& .ck-tooltip {\n\t\tdisplay: none;\n\t}\n}\n\n/**\n * Shows the tooltip, which is already in DOM.\n * Requires `ck-tooltip_enabled` first.\n */\n@define-mixin ck-tooltip_visible {\n\t& .ck-tooltip {\n\t\tvisibility: visible;\n\t\topacity: 1;\n\t}\n}\n", '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-color-split-button-hover-background: hsl(0, 0%, 92%);\n\t--ck-color-split-button-hover-border: hsl(0, 0%, 70%);\n}\n\n.ck.ck-splitbutton {\n\t/*\n\t * Note: ck-rounded and ck-dir mixins don\'t go together (because they both use @nest).\n\t */\n\t& > .ck-splitbutton__action {\n\t\t@nest [dir="ltr"] & {\n\t\t\t/* Don\'t round the action button on the right side */\n\t\t\tborder-top-right-radius: unset;\n\t\t\tborder-bottom-right-radius: unset;\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t/* Don\'t round the action button on the left side */\n\t\t\tborder-top-left-radius: unset;\n\t\t\tborder-bottom-left-radius: unset;\n\t\t}\n\t}\n\n\t& > .ck-splitbutton__arrow {\n\t\t/* It\'s a text-less button and since the icon is positioned absolutely in such situation,\n\t\tit must get some arbitrary min-width. */\n\t\tmin-width: unset;\n\n\t\t@nest [dir="ltr"] & {\n\t\t\t/* Don\'t round the arrow button on the left side */\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-top-left-radius: unset;\n\t\t\t\tborder-bottom-left-radius: unset;\n\t\t\t}\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t/* Don\'t round the arrow button on the right side */\n\t\t\tborder-top-right-radius: unset;\n\t\t\tborder-bottom-right-radius: unset;\n\t\t}\n\n\t\t& svg {\n\t\t\twidth: var(--ck-dropdown-arrow-size);\n\t\t}\n\t}\n\n\t/* When the split button is "open" (the arrow is on) or being hovered, it should get some styling\n\tas a whole. The background of both buttons should stand out and there should be a visual\n\tseparation between both buttons. */\n\t&.ck-splitbutton_open,\n\t&:hover {\n\t\t/* When the split button hovered as a whole, not as individual buttons. */\n\t\t& > .ck-button:not(.ck-on):not(.ck-disabled):not(:hover) {\n\t\t\tbackground: var(--ck-color-split-button-hover-background);\n\t\t}\n\n\t\t@nest [dir="ltr"] & {\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled) {\n\t\t\t\tborder-left-color: var(--ck-color-split-button-hover-border);\n\t\t\t}\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled) {\n\t\t\t\tborder-right-color: var(--ck-color-split-button-hover-border);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Don\'t round the bottom left and right corners of the buttons when "open"\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t&.ck-splitbutton_open {\n\t\t@mixin ck-rounded-corners {\n\t\t\t& > .ck-splitbutton__action {\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t}\n\n\t\t\t& > .ck-splitbutton__arrow {\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck-content pre{padding:1em;color:#353535;background:hsla(0,0%,78%,.3);border:1px solid #c4c4c4;border-radius:2px;text-align:left;direction:ltr;tab-size:4;white-space:pre-wrap;font-style:normal;min-width:200px}.ck-content pre code{background:unset;padding:0;border-radius:0}.ck.ck-editor__editable pre{position:relative}.ck.ck-editor__editable pre[data-language]:after{content:attr(data-language);position:absolute}:root{--ck-color-code-block-label-background:#757575}.ck.ck-editor__editable pre[data-language]:after{top:-1px;right:10px;background:var(--ck-color-code-block-label-background);font-size:10px;font-family:var(--ck-font-face);line-height:16px;padding:var(--ck-spacing-tiny) var(--ck-spacing-medium);color:#fff;white-space:nowrap}.ck.ck-code-block-dropdown .ck-dropdown__panel{max-height:250px;overflow-y:auto;overflow-x:hidden}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-code-block/theme/codeblock.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-code-block/codeblock.css"],
            names: [],
            mappings: "AAKA,gBACC,WAAY,CACZ,aAAwB,CACxB,4BAAiC,CACjC,wBAAiC,CACjC,iBAAkB,CAGlB,eAAgB,CAChB,aAAc,CAEd,UAAW,CACX,oBAAqB,CAGrB,iBAAkB,CAGlB,eAOD,CALC,qBACC,gBAAiB,CACjB,SAAU,CACV,eACD,CAGD,4BACC,iBAMD,CAJC,iDACC,2BAA4B,CAC5B,iBACD,CCjCD,MACC,8CACD,CAEA,iDACC,QAAS,CACT,UAAW,CACX,sDAAuD,CAEvD,cAAe,CACf,+BAAgC,CAChC,gBAAiB,CACjB,uDAAwD,CACxD,UAAuB,CACvB,kBACD,CAEA,+CAEC,gBAAiB,CACjB,eAAgB,CAChB,iBACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content pre {\n\tpadding: 1em;\n\tcolor: hsl(0, 0%, 20.8%);\n\tbackground: hsla(0, 0%, 78%, 0.3);\n\tborder: 1px solid hsl(0, 0%, 77%);\n\tborder-radius: 2px;\n\n\t/* Code block are language direction–agnostic. */\n\ttext-align: left;\n\tdirection: ltr;\n\n\ttab-size: 4;\n\twhite-space: pre-wrap;\n\n\t/* Don't inherit the style, e.g. when in a block quote. */\n\tfont-style: normal;\n\n\t/* Don't let the code be squashed e.g. when in a table cell. */\n\tmin-width: 200px;\n\n\t& code {\n\t\tbackground: unset;\n\t\tpadding: 0;\n\t\tborder-radius: 0;\n\t}\n}\n\n.ck.ck-editor__editable pre {\n\tposition: relative;\n\n\t&[data-language]::after {\n\t\tcontent: attr(data-language);\n\t\tposition: absolute;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-code-block-label-background: hsl(0, 0%, 46%);\n}\n\n.ck.ck-editor__editable pre[data-language]::after {\n\ttop: -1px;\n\tright: 10px;\n\tbackground: var(--ck-color-code-block-label-background);\n\n\tfont-size: 10px;\n\tfont-family: var(--ck-font-face);\n\tline-height: 16px;\n\tpadding: var(--ck-spacing-tiny) var(--ck-spacing-medium);\n\tcolor: hsl(0, 0%, 100%);\n\twhite-space: nowrap;\n}\n\n.ck.ck-code-block-dropdown .ck-dropdown__panel {\n\t/* There could be dozens of languages available. Use scroll to prevent a 10e6px dropdown. */\n\tmax-height: 250px;\n\toverflow-y: auto;\n\toverflow-x: hidden;\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck.ck-color-grid{display:grid}:root{--ck-color-grid-tile-size:24px;--ck-color-color-grid-check-icon:#000}.ck.ck-color-grid{grid-gap:5px;padding:8px}.ck.ck-color-grid__tile{width:var(--ck-color-grid-tile-size);height:var(--ck-color-grid-tile-size);min-width:var(--ck-color-grid-tile-size);min-height:var(--ck-color-grid-tile-size);padding:0;transition:box-shadow .2s ease;border:0}.ck.ck-color-grid__tile.ck-disabled{cursor:unset;transition:unset}.ck.ck-color-grid__tile.ck-color-table__color-tile_bordered{box-shadow:0 0 0 1px var(--ck-color-base-border)}.ck.ck-color-grid__tile .ck.ck-icon{display:none;color:var(--ck-color-color-grid-check-icon)}.ck.ck-color-grid__tile.ck-on{box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-base-text)}.ck.ck-color-grid__tile.ck-on .ck.ck-icon{display:block}.ck.ck-color-grid__tile.ck-on,.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){border:0}.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-focus-border)}.ck.ck-color-grid__label{padding:0 var(--ck-spacing-standard)}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-ui/theme/components/colorgrid/colorgrid.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/colorgrid/colorgrid.css"],
            names: [],
            mappings: "AAKA,kBACC,YACD,CCAA,MACC,8BAA+B,CAK/B,qCACD,CAEA,kBACC,YAAa,CACb,WACD,CAEA,wBACC,oCAAqC,CACrC,qCAAsC,CACtC,wCAAyC,CACzC,yCAA0C,CAC1C,SAAU,CACV,8BAA+B,CAC/B,QAmCD,CAjCC,oCACC,YAAa,CACb,gBACD,CAEA,4DACC,gDACD,CAEA,oCACC,YAAa,CACb,2CACD,CAEA,8BACC,8FAKD,CAHC,0CACC,aACD,CAGD,8HAIC,QACD,CAEA,gGAEC,iGACD,CAGD,yBACC,oCACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-color-grid {\n\tdisplay: grid;\n}\n", '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-color-grid-tile-size: 24px;\n\n\t/* Not using global colors here because these may change but some colors in a pallette\n\t * require special treatment. For instance, this ensures no matter what the UI text color is,\n\t * the check icon will look good on the black color tile. */\n\t--ck-color-color-grid-check-icon: hsl(0, 0%, 0%);\n}\n\n.ck.ck-color-grid {\n\tgrid-gap: 5px;\n\tpadding: 8px;\n}\n\n.ck.ck-color-grid__tile {\n\twidth: var(--ck-color-grid-tile-size);\n\theight: var(--ck-color-grid-tile-size);\n\tmin-width: var(--ck-color-grid-tile-size);\n\tmin-height: var(--ck-color-grid-tile-size);\n\tpadding: 0;\n\ttransition: .2s ease box-shadow;\n\tborder: 0;\n\n\t&.ck-disabled {\n\t\tcursor: unset;\n\t\ttransition: unset;\n\t}\n\n\t&.ck-color-table__color-tile_bordered {\n\t\tbox-shadow: 0 0 0 1px var(--ck-color-base-border);\n\t}\n\n\t& .ck.ck-icon {\n\t\tdisplay: none;\n\t\tcolor: var(--ck-color-color-grid-check-icon);\n\t}\n\n\t&.ck-on {\n\t\tbox-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-base-text);\n\n\t\t& .ck.ck-icon {\n\t\t\tdisplay: block;\n\t\t}\n\t}\n\n\t&.ck-on,\n\t&:focus:not( .ck-disabled ),\n\t&:hover:not( .ck-disabled ) {\n\t\t/* Disable the default .ck-button\'s border ring. */\n\t\tborder: 0;\n\t}\n\n\t&:focus:not( .ck-disabled ),\n\t&:hover:not( .ck-disabled ) {\n\t\tbox-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-focus-border);\n\t}\n}\n\n.ck.ck-color-grid__label {\n\tpadding: 0 var(--ck-spacing-standard);\n}\n'],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck .ck-button.ck-color-table__remove-color{display:flex;align-items:center;width:100%}label.ck.ck-color-grid__label{font-weight:unset}.ck .ck-button.ck-color-table__remove-color{padding:calc(var(--ck-spacing-standard)/2) var(--ck-spacing-standard);border-bottom-left-radius:0;border-bottom-right-radius:0}.ck .ck-button.ck-color-table__remove-color:not(:focus){border-bottom:1px solid var(--ck-color-base-border)}[dir=ltr] .ck .ck-button.ck-color-table__remove-color .ck.ck-icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck .ck-button.ck-color-table__remove-color .ck.ck-icon{margin-left:var(--ck-spacing-standard)}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-font/theme/fontcolor.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-font/fontcolor.css"],
            names: [],
            mappings: "AAKA,4CACC,YAAa,CACb,kBAAmB,CACnB,UACD,CAEA,8BACC,iBACD,CCNA,4CACC,qEAAyE,CACzE,2BAA4B,CAC5B,4BAeD,CAbC,wDACC,mDACD,CAEA,kEAEE,uCAMF,CARA,kEAME,sCAEF",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-button.ck-color-table__remove-color {\n\tdisplay: flex;\n\talign-items: center;\n\twidth: 100%;\n}\n\nlabel.ck.ck-color-grid__label {\n\tfont-weight: unset;\n}\n", '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck .ck-button.ck-color-table__remove-color {\n\tpadding: calc(var(--ck-spacing-standard) / 2 ) var(--ck-spacing-standard);\n\tborder-bottom-left-radius: 0;\n\tborder-bottom-right-radius: 0;\n\n\t&:not(:focus) {\n\t\tborder-bottom: 1px solid var(--ck-color-base-border);\n\t}\n\n\t& .ck.ck-icon {\n\t\t@mixin ck-dir ltr {\n\t\t\tmargin-right: var(--ck-spacing-standard);\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n}\n\n'],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck-content .text-tiny{font-size:.7em}.ck-content .text-small{font-size:.85em}.ck-content .text-big{font-size:1.4em}.ck-content .text-huge{font-size:1.8em}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-font/theme/fontsize.css"],
            names: [],
            mappings: "AAUC,uBACC,cACD,CAEA,wBACC,eACD,CAEA,sBACC,eACD,CAEA,uBACC,eACD",
            sourcesContent: ['/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* The values should be synchronized with the "FONT_SIZE_PRESET_UNITS" object in the "/src/fontsize/utils.js" file. */\n\n/* Styles should be prefixed with the `.ck-content` class.\nSee https://github.com/ckeditor/ckeditor5/issues/6636 */\n.ck-content {\n\t& .text-tiny {\n\t\tfont-size: .7em;\n\t}\n\n\t& .text-small {\n\t\tfont-size: .85em;\n\t}\n\n\t& .text-big {\n\t\tfont-size: 1.4em;\n\t}\n\n\t& .text-huge {\n\t\tfont-size: 1.8em;\n\t}\n}\n'],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck.ck-heading_heading1{font-size:20px}.ck.ck-heading_heading2{font-size:17px}.ck.ck-heading_heading3{font-size:14px}.ck[class*=ck-heading_heading]{font-weight:700}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__button .ck-button__label{width:8em}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__panel .ck-list__item{min-width:18em}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-heading/theme/heading.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-heading/heading.css"],
            names: [],
            mappings: "AAKA,wBACC,cACD,CAEA,wBACC,cACD,CAEA,wBACC,cACD,CAEA,+BACC,eACD,CCZC,2EACC,SACD,CAEA,uEACC,cACD",
            sourcesContent: ['/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-heading_heading1 {\n\tfont-size: 20px;\n}\n\n.ck.ck-heading_heading2 {\n\tfont-size: 17px;\n}\n\n.ck.ck-heading_heading3 {\n\tfont-size: 14px;\n}\n\n.ck[class*="ck-heading_heading"] {\n\tfont-weight: bold;\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Resize dropdown's button label. */\n.ck.ck-dropdown.ck-heading-dropdown {\n\t& .ck-dropdown__button .ck-button__label {\n\t\twidth: 8em;\n\t}\n\n\t& .ck-dropdown__panel .ck-list__item {\n\t\tmin-width: 18em;\n\t}\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ":root{--ck-highlight-marker-yellow:#fdfd77;--ck-highlight-marker-green:#62f962;--ck-highlight-marker-pink:#fc7899;--ck-highlight-marker-blue:#72ccfd;--ck-highlight-pen-red:#e71313;--ck-highlight-pen-green:#128a00}.ck-content .marker-yellow{background-color:var(--ck-highlight-marker-yellow)}.ck-content .marker-green{background-color:var(--ck-highlight-marker-green)}.ck-content .marker-pink{background-color:var(--ck-highlight-marker-pink)}.ck-content .marker-blue{background-color:var(--ck-highlight-marker-blue)}.ck-content .pen-red{color:var(--ck-highlight-pen-red);background-color:transparent}.ck-content .pen-green{color:var(--ck-highlight-pen-green);background-color:transparent}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-highlight/theme/highlight.css"],
            names: [],
            mappings: "AAKA,MACC,oCAA+C,CAC/C,mCAA+C,CAC/C,kCAA8C,CAC9C,kCAA8C,CAC9C,8BAAwC,CACxC,gCACD,CAGC,2BACC,kDACD,CAFA,0BACC,iDACD,CAFA,yBACC,gDACD,CAFA,yBACC,gDACD,CAIA,qBACC,iCAAqC,CAGrC,4BACD,CALA,uBACC,mCAAqC,CAGrC,4BACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-highlight-marker-yellow: hsl(60, 97%, 73%);\n\t--ck-highlight-marker-green: hsl(120, 93%, 68%);\n\t--ck-highlight-marker-pink: hsl(345, 96%, 73%);\n\t--ck-highlight-marker-blue: hsl(201, 97%, 72%);\n\t--ck-highlight-pen-red: hsl(0, 85%, 49%);\n\t--ck-highlight-pen-green: hsl(112, 100%, 27%);\n}\n\n@define-mixin highlight-marker-color $color {\n\t.ck-content .marker-$color {\n\t\tbackground-color: var(--ck-highlight-marker-$color);\n\t}\n}\n\n@define-mixin highlight-pen-color $color {\n\t.ck-content .pen-$color {\n\t\tcolor: var(--ck-highlight-pen-$color);\n\n\t\t/* Override default yellow background of `<mark>` from user agent stylesheet */\n\t\tbackground-color: transparent;\n\t}\n}\n\n@mixin highlight-marker-color yellow;\n@mixin highlight-marker-color green;\n@mixin highlight-marker-color pink;\n@mixin highlight-marker-color blue;\n\n@mixin highlight-pen-color red;\n@mixin highlight-pen-color green;\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ':root{--ck-balloon-panel-arrow-z-index:calc(var(--ck-z-default) - 3)}.ck.ck-balloon-panel{display:none;position:absolute;z-index:var(--ck-z-modal)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{content:"";position:absolute}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_n]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_n]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_s]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_s]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel.ck-balloon-panel_visible{display:block}:root{--ck-balloon-arrow-offset:2px;--ck-balloon-arrow-height:10px;--ck-balloon-arrow-half-width:8px;--ck-balloon-arrow-drop-shadow:0 2px 2px var(--ck-color-shadow-drop)}.ck.ck-balloon-panel{border-radius:0}.ck-rounded-corners .ck.ck-balloon-panel,.ck.ck-balloon-panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-balloon-panel{box-shadow:var(--ck-drop-shadow),0 0;min-height:15px;background:var(--ck-color-panel-background);border:1px solid var(--ck-color-panel-border)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{width:0;height:0;border-style:solid}.ck.ck-balloon-panel[class*=arrow_n]:after,.ck.ck-balloon-panel[class*=arrow_n]:before{border-left-width:var(--ck-balloon-arrow-half-width);border-bottom-width:var(--ck-balloon-arrow-height);border-right-width:var(--ck-balloon-arrow-half-width);border-top-width:0}.ck.ck-balloon-panel[class*=arrow_n]:before{border-bottom-color:var(--ck-color-panel-border)}.ck.ck-balloon-panel[class*=arrow_n]:after,.ck.ck-balloon-panel[class*=arrow_n]:before{border-left-color:transparent;border-right-color:transparent;border-top-color:transparent}.ck.ck-balloon-panel[class*=arrow_n]:after{border-bottom-color:var(--ck-color-panel-background);margin-top:var(--ck-balloon-arrow-offset)}.ck.ck-balloon-panel[class*=arrow_s]:after,.ck.ck-balloon-panel[class*=arrow_s]:before{border-left-width:var(--ck-balloon-arrow-half-width);border-bottom-width:0;border-right-width:var(--ck-balloon-arrow-half-width);border-top-width:var(--ck-balloon-arrow-height)}.ck.ck-balloon-panel[class*=arrow_s]:before{border-top-color:var(--ck-color-panel-border);filter:drop-shadow(var(--ck-balloon-arrow-drop-shadow))}.ck.ck-balloon-panel[class*=arrow_s]:after,.ck.ck-balloon-panel[class*=arrow_s]:before{border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent}.ck.ck-balloon-panel[class*=arrow_s]:after{border-top-color:var(--ck-color-panel-background);margin-bottom:var(--ck-balloon-arrow-offset)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:before{left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:before{left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:before{right:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:before{left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1);bottom:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:before{left:calc(var(--ck-balloon-arrow-half-width)*2);bottom:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:before{right:calc(var(--ck-balloon-arrow-half-width)*2);bottom:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:before{right:25%;margin-right:calc(var(--ck-balloon-arrow-half-width)*2);bottom:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:before{left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2);bottom:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:before{right:25%;margin-right:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:before{left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}', "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/balloonpanel.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonpanel.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css"],
            names: [],
            mappings: "AAKA,MAEC,8DACD,CAEA,qBACC,YAAa,CACb,iBAAkB,CAElB,yBAyCD,CAtCE,+GAEC,UAAW,CACX,iBACD,CAEA,wDACC,6CACD,CAEA,uDACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAGD,8CACC,aACD,CC9CD,MACC,6BAA8B,CAC9B,8BAA+B,CAC/B,iCAAkC,CAClC,oEACD,CAEA,qBCJC,eD4ID,CAxIA,iFCAE,qCDwIF,CAxIA,qBENC,oCAA8B,CFU9B,eAAgB,CAEhB,2CAA4C,CAC5C,6CAiID,CA9HE,+GAEC,OAAQ,CACR,QAAS,CACT,kBACD,CAIA,uFAEC,oDAAoH,CAApH,kDAAoH,CAApH,qDAAoH,CAApH,kBACD,CAEA,4CACC,gDACD,CAEA,uFAHC,6BAA8E,CAA9E,8BAA8E,CAA9E,4BAMD,CAHA,2CACC,oDAAkF,CAClF,yCACD,CAIA,uFAEC,oDAAoH,CAApH,qBAAoH,CAApH,qDAAoH,CAApH,+CACD,CAEA,4CACC,6CAAkE,CAClE,uDACD,CAEA,uFAJC,6BAAkE,CAAlE,+BAAkE,CAAlE,8BAOD,CAHA,2CACC,iDAAkF,CAClF,4CACD,CAIA,yGAEC,QAAS,CACT,uDAA0D,CAC1D,2CACD,CAIA,2GAEC,+CAAkD,CAClD,2CACD,CAIA,2GAEC,gDAAmD,CACnD,2CACD,CAIA,yGAEC,QAAS,CACT,uDAA0D,CAC1D,8CACD,CAIA,2GAEC,+CAAkD,CAClD,8CACD,CAIA,2GAEC,gDAAmD,CACnD,8CACD,CAIA,6GAEC,SAAU,CACV,uDAA0D,CAC1D,8CACD,CAIA,6GAEC,QAAS,CACT,sDAAyD,CACzD,8CACD,CAIA,6GAEC,SAAU,CACV,uDAA0D,CAC1D,2CACD,CAIA,6GAEC,QAAS,CACT,sDAAyD,CACzD,2CACD",
            sourcesContent: ['/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/* Make sure the balloon arrow does not float over its children. */\n\t--ck-balloon-panel-arrow-z-index: calc(var(--ck-z-default) - 3);\n}\n\n.ck.ck-balloon-panel {\n\tdisplay: none;\n\tposition: absolute;\n\n\tz-index: var(--ck-z-modal);\n\n\t&.ck-balloon-panel_with-arrow {\n\t\t&::before,\n\t\t&::after {\n\t\t\tcontent: "";\n\t\t\tposition: absolute;\n\t\t}\n\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&[class*="arrow_n"] {\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&[class*="arrow_s"] {\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_visible {\n\t\tdisplay: block;\n\t}\n}\n', '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-balloon-arrow-offset: 2px;\n\t--ck-balloon-arrow-height: 10px;\n\t--ck-balloon-arrow-half-width: 8px;\n\t--ck-balloon-arrow-drop-shadow: 0 2px 2px var(--ck-color-shadow-drop);\n}\n\n.ck.ck-balloon-panel {\n\t@mixin ck-rounded-corners;\n\t@mixin ck-drop-shadow;\n\n\tmin-height: 15px;\n\n\tbackground: var(--ck-color-panel-background);\n\tborder: 1px solid var(--ck-color-panel-border);\n\n\t&.ck-balloon-panel_with-arrow {\n\t\t&::before,\n\t\t&::after {\n\t\t\twidth: 0;\n\t\t\theight: 0;\n\t\t\tborder-style: solid;\n\t\t}\n\t}\n\n\t&[class*="arrow_n"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: transparent transparent var(--ck-color-panel-border) transparent;\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: transparent transparent var(--ck-color-panel-background) transparent;\n\t\t\tmargin-top: var(--ck-balloon-arrow-offset);\n\t\t}\n\t}\n\n\t&[class*="arrow_s"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: var(--ck-color-panel-border) transparent transparent;\n\t\t\tfilter: drop-shadow(var(--ck-balloon-arrow-drop-shadow));\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: var(--ck-color-panel-background) transparent transparent transparent;\n\t\t\tmargin-bottom: var(--ck-balloon-arrow-offset);\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_n {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 50%;\n\t\t\tmargin-left: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_ne {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_s {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 50%;\n\t\t\tmargin-left: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_sw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_se {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_sme {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: 25%;\n\t\t\tmargin-right: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_smw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 25%;\n\t\t\tmargin-left: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nme {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: 25%;\n\t\t\tmargin-right: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nmw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 25%;\n\t\t\tmargin-left: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck-editor__editable .ck-horizontal-line{display:flow-root}.ck-content hr{margin:15px 0;height:4px;background:#dedede;border:0}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-horizontal-line/theme/horizontalline.css"],
            names: [],
            mappings: "AAMA,yCAEC,iBACD,CAEA,eACC,aAAc,CACd,UAAW,CACX,kBAA2B,CAC3B,QACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n\n.ck-editor__editable .ck-horizontal-line {\n\t/* Necessary to render properly next to floated objects, e.g. side image case. */\n\tdisplay: flow-root;\n}\n\n.ck-content hr {\n\tmargin: 15px 0;\n\theight: 4px;\n\tbackground: hsl(0, 0%, 87%);\n\tborder: 0;\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck-widget.raw-html-embed{margin:1em auto;position:relative;clear:both}.ck-widget.raw-html-embed:before{position:absolute;z-index:1}.ck-widget.raw-html-embed .raw-html-embed__buttons-wrapper{position:absolute;display:flex;flex-direction:column}.ck-content .raw-html-embed{margin:1em auto;min-width:15em}:root{--ck-html-embed-content-width:calc(100% - var(--ck-icon-size)*1.5);--ck-html-embed-source-height:10em;--ck-html-embed-unfocused-outline-width:1px;--ck-html-embed-content-min-height:calc(var(--ck-icon-size) + var(--ck-spacing-standard))}.ck-widget.raw-html-embed{font-size:var(--ck-font-size-base);background-color:var(--ck-color-base-foreground)}.ck-widget.raw-html-embed:not(.ck-widget_selected):not(:hover){outline:var(--ck-html-embed-unfocused-outline-width) dashed var(--ck-color-widget-blurred-border)}.ck-widget.raw-html-embed .ck-widget__type-around .ck-widget__type-around__button.ck-widget__type-around__button_before{margin-left:50px}.ck-widget.raw-html-embed:before{content:attr(data-html-embed-label);top:calc(var(--ck-html-embed-unfocused-outline-width)*-1);left:var(--ck-spacing-standard);background:hsl(0deg 0% 60%);transition:background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);padding:calc(var(--ck-spacing-tiny) + var(--ck-html-embed-unfocused-outline-width)) var(--ck-spacing-small) var(--ck-spacing-tiny);border-radius:0 0 var(--ck-border-radius) var(--ck-border-radius);color:var(--ck-color-base-background);font-size:var(--ck-font-size-tiny);font-family:var(--ck-font-face)}.ck.ck-editor__editable.ck-blurred .ck-widget.raw-html-embed.ck-widget_selected:before{top:0;padding:var(--ck-spacing-tiny) var(--ck-spacing-small)}.ck.ck-editor__editable:not(.ck-blurred) .ck-widget.raw-html-embed.ck-widget_selected:before{top:0;padding:var(--ck-spacing-tiny) var(--ck-spacing-small);background:var(--ck-color-focus-border)}.ck.ck-editor__editable .ck-widget.raw-html-embed:not(.ck-widget_selected):hover:before{top:0;padding:var(--ck-spacing-tiny) var(--ck-spacing-small)}.ck-widget.raw-html-embed .raw-html-embed__content-wrapper{padding:var(--ck-spacing-standard)}.ck-widget.raw-html-embed .raw-html-embed__buttons-wrapper{top:var(--ck-spacing-standard);right:var(--ck-spacing-standard)}.ck-widget.raw-html-embed .raw-html-embed__buttons-wrapper .ck-button.raw-html-embed__save-button{color:var(--ck-color-button-save)}.ck-widget.raw-html-embed .raw-html-embed__buttons-wrapper .ck-button.raw-html-embed__cancel-button{color:var(--ck-color-button-cancel)}.ck-widget.raw-html-embed .raw-html-embed__buttons-wrapper .ck-button:not(:first-child){margin-top:var(--ck-spacing-small)}.ck-widget.raw-html-embed .raw-html-embed__source{box-sizing:border-box;height:var(--ck-html-embed-source-height);width:var(--ck-html-embed-content-width);resize:none;min-width:0;padding:var(--ck-spacing-standard);font-family:monospace;tab-size:4;white-space:pre-wrap;font-size:var(--ck-font-size-base)}.ck-widget.raw-html-embed .raw-html-embed__source[disabled]{background:hsl(0deg 0% 97%);color:hsl(0deg 0% 56%)}.ck-widget.raw-html-embed .raw-html-embed__preview{overflow:hidden;box-sizing:border-box;width:var(--ck-html-embed-content-width);min-height:var(--ck-html-embed-content-min-height);text-align:center}.ck-widget.raw-html-embed .raw-html-embed__preview>table{margin-left:auto;margin-right:auto}.ck-editor__editable:not(.ck-read-only) .ck-widget.raw-html-embed .raw-html-embed__preview{pointer-events:none}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-html-embed/theme/htmlembed.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-html-embed/htmlembed.css"],
            names: [],
            mappings: "AAMA,0BAEC,eAAgB,CAChB,iBAAkB,CAClB,UAmBD,CAfC,iCACC,iBAAkB,CAGlB,SACD,CAKA,2DACC,iBAAkB,CAClB,YAAa,CACb,qBACD,CAGD,4BAEC,eAAgB,CAIhB,cACD,CCjCA,MACC,kEAAqE,CACrE,kCAAmC,CACnC,2CAA4C,CAC5C,yFACD,CAGA,0BACC,kCAAmC,CACnC,gDAuGD,CArGC,+DACC,iGACD,CAEA,wHACC,gBACD,CAIA,iCACC,mCAAoC,CACpC,yDAA4D,CAC5D,+BAAgC,CAChC,2BAA4B,CAC5B,0GAA2G,CAC3G,kIAAmI,CACnI,iEAAkE,CAClE,qCAAsC,CACtC,kCAAmC,CACnC,+BACD,CAzBD,uFA4BE,KAAQ,CACR,sDA4EF,CAzGA,6FAiCE,KAAM,CACN,sDAAuD,CACvD,uCAsEF,CAzGA,wFAuCE,KAAQ,CACR,sDAiEF,CA5DC,2DACC,kCACD,CAGA,2DACC,8BAA+B,CAC/B,gCAaD,CAXC,kGACC,iCACD,CAEA,oGACC,mCACD,CAEA,wFACC,kCACD,CAID,kDACC,qBAAsB,CACtB,yCAA0C,CAC1C,wCAAyC,CACzC,WAAY,CACZ,WAAY,CACZ,kCAAmC,CAEnC,qBAAsB,CACtB,UAAW,CACX,oBAAqB,CACrB,kCAMD,CAJC,4DACC,2BAA4B,CAC5B,sBACD,CAID,mDACC,eAAgB,CAChB,qBAAsB,CACtB,wCAAyC,CACzC,kDAAmD,CACnD,iBAWD,CATC,yDACC,gBAAiB,CACjB,iBACD,CAVD,2FAcE,mBAEF",
            sourcesContent: ['/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* The feature container. */\n.ck-widget.raw-html-embed {\n\t/* Give the embed some air. */\n\tmargin: 1em auto;\n\tposition: relative;\n\tclear: both;\n\n\t/* ----- Emebed label in the upper left corner ----------------------------------------------- */\n\n\t&::before {\n\t\tposition: absolute;\n\n\t\t/* Make sure the content does not cover the label. */\n\t\tz-index: 1;\n\t}\n\n\t/* ----- Emebed internals --------------------------------------------------------------------- */\n\n\t/* The switch mode button wrapper. */\n\t& .raw-html-embed__buttons-wrapper {\n\t\tposition: absolute;\n\t\tdisplay: flex;\n\t\tflex-direction: column;\n\t}\n}\n\n.ck-content .raw-html-embed {\n\t/* Give the embed some air. */\n\tmargin: 1em auto;\n\n\t/* Give the html embed some minimal width in the content to prevent them\n\tfrom being "squashed" in tight spaces, e.g. in table cells (https://github.com/ckeditor/ckeditor5/issues/8331) */\n\tmin-width: 15em;\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-html-embed-content-width: calc(100% - 1.5 * var(--ck-icon-size));\n\t--ck-html-embed-source-height: 10em;\n\t--ck-html-embed-unfocused-outline-width: 1px;\n\t--ck-html-embed-content-min-height: calc(var(--ck-icon-size) + var(--ck-spacing-standard));\n}\n\n/* The feature container. */\n.ck-widget.raw-html-embed {\n\tfont-size: var(--ck-font-size-base);\n\tbackground-color: var(--ck-color-base-foreground);\n\n\t&:not(.ck-widget_selected):not(:hover) {\n\t\toutline: var(--ck-html-embed-unfocused-outline-width) dashed var(--ck-color-widget-blurred-border);\n\t}\n\n\t& .ck-widget__type-around .ck-widget__type-around__button.ck-widget__type-around__button_before {\n\t\tmargin-left: 50px;\n\t}\n\n\t/* ----- Emebed label in the upper left corner ----------------------------------------------- */\n\n\t&::before {\n\t\tcontent: attr(data-html-embed-label);\n\t\ttop: calc(-1 * var(--ck-html-embed-unfocused-outline-width));\n\t\tleft: var(--ck-spacing-standard);\n\t\tbackground: hsl(0deg 0% 60%);\n\t\ttransition: background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\t\tpadding: calc(var(--ck-spacing-tiny) + var(--ck-html-embed-unfocused-outline-width)) var(--ck-spacing-small) var(--ck-spacing-tiny);\n\t\tborder-radius: 0 0 var(--ck-border-radius) var(--ck-border-radius);\n\t\tcolor: var(--ck-color-base-background);\n\t\tfont-size: var(--ck-font-size-tiny);\n\t\tfont-family: var(--ck-font-face);\n\t}\n\n\t@nest .ck.ck-editor__editable.ck-blurred &.ck-widget_selected::before {\n\t\ttop: 0px;\n\t\tpadding: var(--ck-spacing-tiny) var(--ck-spacing-small);\n\t}\n\n\t@nest .ck.ck-editor__editable:not(.ck-blurred) &.ck-widget_selected::before {\n\t\ttop: 0;\n\t\tpadding: var(--ck-spacing-tiny) var(--ck-spacing-small);\n\t\tbackground: var(--ck-color-focus-border);\n\t}\n\n\t@nest .ck.ck-editor__editable &:not(.ck-widget_selected):hover::before {\n\t\ttop: 0px;\n\t\tpadding: var(--ck-spacing-tiny) var(--ck-spacing-small);\n\t}\n\n\t/* ----- Emebed internals --------------------------------------------------------------------- */\n\n\t& .raw-html-embed__content-wrapper {\n\t\tpadding: var(--ck-spacing-standard);\n\t}\n\n\t/* The switch mode button wrapper. */\n\t& .raw-html-embed__buttons-wrapper {\n\t\ttop: var(--ck-spacing-standard);\n\t\tright: var(--ck-spacing-standard);\n\n\t\t& .ck-button.raw-html-embed__save-button {\n\t\t\tcolor: var(--ck-color-button-save);\n\t\t}\n\n\t\t& .ck-button.raw-html-embed__cancel-button {\n\t\t\tcolor: var(--ck-color-button-cancel);\n\t\t}\n\n\t\t& .ck-button:not(:first-child) {\n\t\t\tmargin-top: var(--ck-spacing-small);\n\t\t}\n\t}\n\n\t/* The edit source element. */\n\t& .raw-html-embed__source {\n\t\tbox-sizing: border-box;\n\t\theight: var(--ck-html-embed-source-height);\n\t\twidth: var(--ck-html-embed-content-width);\n\t\tresize: none;\n\t\tmin-width: 0;\n\t\tpadding: var(--ck-spacing-standard);\n\n\t\tfont-family: monospace;\n\t\ttab-size: 4;\n\t\twhite-space: pre-wrap;\n\t\tfont-size: var(--ck-font-size-base); /* Safari needs this. */\n\n\t\t&[disabled] {\n\t\t\tbackground: hsl(0deg 0% 97%);\n\t\t\tcolor: hsl(0deg 0% 56%);\n\t\t}\n\t}\n\n\t/* The preview data container. */\n\t& .raw-html-embed__preview {\n\t\toverflow: hidden;\n\t\tbox-sizing: border-box;\n\t\twidth: var(--ck-html-embed-content-width);\n\t\tmin-height: var(--ck-html-embed-content-min-height);\n\t\ttext-align: center;\n\n\t\t& > table {\n\t\t\tmargin-left: auto;\n\t\t\tmargin-right: auto;\n\t\t}\n\n\t\t/* Disable all mouse interaction as long as the editor is not read–only. */\n\t\t@nest .ck-editor__editable:not(.ck-read-only) & {\n\t\t\tpointer-events: none;\n\t\t}\n\t}\n}\n\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, '.ck .ck-widget .ck-widget__type-around__button{display:block;position:absolute;overflow:hidden;z-index:var(--ck-z-default)}.ck .ck-widget .ck-widget__type-around__button svg{position:absolute;top:50%;left:50%;z-index:calc(var(--ck-z-default) + 2)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_before{top:calc(var(--ck-widget-outline-thickness)*-0.5);left:min(10%,30px);transform:translateY(-50%)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_after{bottom:calc(var(--ck-widget-outline-thickness)*-0.5);right:min(10%,30px);transform:translateY(50%)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{content:"";display:block;position:absolute;top:1px;left:1px;z-index:calc(var(--ck-z-default) + 1)}.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:none;position:absolute;left:0;right:0}.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__fake-caret{left:calc(var(--ck-widget-outline-thickness)*-1);right:calc(var(--ck-widget-outline-thickness)*-1)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__fake-caret{top:calc(var(--ck-widget-outline-thickness)*-1 - 1px);display:block}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__fake-caret{bottom:calc(var(--ck-widget-outline-thickness)*-1 - 1px);display:block}.ck.ck-editor__editable.ck-read-only .ck-widget__type-around,.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around,.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around{display:none}:root{--ck-widget-type-around-button-size:20px;--ck-color-widget-type-around-button-active:var(--ck-color-focus-border);--ck-color-widget-type-around-button-hover:var(--ck-color-widget-hover-border);--ck-color-widget-type-around-button-blurred-editable:var(--ck-color-widget-blurred-border);--ck-color-widget-type-around-button-radar-start-alpha:0;--ck-color-widget-type-around-button-radar-end-alpha:.3;--ck-color-widget-type-around-button-icon:var(--ck-color-base-background)}.ck .ck-widget .ck-widget__type-around__button{width:var(--ck-widget-type-around-button-size);height:var(--ck-widget-type-around-button-size);background:var(--ck-color-widget-type-around-button);border-radius:100px;transition:opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);opacity:0;pointer-events:none}.ck .ck-widget .ck-widget__type-around__button svg{width:10px;height:8px;transform:translate(-50%,-50%);transition:transform .5s ease;margin-top:1px}.ck .ck-widget .ck-widget__type-around__button svg *{stroke-dasharray:10;stroke-dashoffset:0;fill:none;stroke:var(--ck-color-widget-type-around-button-icon);stroke-width:1.5px;stroke-linecap:round;stroke-linejoin:round}.ck .ck-widget .ck-widget__type-around__button svg line{stroke-dasharray:7}.ck .ck-widget .ck-widget__type-around__button:hover{animation:ck-widget-type-around-button-sonar 1s ease infinite}.ck .ck-widget .ck-widget__type-around__button:hover svg polyline{animation:ck-widget-type-around-arrow-dash 2s linear}.ck .ck-widget .ck-widget__type-around__button:hover svg line{animation:ck-widget-type-around-arrow-tip-dash 2s linear}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:1;pointer-events:auto}.ck .ck-widget:not(.ck-widget_selected)>.ck-widget__type-around>.ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button-hover)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover{background:var(--ck-color-widget-type-around-button-active)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{width:calc(var(--ck-widget-type-around-button-size) - 2px);height:calc(var(--ck-widget-type-around-button-size) - 2px);border-radius:100px;background:linear-gradient(135deg,hsla(0,0%,100%,0),hsla(0,0%,100%,.3))}.ck .ck-widget.ck-widget_with-selection-handle>.ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:20px}.ck .ck-widget .ck-widget__type-around__fake-caret{pointer-events:none;height:1px;animation:ck-widget-type-around-fake-caret-pulse 1s linear infinite normal forwards;outline:1px solid hsla(0,0%,100%,.5);background:var(--ck-color-base-text)}.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_after,.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_before{outline-color:transparent}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected:hover,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{opacity:0}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer{opacity:0}.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover){background:var(--ck-color-widget-type-around-button-blurred-editable)}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover) svg *{stroke:#999}@keyframes ck-widget-type-around-arrow-dash{0%{stroke-dashoffset:10}20%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-arrow-tip-dash{0%,20%{stroke-dashoffset:7}40%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-button-sonar{0%{box-shadow:0 0 0 0 hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}50%{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-end-alpha))}to{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}}@keyframes ck-widget-type-around-fake-caret-pulse{0%{opacity:1}49%{opacity:1}50%{opacity:0}99%{opacity:0}to{opacity:1}}', "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-widget/theme/widgettypearound.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-widget/widgettypearound.css"],
            names: [],
            mappings: "AASC,+CACC,aAAc,CACd,iBAAkB,CAClB,eAAgB,CAChB,2BAwBD,CAtBC,mDACC,iBAAkB,CAClB,OAAQ,CACR,QAAS,CACT,qCACD,CAEA,qFAEC,iDAAoD,CACpD,kBAAoB,CAEpB,0BACD,CAEA,oFAEC,oDAAuD,CACvD,mBAAqB,CAErB,yBACD,CAUA,mLACC,UAAW,CACX,aAAc,CACd,iBAAkB,CAClB,OAAQ,CACR,QAAS,CACT,qCACD,CAMD,2EACC,YAAa,CACb,iBAAkB,CAClB,MAAO,CACP,OACD,CAOA,iFACC,gDAAqD,CACrD,iDACD,CAKA,wHACC,qDAA0D,CAC1D,aACD,CAKA,uHACC,wDAA6D,CAC7D,aACD,CAoBD,mOACC,YACD,CC3GA,MACC,wCAAyC,CACzC,wEAAyE,CACzE,8EAA+E,CAC/E,2FAA4F,CAC5F,wDAAyD,CACzD,uDAAwD,CACxD,yEACD,CAgBC,+CACC,8CAA+C,CAC/C,+CAAgD,CAChD,oDAAqD,CACrD,mBAAoB,CACpB,uMAAyM,CAb1M,SAAU,CACV,mBA0DA,CA1CC,mDACC,UAAW,CACX,UAAW,CACX,8BAA+B,CAC/B,6BAA8B,CAC9B,cAgBD,CAdC,qDACC,mBAAoB,CACpB,mBAAoB,CAEpB,SAAU,CACV,qDAAsD,CACtD,kBAAmB,CACnB,oBAAqB,CACrB,qBACD,CAEA,wDACC,kBACD,CAGD,qDAIC,6DAcD,CARE,kEACC,oDACD,CAEA,8DACC,wDACD,CAUF,uKAvED,SAAU,CACV,mBAwEC,CAOD,gGACC,0DACD,CAOA,uKAEC,2DAQD,CANC,mLACC,0DAA2D,CAC3D,2DAA4D,CAC5D,mBAAoB,CACpB,uEACD,CAOD,8GACC,gBACD,CAKA,mDACC,mBAAoB,CACpB,UAAW,CACX,mFAAoF,CAMpF,oCAAwC,CACxC,oCACD,CAOC,6JAEC,yBACD,CAUA,yKACC,iDACD,CAMA,uOAlJD,SAAU,CACV,mBAmJC,CASE,0jBACC,SACD,CASF,mPACC,SACD,CAcC,iRAxLF,SAAU,CACV,mBAyLE,CAQH,kIACC,qEAKD,CAHC,wIACC,WACD,CAGD,4CACC,GACC,oBACD,CACA,OACC,mBACD,CACD,CAEA,gDACC,OACC,mBACD,CACA,OACC,mBACD,CACD,CAEA,8CACC,GACC,6HACD,CACA,IACC,6HACD,CACA,GACC,+HACD,CACD,CAEA,kDACC,GACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,GACC,SACD,CACD",
            sourcesContent: ['/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-widget {\n\t/*\n\t * Styles of the type around buttons\n\t */\n\t& .ck-widget__type-around__button {\n\t\tdisplay: block;\n\t\tposition: absolute;\n\t\toverflow: hidden;\n\t\tz-index: var(--ck-z-default);\n\n\t\t& svg {\n\t\t\tposition: absolute;\n\t\t\ttop: 50%;\n\t\t\tleft: 50%;\n\t\t\tz-index: calc(var(--ck-z-default) + 2);\n\t\t}\n\n\t\t&.ck-widget__type-around__button_before {\n\t\t\t/* Place it in the middle of the outline */\n\t\t\ttop: calc(-0.5 * var(--ck-widget-outline-thickness));\n\t\t\tleft: min(10%, 30px);\n\n\t\t\ttransform: translateY(-50%);\n\t\t}\n\n\t\t&.ck-widget__type-around__button_after {\n\t\t\t/* Place it in the middle of the outline */\n\t\t\tbottom: calc(-0.5 * var(--ck-widget-outline-thickness));\n\t\t\tright: min(10%, 30px);\n\n\t\t\ttransform: translateY(50%);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the buttons when:\n\t * - the widget is selected,\n\t * - or the button is being hovered (regardless of the widget state).\n\t */\n\t&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,\n\t& > .ck-widget__type-around > .ck-widget__type-around__button:hover {\n\t\t&::after {\n\t\t\tcontent: "";\n\t\t\tdisplay: block;\n\t\t\tposition: absolute;\n\t\t\ttop: 1px;\n\t\t\tleft: 1px;\n\t\t\tz-index: calc(var(--ck-z-default) + 1);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.\n\t */\n\t& > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tdisplay: none;\n\t\tposition: absolute;\n\t\tleft: 0;\n\t\tright: 0;\n\t}\n\n\t/*\n\t * When the widget is hovered the "fake caret" would normally be narrower than the\n\t * extra outline displayed around the widget. Let\'s extend the "fake caret" to match\n\t * the full width of the widget.\n\t */\n\t&:hover > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tleft: calc( -1 * var(--ck-widget-outline-thickness) );\n\t\tright: calc( -1 * var(--ck-widget-outline-thickness) );\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" when it should be displayed before the widget (backward keyboard navigation).\n\t */\n\t&.ck-widget_type-around_show-fake-caret_before > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\ttop: calc( -1 * var(--ck-widget-outline-thickness) - 1px );\n\t\tdisplay: block;\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" when it should be displayed after the widget (forward keyboard navigation).\n\t */\n\t&.ck-widget_type-around_show-fake-caret_after > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tbottom: calc( -1 * var(--ck-widget-outline-thickness) - 1px );\n\t\tdisplay: block;\n\t}\n}\n\n/*\n * Integration with the read-only mode of the editor.\n */\n.ck.ck-editor__editable.ck-read-only .ck-widget__type-around {\n\tdisplay: none;\n}\n\n/*\n * Integration with the restricted editing mode (feature) of the editor.\n */\n.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around {\n\tdisplay: none;\n}\n\n/*\n * Integration with the #isEnabled property of the WidgetTypeAround plugin.\n */\n.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around {\n\tdisplay: none;\n}\n', '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-widget-type-around-button-size: 20px;\n\t--ck-color-widget-type-around-button-active: var(--ck-color-focus-border);\n\t--ck-color-widget-type-around-button-hover: var(--ck-color-widget-hover-border);\n\t--ck-color-widget-type-around-button-blurred-editable: var(--ck-color-widget-blurred-border);\n\t--ck-color-widget-type-around-button-radar-start-alpha: 0;\n\t--ck-color-widget-type-around-button-radar-end-alpha: .3;\n\t--ck-color-widget-type-around-button-icon: var(--ck-color-base-background);\n}\n\n@define-mixin ck-widget-type-around-button-visible {\n\topacity: 1;\n\tpointer-events: auto;\n}\n\n@define-mixin ck-widget-type-around-button-hidden {\n\topacity: 0;\n\tpointer-events: none;\n}\n\n.ck .ck-widget {\n\t/*\n\t * Styles of the type around buttons\n\t */\n\t& .ck-widget__type-around__button {\n\t\twidth: var(--ck-widget-type-around-button-size);\n\t\theight: var(--ck-widget-type-around-button-size);\n\t\tbackground: var(--ck-color-widget-type-around-button);\n\t\tborder-radius: 100px;\n\t\ttransition: opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve), background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t\t@mixin ck-widget-type-around-button-hidden;\n\n\t\t& svg {\n\t\t\twidth: 10px;\n\t\t\theight: 8px;\n\t\t\ttransform: translate(-50%,-50%);\n\t\t\ttransition: transform .5s ease;\n\t\t\tmargin-top: 1px;\n\n\t\t\t& * {\n\t\t\t\tstroke-dasharray: 10;\n\t\t\t\tstroke-dashoffset: 0;\n\n\t\t\t\tfill: none;\n\t\t\t\tstroke: var(--ck-color-widget-type-around-button-icon);\n\t\t\t\tstroke-width: 1.5px;\n\t\t\t\tstroke-linecap: round;\n\t\t\t\tstroke-linejoin: round;\n\t\t\t}\n\n\t\t\t& line {\n\t\t\t\tstroke-dasharray: 7;\n\t\t\t}\n\t\t}\n\n\t\t&:hover {\n\t\t\t/*\n\t\t\t * Display the "sonar" around the button when hovered.\n\t\t\t */\n\t\t\tanimation: ck-widget-type-around-button-sonar 1s ease infinite;\n\n\t\t\t/*\n\t\t\t * Animate active button\'s icon.\n\t\t\t */\n\t\t\t& svg {\n\t\t\t\t& polyline {\n\t\t\t\t\tanimation: ck-widget-type-around-arrow-dash 2s linear;\n\t\t\t\t}\n\n\t\t\t\t& line {\n\t\t\t\t\tanimation: ck-widget-type-around-arrow-tip-dash 2s linear;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Show type around buttons when the widget gets selected or being hovered.\n\t */\n\t&.ck-widget_selected,\n\t&:hover {\n\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t@mixin ck-widget-type-around-button-visible;\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the buttons when the widget is NOT selected (but the buttons are visible\n\t * and still can be hovered).\n\t */\n\t&:not(.ck-widget_selected) > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\tbackground: var(--ck-color-widget-type-around-button-hover);\n\t}\n\n\t/*\n\t * Styles for the buttons when:\n\t * - the widget is selected,\n\t * - or the button is being hovered (regardless of the widget state).\n\t */\n\t&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,\n\t& > .ck-widget__type-around > .ck-widget__type-around__button:hover {\n\t\tbackground: var(--ck-color-widget-type-around-button-active);\n\n\t\t&::after {\n\t\t\twidth: calc(var(--ck-widget-type-around-button-size) - 2px);\n\t\t\theight: calc(var(--ck-widget-type-around-button-size) - 2px);\n\t\t\tborder-radius: 100px;\n\t\t\tbackground: linear-gradient(135deg, hsla(0,0%,100%,0) 0%, hsla(0,0%,100%,.3) 100%);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the "before" button when the widget has a selection handle. Because some space\n\t * is consumed by the handle, the button must be moved slightly to the right to let it breathe.\n\t */\n\t&.ck-widget_with-selection-handle > .ck-widget__type-around > .ck-widget__type-around__button_before {\n\t\tmargin-left: 20px;\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.\n\t */\n\t& .ck-widget__type-around__fake-caret {\n\t\tpointer-events: none;\n\t\theight: 1px;\n\t\tanimation: ck-widget-type-around-fake-caret-pulse linear 1s infinite normal forwards;\n\n\t\t/*\n\t\t * The semi-transparent-outline+background combo improves the contrast\n\t\t * when the background underneath the fake caret is dark.\n\t\t */\n\t\toutline: solid 1px hsla(0, 0%, 100%, .5);\n\t\tbackground: var(--ck-color-base-text);\n\t}\n\n\t/*\n\t * Styles of the widget when the "fake caret" is blinking (e.g. upon keyboard navigation).\n\t * Despite the widget being physically selected in the model, its outline should disappear.\n\t */\n\t&.ck-widget_selected {\n\t\t&.ck-widget_type-around_show-fake-caret_before,\n\t\t&.ck-widget_type-around_show-fake-caret_after {\n\t\t\toutline-color: transparent;\n\t\t}\n\t}\n\n\t&.ck-widget_type-around_show-fake-caret_before,\n\t&.ck-widget_type-around_show-fake-caret_after {\n\t\t/*\n\t\t * When the "fake caret" is visible we simulate that the widget is not selected\n\t\t * (despite being physically selected), so the outline color should be for the\n\t\t * unselected widget.\n\t\t */\n\t\t&.ck-widget_selected:hover {\n\t\t\toutline-color: var(--ck-color-widget-hover-border);\n\t\t}\n\n\t\t/*\n\t\t * Styles of the type around buttons when the "fake caret" is blinking (e.g. upon keyboard navigation).\n\t\t * In this state, the type around buttons would collide with the fake carets so they should disappear.\n\t\t */\n\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t@mixin ck-widget-type-around-button-hidden;\n\t\t}\n\n\t\t/*\n\t\t * Fake horizontal caret integration with the selection handle. When the caret is visible, simply\n\t\t * hide the handle because it intersects with the caret (and does not make much sense anyway).\n\t\t */\n\t\t&.ck-widget_with-selection-handle {\n\t\t\t&.ck-widget_selected,\n\t\t\t&.ck-widget_selected:hover {\n\t\t\t\t& > .ck-widget__selection-handle {\n\t\t\t\t\topacity: 0\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Fake horizontal caret integration with the resize UI. When the caret is visible, simply\n\t\t * hide the resize UI because it creates too much noise. It can be visible when the user\n\t\t * hovers the widget, though.\n\t\t */\n\t\t&.ck-widget_selected.ck-widget_with-resizer > .ck-widget__resizer {\n\t\t\topacity: 0\n\t\t}\n\t}\n}\n\n/*\n * Hide type around buttons when the widget is selected as a child of a selected\n * nested editable (e.g. mulit-cell table selection).\n *\n * See https://github.com/ckeditor/ckeditor5/issues/7263.\n */\n.ck-editor__nested-editable.ck-editor__editable_selected {\n\t& .ck-widget {\n\t\t&.ck-widget_selected,\n\t\t&:hover {\n\t\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t\t@mixin ck-widget-type-around-button-hidden;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n * Styles for the buttons when the widget is selected but the user clicked outside of the editor (blurred the editor).\n */\n.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button:not(:hover) {\n\tbackground: var(--ck-color-widget-type-around-button-blurred-editable);\n\n\t& svg * {\n\t\tstroke: hsl(0,0%,60%);\n\t}\n}\n\n@keyframes ck-widget-type-around-arrow-dash {\n\t0% {\n\t\tstroke-dashoffset: 10;\n\t}\n\t20%, 100% {\n\t\tstroke-dashoffset: 0;\n\t}\n}\n\n@keyframes ck-widget-type-around-arrow-tip-dash {\n\t0%, 20% {\n\t\tstroke-dashoffset: 7;\n\t}\n\t40%, 100% {\n\t\tstroke-dashoffset: 0;\n\t}\n}\n\n@keyframes ck-widget-type-around-button-sonar {\n\t0% {\n\t\tbox-shadow: 0 0 0 0 hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));\n\t}\n\t50% {\n\t\tbox-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-end-alpha));\n\t}\n\t100% {\n\t\tbox-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));\n\t}\n}\n\n@keyframes ck-widget-type-around-fake-caret-pulse {\n\t0% {\n\t\topacity: 1;\n\t}\n\t49% {\n\t\topacity: 1;\n\t}\n\t50% {\n\t\topacity: 0;\n\t}\n\t99% {\n\t\topacity: 0;\n\t}\n\t100% {\n\t\topacity: 1;\n\t}\n}\n'],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ":root{--ck-color-resizer:var(--ck-color-focus-border);--ck-resizer-size:10px;--ck-resizer-border-width:1px;--ck-resizer-border-radius:2px;--ck-resizer-offset:calc(var(--ck-resizer-size)/-2 - 2px);--ck-resizer-tooltip-offset:10px;--ck-color-resizer-tooltip-background:#262626;--ck-color-resizer-tooltip-text:#f2f2f2}.ck .ck-widget,.ck .ck-widget.ck-widget_with-selection-handle{position:relative}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{position:absolute}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{display:block}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected .ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle:hover .ck-widget__selection-handle{visibility:visible}.ck .ck-size-view{background:var(--ck-color-resizer-tooltip-background);color:var(--ck-color-resizer-tooltip-text);border:1px solid var(--ck-color-resizer-tooltip-text);border-radius:var(--ck-resizer-border-radius);font-size:var(--ck-font-size-tiny);display:block;padding:var(--ck-spacing-small)}.ck .ck-size-view.ck-orientation-bottom-left,.ck .ck-size-view.ck-orientation-bottom-right,.ck .ck-size-view.ck-orientation-top-left,.ck .ck-size-view.ck-orientation-top-right{position:absolute}.ck .ck-size-view.ck-orientation-top-left{top:var(--ck-resizer-tooltip-offset);left:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-top-right{top:var(--ck-resizer-tooltip-offset);right:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-right{bottom:var(--ck-resizer-tooltip-offset);right:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-left{bottom:var(--ck-resizer-tooltip-offset);left:var(--ck-resizer-tooltip-offset)}:root{--ck-widget-outline-thickness:3px;--ck-widget-handler-icon-size:16px;--ck-widget-handler-animation-duration:200ms;--ck-widget-handler-animation-curve:ease;--ck-color-widget-blurred-border:#dedede;--ck-color-widget-hover-border:#ffc83d;--ck-color-widget-editable-focus-background:var(--ck-color-base-background);--ck-color-widget-drag-handler-icon-color:var(--ck-color-base-background)}.ck .ck-widget{outline-width:var(--ck-widget-outline-thickness);outline-style:solid;outline-color:transparent;transition:outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_selected,.ck .ck-widget.ck-widget_selected:hover{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border)}.ck .ck-widget:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-editor__nested-editable{border:1px solid transparent}.ck .ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck .ck-editor__nested-editable:focus{outline:none;border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;background-color:var(--ck-color-widget-editable-focus-background)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{padding:4px;box-sizing:border-box;background-color:transparent;opacity:0;transition:background-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),visibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);border-radius:var(--ck-border-radius) var(--ck-border-radius) 0 0;transform:translateY(-100%);left:calc(0px - var(--ck-widget-outline-thickness))}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{width:var(--ck-widget-handler-icon-size);height:var(--ck-widget-handler-icon-size);color:var(--ck-color-widget-drag-handler-icon-color)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:0;transition:opacity .3s var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover .ck-icon .ck-icon__selected-indicator{opacity:1}.ck .ck-widget.ck-widget_with-selection-handle:hover .ck-widget__selection-handle{opacity:1;background-color:var(--ck-color-widget-hover-border)}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected .ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover .ck-widget__selection-handle{opacity:1;background-color:var(--ck-color-focus-border)}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:1}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{left:auto;right:calc(0px - var(--ck-widget-outline-thickness))}.ck.ck-editor__editable.ck-read-only .ck-widget{transition:none}.ck.ck-editor__editable.ck-read-only .ck-widget:not(.ck-widget_selected){--ck-widget-outline-thickness:0px}.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle,.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover{outline-color:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle .ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle .ck-widget__selection-handle:hover,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover.ck-widget_with-selection-handle .ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover.ck-widget_with-selection-handle .ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable>.ck-widget.ck-widget_with-selection-handle:first-child,.ck.ck-editor__editable blockquote>.ck-widget.ck-widget_with-selection-handle:first-child{margin-top:calc(1em + var(--ck-widget-handler-icon-size))}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-widget/theme/widget.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-widget/widget.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css"],
            names: [],
            mappings: "AAKA,MACC,+CAAgD,CAChD,sBAAuB,CACvB,6BAA8B,CAC9B,8BAA+B,CAG/B,yDAAiE,CAEjE,gCAAiC,CACjC,6CAAsD,CACtD,uCACD,CAOA,8DAEC,iBAuBD,CArBC,4EACC,iBAOD,CALC,qFAGC,aACD,CAWD,iLACC,kBACD,CAGD,kBACC,qDAAsD,CACtD,0CAA2C,CAC3C,qDAAsD,CACtD,6CAA8C,CAC9C,kCAAmC,CACnC,aAAc,CACd,+BA4BD,CA1BC,gLAIC,iBACD,CAEA,0CACC,oCAAuC,CACvC,qCACD,CAEA,2CACC,oCAAuC,CACvC,sCACD,CAEA,8CACC,uCAA0C,CAC1C,sCACD,CAEA,6CACC,uCAA0C,CAC1C,qCACD,CC7ED,MACC,iCAAkC,CAClC,kCAAmC,CACnC,4CAA6C,CAC7C,wCAAyC,CAEzC,wCAAiD,CACjD,sCAAkD,CAClD,2EAA4E,CAC5E,yEACD,CAEA,eACC,gDAAiD,CACjD,mBAAoB,CACpB,yBAA0B,CAC1B,6GAUD,CARC,0EAEC,6EACD,CAEA,qBACC,iDACD,CAGD,gCACC,4BAWD,CAPC,yGC/BA,YAAa,CACb,2BAA2B,CCF3B,qCAA8B,CFqC7B,iEACD,CAIA,4EACC,WAAY,CACZ,qBAAsB,CAGtB,4BAA6B,CAC7B,SAAU,CAMV,6SAG6F,CAG7F,iEAAkE,CAGlE,2BAA4B,CAC5B,mDAqBD,CAnBC,qFAEC,wCAAyC,CACzC,yCAA0C,CAC1C,oDASD,CANC,kHACC,SAAU,CAGV,+DACD,CAID,wHACC,SACD,CAID,kFACC,SAAU,CACV,oDACD,CAKC,oMACC,SAAU,CACV,6CAMD,CAHC,gRACC,SACD,CAOH,qFACC,SAAU,CACV,oDACD,CAGA,gDAEC,eAkBD,CAhBC,yEAOC,iCACD,CAGC,gOAEC,gDACD,CAOD,wIAEC,mDAQD,CALE,ghBAEC,gDACD,CAKH,yKAOC,yDACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-resizer: var(--ck-color-focus-border);\n\t--ck-resizer-size: 10px;\n\t--ck-resizer-border-width: 1px;\n\t--ck-resizer-border-radius: 2px;\n\n\t/* Set the resizer with a 50% offset. */\n\t--ck-resizer-offset: calc( ( var(--ck-resizer-size) / -2 ) - 2px);\n\n\t--ck-resizer-tooltip-offset: 10px;\n\t--ck-color-resizer-tooltip-background: hsl(0, 0%, 15%);\n\t--ck-color-resizer-tooltip-text: hsl(0, 0%, 95%);\n}\n\n.ck .ck-widget {\n\t/* This is neccessary for type around UI to be positioned properly. */\n\tposition: relative;\n}\n\n.ck .ck-widget.ck-widget_with-selection-handle {\n\t/* Make the widget wrapper a relative positioning container for the drag handle. */\n\tposition: relative;\n\n\t& .ck-widget__selection-handle {\n\t\tposition: absolute;\n\n\t\t& .ck-icon {\n\t\t\t/* Make sure the icon in not a subject to font-size or line-height to avoid\n\t\t\tunnecessary spacing around it. */\n\t\t\tdisplay: block;\n\t\t}\n\t}\n\n\t/* Show the selection handle on mouse hover over the widget. */\n\t&:hover {\n\t\t& .ck-widget__selection-handle {\n\t\t\tvisibility: visible;\n\t\t}\n\t}\n\n\t/* Show the selection handle when the widget is selected. */\n\t&.ck-widget_selected .ck-widget__selection-handle {\n\t\tvisibility: visible;\n\t}\n}\n\n.ck .ck-size-view {\n\tbackground: var(--ck-color-resizer-tooltip-background);\n\tcolor: var(--ck-color-resizer-tooltip-text);\n\tborder: 1px solid var(--ck-color-resizer-tooltip-text);\n\tborder-radius: var(--ck-resizer-border-radius);\n\tfont-size: var(--ck-font-size-tiny);\n\tdisplay: block;\n\tpadding: var(--ck-spacing-small);\n\n\t&.ck-orientation-top-left,\n\t&.ck-orientation-top-right,\n\t&.ck-orientation-bottom-right,\n\t&.ck-orientation-bottom-left {\n\t\tposition: absolute;\n\t}\n\n\t&.ck-orientation-top-left {\n\t\ttop: var( --ck-resizer-tooltip-offset );\n\t\tleft: var( --ck-resizer-tooltip-offset );\n\t}\n\n\t&.ck-orientation-top-right {\n\t\ttop: var( --ck-resizer-tooltip-offset );\n\t\tright: var( --ck-resizer-tooltip-offset );\n\t}\n\n\t&.ck-orientation-bottom-right {\n\t\tbottom: var( --ck-resizer-tooltip-offset );\n\t\tright: var( --ck-resizer-tooltip-offset );\n\t}\n\n\t&.ck-orientation-bottom-left {\n\t\tbottom: var( --ck-resizer-tooltip-offset );\n\t\tleft: var( --ck-resizer-tooltip-offset );\n\t}\n}\n", '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../mixins/_focus.css";\n@import "../mixins/_shadow.css";\n\n:root {\n\t--ck-widget-outline-thickness: 3px;\n\t--ck-widget-handler-icon-size: 16px;\n\t--ck-widget-handler-animation-duration: 200ms;\n\t--ck-widget-handler-animation-curve: ease;\n\n\t--ck-color-widget-blurred-border: hsl(0, 0%, 87%);\n\t--ck-color-widget-hover-border: hsl(43, 100%, 62%);\n\t--ck-color-widget-editable-focus-background: var(--ck-color-base-background);\n\t--ck-color-widget-drag-handler-icon-color: var(--ck-color-base-background);\n}\n\n.ck .ck-widget {\n\toutline-width: var(--ck-widget-outline-thickness);\n\toutline-style: solid;\n\toutline-color: transparent;\n\ttransition: outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\toutline: var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border);\n\t}\n\n\t&:hover {\n\t\toutline-color: var(--ck-color-widget-hover-border);\n\t}\n}\n\n.ck .ck-editor__nested-editable {\n\tborder: 1px solid transparent;\n\n\t/* The :focus style is applied before .ck-editor__nested-editable_focused class is rendered in the view.\n\tThese styles show a different border for a blink of an eye, so `:focus` need to have same styles applied. */\n\t&.ck-editor__nested-editable_focused,\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-inner-shadow);\n\n\t\tbackground-color: var(--ck-color-widget-editable-focus-background);\n\t}\n}\n\n.ck .ck-widget.ck-widget_with-selection-handle {\n\t& .ck-widget__selection-handle {\n\t\tpadding: 4px;\n\t\tbox-sizing: border-box;\n\n\t\t/* Background and opacity will be animated as the handler shows up or the widget gets selected. */\n\t\tbackground-color: transparent;\n\t\topacity: 0;\n\n\t\t/* Transition:\n\t\t   * background-color for the .ck-widget_selected state change,\n\t\t   * visibility for hiding the handler,\n\t\t   * opacity for the proper look of the icon when the handler disappears. */\n\t\ttransition:\n\t\t\tbackground-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),\n\t\t\tvisibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),\n\t\t\topacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t\t/* Make only top corners round. */\n\t\tborder-radius: var(--ck-border-radius) var(--ck-border-radius) 0 0;\n\n\t\t/* Place the drag handler outside the widget wrapper. */\n\t\ttransform: translateY(-100%);\n\t\tleft: calc(0px - var(--ck-widget-outline-thickness));\n\n\t\t& .ck-icon {\n\t\t\t/* Make sure the dimensions of the icon are independent of the fon-size of the content. */\n\t\t\twidth: var(--ck-widget-handler-icon-size);\n\t\t\theight: var(--ck-widget-handler-icon-size);\n\t\t\tcolor: var(--ck-color-widget-drag-handler-icon-color);\n\n\t\t\t/* The "selected" part of the icon is invisible by default */\n\t\t\t& .ck-icon__selected-indicator {\n\t\t\t\topacity: 0;\n\n\t\t\t\t/* Note: The animation is longer on purpose. Simply feels better. */\n\t\t\t\ttransition: opacity 300ms var(--ck-widget-handler-animation-curve);\n\t\t\t}\n\t\t}\n\n\t\t/* Advertise using the look of the icon that once clicked the handler, the widget will be selected. */\n\t\t&:hover .ck-icon .ck-icon__selected-indicator {\n\t\t\topacity: 1;\n\t\t}\n\t}\n\n\t/* Show the selection handler on mouse hover over the widget. */\n\t&:hover .ck-widget__selection-handle {\n\t\topacity: 1;\n\t\tbackground-color: var(--ck-color-widget-hover-border);\n\t}\n\n\t/* Show the selection handler when the widget is selected. */\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\t& .ck-widget__selection-handle {\n\t\t\topacity: 1;\n\t\t\tbackground-color: var(--ck-color-focus-border);\n\n\t\t\t/* When the widget is selected, notify the user using the proper look of the icon. */\n\t\t\t& .ck-icon .ck-icon__selected-indicator {\n\t\t\t\topacity: 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* In a RTL environment, align the selection handler to the right side of the widget */\n/* stylelint-disable-next-line no-descending-specificity */\n.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle {\n\tleft: auto;\n\tright: calc(0px - var(--ck-widget-outline-thickness));\n}\n\n/* https://github.com/ckeditor/ckeditor5/issues/6415 */\n.ck.ck-editor__editable.ck-read-only .ck-widget {\n\t/* Prevent the :hover outline from showing up because of the used outline-color transition. */\n\ttransition: none;\n\n\t&:not(.ck-widget_selected) {\n\t\t/* Disable visual effects of hover/active widget when CKEditor is in readOnly mode.\n\t\t * See: https://github.com/ckeditor/ckeditor5/issues/1261\n\t\t *\n\t\t * Leave the unit because this custom property is used in calc() by other features.\n\t\t * See: https://github.com/ckeditor/ckeditor5/issues/6775\n\t\t */\n\t\t--ck-widget-outline-thickness: 0px;\n\t}\n\n\t&.ck-widget_with-selection-handle {\n\t\t& .ck-widget__selection-handle,\n\t\t& .ck-widget__selection-handle:hover {\n\t\t\tbackground: var(--ck-color-widget-blurred-border);\n\t\t}\n\t}\n}\n\n/* Style the widget when it\'s selected but the editable it belongs to lost focus. */\n/* stylelint-disable-next-line no-descending-specificity */\n.ck.ck-editor__editable.ck-blurred .ck-widget {\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\toutline-color: var(--ck-color-widget-blurred-border);\n\n\t\t&.ck-widget_with-selection-handle {\n\t\t\t& .ck-widget__selection-handle,\n\t\t\t& .ck-widget__selection-handle:hover {\n\t\t\t\tbackground: var(--ck-color-widget-blurred-border);\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-editor__editable > .ck-widget.ck-widget_with-selection-handle:first-child,\n.ck.ck-editor__editable blockquote > .ck-widget.ck-widget_with-selection-handle:first-child {\n\t/* Do not crop selection handler if a widget is a first-child in the blockquote or in the root editable.\n\tIn fact, anything with overflow: hidden.\n\thttps://github.com/ckeditor/ckeditor5-block-quote/issues/28\n\thttps://github.com/ckeditor/ckeditor5-widget/issues/44\n\thttps://github.com/ckeditor/ckeditor5-widget/issues/66 */\n\tmargin-top: calc(1em + var(--ck-widget-handler-icon-size));\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck.ck-labeled-field-view .ck-labeled-field-view__status{font-size:var(--ck-font-size-small);margin-top:var(--ck-spacing-small);white-space:normal}.ck.ck-labeled-field-view .ck-labeled-field-view__status_error{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view>.ck.ck-label{width:100%;text-overflow:ellipsis;overflow:hidden}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/labeledfield/labeledfieldview.css"],
            names: [],
            mappings: "AAKA,yDACC,mCAAoC,CACpC,kCAAmC,CAInC,kBACD,CAEA,+DACC,gCACD,CAEA,uCACC,UAAW,CACX,sBAAuB,CACvB,eACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-labeled-field-view .ck-labeled-field-view__status {\n\tfont-size: var(--ck-font-size-small);\n\tmargin-top: var(--ck-spacing-small);\n\n\t/* Let the info wrap to the next line to avoid stretching the layout horizontally.\n\tThe status could be very long. */\n\twhite-space: normal;\n}\n\n.ck.ck-labeled-field-view .ck-labeled-field-view__status_error {\n\tcolor: var(--ck-color-base-error);\n}\n\n.ck.ck-labeled-field-view > .ck.ck-label {\n\twidth: 100%;\n\ttext-overflow: ellipsis;\n\toverflow: hidden;\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ":root{--ck-input-text-width:18em}.ck.ck-input-text{border-radius:0}.ck-rounded-corners .ck.ck-input-text,.ck.ck-input-text.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input-text{box-shadow:var(--ck-inner-shadow),0 0;background:var(--ck-color-input-background);border:1px solid var(--ck-color-input-border);padding:var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);min-width:var(--ck-input-text-width);min-height:var(--ck-ui-component-min-height);transition:box-shadow .2s ease-in-out,border .2s ease-in-out}.ck.ck-input-text:focus{outline:none;border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),var(--ck-inner-shadow)}.ck.ck-input-text[readonly]{border:1px solid var(--ck-color-input-disabled-border);background:var(--ck-color-input-disabled-background);color:var(--ck-color-input-disabled-text)}.ck.ck-input-text[readonly]:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),var(--ck-inner-shadow)}.ck.ck-input-text.ck-error{border-color:var(--ck-color-input-error-border);animation:ck-text-input-shake .3s ease both}.ck.ck-input-text.ck-error:focus{box-shadow:var(--ck-focus-error-outer-shadow),var(--ck-inner-shadow)}@keyframes ck-text-input-shake{20%{transform:translateX(-2px)}40%{transform:translateX(2px)}60%{transform:translateX(-1px)}80%{transform:translateX(1px)}}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/inputtext/inputtext.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css"],
            names: [],
            mappings: "AASA,MACC,0BACD,CAEA,kBCFC,eDyCD,CAvCA,2ECEE,qCDqCF,CAvCA,kBEJC,qCAA8B,CFQ9B,2CAA4C,CAC5C,6CAA8C,CAC9C,6DAA8D,CAC9D,oCAAqC,CAGrC,4CAA6C,CAG7C,4DA0BD,CAxBC,wBGlBA,YAAa,CACb,2BAA2B,CDF3B,8DFsBA,CAEA,4BACC,sDAAuD,CACvD,oDAAqD,CACrD,yCAMD,CAJC,kCE7BD,uEFgCC,CAGD,2BACC,+CAAgD,CAChD,2CAKD,CAHC,iCEvCD,oEFyCC,CAIF,+BACC,IACC,0BACD,CAEA,IACC,yBACD,CAEA,IACC,0BACD,CAEA,IACC,yBACD,CACD",
            sourcesContent: ['/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_focus.css";\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-input-text-width: 18em;\n}\n\n.ck.ck-input-text {\n\t@mixin ck-rounded-corners;\n\t@mixin ck-box-shadow var(--ck-inner-shadow);\n\n\tbackground: var(--ck-color-input-background);\n\tborder: 1px solid var(--ck-color-input-border);\n\tpadding: var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);\n\tmin-width: var(--ck-input-text-width);\n\n\t/* This is important to stay of the same height as surrounding buttons */\n\tmin-height: var(--ck-ui-component-min-height);\n\n\t/* Apply some smooth transition to the box-shadow and border. */\n\ttransition: box-shadow .2s ease-in-out, border .2s ease-in-out;\n\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow), var(--ck-inner-shadow);\n\t}\n\n\t&[readonly] {\n\t\tborder: 1px solid var(--ck-color-input-disabled-border);\n\t\tbackground: var(--ck-color-input-disabled-background);\n\t\tcolor: var(--ck-color-input-disabled-text);\n\n\t\t&:focus {\n\t\t\t/* The read-only input should have a slightly less visible shadow when focused. */\n\t\t\t@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow), var(--ck-inner-shadow);\n\t\t}\n\t}\n\n\t&.ck-error {\n\t\tborder-color: var(--ck-color-input-error-border);\n\t\tanimation: ck-text-input-shake .3s ease both;\n\n\t\t&:focus {\n\t\t\t@mixin ck-box-shadow var(--ck-focus-error-outer-shadow), var(--ck-inner-shadow);\n\t\t}\n\t}\n}\n\n@keyframes ck-text-input-shake {\n\t20% {\n\t\ttransform: translateX(-2px);\n\t}\n\n\t40% {\n\t\ttransform: translateX(2px);\n\t}\n\n\t60% {\n\t\ttransform: translateX(-1px);\n\t}\n\n\t80% {\n\t\ttransform: translateX(1px);\n\t}\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck.ck-text-alternative-form{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-text-alternative-form .ck-labeled-field-view{display:inline-block}.ck.ck-text-alternative-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-text-alternative-form{flex-wrap:wrap}.ck.ck-text-alternative-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-text-alternative-form .ck-button{flex-basis:50%}}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-image/theme/textalternativeform.css", "webpack://node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css"],
            names: [],
            mappings: "AAOA,6BACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,oDACC,oBACD,CAEA,uCACC,YACD,CCZA,oCDCD,6BAcE,cAUF,CARE,oDACC,eACD,CAEA,wCACC,cACD,CCrBD",
            sourcesContent: ['/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-text-alternative-form {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\n\t& .ck-labeled-field-view {\n\t\tdisplay: inline-block;\n\t}\n\n\t& .ck-label {\n\t\tdisplay: none;\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-labeled-field-view {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, '.ck-vertical-form .ck-button:after{content:"";width:0;position:absolute;right:-1px;top:var(--ck-spacing-small);bottom:var(--ck-spacing-small);z-index:1}@media screen and (max-width:600px){.ck.ck-responsive-form .ck-button:after{content:"";width:0;position:absolute;right:-1px;top:var(--ck-spacing-small);bottom:var(--ck-spacing-small);z-index:1}}.ck-vertical-form>.ck-button:nth-last-child(2):after{border-right:1px solid var(--ck-color-base-border)}.ck.ck-responsive-form{padding:var(--ck-spacing-standard)}.ck.ck-responsive-form:focus{outline:none}[dir=ltr] .ck.ck-responsive-form>:not(:first-child),[dir=rtl] .ck.ck-responsive-form>:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-responsive-form{padding:0;width:calc(var(--ck-input-text-width)*0.8)}.ck.ck-responsive-form .ck-labeled-field-view{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) 0}.ck.ck-responsive-form .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-responsive-form .ck-labeled-field-view .ck-labeled-field-view__error{white-space:normal}.ck.ck-responsive-form>.ck-button:last-child,.ck.ck-responsive-form>.ck-button:nth-last-child(2){padding:var(--ck-spacing-standard);margin-top:var(--ck-spacing-standard);border-radius:0;border:0;border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-responsive-form>.ck-button:last-child,[dir=ltr] .ck.ck-responsive-form>.ck-button:nth-last-child(2),[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2){margin-left:0}.ck.ck-responsive-form>.ck-button:nth-last-child(2):after,[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child:last-of-type,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2):last-of-type{border-right:1px solid var(--ck-color-base-border)}}', "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-ui/theme/components/responsive-form/responsiveform.css", "webpack://node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/responsive-form/responsiveform.css"],
            names: [],
            mappings: "AAOA,mCACC,UAAW,CACX,OAAQ,CACR,iBAAkB,CAClB,UAAW,CACX,2BAA4B,CAC5B,8BAA+B,CAC/B,SACD,CCTC,oCDaC,wCACC,UAAW,CACX,OAAQ,CACR,iBAAkB,CAClB,UAAW,CACX,2BAA4B,CAC5B,8BAA+B,CAC/B,SACD,CCnBD,CCAD,qDACC,kDACD,CAEA,uBACC,kCAkED,CAhEC,6BAEC,YACD,CASC,uGACC,sCACD,CDvBD,oCCMD,uBAqBE,SAAU,CACV,0CA6CF,CA3CE,8CACC,8DAWD,CATC,6DACC,WAAY,CACZ,UACD,CAGA,4EACC,kBACD,CAID,iGAEC,kCAAmC,CACnC,qCAAsC,CAEtC,eAAgB,CAChB,QAAS,CACT,gDAaD,CApBA,0OAcE,aAMF,CAGC,yMACC,kDACD,CDpEF",
            sourcesContent: ['/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck-vertical-form .ck-button::after {\n\tcontent: "";\n\twidth: 0;\n\tposition: absolute;\n\tright: -1px;\n\ttop: var(--ck-spacing-small);\n\tbottom: var(--ck-spacing-small);\n\tz-index: 1;\n}\n\n.ck.ck-responsive-form {\n\t@mixin ck-media-phone {\n\t\t& .ck-button::after {\n\t\t\tcontent: "";\n\t\t\twidth: 0;\n\t\t\tposition: absolute;\n\t\t\tright: -1px;\n\t\t\ttop: var(--ck-spacing-small);\n\t\t\tbottom: var(--ck-spacing-small);\n\t\t\tz-index: 1;\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n", '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck-vertical-form > .ck-button:nth-last-child(2)::after {\n\tborder-right: 1px solid var(--ck-color-base-border);\n}\n\n.ck.ck-responsive-form {\n\tpadding: var(--ck-spacing-standard);\n\n\t&:focus {\n\t\t/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */\n\t\toutline: none;\n\t}\n\n\t@mixin ck-dir ltr {\n\t\t& > :not(:first-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& > :not(:last-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-media-phone {\n\t\tpadding: 0;\n\t\twidth: calc(.8 * var(--ck-input-text-width));\n\n\t\t& .ck-labeled-field-view {\n\t\t\tmargin: var(--ck-spacing-standard) var(--ck-spacing-standard) 0;\n\n\t\t\t& .ck-input-text {\n\t\t\t\tmin-width: 0;\n\t\t\t\twidth: 100%;\n\t\t\t}\n\n\t\t\t/* Let the long error messages wrap in the narrow form. */\n\t\t\t& .ck-labeled-field-view__error {\n\t\t\t\twhite-space: normal;\n\t\t\t}\n\t\t}\n\n\t\t/* Styles for two last buttons in the form (save&cancel, edit&unlink, etc.). */\n\t\t& > .ck-button:nth-last-child(1),\n\t\t& > .ck-button:nth-last-child(2) {\n\t\t\tpadding: var(--ck-spacing-standard);\n\t\t\tmargin-top: var(--ck-spacing-standard);\n\n\t\t\tborder-radius: 0;\n\t\t\tborder: 0;\n\t\t\tborder-top: 1px solid var(--ck-color-base-border);\n\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-left: 0;\n\n\t\t\t\t&:last-of-type {\n\t\t\t\t\tborder-right: 1px solid var(--ck-color-base-border);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t& > .ck-button:nth-last-child(2) {\n\t\t\t&::after {\n\t\t\t\tborder-right: 1px solid var(--ck-color-base-border);\n\t\t\t}\n\t\t}\n\t}\n}\n'],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck .ck-balloon-rotator__navigation{display:flex;align-items:center;justify-content:center}.ck .ck-balloon-rotator__content .ck-toolbar{justify-content:center}.ck .ck-balloon-rotator__navigation{background:var(--ck-color-toolbar-background);border-bottom:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation>*{margin-right:var(--ck-spacing-small);margin-top:var(--ck-spacing-small);margin-bottom:var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation .ck-balloon-rotator__counter{margin-right:var(--ck-spacing-standard);margin-left:var(--ck-spacing-small)}.ck .ck-balloon-rotator__content .ck.ck-annotation-wrapper{box-shadow:none}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/balloonrotator.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonrotator.css"],
            names: [],
            mappings: "AAKA,oCACC,YAAa,CACb,kBAAmB,CACnB,sBACD,CAKA,6CACC,sBACD,CCXA,oCACC,6CAA8C,CAC9C,sDAAuD,CACvD,iCAgBD,CAbC,sCACC,oCAAqC,CACrC,kCAAmC,CACnC,qCACD,CAGA,iEACC,uCAAwC,CAGxC,mCACD,CAMA,2DACC,eACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-balloon-rotator__navigation {\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n}\n\n/* Buttons inside a toolbar should be centered when rotator bar is wider.\n * See: https://github.com/ckeditor/ckeditor5-ui/issues/495\n */\n.ck .ck-balloon-rotator__content .ck-toolbar {\n\tjustify-content: center;\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-balloon-rotator__navigation {\n\tbackground: var(--ck-color-toolbar-background);\n\tborder-bottom: 1px solid var(--ck-color-toolbar-border);\n\tpadding: 0 var(--ck-spacing-small);\n\n\t/* Let's keep similar appearance to `ck-toolbar`. */\n\t& > * {\n\t\tmargin-right: var(--ck-spacing-small);\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t/* Gives counter more breath than buttons. */\n\t& .ck-balloon-rotator__counter {\n\t\tmargin-right: var(--ck-spacing-standard);\n\n\t\t/* We need to use smaller margin because of previous button's right margin. */\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n}\n\n.ck .ck-balloon-rotator__content {\n\n\t/* Disable default annotation shadow inside rotator with fake panels. */\n\t& .ck.ck-annotation-wrapper {\n\t\tbox-shadow: none;\n\t}\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck .ck-fake-panel{position:absolute;z-index:calc(var(--ck-z-modal) - 1)}.ck .ck-fake-panel div{position:absolute}.ck .ck-fake-panel div:first-child{z-index:2}.ck .ck-fake-panel div:nth-child(2){z-index:1}:root{--ck-balloon-fake-panel-offset-horizontal:6px;--ck-balloon-fake-panel-offset-vertical:6px}.ck .ck-fake-panel div{box-shadow:var(--ck-drop-shadow),0 0;min-height:15px;background:var(--ck-color-panel-background);border:1px solid var(--ck-color-panel-border);border-radius:var(--ck-border-radius);width:100%;height:100%}.ck .ck-fake-panel div:first-child{margin-left:var(--ck-balloon-fake-panel-offset-horizontal);margin-top:var(--ck-balloon-fake-panel-offset-vertical)}.ck .ck-fake-panel div:nth-child(2){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*2);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*2)}.ck .ck-fake-panel div:nth-child(3){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*3);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*3)}.ck .ck-balloon-panel_arrow_s+.ck-fake-panel,.ck .ck-balloon-panel_arrow_se+.ck-fake-panel,.ck .ck-balloon-panel_arrow_sw+.ck-fake-panel{--ck-balloon-fake-panel-offset-vertical:-6px}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/fakepanel.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/fakepanel.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css"],
            names: [],
            mappings: "AAKA,mBACC,iBAAkB,CAGlB,mCACD,CAEA,uBACC,iBACD,CAEA,mCACC,SACD,CAEA,oCACC,SACD,CCfA,MACC,6CAA8C,CAC9C,2CACD,CAGA,uBCJC,oCAA8B,CDO9B,eAAgB,CAEhB,2CAA4C,CAC5C,6CAA8C,CAC9C,qCAAsC,CAEtC,UAAW,CACX,WACD,CAEA,mCACC,0DAA2D,CAC3D,uDACD,CAEA,oCACC,kEAAqE,CACrE,+DACD,CACA,oCACC,kEAAqE,CACrE,+DACD,CAGA,yIAGC,4CACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-fake-panel {\n\tposition: absolute;\n\n\t/* Fake panels should be placed under main balloon content. */\n\tz-index: calc(var(--ck-z-modal) - 1);\n}\n\n.ck .ck-fake-panel div {\n\tposition: absolute;\n}\n\n.ck .ck-fake-panel div:nth-child( 1 ) {\n\tz-index: 2;\n}\n\n.ck .ck-fake-panel div:nth-child( 2 ) {\n\tz-index: 1;\n}\n", '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-balloon-fake-panel-offset-horizontal: 6px;\n\t--ck-balloon-fake-panel-offset-vertical: 6px;\n}\n\n/* Let\'s use `.ck-balloon-panel` appearance. See: balloonpanel.css. */\n.ck .ck-fake-panel div {\n\t@mixin ck-drop-shadow;\n\n\tmin-height: 15px;\n\n\tbackground: var(--ck-color-panel-background);\n\tborder: 1px solid var(--ck-color-panel-border);\n\tborder-radius: var(--ck-border-radius);\n\n\twidth: 100%;\n\theight: 100%;\n}\n\n.ck .ck-fake-panel div:nth-child( 1 ) {\n\tmargin-left: var(--ck-balloon-fake-panel-offset-horizontal);\n\tmargin-top: var(--ck-balloon-fake-panel-offset-vertical);\n}\n\n.ck .ck-fake-panel div:nth-child( 2 ) {\n\tmargin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 2);\n\tmargin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 2);\n}\n.ck .ck-fake-panel div:nth-child( 3 ) {\n\tmargin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 3);\n\tmargin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 3);\n}\n\n/* If balloon is positioned above element, we need to move fake panel to the top. */\n.ck .ck-balloon-panel_arrow_s + .ck-fake-panel,\n.ck .ck-balloon-panel_arrow_se + .ck-fake-panel,\n.ck .ck-balloon-panel_arrow_sw + .ck-fake-panel {\n\t--ck-balloon-fake-panel-offset-vertical: -6px;\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck-content .image{display:table;clear:both;text-align:center;margin:1em auto}.ck-content .image img{display:block;margin:0 auto;max-width:100%;min-width:50px}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-image/theme/image.css"],
            names: [],
            mappings: "AAKA,mBACC,aAAc,CACd,UAAW,CACX,iBAAkB,CAGlB,eAeD,CAbC,uBAEC,aAAc,CAGd,aAAc,CAGd,cAAe,CAGf,cACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content .image {\n\tdisplay: table;\n\tclear: both;\n\ttext-align: center;\n\n\t/* Make sure there is some space between the content and the image. Center image by default. */\n\tmargin: 1em auto;\n\n\t& img {\n\t\t/* Prevent unnecessary margins caused by line-height (see #44). */\n\t\tdisplay: block;\n\n\t\t/* Center the image if its width is smaller than the content's width. */\n\t\tmargin: 0 auto;\n\n\t\t/* Make sure the image never exceeds the size of the parent container (ckeditor/ckeditor5-ui#67). */\n\t\tmax-width: 100%;\n\n\t\t/* Make sure the caption will be displayed properly (See: https://github.com/ckeditor/ckeditor5/issues/1870). */\n\t\tmin-width: 50px;\n\t}\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck-content .image>figcaption{display:table-caption;caption-side:bottom;word-break:break-word;color:#333;background-color:#f7f7f7;padding:.6em;font-size:.75em;outline-offset:-1px}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-image/theme/imagecaption.css"],
            names: [],
            mappings: "AAKA,8BACC,qBAAsB,CACtB,mBAAoB,CACpB,qBAAsB,CACtB,UAAsB,CACtB,wBAAiC,CACjC,YAAa,CACb,eAAgB,CAChB,mBACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content .image > figcaption {\n\tdisplay: table-caption;\n\tcaption-side: bottom;\n\tword-break: break-word;\n\tcolor: hsl(0, 0%, 20%);\n\tbackground-color: hsl(0, 0%, 97%);\n\tpadding: .6em;\n\tfont-size: .75em;\n\toutline-offset: -1px;\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck.ck-editor__editable .image{position:relative}.ck.ck-editor__editable .image .ck-progress-bar{position:absolute;top:0;left:0}.ck.ck-editor__editable .image.ck-appear{animation:fadeIn .7s}.ck.ck-editor__editable .image .ck-progress-bar{height:2px;width:0;background:var(--ck-color-upload-bar-background);transition:width .1s}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-image/theme/imageuploadprogress.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadprogress.css"],
            names: [],
            mappings: "AAKA,+BACC,iBACD,CAGA,gDACC,iBAAkB,CAClB,KAAM,CACN,MACD,CCPC,yCACC,oBACD,CAID,gDACC,UAAW,CACX,OAAQ,CACR,gDAAiD,CACjD,oBACD,CAEA,kBACC,GAAO,SAAY,CACnB,GAAO,SAAY,CACpB",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable .image {\n\tposition: relative;\n}\n\n/* Upload progress bar. */\n.ck.ck-editor__editable .image .ck-progress-bar {\n\tposition: absolute;\n\ttop: 0;\n\tleft: 0;\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable .image {\n\t/* Showing animation. */\n\t&.ck-appear {\n\t\tanimation: fadeIn 700ms;\n\t}\n}\n\n/* Upload progress bar. */\n.ck.ck-editor__editable .image .ck-progress-bar {\n\theight: 2px;\n\twidth: 0;\n\tbackground: var(--ck-color-upload-bar-background);\n\ttransition: width 100ms;\n}\n\n@keyframes fadeIn {\n\tfrom { opacity: 0; }\n\tto   { opacity: 1; }\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, '.ck-image-upload-complete-icon{display:block;position:absolute;top:10px;right:10px;border-radius:50%}.ck-image-upload-complete-icon:after{content:"";position:absolute}:root{--ck-color-image-upload-icon:#fff;--ck-color-image-upload-icon-background:#008a00;--ck-image-upload-icon-size:20px;--ck-image-upload-icon-width:2px}.ck-image-upload-complete-icon{width:var(--ck-image-upload-icon-size);height:var(--ck-image-upload-icon-size);opacity:0;background:var(--ck-color-image-upload-icon-background);animation-name:ck-upload-complete-icon-show,ck-upload-complete-icon-hide;animation-fill-mode:forwards,forwards;animation-duration:.5s,.5s;font-size:var(--ck-image-upload-icon-size);animation-delay:0ms,3s}.ck-image-upload-complete-icon:after{left:25%;top:50%;opacity:0;height:0;width:0;transform:scaleX(-1) rotate(135deg);transform-origin:left top;border-top:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);border-right:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);animation-name:ck-upload-complete-icon-check;animation-duration:.5s;animation-delay:.5s;animation-fill-mode:forwards;box-sizing:border-box}@keyframes ck-upload-complete-icon-show{0%{opacity:0}to{opacity:1}}@keyframes ck-upload-complete-icon-hide{0%{opacity:1}to{opacity:0}}@keyframes ck-upload-complete-icon-check{0%{opacity:1;width:0;height:0}33%{width:.3em;height:0}to{opacity:1;width:.3em;height:.45em}}', "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-image/theme/imageuploadicon.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadicon.css"],
            names: [],
            mappings: "AAKA,+BACC,aAAc,CACd,iBAAkB,CAClB,QAAS,CACT,UAAW,CACX,iBAMD,CAJC,qCACC,UAAW,CACX,iBACD,CCVD,MACC,iCAA8C,CAC9C,+CAA4D,CAE5D,gCAAiC,CACjC,gCACD,CAEA,+BACC,sCAAuC,CACvC,uCAAwC,CACxC,SAAU,CACV,uDAAwD,CACxD,wEAA0E,CAC1E,qCAAuC,CACvC,0BAAgC,CAGhC,0CAA2C,CAG3C,sBAyBD,CAtBC,qCAEC,QAAS,CAET,OAAQ,CACR,SAAU,CACV,QAAS,CACT,OAAQ,CAER,mCAAoC,CACpC,yBAA0B,CAC1B,oFAAqF,CACrF,sFAAuF,CAEvF,4CAA6C,CAC7C,sBAAyB,CACzB,mBAAsB,CACtB,4BAA6B,CAG7B,qBACD,CAGD,wCACC,GACC,SACD,CAEA,GACC,SACD,CACD,CAEA,wCACC,GACC,SACD,CAEA,GACC,SACD,CACD,CAEA,yCACC,GACC,SAAU,CACV,OAAQ,CACR,QACD,CACA,IACC,UAAY,CACZ,QACD,CACA,GACC,SAAU,CACV,UAAY,CACZ,YACD,CACD",
            sourcesContent: ['/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-image-upload-complete-icon {\n\tdisplay: block;\n\tposition: absolute;\n\ttop: 10px;\n\tright: 10px;\n\tborder-radius: 50%;\n\n\t&::after {\n\t\tcontent: "";\n\t\tposition: absolute;\n\t}\n}\n', '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-image-upload-icon: hsl(0, 0%, 100%);\n\t--ck-color-image-upload-icon-background: hsl(120, 100%, 27%);\n\n\t--ck-image-upload-icon-size: 20px;\n\t--ck-image-upload-icon-width: 2px;\n}\n\n.ck-image-upload-complete-icon {\n\twidth: var(--ck-image-upload-icon-size);\n\theight: var(--ck-image-upload-icon-size);\n\topacity: 0;\n\tbackground: var(--ck-color-image-upload-icon-background);\n\tanimation-name: ck-upload-complete-icon-show, ck-upload-complete-icon-hide;\n\tanimation-fill-mode: forwards, forwards;\n\tanimation-duration: 500ms, 500ms;\n\n\t/* To make animation scalable. */\n\tfont-size: var(--ck-image-upload-icon-size);\n\n\t/* Hide completed upload icon after 3 seconds. */\n\tanimation-delay: 0ms, 3000ms;\n\n\t/* This is check icon element made from border-width mixed with animations. */\n\t&::after {\n\t\t/* Because of border transformation we need to "hard code" left position. */\n\t\tleft: 25%;\n\n\t\ttop: 50%;\n\t\topacity: 0;\n\t\theight: 0;\n\t\twidth: 0;\n\n\t\ttransform: scaleX(-1) rotate(135deg);\n\t\ttransform-origin: left top;\n\t\tborder-top: var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);\n\t\tborder-right: var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);\n\n\t\tanimation-name: ck-upload-complete-icon-check;\n\t\tanimation-duration: 500ms;\n\t\tanimation-delay: 500ms;\n\t\tanimation-fill-mode: forwards;\n\n\t\t/* #1095. While reset is not providing proper box-sizing for pseudoelements, we need to handle it. */\n\t\tbox-sizing: border-box;\n\t}\n}\n\n@keyframes ck-upload-complete-icon-show {\n\tfrom {\n\t\topacity: 0;\n\t}\n\n\tto {\n\t\topacity: 1;\n\t}\n}\n\n@keyframes ck-upload-complete-icon-hide {\n\tfrom {\n\t\topacity: 1;\n\t}\n\n\tto {\n\t\topacity: 0;\n\t}\n}\n\n@keyframes ck-upload-complete-icon-check {\n\t0% {\n\t\topacity: 1;\n\t\twidth: 0;\n\t\theight: 0;\n\t}\n\t33% {\n\t\twidth: 0.3em;\n\t\theight: 0;\n\t}\n\t100% {\n\t\topacity: 1;\n\t\twidth: 0.3em;\n\t\theight: 0.45em;\n\t}\n}\n'],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, '.ck .ck-upload-placeholder-loader{position:absolute;display:flex;align-items:center;justify-content:center;top:0;left:0}.ck .ck-upload-placeholder-loader:before{content:"";position:relative}:root{--ck-color-upload-placeholder-loader:#b3b3b3;--ck-upload-placeholder-loader-size:32px}.ck .ck-image-upload-placeholder{width:100%;margin:0}.ck .ck-upload-placeholder-loader{width:100%;height:100%}.ck .ck-upload-placeholder-loader:before{width:var(--ck-upload-placeholder-loader-size);height:var(--ck-upload-placeholder-loader-size);border-radius:50%;border-top:3px solid var(--ck-color-upload-placeholder-loader);border-right:2px solid transparent;animation:ck-upload-placeholder-loader 1s linear infinite}@keyframes ck-upload-placeholder-loader{to{transform:rotate(1turn)}}', "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-image/theme/imageuploadloader.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadloader.css"],
            names: [],
            mappings: "AAKA,kCACC,iBAAkB,CAClB,YAAa,CACb,kBAAmB,CACnB,sBAAuB,CACvB,KAAM,CACN,MAMD,CAJC,yCACC,UAAW,CACX,iBACD,CCXD,MACC,4CAAqD,CACrD,wCACD,CAEA,iCAEC,UAAW,CACX,QACD,CAEA,kCACC,UAAW,CACX,WAUD,CARC,yCACC,8CAA+C,CAC/C,+CAAgD,CAChD,iBAAkB,CAClB,8DAA+D,CAC/D,kCAAmC,CACnC,yDACD,CAGD,wCACC,GACC,uBACD,CACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-upload-placeholder-loader {\n\tposition: absolute;\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n\ttop: 0;\n\tleft: 0;\n\n\t&::before {\n\t\tcontent: '';\n\t\tposition: relative;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-upload-placeholder-loader: hsl(0, 0%, 70%);\n\t--ck-upload-placeholder-loader-size: 32px;\n}\n\n.ck .ck-image-upload-placeholder {\n\t/* We need to control the full width of the SVG gray background. */\n\twidth: 100%;\n\tmargin: 0;\n}\n\n.ck .ck-upload-placeholder-loader {\n\twidth: 100%;\n\theight: 100%;\n\n\t&::before {\n\t\twidth: var(--ck-upload-placeholder-loader-size);\n\t\theight: var(--ck-upload-placeholder-loader-size);\n\t\tborder-radius: 50%;\n\t\tborder-top: 3px solid var(--ck-color-upload-placeholder-loader);\n\t\tborder-right: 2px solid transparent;\n\t\tanimation: ck-upload-placeholder-loader 1s linear infinite;\n\t}\n}\n\n@keyframes ck-upload-placeholder-loader {\n\tto {\n\t\ttransform: rotate( 360deg );\n\t}\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck.ck-image-insert-form:focus{outline:none}.ck.ck-form__row{display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}.ck.ck-form__row>:not(.ck-label){flex-grow:1}.ck.ck-form__row.ck-image-insert-form__action-row{margin-top:var(--ck-spacing-standard)}.ck.ck-form__row.ck-image-insert-form__action-row .ck-button-cancel,.ck.ck-form__row.ck-image-insert-form__action-row .ck-button-save{justify-content:center}.ck.ck-form__row.ck-image-insert-form__action-row .ck-button .ck-button__label{color:var(--ck-color-text)}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-image/theme/imageinsertformrowview.css"],
            names: [],
            mappings: "AAMC,+BAEC,YACD,CAGD,iBACC,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CACjB,6BAmBD,CAhBC,iCACC,WACD,CAEA,kDACC,qCAUD,CARC,sIAEC,sBACD,CAEA,+EACC,0BACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-image-insert-form {\n\t&:focus {\n\t\t/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */\n\t\toutline: none;\n\t}\n}\n\n.ck.ck-form__row {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\tjustify-content: space-between;\n\n\t/* Ignore labels that work as fieldset legends */\n\t& > *:not(.ck-label) {\n\t\tflex-grow: 1;\n\t}\n\n\t&.ck-image-insert-form__action-row {\n\t\tmargin-top: var(--ck-spacing-standard);\n\n\t\t& .ck-button-save,\n\t\t& .ck-button-cancel {\n\t\t\tjustify-content: center;\n\t\t}\n\n\t\t& .ck-button .ck-button__label {\n\t\t\tcolor: var(--ck-color-text);\n\t\t}\n\t}\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck.ck-image-insert__panel{padding:var(--ck-spacing-standard)}.ck.ck-image-insert__ck-finder-button{display:block;width:100%;margin:var(--ck-spacing-standard) auto;border:1px solid #ccc;border-radius:var(--ck-border-radius)}.ck.ck-splitbutton>.ck-file-dialog-button.ck-button{padding:0;margin:0;border:none}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-image/theme/imageinsert.css"],
            names: [],
            mappings: "AAKA,2BACC,kCACD,CAEA,sCACC,aAAc,CACd,UAAW,CACX,sCAAuC,CACvC,qBAAiC,CACjC,qCACD,CAGA,oDACC,SAAU,CACV,QAAS,CACT,WACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-image-insert__panel {\n\tpadding: var(--ck-spacing-standard);\n}\n\n.ck.ck-image-insert__ck-finder-button {\n\tdisplay: block;\n\twidth: 100%;\n\tmargin: var(--ck-spacing-standard) auto;\n\tborder: 1px solid hsl(0, 0%, 80%);\n\tborder-radius: var(--ck-border-radius);\n}\n\n/* https://github.com/ckeditor/ckeditor5/issues/7986 */\n.ck.ck-splitbutton > .ck-file-dialog-button.ck-button {\n\tpadding: 0;\n\tmargin: 0;\n\tborder: none;\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck .ck-widget_with-resizer{position:relative}.ck .ck-widget__resizer{display:none;position:absolute;pointer-events:none;left:0;top:0;outline:1px solid var(--ck-color-resizer)}.ck-focused .ck-widget_with-resizer.ck-widget_selected>.ck-widget__resizer{display:block}.ck .ck-widget__resizer__handle{position:absolute;pointer-events:all;width:var(--ck-resizer-size);height:var(--ck-resizer-size);background:var(--ck-color-focus-border);border:var(--ck-resizer-border-width) solid #fff;border-radius:var(--ck-resizer-border-radius)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{top:var(--ck-resizer-offset);left:var(--ck-resizer-offset);cursor:nwse-resize}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{top:var(--ck-resizer-offset);right:var(--ck-resizer-offset);cursor:nesw-resize}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right{bottom:var(--ck-resizer-offset);right:var(--ck-resizer-offset);cursor:nwse-resize}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left{bottom:var(--ck-resizer-offset);left:var(--ck-resizer-offset);cursor:nesw-resize}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-widget/theme/widgetresize.css"],
            names: [],
            mappings: "AAKA,4BAEC,iBACD,CAEA,wBACC,YAAa,CACb,iBAAkB,CAGlB,mBAAoB,CAEpB,MAAO,CACP,KAAM,CAEN,yCACD,CAGC,2EACC,aACD,CAGD,gCACC,iBAAkB,CAGlB,kBAAmB,CAEnB,4BAA6B,CAC7B,6BAA8B,CAC9B,uCAAwC,CACxC,gDAA6D,CAC7D,6CAyBD,CAvBC,oEACC,4BAA+B,CAC/B,6BAAgC,CAChC,kBACD,CAEA,qEACC,4BAA+B,CAC/B,8BAAiC,CACjC,kBACD,CAEA,wEACC,+BAAkC,CAClC,8BAAiC,CACjC,kBACD,CAEA,uEACC,+BAAkC,CAClC,6BAAgC,CAChC,kBACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-widget_with-resizer {\n\t/* Make the widget wrapper a relative positioning container for the drag handle. */\n\tposition: relative;\n}\n\n.ck .ck-widget__resizer {\n\tdisplay: none;\n\tposition: absolute;\n\n\t/* The wrapper itself should not interfere with the pointer device, only the handles should. */\n\tpointer-events: none;\n\n\tleft: 0;\n\ttop: 0;\n\n\toutline: 1px solid var(--ck-color-resizer);\n}\n\n.ck-focused .ck-widget_with-resizer.ck-widget_selected {\n\t& > .ck-widget__resizer {\n\t\tdisplay: block;\n\t}\n}\n\n.ck .ck-widget__resizer__handle {\n\tposition: absolute;\n\n\t/* Resizers are the only UI elements that should interfere with a pointer device. */\n\tpointer-events: all;\n\n\twidth: var(--ck-resizer-size);\n\theight: var(--ck-resizer-size);\n\tbackground: var(--ck-color-focus-border);\n\tborder: var(--ck-resizer-border-width) solid hsl(0, 0%, 100%);\n\tborder-radius: var(--ck-resizer-border-radius);\n\n\t&.ck-widget__resizer__handle-top-left {\n\t\ttop: var( --ck-resizer-offset );\n\t\tleft: var( --ck-resizer-offset );\n\t\tcursor: nwse-resize;\n\t}\n\n\t&.ck-widget__resizer__handle-top-right {\n\t\ttop: var( --ck-resizer-offset );\n\t\tright: var( --ck-resizer-offset );\n\t\tcursor: nesw-resize;\n\t}\n\n\t&.ck-widget__resizer__handle-bottom-right {\n\t\tbottom: var( --ck-resizer-offset );\n\t\tright: var( --ck-resizer-offset );\n\t\tcursor: nwse-resize;\n\t}\n\n\t&.ck-widget__resizer__handle-bottom-left {\n\t\tbottom: var( --ck-resizer-offset );\n\t\tleft: var( --ck-resizer-offset );\n\t\tcursor: nesw-resize;\n\t}\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck-content .image.image_resized{max-width:100%;display:block;box-sizing:border-box}.ck-content .image.image_resized img{width:100%}.ck-content .image.image_resized>figcaption{display:block}[dir=ltr] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon{margin-left:var(--ck-spacing-standard)}.ck.ck-dropdown .ck-button.ck-resize-image-button .ck-button__label{width:4em}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-image/theme/imageresize.css"],
            names: [],
            mappings: "AAKA,iCACC,cAAe,CAMf,aAAc,CACd,qBAWD,CATC,qCAEC,UACD,CAEA,4CAEC,aACD,CAGD,oFACC,uCACD,CAEA,oFACC,sCACD,CAEA,oEACC,SACD",
            sourcesContent: ['/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content .image.image_resized {\n\tmax-width: 100%;\n\t/*\n\tThe `<figure>` element for resized images must not use `display:table` as browsers do not support `max-width` for it well.\n\tSee https://stackoverflow.com/questions/4019604/chrome-safari-ignoring-max-width-in-table/14420691#14420691 for more.\n\tFortunately, since we control the width, there is no risk that the image will look bad.\n\t*/\n\tdisplay: block;\n\tbox-sizing: border-box;\n\n\t& img {\n\t\t/* For resized images it is the `<figure>` element that determines the image width. */\n\t\twidth: 100%;\n\t}\n\n\t& > figcaption {\n\t\t/* The `<figure>` element uses `display:block`, so `<figcaption>` also has to. */\n\t\tdisplay: block;\n\t}\n}\n\n[dir="ltr"] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon {\n\tmargin-right: var(--ck-spacing-standard);\n}\n\n[dir="rtl"] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon {\n\tmargin-left: var(--ck-spacing-standard);\n}\n\n.ck.ck-dropdown .ck-button.ck-resize-image-button .ck-button__label {\n\twidth: 4em;\n}\n'],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ":root{--ck-image-style-spacing:1.5em}.ck-content .image-style-side{float:right;margin-left:var(--ck-image-style-spacing);max-width:50%}.ck-content .image-style-align-left{float:left;margin-right:var(--ck-image-style-spacing)}.ck-content .image-style-align-center{margin-left:auto;margin-right:auto}.ck-content .image-style-align-right{float:right;margin-left:var(--ck-image-style-spacing)}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-image/theme/imagestyle.css"],
            names: [],
            mappings: "AAKA,MACC,8BACD,CAGC,8BACC,WAAY,CACZ,yCAA0C,CAC1C,aACD,CAEA,oCACC,UAAW,CACX,0CACD,CAEA,sCACC,gBAAiB,CACjB,iBACD,CAEA,qCACC,WAAY,CACZ,yCACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-image-style-spacing: 1.5em;\n}\n\n.ck-content {\n\t& .image-style-side {\n\t\tfloat: right;\n\t\tmargin-left: var(--ck-image-style-spacing);\n\t\tmax-width: 50%;\n\t}\n\n\t& .image-style-align-left {\n\t\tfloat: left;\n\t\tmargin-right: var(--ck-image-style-spacing);\n\t}\n\n\t& .image-style-align-center {\n\t\tmargin-left: auto;\n\t\tmargin-right: auto;\n\t}\n\n\t& .image-style-align-right {\n\t\tfloat: right;\n\t\tmargin-left: var(--ck-image-style-spacing);\n\t}\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck .ck-link_selected{background:var(--ck-color-link-selected-background)}.ck .ck-fake-link-selection{background:var(--ck-color-link-fake-selection)}.ck .ck-fake-link-selection_collapsed{height:100%;border-right:1px solid var(--ck-color-base-text);margin-right:-1px;outline:1px solid hsla(0,0%,100%,.5)}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-link/link.css"],
            names: [],
            mappings: "AAMA,sBACC,mDACD,CAMA,4BACC,8CACD,CAGA,sCACC,WAAY,CACZ,gDAAiD,CACjD,iBAAkB,CAClB,oCACD",
            sourcesContent: ['/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Class added to span element surrounding currently selected link. */\n.ck .ck-link_selected {\n\tbackground: var(--ck-color-link-selected-background);\n}\n\n/*\n * Classes used by the "fake visual selection" displayed in the content when an input\n * in the link UI has focus (the browser does not render the native selection in this state).\n */\n.ck .ck-fake-link-selection {\n\tbackground: var(--ck-color-link-fake-selection);\n}\n\n/* A collapsed fake visual selection. */\n.ck .ck-fake-link-selection_collapsed {\n\theight: 100%;\n\tborder-right: 1px solid var(--ck-color-base-text);\n\tmargin-right: -1px;\n\toutline: solid 1px hsla(0, 0%, 100%, .5);\n}\n'],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck.ck-link-form{display:flex}.ck.ck-link-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-link-form{flex-wrap:wrap}.ck.ck-link-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-link-form .ck-button{flex-basis:50%}}.ck.ck-link-form_layout-vertical{display:block;padding:0;min-width:var(--ck-input-text-width)}.ck.ck-link-form_layout-vertical .ck-labeled-field-view{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) var(--ck-spacing-small)}.ck.ck-link-form_layout-vertical .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-link-form_layout-vertical .ck-button{padding:var(--ck-spacing-standard);margin:0;border-radius:0;border:0;border-top:1px solid var(--ck-color-base-border);width:50%}[dir=ltr] .ck.ck-link-form_layout-vertical .ck-button,[dir=rtl] .ck.ck-link-form_layout-vertical .ck-button{margin-left:0}[dir=rtl] .ck.ck-link-form_layout-vertical .ck-button:last-of-type{border-right:1px solid var(--ck-color-base-border)}.ck.ck-link-form_layout-vertical .ck.ck-list{margin-left:0}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton{border:0;width:100%}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton:hover{background:none}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-link/theme/linkform.css", "webpack://node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-link/linkform.css"],
            names: [],
            mappings: "AAOA,iBACC,YAiBD,CAfC,2BACC,YACD,CCNA,oCDCD,iBAQE,cAUF,CARE,wCACC,eACD,CAEA,4BACC,cACD,CCfD,CDuBD,iCACC,aAAc,CEpBd,SAAU,CACV,oCFoBD,CElBC,wDACC,oFAMD,CAJC,uEACC,WAAY,CACZ,UACD,CAGD,4CACC,kCAAmC,CACnC,QAAS,CACT,eAAgB,CAChB,QAAS,CACT,gDAAiD,CACjD,SAaD,CAnBA,4GAaE,aAMF,CAJE,mEACC,kDACD,CAKF,6CACC,aAUD,CARC,wEACC,QAAS,CACT,UAKD,CAHC,8EACC,eACD",
            sourcesContent: ['/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-form {\n\tdisplay: flex;\n\n\t& .ck-label {\n\t\tdisplay: none;\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-labeled-field-view {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n\n/*\n * Style link form differently when manual decorators are available.\n * See: https://github.com/ckeditor/ckeditor5-link/issues/186.\n */\n.ck.ck-link-form_layout-vertical {\n\tdisplay: block;\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n", '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n/*\n * Style link form differently when manual decorators are available.\n * See: https://github.com/ckeditor/ckeditor5-link/issues/186.\n */\n.ck.ck-link-form_layout-vertical {\n\tpadding: 0;\n\tmin-width: var(--ck-input-text-width);\n\n\t& .ck-labeled-field-view {\n\t\tmargin: var(--ck-spacing-standard) var(--ck-spacing-standard) var(--ck-spacing-small);\n\n\t\t& .ck-input-text {\n\t\t\tmin-width: 0;\n\t\t\twidth: 100%;\n\t\t}\n\t}\n\n\t& .ck-button {\n\t\tpadding: var(--ck-spacing-standard);\n\t\tmargin: 0;\n\t\tborder-radius: 0;\n\t\tborder: 0;\n\t\tborder-top: 1px solid var(--ck-color-base-border);\n\t\twidth: 50%;\n\n\t\t@mixin ck-dir ltr {\n\t\t\tmargin-left: 0;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tmargin-left: 0;\n\n\t\t\t&:last-of-type {\n\t\t\t\tborder-right: 1px solid var(--ck-color-base-border);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Using additional `.ck` class for stronger CSS specificity than `.ck.ck-link-form > :not(:first-child)`. */\n\t& .ck.ck-list {\n\t\tmargin-left: 0;\n\n\t\t& .ck-button.ck-switchbutton {\n\t\t\tborder: 0;\n\t\t\twidth: 100%;\n\n\t\t\t&:hover {\n\t\t\t\tbackground: none;\n\t\t\t}\n\t\t}\n\t}\n}\n'],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck.ck-link-actions{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-link-actions .ck-link-actions__preview{display:inline-block}.ck.ck-link-actions .ck-link-actions__preview .ck-button__label{overflow:hidden}@media screen and (max-width:600px){.ck.ck-link-actions{flex-wrap:wrap}.ck.ck-link-actions .ck-link-actions__preview{flex-basis:100%}.ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){flex-basis:50%}}.ck.ck-link-actions .ck-button.ck-link-actions__preview{padding-left:0;padding-right:0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{padding:0 var(--ck-spacing-medium);color:var(--ck-color-link-default);text-overflow:ellipsis;cursor:pointer;max-width:var(--ck-input-text-width);min-width:3em;text-align:center}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label:hover{text-decoration:underline}.ck.ck-link-actions .ck-button.ck-link-actions__preview,.ck.ck-link-actions .ck-button.ck-link-actions__preview:active,.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus,.ck.ck-link-actions .ck-button.ck-link-actions__preview:hover{background:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:active{box-shadow:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus .ck-button__label{text-decoration:underline}[dir=ltr] .ck.ck-link-actions .ck-button:not(:first-child),[dir=rtl] .ck.ck-link-actions .ck-button:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-link-actions .ck-button.ck-link-actions__preview{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) 0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{min-width:0;max-width:100%}[dir=ltr] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview),[dir=rtl] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){margin-left:0}}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-link/theme/linkactions.css", "webpack://node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-link/linkactions.css"],
            names: [],
            mappings: "AAOA,oBACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,8CACC,oBAKD,CAHC,gEACC,eACD,CCXD,oCDCD,oBAcE,cAUF,CARE,8CACC,eACD,CAEA,8DACC,cACD,CCrBD,CCKA,wDACC,cAAe,CACf,eAmCD,CAjCC,0EACC,kCAAmC,CACnC,kCAAmC,CACnC,sBAAuB,CACvB,cAAe,CAIf,oCAAqC,CACrC,aAAc,CACd,iBAKD,CAHC,gFACC,yBACD,CAGD,mPAIC,eACD,CAEA,+DACC,eACD,CAGC,gFACC,yBACD,CAWD,qHACC,sCACD,CDvDD,oCC2DC,wDACC,8DAMD,CAJC,0EACC,WAAY,CACZ,cACD,CAGD,gJAME,aAEF,CD1ED",
            sourcesContent: ['/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-actions {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\n\t& .ck-link-actions__preview {\n\t\tdisplay: inline-block;\n\n\t\t& .ck-button__label {\n\t\t\toverflow: hidden;\n\t\t}\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-link-actions__preview {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button:not(.ck-link-actions__preview) {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n", '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/components/tooltip/mixins/_tooltip.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n@import "../mixins/_focus.css";\n@import "../mixins/_shadow.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-actions {\n\t& .ck-button.ck-link-actions__preview {\n\t\tpadding-left: 0;\n\t\tpadding-right: 0;\n\n\t\t& .ck-button__label {\n\t\t\tpadding: 0 var(--ck-spacing-medium);\n\t\t\tcolor: var(--ck-color-link-default);\n\t\t\ttext-overflow: ellipsis;\n\t\t\tcursor: pointer;\n\n\t\t\t/* Match the box model of the link editor form\'s input so the balloon\n\t\t\tdoes not change width when moving between actions and the form. */\n\t\t\tmax-width: var(--ck-input-text-width);\n\t\t\tmin-width: 3em;\n\t\t\ttext-align: center;\n\n\t\t\t&:hover {\n\t\t\t\ttext-decoration: underline;\n\t\t\t}\n\t\t}\n\n\t\t&,\n\t\t&:hover,\n\t\t&:focus,\n\t\t&:active {\n\t\t\tbackground: none;\n\t\t}\n\n\t\t&:active {\n\t\t\tbox-shadow: none;\n\t\t}\n\n\t\t&:focus {\n\t\t\t& .ck-button__label {\n\t\t\t\ttext-decoration: underline;\n\t\t\t}\n\t\t}\n\t}\n\n\t@mixin ck-dir ltr {\n\t\t& .ck-button:not(:first-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& .ck-button:not(:last-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-media-phone {\n\t\t& .ck-button.ck-link-actions__preview {\n\t\t\tmargin: var(--ck-spacing-standard) var(--ck-spacing-standard) 0;\n\n\t\t\t& .ck-button__label {\n\t\t\t\tmin-width: 0;\n\t\t\t\tmax-width: 100%;\n\t\t\t}\n\t\t}\n\n\t\t& .ck-button:not(.ck-link-actions__preview) {\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n'],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck.ck-link-image_icon{position:absolute;top:var(--ck-spacing-medium);right:var(--ck-spacing-medium);width:28px;height:28px;padding:4px;box-sizing:border-box;border-radius:var(--ck-border-radius)}.ck.ck-link-image_icon svg{fill:currentColor}.ck.ck-link-image_icon{color:#fff;background:rgba(0,0,0,.4)}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-link/theme/linkimage.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-link/linkimage.css"],
            names: [],
            mappings: "AAKA,uBACC,iBAAkB,CAClB,4BAA6B,CAC7B,8BAA+B,CAC/B,UAAW,CACX,WAAY,CACZ,WAAY,CACZ,qBAAsB,CACtB,qCAKD,CAHC,2BACC,iBACD,CCZD,uBACC,UAAuB,CACvB,yBACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-link-image_icon {\n\tposition: absolute;\n\ttop: var(--ck-spacing-medium);\n\tright: var(--ck-spacing-medium);\n\twidth: 28px;\n\theight: 28px;\n\tpadding: 4px;\n\tbox-sizing: border-box;\n\tborder-radius: var(--ck-border-radius);\n\n\t& svg {\n\t\tfill: currentColor;\n\t}\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-link-image_icon {\n\tcolor: hsl(0, 0%, 100%);\n\tbackground: hsla(0, 0%, 0%, .4);\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck.ck-list-styles-dropdown>.ck-dropdown__panel>.ck-toolbar>.ck-toolbar__items{display:grid}:root{--ck-list-style-button-size:44px}.ck.ck-list-styles-dropdown>.ck-dropdown__panel>.ck-toolbar{background:none;padding:0}.ck.ck-list-styles-dropdown>.ck-dropdown__panel>.ck-toolbar>.ck-toolbar__items{grid-template-columns:repeat(3,auto);row-gap:var(--ck-spacing-medium);column-gap:var(--ck-spacing-medium);padding:var(--ck-spacing-medium)}.ck.ck-list-styles-dropdown>.ck-dropdown__panel>.ck-toolbar>.ck-toolbar__items .ck-button{width:var(--ck-list-style-button-size);height:var(--ck-list-style-button-size);padding:0;margin:0;box-sizing:content-box}.ck.ck-list-styles-dropdown>.ck-dropdown__panel>.ck-toolbar>.ck-toolbar__items .ck-button .ck-icon{width:var(--ck-list-style-button-size);height:var(--ck-list-style-button-size)}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-list/theme/liststyles.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-list/liststyles.css"],
            names: [],
            mappings: "AAKA,+EAKC,YACD,CCNA,MACC,gCACD,CAEA,4DACC,eAAgB,CAChB,SAiCD,CA/BC,+EACC,oCAAwC,CACxC,gCAAiC,CACjC,mCAAoC,CACpC,gCA0BD,CAxBC,0FAEC,sCAAuC,CACvC,uCAAwC,CACxC,SAAU,CAMV,QAAS,CAOT,sBAMD,CAJC,mGACC,sCAAuC,CACvC,uCACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-list-styles-dropdown > .ck-dropdown__panel > .ck-toolbar > .ck-toolbar__items {\n\t/*\n\t * Use the benefits of the toolbar (e.g. out-of-the-box keyboard navigation) but make it look\n\t * like a panel with thumbnails (previews).\n\t */\n\tdisplay: grid;\n}\n", '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-list-style-button-size: 44px;\n}\n\n.ck.ck-list-styles-dropdown > .ck-dropdown__panel > .ck-toolbar {\n\tbackground: none;\n\tpadding: 0;\n\n\t& > .ck-toolbar__items {\n\t\tgrid-template-columns: repeat( 3, auto );\n\t\trow-gap: var(--ck-spacing-medium);\n\t\tcolumn-gap: var(--ck-spacing-medium);\n\t\tpadding: var(--ck-spacing-medium);\n\n\t\t& .ck-button {\n\t\t\t/* Make the button look like a thumbnail (the icon "takes it all"). */\n\t\t\twidth: var(--ck-list-style-button-size);\n\t\t\theight: var(--ck-list-style-button-size);\n\t\t\tpadding: 0;\n\n\t\t\t/*\n\t\t\t * Buttons are aligned by the grid so disable default button margins to not collide with the\n\t\t\t * gaps in the grid.\n\t\t\t */\n\t\t\tmargin: 0;\n\n\t\t\t/*\n\t\t\t * Make sure the button border (which is displayed on focus, BTW) does not steal pixels\n\t\t\t * from the button dimensions and, as a result, decrease the size of the icon\n\t\t\t * (which becomes blurry as it scales down).\n\t\t\t */\n\t\t\tbox-sizing: content-box;\n\n\t\t\t& .ck-icon {\n\t\t\t\twidth: var(--ck-list-style-button-size);\n\t\t\t\theight: var(--ck-list-style-button-size);\n\t\t\t}\n\t\t}\n\t}\n}\n'],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".wrs_modal_overlay{position:fixed;font-family:arial,sans-serif;top:0;right:0;left:0;bottom:0;background:rgba(0,0,0,.8);z-index:999998;opacity:.65;pointer-events:auto}.wrs_modal_overlay.wrs_modal_android,.wrs_modal_overlay.wrs_modal_ios{visibility:hidden;display:none}.wrs_modal_overlay.wrs_modal_ios.moodle{position:fixed}.wrs_modal_overlay.wrs_modal_desktop.wrs_stack{background:transparent;display:none}.wrs_modal_overlay.wrs_modal_desktop.wrs_maximized{background:rgba(0,0,0,.8)}.wrs_modal_overlay.wrs_modal_desktop.wrs_closed,.wrs_modal_overlay.wrs_modal_desktop.wrs_minimized{background:transparent;display:none}.wrs_modal_title{color:#fff;padding:5px 0 5px 10px;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none;text-align:left}.wrs_modal_close_button{background-repeat:no-repeat}.wrs_modal_close_button,.wrs_modal_minimize_button{float:right;cursor:pointer;color:#fff;padding:5px 10px 5px 0;margin:10px 7px 0 0}.wrs_modal_minimize_button{top:inherit}.wrs_modal_stack_button{float:right;cursor:pointer;color:#fff;margin:10px 7px 0 0;padding:5px 10px 5px 0;top:inherit}.wrs_modal_stack_button.wrs_minimized,.wrs_modal_stack_button.wrs_stack{visibility:hidden;margin:0;padding:0}.wrs_modal_maximize_button{float:right;cursor:pointer;color:#fff;margin:10px 7px 0 0;padding:5px 10px 5px 0;top:inherit}.wrs_modal_maximize_button.wrs_maximized{visibility:hidden;margin:0;padding:0}.wrs_modal_wrapper{display:block}.wrs_modal_title_bar{display:block;background-color:#778e9a}.wrs_modal_dialogContainer{border:none;background:#fafafa;z-index:999999}.wrs_modal_dialogContainer.wrs_modal_desktop{font-size:14px}.wrs_modal_dialogContainer.wrs_modal_desktop.wrs_maximized{position:fixed}.wrs_modal_dialogContainer.wrs_modal_desktop.wrs_minimized{position:fixed;top:inherit;margin:0 10px 0 0}.wrs_modal_dialogContainer.wrs_closed{visibility:hidden;display:none;opacity:0}.wrs_modal_dialogContainer.wrs_modal_desktop.wrs_stack{position:fixed;bottom:0;right:0;box-shadow:0 2px 8px rgba(0,0,0,.5)}.wrs_modal_dialogContainer.wrs_drag,.wrs_modal_dialogContainer.wrs_modal_desktop.wrs_drag{box-shadow:0 2px 8px rgba(0,0,0,.5)}.wrs_modal_dialogContainer.wrs_modal_android{width:99%;height:99%}.wrs_modal_dialogContainer.wrs_modal_android,.wrs_modal_dialogContainer.wrs_modal_ios{margin:auto;overflow:hidden;transform:translate(50%,-50%);top:50%;right:50%!important;position:fixed}.wrs_modal_dialogContainer.wrs_modal_ios{width:100%;height:100%}.wrs_content_container.wrs_minimized{display:none}.wrs_content_container.wrs_modal_android{width:100%;flex-grow:1;display:flex;flex-direction:column}.wrs_content_container.wrs_modal_android>div:first-child,.wrs_content_container.wrs_modal_desktop>div:first-child,.wrs_content_container.wrs_modal_ios>div:first-child{flex-grow:1}.wrs_modal_wrapper.wrs_modal_android{margin:auto;display:flex;flex-direction:column;height:100%;width:100%}.wrs_content_container.wrs_modal_desktop,.wrs_content_container.wrs_modal_ios{width:100%;flex-grow:1;display:flex;flex-direction:column}.wrs_modal_wrapper.wrs_modal_ios{margin:auto;display:flex;flex-direction:column;height:100%;width:100%}.wrs_virtual_keyboard{height:100%;width:100%;top:0;left:50%;transform:translate(-50%)}@media (orientation:portrait){.wrs_modal_dialogContainer.wrs_modal_mobile{width:100vmin;height:100vmin;margin:auto;border-width:0}.wrs_modal_wrapper.wrs_modal_mobile{width:100vmin;height:100vmin;margin:auto}}@media (orientation:landscape){.wrs_modal_dialogContainer.wrs_modal_mobile{width:100vmin;height:100vmin;margin:auto;border-width:0}.wrs_modal_wrapper.wrs_modal_mobile{width:100vmin;height:100vmin;margin:auto}}.wrs_modal_dialogContainer.wrs_modal_badStock,.wrs_modal_wrapper.wrs_modal_badStock{width:100%;height:280px;margin:0 auto;border-width:0}.wrs_noselect{-khtml-user-select:none}.wrs_bottom_right_resizer,.wrs_noselect{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.wrs_bottom_right_resizer{width:10px;height:10px;color:#778e9a;position:absolute;right:4px;bottom:8px;cursor:se-resize}.wrs_bottom_left_resizer{width:15px;height:15px;color:#778e9a;position:absolute;left:0;top:0;cursor:se-resize}.wrs_modal_controls{height:42px;margin:3px 0;overflow:hidden;line-height:normal}.wrs_modal_links{margin:10px auto 0;font-family:arial,sans-serif;padding:6px;display:inline;float:right;text-align:right}.wrs_modal_links>a{text-decoration:none;color:#778e9a;font-size:16px}.wrs_modal_button_cancel,.wrs_modal_button_cancel:active,.wrs_modal_button_cancel:focus,.wrs_modal_button_cancel:hover,.wrs_modal_button_cancel:visited{min-width:80px;font-size:14px;border-radius:3px;border:1px solid #778e9a;padding:6px 8px;margin:10px auto 0 5px;cursor:pointer;font-family:arial,sans-serif;background-color:#ddd;height:32px}.wrs_modal_button_accept,.wrs_modal_button_accept:active,.wrs_modal_button_accept:focus,.wrs_modal_button_accept:hover,.wrs_modal_button_accept:visited{min-width:80px;font-size:14px;border-radius:3px;border:1px solid #778e9a;padding:6px 8px;margin:10px 5px 0 auto;color:#fff;background:#778e9a;cursor:pointer;font-family:arial,sans-serif;height:32px}.wrs_editor_vertical_bar{height:20px;float:right;background:none;width:20px;cursor:pointer}.wrs_modal_buttons_container{display:inline;float:left}.wrs_modal_buttons_container.wrs_modalAndroid{padding-left:6px}.wrs_modal_buttons_container.wrs_modalDesktop{padding-left:0}.wrs_modal_buttons_container>button{line-height:normal;background-image:none}.wrs_modal_wrapper{margin:6px;display:flex;flex-direction:column}.wrs_modal_wrapper.wrs_modal_desktop.wrs_minimized{display:none}@media only screen and (max-device-width:480px) and (orientation:portrait){#wrs_modal_wrapper{width:140%}}.wrs_popupmessage_overlay_envolture{display:none;width:100%}.wrs_popupmessage_overlay{position:absolute;width:100%;height:100%;top:0;left:0;right:0;bottom:0;background-color:rgba(0,0,0,.5);z-index:4;cursor:pointer}.wrs_popupmessage_panel{top:50%;left:50%;transform:translate(-50%,-50%);position:absolute;background:#fff;max-width:500px;width:75%;border-radius:2px;padding:20px;font-family:sans-serif;font-size:15px;text-align:left;color:#2e2e2e;z-index:5;max-height:75%;overflow:auto}.wrs_popupmessage_button_area{margin:10px 0 0}.wrs_panelContainer *{border:0}.wrs_button_cancel,.wrs_button_cancel:active,.wrs_button_cancel:focus,.wrs_button_cancel:hover,.wrs_button_cancel:visited{min-width:80px;font-size:14px;border-radius:3px;border:1px solid #778e9a;padding:6px 8px;margin:10px auto 0 5px;cursor:pointer;font-family:arial,sans-serif;background-color:#ddd;background-image:none;height:32px}.wrs_button_accept,.wrs_button_accept:active,.wrs_button_accept:focus,.wrs_button_accept:hover,.wrs_button_accept:visited{min-width:80px;font-size:14px;border-radius:3px;border:1px solid #778e9a;padding:6px 8px;margin:10px 5px 0 auto;color:#fff;background:#778e9a;cursor:pointer;font-family:arial,sans-serif;height:32px}.wrs_editor button{box-shadow:none}.wrs_editor .wrs_header button{border-bottom:none;border-bottom-left-radius:0;border-bottom-right-radius:0}.wrs_modal_overlay.wrs_modal_desktop.wrs_stack.wrs_overlay_active{display:block}.wrs_toolbar tr:focus,.wrs_toolbar tr:hover{background:none}.wrs_modal_rtl .wrs_modal_button_cancel{margin-right:5px;margin-left:0}.wrs_modal_rtl .wrs_modal_button_accept{margin-right:0;margin-left:5px}.wrs_modal_rtl .wrs_button_cancel{margin-right:5px;margin-left:0}.wrs_modal_rtl .wrs_button_accept{margin-right:0;margin-left:5px}", "", {
            version: 3,
            sources: ["webpack://node_modules/@wiris/mathtype-html-integration-devkit/styles/styles.css"],
            names: [],
            mappings: "AAAA,mBACI,cAAe,CACf,4BAA8B,CAC9B,KAAM,CACN,OAAQ,CACR,MAAO,CACP,QAAS,CACT,yBAA8B,CAC9B,cAAe,CACf,WAAa,CACb,mBACJ,CAOA,sEACI,iBAAkB,CAClB,YACJ,CAEA,wCACI,cACJ,CAEA,+CACI,sBAA4B,CAC5B,YACJ,CAEA,mDACI,yBACJ,CAOA,mGACI,sBAA4B,CAC5B,YACJ,CAEA,iBACI,UAAW,CACX,sBAAuB,CACvB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBAAiB,CACjB,eACJ,CAEA,wBAMI,2BACJ,CAEA,mDARI,WAAY,CACZ,cAAe,CACf,UAAW,CACX,sBAAuB,CACvB,mBAWJ,CAPA,2BAKI,WAEJ,CAEA,wBACI,WAAY,CACZ,cAAe,CACf,UAAW,CACX,mBAAoB,CACpB,sBAAuB,CACvB,WACJ,CAQA,wEACI,iBAAkB,CAClB,QAAS,CACT,SACJ,CAEA,2BACI,WAAY,CACZ,cAAe,CACf,UAAW,CACX,mBAAoB,CACpB,sBAAuB,CACvB,WACJ,CAEA,yCACI,iBAAkB,CAClB,QAAS,CACT,SACJ,CAEA,mBACI,aAEJ,CAEA,qBACI,aAAc,CACd,wBACJ,CAEA,2BACI,WAAY,CACZ,kBAAmB,CACnB,cACJ,CAEA,6CACI,cACJ,CAEA,2DACI,cACJ,CAEA,2DACI,cAAe,CACf,WAAY,CAEZ,iBACJ,CAEA,sCACI,iBAAkB,CAClB,YAAa,CACb,SACJ,CAMA,uDACI,cAAe,CACf,QAAS,CACT,OAAQ,CACR,mCACJ,CAMA,0FACI,mCACJ,CAEA,6CAGI,SAAU,CACV,UAMJ,CAEA,sFAXI,WAAY,CAIZ,eAAgB,CAChB,6BAA+B,CAC/B,OAAQ,CACR,mBAAqB,CACrB,cAaJ,CAVA,yCAGI,UAAW,CACX,WAMJ,CAMA,qCACI,YACJ,CAMA,yCACI,UAAW,CACX,WAAY,CACZ,YAAa,CACb,qBACJ,CAUA,uKACI,WACJ,CAEA,qCACI,WAAY,CACZ,YAAa,CACb,qBAAsB,CACtB,WAAY,CACZ,UACJ,CASA,8EANI,UAAW,CACX,WAAY,CACZ,YAAa,CACb,qBAQJ,CAEA,iCACI,WAAY,CACZ,YAAa,CACb,qBAAsB,CACtB,WAAY,CACZ,UACJ,CAEA,sBACI,WAAY,CACZ,UAAW,CACX,KAAM,CACN,QAAS,CACT,yBACJ,CAEA,8BACI,4CACI,aAAc,CACd,cAAe,CACf,WAAY,CACZ,cACJ,CACA,oCACI,aAAc,CACd,cAAe,CACf,WACJ,CACJ,CAEA,+BACI,4CACI,aAAc,CACd,cAAe,CACf,WAAY,CACZ,cACJ,CACA,oCACI,aAAc,CACd,cAAe,CACf,WACJ,CACJ,CASA,oFACI,UAAW,CACX,YAAa,CACb,aAAc,CACd,cACJ,CACA,cAEI,uBAIJ,CACA,wCANI,qBAAsB,CAEtB,wBAAyB,CACzB,oBAAqB,CACrB,gBAcJ,CAZA,0BACI,UAAW,CACX,WAAY,CACZ,aAAc,CACd,iBAAkB,CAClB,SAAU,CACV,UAAW,CACX,gBAKJ,CACA,yBACI,UAAW,CACX,WAAY,CACZ,aAAc,CACd,iBAAkB,CAClB,MAAO,CACP,KAAM,CACN,gBACJ,CAEA,oBACI,WAAY,CACZ,YAAa,CACb,eAAgB,CAChB,kBACJ,CAEA,iBAEI,kBAAgB,CAChB,4BAA8B,CAC9B,WAAY,CACZ,cAAe,CACf,WAAY,CACZ,gBACJ,CAEA,mBACI,oBAAqB,CACrB,aAAc,CACd,cACJ,CAEA,wJAKI,cAAe,CACf,cAAe,CACf,iBAAkB,CAClB,wBAAyB,CACzB,eAAgB,CAGhB,sBAAgB,CAChB,cAAe,CACf,4BAA8B,CAC9B,qBAAyB,CACzB,WACJ,CAEA,wJAKI,cAAe,CACf,cAAe,CACf,iBAAkB,CAClB,wBAAyB,CACzB,eAAgB,CAGhB,sBAAgB,CAChB,UAAW,CACX,kBAAmB,CACnB,cAAe,CACf,4BAA8B,CAC9B,WACJ,CAEA,yBACI,WAAY,CACZ,WAAY,CACZ,eAAgB,CAChB,UAAW,CACX,cACJ,CAEA,6BACI,cAAe,CACf,UACJ,CAEA,8CACI,gBACJ,CAEA,8CACI,cACJ,CAEA,oCACI,kBAAmB,CACnB,qBACJ,CAEA,mBACI,UAAW,CACX,YAAa,CACb,qBACJ,CAEA,mDACI,YACJ,CAEA,2EACI,mBACI,UACJ,CACJ,CAEA,oCACI,YAAa,CACb,UACJ,CACA,0BACI,iBAAkB,CAClB,UAAW,CACX,WAAY,CACZ,KAAM,CACN,MAAO,CACP,OAAQ,CACR,QAAS,CACT,+BAAoC,CACpC,SAAU,CACV,cACJ,CACA,wBACI,OAAQ,CACR,QAAS,CACT,8BAAgC,CAChC,iBAAkB,CAClB,eAAiB,CACjB,eAAgB,CAChB,SAAU,CACV,iBAAkB,CAClB,YAAa,CACb,sBAAuB,CACvB,cAAe,CACf,eAAgB,CAChB,aAAc,CACd,SAAU,CACV,cAAe,CACf,aACJ,CAEA,8BACI,eACJ,CAEA,sBACI,QACJ,CAEA,0HAKI,cAAe,CACf,cAAe,CACf,iBAAkB,CAClB,wBAAyB,CACzB,eAAgB,CAGhB,sBAAgB,CAChB,cAAe,CACf,4BAA8B,CAC9B,qBAAyB,CACzB,qBAAsB,CACtB,WACJ,CAEA,0HAKI,cAAe,CACf,cAAe,CACf,iBAAkB,CAClB,wBAAyB,CACzB,eAAgB,CAGhB,sBAAgB,CAChB,UAAW,CACX,kBAAmB,CACnB,cAAe,CACf,4BAA8B,CAC9B,WACJ,CAEA,mBACI,eACJ,CAEA,+BACI,kBAAmB,CACnB,2BAA4B,CAC5B,4BACJ,CAEA,kEACI,aACJ,CAKA,4CACI,eACJ,CAEA,wCACI,gBAAiB,CACjB,aACJ,CACA,wCACI,cAAe,CACf,eACJ,CACA,kCACI,gBAAiB,CACjB,aACJ,CACA,kCACI,cAAe,CACf,eACJ",
            sourcesContent: [".wrs_modal_overlay {\n    position: fixed;\n    font-family: arial, sans-serif;\n    top: 0;\n    right: 0;\n    left: 0;\n    bottom: 0;\n    background: rgba(0, 0, 0, 0.8);\n    z-index: 999998;\n    opacity: 0.65;\n    pointer-events: auto;\n}\n\n.wrs_modal_overlay.wrs_modal_ios {\n    visibility: hidden;\n    display: none;\n}\n\n.wrs_modal_overlay.wrs_modal_android {\n    visibility: hidden;\n    display: none;\n}\n\n.wrs_modal_overlay.wrs_modal_ios.moodle {\n    position: fixed;\n}\n\n.wrs_modal_overlay.wrs_modal_desktop.wrs_stack {\n    background: rgba(0, 0, 0, 0);\n    display: none;\n}\n\n.wrs_modal_overlay.wrs_modal_desktop.wrs_maximized {\n    background: rgba(0, 0, 0, 0.8);\n}\n\n.wrs_modal_overlay.wrs_modal_desktop.wrs_minimized {\n    background: rgba(0, 0, 0, 0);\n    display: none;\n}\n\n.wrs_modal_overlay.wrs_modal_desktop.wrs_closed {\n    background: rgba(0, 0, 0, 0);\n    display: none;\n}\n\n.wrs_modal_title {\n    color: #fff;\n    padding: 5px 0 5px 10px;\n    -moz-user-select: none;\n    -webkit-user-select: none;\n    -ms-user-select: none;\n    user-select: none;\n    text-align: left;\n}\n\n.wrs_modal_close_button {\n    float: right;\n    cursor: pointer;\n    color: #fff;\n    padding: 5px 10px 5px 0;\n    margin: 10px 7px 0 0;\n    background-repeat: no-repeat;\n}\n\n.wrs_modal_minimize_button {\n    float: right;\n    cursor: pointer;\n    color: #fff;\n    padding: 5px 10px 5px 0;\n    top: inherit;\n    margin: 10px 7px 0 0;\n}\n\n.wrs_modal_stack_button {\n    float: right;\n    cursor: pointer;\n    color: #fff;\n    margin: 10px 7px 0 0;\n    padding: 5px 10px 5px 0;\n    top: inherit;\n}\n\n.wrs_modal_stack_button.wrs_stack {\n    visibility: hidden;\n    margin: 0;\n    padding: 0;\n}\n\n.wrs_modal_stack_button.wrs_minimized {\n    visibility: hidden;\n    margin: 0;\n    padding: 0;\n}\n\n.wrs_modal_maximize_button {\n    float: right;\n    cursor: pointer;\n    color: #fff;\n    margin: 10px 7px 0 0;\n    padding: 5px 10px 5px 0;\n    top: inherit;\n}\n\n.wrs_modal_maximize_button.wrs_maximized {\n    visibility: hidden;\n    margin: 0;\n    padding: 0;\n}\n\n.wrs_modal_wrapper {\n    display: block;\n    margin: 6px;\n}\n\n.wrs_modal_title_bar {\n    display: block;\n    background-color: #778e9a;\n}\n\n.wrs_modal_dialogContainer {\n    border: none;\n    background: #fafafa;\n    z-index: 999999;\n}\n\n.wrs_modal_dialogContainer.wrs_modal_desktop {\n    font-size: 14px;\n}\n\n.wrs_modal_dialogContainer.wrs_modal_desktop.wrs_maximized {\n    position: fixed;\n}\n\n.wrs_modal_dialogContainer.wrs_modal_desktop.wrs_minimized {\n    position: fixed;\n    top: inherit;\n    margin: 0;\n    margin-right: 10px;\n}\n\n.wrs_modal_dialogContainer.wrs_closed {\n    visibility: hidden;\n    display: none;\n    opacity: 0;\n}\n\n\n/* Class that exists but hasn't got css properties defined\n.wrs_modal_dialogContainer.wrs_modal_desktop.wrs_minimized.wrs_drag {} */\n\n.wrs_modal_dialogContainer.wrs_modal_desktop.wrs_stack {\n    position: fixed;\n    bottom: 0;\n    right: 0;\n    box-shadow: rgba(0, 0, 0, 0.5) 0 2px 8px;\n}\n\n.wrs_modal_dialogContainer.wrs_drag {\n    box-shadow: rgba(0, 0, 0, 0.5) 0 2px 8px;\n}\n\n.wrs_modal_dialogContainer.wrs_modal_desktop.wrs_drag {\n    box-shadow: rgba(0, 0, 0, 0.5) 0 2px 8px;\n}\n\n.wrs_modal_dialogContainer.wrs_modal_android {\n    margin: auto;\n    position: fixed;\n    width: 99%;\n    height: 99%;\n    overflow: hidden;\n    transform: translate(50%, -50%);\n    top: 50%;\n    right: 50% !important;\n    position: fixed;\n}\n\n.wrs_modal_dialogContainer.wrs_modal_ios {\n    margin: auto;\n    position: fixed;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n    transform: translate(50%, -50%);\n    top: 50%;\n    right: 50% !important;\n    position: fixed;\n}\n\n\n/* Class that exists but hasn't got css properties defined\n.wrs_content_container.wrs_maximized {} */\n\n.wrs_content_container.wrs_minimized {\n    display: none;\n}\n\n/* .wrs_editor {\n    flex-grow: 1;\n} */\n\n.wrs_content_container.wrs_modal_android {\n    width: 100%;\n    flex-grow: 1;\n    display: flex;\n    flex-direction: column;\n}\n\n.wrs_content_container.wrs_modal_android > div:first-child {\n    flex-grow: 1;\n}\n\n.wrs_content_container.wrs_modal_ios > div:first-child {\n    flex-grow: 1;\n}\n\n.wrs_content_container.wrs_modal_desktop > div:first-child {\n    flex-grow: 1;\n}\n\n.wrs_modal_wrapper.wrs_modal_android {\n    margin: auto;\n    display: flex;\n    flex-direction: column;\n    height: 100%;\n    width: 100%;\n}\n\n.wrs_content_container.wrs_modal_desktop {\n    width: 100%;\n    flex-grow: 1;\n    display: flex;\n    flex-direction: column;\n}\n\n.wrs_content_container.wrs_modal_ios {\n    width: 100%;\n    flex-grow: 1;\n    display: flex;\n    flex-direction: column;\n}\n\n.wrs_modal_wrapper.wrs_modal_ios {\n    margin: auto;\n    display: flex;\n    flex-direction: column;\n    height: 100%;\n    width: 100%;\n}\n\n.wrs_virtual_keyboard {\n    height: 100%;\n    width: 100%;\n    top: 0;\n    left: 50%;\n    transform: translate(-50%, 0%);\n}\n\n@media all and (orientation: portrait) {\n    .wrs_modal_dialogContainer.wrs_modal_mobile {\n        width: 100vmin;\n        height: 100vmin;\n        margin: auto;\n        border-width: 0;\n    }\n    .wrs_modal_wrapper.wrs_modal_mobile {\n        width: 100vmin;\n        height: 100vmin;\n        margin: auto;\n    }\n}\n\n@media all and (orientation: landscape) {\n    .wrs_modal_dialogContainer.wrs_modal_mobile {\n        width: 100vmin;\n        height: 100vmin;\n        margin: auto;\n        border-width: 0;\n    }\n    .wrs_modal_wrapper.wrs_modal_mobile {\n        width: 100vmin;\n        height: 100vmin;\n        margin: auto;\n    }\n}\n\n.wrs_modal_dialogContainer.wrs_modal_badStock {\n    width: 100%;\n    height: 280px;\n    margin: 0 auto;\n    border-width: 0;\n}\n\n.wrs_modal_wrapper.wrs_modal_badStock {\n    width: 100%;\n    height: 280px;\n    margin: 0 auto;\n    border-width: 0;\n}\n.wrs_noselect {\n    -moz-user-select: none;\n    -khtml-user-select: none;\n    -webkit-user-select: none;\n    -ms-user-select: none;\n    user-select: none;\n}\n.wrs_bottom_right_resizer {\n    width: 10px;\n    height: 10px;\n    color: #778e9a;\n    position: absolute;\n    right: 4px;\n    bottom: 8px;\n    cursor: se-resize;\n    -moz-user-select: none;\n    -webkit-user-select: none;\n    -ms-user-select: none;\n    user-select: none;\n}\n.wrs_bottom_left_resizer {\n    width: 15px;\n    height: 15px;\n    color: #778e9a;\n    position: absolute;\n    left: 0;\n    top: 0;\n    cursor: se-resize;\n}\n\n.wrs_modal_controls {\n    height: 42px;\n    margin: 3px 0;\n    overflow: hidden;\n    line-height: normal;\n}\n\n.wrs_modal_links {\n    margin: 10px auto;\n    margin-bottom: 0;\n    font-family: arial, sans-serif;\n    padding: 6px;\n    display: inline;\n    float: right;\n    text-align: right;\n}\n\n.wrs_modal_links > a {\n    text-decoration: none;\n    color: #778e9a;\n    font-size: 16px;\n}\n\n.wrs_modal_button_cancel,\n.wrs_modal_button_cancel:hover,\n.wrs_modal_button_cancel:visited,\n.wrs_modal_button_cancel:active,\n.wrs_modal_button_cancel:focus {\n    min-width: 80px;\n    font-size: 14px;\n    border-radius: 3px;\n    border: 1px solid #778e9a;\n    padding: 6px 8px;\n    margin: 10px auto;\n    margin-left: 5px;\n    margin-bottom: 0;\n    cursor: pointer;\n    font-family: arial, sans-serif;\n    background-color: #DDDDDD;\n    height: 32px;\n}\n\n.wrs_modal_button_accept,\n.wrs_modal_button_accept:hover,\n.wrs_modal_button_accept:visited,\n.wrs_modal_button_accept:active,\n.wrs_modal_button_accept:focus {\n    min-width: 80px;\n    font-size: 14px;\n    border-radius: 3px;\n    border: 1px solid #778e9a;\n    padding: 6px 8px;\n    margin: 10px auto;\n    margin-right: 5px;\n    margin-bottom: 0;\n    color: #fff;\n    background: #778e9a;\n    cursor: pointer;\n    font-family: arial, sans-serif;\n    height: 32px;\n}\n\n.wrs_editor_vertical_bar {\n    height: 20px;\n    float: right;\n    background: none;\n    width: 20px;\n    cursor: pointer;\n}\n\n.wrs_modal_buttons_container {\n    display: inline;\n    float: left;\n}\n\n.wrs_modal_buttons_container.wrs_modalAndroid {\n    padding-left: 6px;\n}\n\n.wrs_modal_buttons_container.wrs_modalDesktop {\n    padding-left: 0;\n}\n\n.wrs_modal_buttons_container > button {\n    line-height: normal;\n    background-image: none;\n}\n\n.wrs_modal_wrapper {\n    margin: 6px;\n    display: flex;\n    flex-direction: column;\n}\n\n.wrs_modal_wrapper.wrs_modal_desktop.wrs_minimized {\n    display: none;\n}\n\n@media only screen and (max-device-width: 480px) and (orientation: portrait) {\n    #wrs_modal_wrapper {\n        width: 140%;\n    }\n}\n\n.wrs_popupmessage_overlay_envolture {\n    display: none;\n    width: 100%;\n}\n.wrs_popupmessage_overlay {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    background-color: rgba(0, 0, 0, 0.5);\n    z-index: 4;\n    cursor: pointer;\n}\n.wrs_popupmessage_panel {\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    position: absolute;\n    background: white;\n    max-width: 500px;\n    width: 75%;\n    border-radius: 2px;\n    padding: 20px;\n    font-family: sans-serif;\n    font-size: 15px;\n    text-align: left;\n    color: #2e2e2e;\n    z-index: 5;\n    max-height: 75%;\n    overflow: auto;\n}\n\n.wrs_popupmessage_button_area {\n    margin: 10px 0 0 0;\n}\n\n.wrs_panelContainer * {\n    border: 0;\n}\n\n.wrs_button_cancel,\n.wrs_button_cancel:hover,\n.wrs_button_cancel:visited,\n.wrs_button_cancel:active,\n.wrs_button_cancel:focus {\n    min-width: 80px;\n    font-size: 14px;\n    border-radius: 3px;\n    border: 1px solid #778e9a;\n    padding: 6px 8px;\n    margin: 10px auto;\n    margin-left: 5px;\n    margin-bottom: 0;\n    cursor: pointer;\n    font-family: arial, sans-serif;\n    background-color: #DDDDDD;\n    background-image: none;\n    height: 32px;\n}\n\n.wrs_button_accept,\n.wrs_button_accept:hover,\n.wrs_button_accept:visited,\n.wrs_button_accept:active,\n.wrs_button_accept:focus {\n    min-width: 80px;\n    font-size: 14px;\n    border-radius: 3px;\n    border: 1px solid #778e9a;\n    padding: 6px 8px;\n    margin: 10px auto;\n    margin-right: 5px;\n    margin-bottom: 0;\n    color: #fff;\n    background: #778e9a;\n    cursor: pointer;\n    font-family: arial, sans-serif;\n    height: 32px;\n}\n\n.wrs_editor button{\n    box-shadow: none;\n}\n\n.wrs_editor .wrs_header button{\n    border-bottom: none;\n    border-bottom-left-radius: 0;\n    border-bottom-right-radius: 0;\n}\n\n.wrs_modal_overlay.wrs_modal_desktop.wrs_stack.wrs_overlay_active {\n    display: block;\n}\n/* Fix selection in drupal style */\n.wrs_toolbar tr:focus{\n    background: none;\n}\n.wrs_toolbar tr:hover{\n    background: none;\n}\n/* End of fix drupal */\n.wrs_modal_rtl .wrs_modal_button_cancel {\n    margin-right: 5px;\n    margin-left: 0;\n}\n.wrs_modal_rtl .wrs_modal_button_accept {\n    margin-right: 0;\n    margin-left: 5px;\n}\n.wrs_modal_rtl .wrs_button_cancel {\n    margin-right: 5px;\n    margin-left: 0;\n}\n.wrs_modal_rtl .wrs_button_accept {\n    margin-right: 0;\n    margin-left: 5px;\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, '.ck-media__wrapper .ck-media__placeholder{display:flex;flex-direction:column;align-items:center}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url .ck-tooltip{display:block}@media (hover:none){.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url .ck-tooltip{display:none}}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url{max-width:100%;position:relative}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url:hover .ck-tooltip{visibility:visible;opacity:1}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url .ck-media__placeholder__url__text{overflow:hidden;display:block}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck-media__placeholder__icon *{display:none}.ck-editor__editable:not(.ck-read-only) .ck-media__wrapper>:not(.ck-media__placeholder),.ck-editor__editable:not(.ck-read-only) .ck-widget:not(.ck-widget_selected) .ck-media__placeholder{pointer-events:none}:root{--ck-media-embed-placeholder-icon-size:3em;--ck-color-media-embed-placeholder-url-text:#757575;--ck-color-media-embed-placeholder-url-text-hover:var(--ck-color-base-text)}.ck-media__wrapper{margin:0 auto}.ck-media__wrapper .ck-media__placeholder{padding:calc(var(--ck-spacing-standard)*3);background:var(--ck-color-base-foreground)}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__icon{min-width:var(--ck-media-embed-placeholder-icon-size);height:var(--ck-media-embed-placeholder-icon-size);margin-bottom:var(--ck-spacing-large);background-position:50%;background-size:cover}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__icon .ck-icon{width:100%;height:100%}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url__text{color:var(--ck-color-media-embed-placeholder-url-text);white-space:nowrap;text-align:center;font-style:italic;text-overflow:ellipsis}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:var(--ck-color-media-embed-placeholder-url-text-hover);cursor:pointer;text-decoration:underline}.ck-media__wrapper[data-oembed-url*="open.spotify.com"]{max-width:300px;max-height:380px}.ck-media__wrapper[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNTAuMzc4IiBoZWlnaHQ9IjI1NC4xNjciIHZpZXdCb3g9IjAgMCA2Ni4yNDYgNjcuMjQ4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTcyLjUzMSAtMjE4LjQ1NSkgc2NhbGUoLjk4MDEyKSI+PHJlY3Qgcnk9IjUuMjM4IiByeD0iNS4yMzgiIHk9IjIzMS4zOTkiIHg9IjE3Ni4wMzEiIGhlaWdodD0iNjAuMDk5IiB3aWR0aD0iNjAuMDk5IiBmaWxsPSIjMzRhNjY4IiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxwYXRoIGQ9Ik0yMDYuNDc3IDI2MC45bC0yOC45ODcgMjguOTg3YTUuMjE4IDUuMjE4IDAgMDAzLjc4IDEuNjFoNDkuNjIxYzEuNjk0IDAgMy4xOS0uNzk4IDQuMTQ2LTIuMDM3eiIgZmlsbD0iIzVjODhjNSIvPjxwYXRoIGQ9Ik0yMjYuNzQyIDIyMi45ODhjLTkuMjY2IDAtMTYuNzc3IDcuMTctMTYuNzc3IDE2LjAxNC4wMDcgMi43NjIuNjYzIDUuNDc0IDIuMDkzIDcuODc1LjQzLjcwMy44MyAxLjQwOCAxLjE5IDIuMTA3LjMzMy41MDIuNjUgMS4wMDUuOTUgMS41MDguMzQzLjQ3Ny42NzMuOTU3Ljk4OCAxLjQ0IDEuMzEgMS43NjkgMi41IDMuNTAyIDMuNjM3IDUuMTY4Ljc5MyAxLjI3NSAxLjY4MyAyLjY0IDIuNDY2IDMuOTkgMi4zNjMgNC4wOTQgNC4wMDcgOC4wOTIgNC42IDEzLjkxNHYuMDEyYy4xODIuNDEyLjUxNi42NjYuODc5LjY2Ny40MDMtLjAwMS43NjgtLjMxNC45My0uNzk5LjYwMy01Ljc1NiAyLjIzOC05LjcyOSA0LjU4NS0xMy43OTQuNzgyLTEuMzUgMS42NzMtMi43MTUgMi40NjUtMy45OSAxLjEzNy0xLjY2NiAyLjMyOC0zLjQgMy42MzgtNS4xNjkuMzE1LS40ODIuNjQ1LS45NjIuOTg4LTEuNDM5LjMtLjUwMy42MTctMS4wMDYuOTUtMS41MDguMzU5LS43Ljc2LTEuNDA0IDEuMTktMi4xMDcgMS40MjYtMi40MDIgMi01LjExNCAyLjAwNC03Ljg3NSAwLTguODQ0LTcuNTExLTE2LjAxNC0xNi43NzYtMTYuMDE0eiIgZmlsbD0iI2RkNGIzZSIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48ZWxsaXBzZSByeT0iNS41NjQiIHJ4PSI1LjgyOCIgY3k9IjIzOS4wMDIiIGN4PSIyMjYuNzQyIiBmaWxsPSIjODAyZDI3IiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxwYXRoIGQ9Ik0xOTAuMzAxIDIzNy4yODNjLTQuNjcgMC04LjQ1NyAzLjg1My04LjQ1NyA4LjYwNnMzLjc4NiA4LjYwNyA4LjQ1NyA4LjYwN2MzLjA0MyAwIDQuODA2LS45NTggNi4zMzctMi41MTYgMS41My0xLjU1NyAyLjA4Ny0zLjkxMyAyLjA4Ny02LjI5IDAtLjM2Mi0uMDIzLS43MjItLjA2NC0xLjA3OWgtOC4yNTd2My4wNDNoNC44NWMtLjE5Ny43NTktLjUzMSAxLjQ1LTEuMDU4IDEuOTg2LS45NDIuOTU4LTIuMDI4IDEuNTQ4LTMuOTAxIDEuNTQ4LTIuODc2IDAtNS4yMDgtMi4zNzItNS4yMDgtNS4yOTkgMC0yLjkyNiAyLjMzMi01LjI5OSA1LjIwOC01LjI5OSAxLjM5OSAwIDIuNjE4LjQwNyAzLjU4NCAxLjI5M2wyLjM4MS0yLjM4YzAtLjAwMi0uMDAzLS4wMDQtLjAwNC0uMDA1LTEuNTg4LTEuNTI0LTMuNjItMi4yMTUtNS45NTUtMi4yMTV6bTQuNDMgNS42NmwuMDAzLjAwNnYtLjAwM3oiIGZpbGw9IiNmZmYiIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PHBhdGggZD0iTTIxNS4xODQgMjUxLjkyOWwtNy45OCA3Ljk3OSAyOC40NzcgMjguNDc1YTUuMjMzIDUuMjMzIDAgMDAuNDQ5LTIuMTIzdi0zMS4xNjVjLS40NjkuNjc1LS45MzQgMS4zNDktMS4zODIgMi4wMDUtLjc5MiAxLjI3NS0xLjY4MiAyLjY0LTIuNDY1IDMuOTktMi4zNDcgNC4wNjUtMy45ODIgOC4wMzgtNC41ODUgMTMuNzk0LS4xNjIuNDg1LS41MjcuNzk4LS45My43OTktLjM2My0uMDAxLS42OTctLjI1NS0uODc5LS42Njd2LS4wMTJjLS41OTMtNS44MjItMi4yMzctOS44Mi00LjYtMTMuOTE0LS43ODMtMS4zNS0xLjY3My0yLjcxNS0yLjQ2Ni0zLjk5LTEuMTM3LTEuNjY2LTIuMzI3LTMuNC0zLjYzNy01LjE2OWwtLjAwMi0uMDAzeiIgZmlsbD0iI2MzYzNjMyIvPjxwYXRoIGQ9Ik0yMTIuOTgzIDI0OC40OTVsLTM2Ljk1MiAzNi45NTN2LjgxMmE1LjIyNyA1LjIyNyAwIDAwNS4yMzggNS4yMzhoMS4wMTVsMzUuNjY2LTM1LjY2NmExMzYuMjc1IDEzNi4yNzUgMCAwMC0yLjc2NC0zLjkgMzcuNTc1IDM3LjU3NSAwIDAwLS45ODktMS40NCAzNS4xMjcgMzUuMTI3IDAgMDAtLjk1LTEuNTA4Yy0uMDgzLS4xNjItLjE3Ni0uMzI2LS4yNjQtLjQ4OXoiIGZpbGw9IiNmZGRjNGYiIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PHBhdGggZD0iTTIxMS45OTggMjYxLjA4M2wtNi4xNTIgNi4xNTEgMjQuMjY0IDI0LjI2NGguNzgxYTUuMjI3IDUuMjI3IDAgMDA1LjIzOS01LjIzOHYtMS4wNDV6IiBmaWxsPSIjZmZmIiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjwvZz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder{background:#4268b3}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAyNCIgaGVpZ2h0PSIxMDI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGQ9Ik05NjcuNDg0IDBINTYuNTE3QzI1LjMwNCAwIDAgMjUuMzA0IDAgNTYuNTE3djkxMC45NjZDMCA5OTguNjk0IDI1LjI5NyAxMDI0IDU2LjUyMiAxMDI0SDU0N1Y2MjhINDE0VjQ3M2gxMzNWMzU5LjAyOWMwLTEzMi4yNjIgODAuNzczLTIwNC4yODIgMTk4Ljc1Ni0yMDQuMjgyIDU2LjUxMyAwIDEwNS4wODYgNC4yMDggMTE5LjI0NCA2LjA4OVYyOTlsLTgxLjYxNi4wMzdjLTYzLjk5MyAwLTc2LjM4NCAzMC40OTItNzYuMzg0IDc1LjIzNlY0NzNoMTUzLjQ4N2wtMTkuOTg2IDE1NUg3MDd2Mzk2aDI2MC40ODRjMzEuMjEzIDAgNTYuNTE2LTI1LjMwMyA1Ni41MTYtNTYuNTE2VjU2LjUxNUMxMDI0IDI1LjMwMyA5OTguNjk3IDAgOTY3LjQ4NCAwIiBmaWxsPSIjRkZGRkZFIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__url__text{color:#cdf}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder{background:linear-gradient(-135deg,#1400c7,#b800b1,#f50000)}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTA0IiBoZWlnaHQ9IjUwNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PGRlZnM+PHBhdGggaWQ9ImEiIGQ9Ik0wIC4xNTloNTAzLjg0MVY1MDMuOTRIMHoiLz48L2RlZnM+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj48bWFzayBpZD0iYiIgZmlsbD0iI2ZmZiI+PHVzZSB4bGluazpocmVmPSIjYSIvPjwvbWFzaz48cGF0aCBkPSJNMjUxLjkyMS4xNTljLTY4LjQxOCAwLTc2Ljk5Ny4yOS0xMDMuODY3IDEuNTE2LTI2LjgxNCAxLjIyMy00NS4xMjcgNS40ODItNjEuMTUxIDExLjcxLTE2LjU2NiA2LjQzNy0zMC42MTUgMTUuMDUxLTQ0LjYyMSAyOS4wNTYtMTQuMDA1IDE0LjAwNi0yMi42MTkgMjguMDU1LTI5LjA1NiA0NC42MjEtNi4yMjggMTYuMDI0LTEwLjQ4NyAzNC4zMzctMTEuNzEgNjEuMTUxQy4yOSAxNzUuMDgzIDAgMTgzLjY2MiAwIDI1Mi4wOGMwIDY4LjQxNy4yOSA3Ni45OTYgMS41MTYgMTAzLjg2NiAxLjIyMyAyNi44MTQgNS40ODIgNDUuMTI3IDExLjcxIDYxLjE1MSA2LjQzNyAxNi41NjYgMTUuMDUxIDMwLjYxNSAyOS4wNTYgNDQuNjIxIDE0LjAwNiAxNC4wMDUgMjguMDU1IDIyLjYxOSA0NC42MjEgMjkuMDU3IDE2LjAyNCA2LjIyNyAzNC4zMzcgMTAuNDg2IDYxLjE1MSAxMS43MDkgMjYuODcgMS4yMjYgMzUuNDQ5IDEuNTE2IDEwMy44NjcgMS41MTYgNjguNDE3IDAgNzYuOTk2LS4yOSAxMDMuODY2LTEuNTE2IDI2LjgxNC0xLjIyMyA0NS4xMjctNS40ODIgNjEuMTUxLTExLjcwOSAxNi41NjYtNi40MzggMzAuNjE1LTE1LjA1MiA0NC42MjEtMjkuMDU3IDE0LjAwNS0xNC4wMDYgMjIuNjE5LTI4LjA1NSAyOS4wNTctNDQuNjIxIDYuMjI3LTE2LjAyNCAxMC40ODYtMzQuMzM3IDExLjcwOS02MS4xNTEgMS4yMjYtMjYuODcgMS41MTYtMzUuNDQ5IDEuNTE2LTEwMy44NjYgMC02OC40MTgtLjI5LTc2Ljk5Ny0xLjUxNi0xMDMuODY3LTEuMjIzLTI2LjgxNC01LjQ4Mi00NS4xMjctMTEuNzA5LTYxLjE1MS02LjQzOC0xNi41NjYtMTUuMDUyLTMwLjYxNS0yOS4wNTctNDQuNjIxLTE0LjAwNi0xNC4wMDUtMjguMDU1LTIyLjYxOS00NC42MjEtMjkuMDU2LTE2LjAyNC02LjIyOC0zNC4zMzctMTAuNDg3LTYxLjE1MS0xMS43MUMzMjguOTE3LjQ0OSAzMjAuMzM4LjE1OSAyNTEuOTIxLjE1OXptMCA0NS4zOTFjNjcuMjY1IDAgNzUuMjMzLjI1NyAxMDEuNzk3IDEuNDY5IDI0LjU2MiAxLjEyIDM3LjkwMSA1LjIyNCA0Ni43NzggOC42NzQgMTEuNzU5IDQuNTcgMjAuMTUxIDEwLjAyOSAyOC45NjYgMTguODQ1IDguODE2IDguODE1IDE0LjI3NSAxNy4yMDcgMTguODQ1IDI4Ljk2NiAzLjQ1IDguODc3IDcuNTU0IDIyLjIxNiA4LjY3NCA0Ni43NzggMS4yMTIgMjYuNTY0IDEuNDY5IDM0LjUzMiAxLjQ2OSAxMDEuNzk4IDAgNjcuMjY1LS4yNTcgNzUuMjMzLTEuNDY5IDEwMS43OTctMS4xMiAyNC41NjItNS4yMjQgMzcuOTAxLTguNjc0IDQ2Ljc3OC00LjU3IDExLjc1OS0xMC4wMjkgMjAuMTUxLTE4Ljg0NSAyOC45NjYtOC44MTUgOC44MTYtMTcuMjA3IDE0LjI3NS0yOC45NjYgMTguODQ1LTguODc3IDMuNDUtMjIuMjE2IDcuNTU0LTQ2Ljc3OCA4LjY3NC0yNi41NiAxLjIxMi0zNC41MjcgMS40NjktMTAxLjc5NyAxLjQ2OS02Ny4yNzEgMC03NS4yMzctLjI1Ny0xMDEuNzk4LTEuNDY5LTI0LjU2Mi0xLjEyLTM3LjkwMS01LjIyNC00Ni43NzgtOC42NzQtMTEuNzU5LTQuNTctMjAuMTUxLTEwLjAyOS0yOC45NjYtMTguODQ1LTguODE1LTguODE1LTE0LjI3NS0xNy4yMDctMTguODQ1LTI4Ljk2Ni0zLjQ1LTguODc3LTcuNTU0LTIyLjIxNi04LjY3NC00Ni43NzgtMS4yMTItMjYuNTY0LTEuNDY5LTM0LjUzMi0xLjQ2OS0xMDEuNzk3IDAtNjcuMjY2LjI1Ny03NS4yMzQgMS40NjktMTAxLjc5OCAxLjEyLTI0LjU2MiA1LjIyNC0zNy45MDEgOC42NzQtNDYuNzc4IDQuNTctMTEuNzU5IDEwLjAyOS0yMC4xNTEgMTguODQ1LTI4Ljk2NiA4LjgxNS04LjgxNiAxNy4yMDctMTQuMjc1IDI4Ljk2Ni0xOC44NDUgOC44NzctMy40NSAyMi4yMTYtNy41NTQgNDYuNzc4LTguNjc0IDI2LjU2NC0xLjIxMiAzNC41MzItMS40NjkgMTAxLjc5OC0xLjQ2OXoiIGZpbGw9IiNGRkYiIG1hc2s9InVybCgjYikiLz48cGF0aCBkPSJNMjUxLjkyMSAzMzYuMDUzYy00Ni4zNzggMC04My45NzQtMzcuNTk2LTgzLjk3NC04My45NzMgMC00Ni4zNzggMzcuNTk2LTgzLjk3NCA4My45NzQtODMuOTc0IDQ2LjM3NyAwIDgzLjk3MyAzNy41OTYgODMuOTczIDgzLjk3NCAwIDQ2LjM3Ny0zNy41OTYgODMuOTczLTgzLjk3MyA4My45NzN6bTAtMjEzLjMzOGMtNzEuNDQ3IDAtMTI5LjM2NSA1Ny45MTgtMTI5LjM2NSAxMjkuMzY1IDAgNzEuNDQ2IDU3LjkxOCAxMjkuMzY0IDEyOS4zNjUgMTI5LjM2NCA3MS40NDYgMCAxMjkuMzY0LTU3LjkxOCAxMjkuMzY0LTEyOS4zNjQgMC03MS40NDctNTcuOTE4LTEyOS4zNjUtMTI5LjM2NC0xMjkuMzY1ek00MTYuNjI3IDExNy42MDRjMCAxNi42OTYtMTMuNTM1IDMwLjIzLTMwLjIzMSAzMC4yMy0xNi42OTUgMC0zMC4yMy0xMy41MzQtMzAuMjMtMzAuMjMgMC0xNi42OTYgMTMuNTM1LTMwLjIzMSAzMC4yMy0zMC4yMzEgMTYuNjk2IDAgMzAuMjMxIDEzLjUzNSAzMC4yMzEgMzAuMjMxIiBmaWxsPSIjRkZGIi8+PC9nPjwvc3ZnPg==)}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__url__text{color:#ffe0fe}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder{background:linear-gradient(90deg,#71c6f4,#0d70a5)}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA0MDAgNDAwIj48cGF0aCBkPSJNNDAwIDIwMGMwIDExMC41LTg5LjUgMjAwLTIwMCAyMDBTMCAzMTAuNSAwIDIwMCA4OS41IDAgMjAwIDBzMjAwIDg5LjUgMjAwIDIwMHpNMTYzLjQgMzA1LjVjODguNyAwIDEzNy4yLTczLjUgMTM3LjItMTM3LjIgMC0yLjEgMC00LjItLjEtNi4yIDkuNC02LjggMTcuNi0xNS4zIDI0LjEtMjUtOC42IDMuOC0xNy45IDYuNC0yNy43IDcuNiAxMC02IDE3LjYtMTUuNCAyMS4yLTI2LjctOS4zIDUuNS0xOS42IDkuNS0zMC42IDExLjctOC44LTkuNC0yMS4zLTE1LjItMzUuMi0xNS4yLTI2LjYgMC00OC4yIDIxLjYtNDguMiA0OC4yIDAgMy44LjQgNy41IDEuMyAxMS00MC4xLTItNzUuNi0yMS4yLTk5LjQtNTAuNC00LjEgNy4xLTYuNSAxNS40LTYuNSAyNC4yIDAgMTYuNyA4LjUgMzEuNSAyMS41IDQwLjEtNy45LS4yLTE1LjMtMi40LTIxLjgtNnYuNmMwIDIzLjQgMTYuNiA0Mi44IDM4LjcgNDcuMy00IDEuMS04LjMgMS43LTEyLjcgMS43LTMuMSAwLTYuMS0uMy05LjEtLjkgNi4xIDE5LjIgMjMuOSAzMy4xIDQ1IDMzLjUtMTYuNSAxMi45LTM3LjMgMjAuNi01OS45IDIwLjYtMy45IDAtNy43LS4yLTExLjUtLjcgMjEuMSAxMy44IDQ2LjUgMjEuOCA3My43IDIxLjgiIGZpbGw9IiNmZmYiLz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__url__text{color:#b8e6ff}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}', "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-media-embed/theme/mediaembedediting.css", "webpack://node_modules/@ckeditor/ckeditor5-ui/theme/components/tooltip/mixins/_tooltip.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-media-embed/mediaembedediting.css"],
            names: [],
            mappings: "AAQC,0CACC,YAAa,CACb,qBAAsB,CACtB,kBAmBD,CCpBA,kFACC,aAqBD,CAHC,oBAnBD,kFAoBE,YAEF,CADC,CDlBA,sEAIC,cAAe,CAEf,iBAUD,CCoBD,wFACC,kBAAmB,CACnB,SACD,CD3BE,wGACC,eAAgB,CAChB,aACD,CAQD,+UACC,YACD,CAYF,2LACC,mBACD,CE/CA,MACC,0CAA2C,CAE3C,mDAA4D,CAC5D,2EACD,CAEA,mBACC,aA4FD,CA1FC,0CACC,0CAA+C,CAC/C,0CA4BD,CA1BC,uEACC,qDAAsD,CACtD,kDAAmD,CACnD,qCAAsC,CACtC,uBAA2B,CAC3B,qBAMD,CAJC,gFACC,UAAW,CACX,WACD,CAGD,4EACC,sDAAuD,CACvD,kBAAmB,CACnB,iBAAkB,CAClB,iBAAkB,CAClB,sBAOD,CALC,kFACC,4DAA6D,CAC7D,cAAe,CACf,yBACD,CAIF,wDACC,eAAgB,CAChB,gBACD,CAEA,oFACC,gvGACD,CAEA,2EACC,kBAaD,CAXC,wGACC,orBACD,CAEA,6GACC,UAKD,CAHC,mHACC,UACD,CAIF,4EACC,2DAcD,CAZC,yGACC,4jHACD,CAGA,8GACC,aAKD,CAHC,oHACC,UACD,CAIF,6EAEC,iDAaD,CAXC,0GACC,48BACD,CAEA,+GACC,aAKD,CAHC,qHACC,UACD",
            sourcesContent: ['/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/components/tooltip/mixins/_tooltip.css";\n\n.ck-media__wrapper {\n\t& .ck-media__placeholder {\n\t\tdisplay: flex;\n\t\tflex-direction: column;\n\t\talign-items: center;\n\n\t\t& .ck-media__placeholder__url {\n\t\t\t@mixin ck-tooltip_enabled;\n\n\t\t\t/* Otherwise the URL will overflow when the content is very narrow. */\n\t\t\tmax-width: 100%;\n\n\t\t\tposition: relative;\n\n\t\t\t&:hover {\n\t\t\t\t@mixin ck-tooltip_visible;\n\t\t\t}\n\n\t\t\t& .ck-media__placeholder__url__text {\n\t\t\t\toverflow: hidden;\n\t\t\t\tdisplay: block;\n\t\t\t}\n\t\t}\n\t}\n\n\t&[data-oembed-url*="twitter.com"],\n\t&[data-oembed-url*="google.com/maps"],\n\t&[data-oembed-url*="facebook.com"],\n\t&[data-oembed-url*="instagram.com"] {\n\t\t& .ck-media__placeholder__icon * {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n\n/* Disable all mouse interaction as long as the editor is not read–only.\n   https://github.com/ckeditor/ckeditor5-media-embed/issues/58 */\n.ck-editor__editable:not(.ck-read-only) .ck-media__wrapper > *:not(.ck-media__placeholder) {\n\tpointer-events: none;\n}\n\n/* Disable all mouse interaction when the widget is not selected (e.g. to avoid opening links by accident).\n   https://github.com/ckeditor/ckeditor5-media-embed/issues/18 */\n.ck-editor__editable:not(.ck-read-only) .ck-widget:not(.ck-widget_selected) .ck-media__placeholder {\n\tpointer-events: none;\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Enables the tooltip, which is the tooltip is in DOM but\n * not yet displayed.\n */\n@define-mixin ck-tooltip_enabled {\n\t& .ck-tooltip {\n\t\tdisplay: block;\n\n\t\t/*\n\t\t * Don't display tooltips in devices which don't support :hover.\n\t\t * In fact, it's all about iOS, which forces user to click UI elements twice to execute\n\t\t * the primary action, when tooltips are enabled.\n\t\t *\n\t\t * Q: OK, but why not the following query?\n\t\t *\n\t\t *   @media (hover) {\n\t\t *       display: block;\n\t\t *   }\n\t\t *\n\t\t * A: Because FF does not support it and it would completely disable tooltips\n\t\t * in that browser.\n\t\t *\n\t\t * More in https://github.com/ckeditor/ckeditor5/issues/920.\n\t\t */\n\t\t@media (hover:none) {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n\n/**\n * Disables the tooltip making it disappear from DOM.\n */\n@define-mixin ck-tooltip_disabled {\n\t& .ck-tooltip {\n\t\tdisplay: none;\n\t}\n}\n\n/**\n * Shows the tooltip, which is already in DOM.\n * Requires `ck-tooltip_enabled` first.\n */\n@define-mixin ck-tooltip_visible {\n\t& .ck-tooltip {\n\t\tvisibility: visible;\n\t\topacity: 1;\n\t}\n}\n", '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-media-embed-placeholder-icon-size: 3em;\n\n\t--ck-color-media-embed-placeholder-url-text: hsl(0, 0%, 46%);\n\t--ck-color-media-embed-placeholder-url-text-hover: var(--ck-color-base-text);\n}\n\n.ck-media__wrapper {\n\tmargin: 0 auto;\n\n\t& .ck-media__placeholder {\n\t\tpadding: calc( 3 * var(--ck-spacing-standard) );\n\t\tbackground: var(--ck-color-base-foreground);\n\n\t\t& .ck-media__placeholder__icon {\n\t\t\tmin-width: var(--ck-media-embed-placeholder-icon-size);\n\t\t\theight: var(--ck-media-embed-placeholder-icon-size);\n\t\t\tmargin-bottom: var(--ck-spacing-large);\n\t\t\tbackground-position: center;\n\t\t\tbackground-size: cover;\n\n\t\t\t& .ck-icon {\n\t\t\t\twidth: 100%;\n\t\t\t\theight: 100%;\n\t\t\t}\n\t\t}\n\n\t\t& .ck-media__placeholder__url__text {\n\t\t\tcolor: var(--ck-color-media-embed-placeholder-url-text);\n\t\t\twhite-space: nowrap;\n\t\t\ttext-align: center;\n\t\t\tfont-style: italic;\n\t\t\ttext-overflow: ellipsis;\n\n\t\t\t&:hover {\n\t\t\t\tcolor: var(--ck-color-media-embed-placeholder-url-text-hover);\n\t\t\t\tcursor: pointer;\n\t\t\t\ttext-decoration: underline;\n\t\t\t}\n\t\t}\n\t}\n\n\t&[data-oembed-url*="open.spotify.com"] {\n\t\tmax-width: 300px;\n\t\tmax-height: 380px;\n\t}\n\n\t&[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon {\n\t\tbackground-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNTAuMzc4IiBoZWlnaHQ9IjI1NC4xNjciIHZpZXdCb3g9IjAgMCA2Ni4yNDYgNjcuMjQ4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTcyLjUzMSAtMjE4LjQ1NSkgc2NhbGUoLjk4MDEyKSI+PHJlY3Qgcnk9IjUuMjM4IiByeD0iNS4yMzgiIHk9IjIzMS4zOTkiIHg9IjE3Ni4wMzEiIGhlaWdodD0iNjAuMDk5IiB3aWR0aD0iNjAuMDk5IiBmaWxsPSIjMzRhNjY4IiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxwYXRoIGQ9Ik0yMDYuNDc3IDI2MC45bC0yOC45ODcgMjguOTg3YTUuMjE4IDUuMjE4IDAgMCAwIDMuNzggMS42MWg0OS42MjFjMS42OTQgMCAzLjE5LS43OTggNC4xNDYtMi4wMzd6IiBmaWxsPSIjNWM4OGM1Ii8+PHBhdGggZD0iTTIyNi43NDIgMjIyLjk4OGMtOS4yNjYgMC0xNi43NzcgNy4xNy0xNi43NzcgMTYuMDE0LjAwNyAyLjc2Mi42NjMgNS40NzQgMi4wOTMgNy44NzUuNDMuNzAzLjgzIDEuNDA4IDEuMTkgMi4xMDcuMzMzLjUwMi42NSAxLjAwNS45NSAxLjUwOC4zNDMuNDc3LjY3My45NTcuOTg4IDEuNDQgMS4zMSAxLjc2OSAyLjUgMy41MDIgMy42MzcgNS4xNjguNzkzIDEuMjc1IDEuNjgzIDIuNjQgMi40NjYgMy45OSAyLjM2MyA0LjA5NCA0LjAwNyA4LjA5MiA0LjYgMTMuOTE0di4wMTJjLjE4Mi40MTIuNTE2LjY2Ni44NzkuNjY3LjQwMy0uMDAxLjc2OC0uMzE0LjkzLS43OTkuNjAzLTUuNzU2IDIuMjM4LTkuNzI5IDQuNTg1LTEzLjc5NC43ODItMS4zNSAxLjY3My0yLjcxNSAyLjQ2NS0zLjk5IDEuMTM3LTEuNjY2IDIuMzI4LTMuNCAzLjYzOC01LjE2OS4zMTUtLjQ4Mi42NDUtLjk2Mi45ODgtMS40MzkuMy0uNTAzLjYxNy0xLjAwNi45NS0xLjUwOC4zNTktLjcuNzYtMS40MDQgMS4xOS0yLjEwNyAxLjQyNi0yLjQwMiAyLTUuMTE0IDIuMDA0LTcuODc1IDAtOC44NDQtNy41MTEtMTYuMDE0LTE2Ljc3Ni0xNi4wMTR6IiBmaWxsPSIjZGQ0YjNlIiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxlbGxpcHNlIHJ5PSI1LjU2NCIgcng9IjUuODI4IiBjeT0iMjM5LjAwMiIgY3g9IjIyNi43NDIiIGZpbGw9IiM4MDJkMjciIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PHBhdGggZD0iTTE5MC4zMDEgMjM3LjI4M2MtNC42NyAwLTguNDU3IDMuODUzLTguNDU3IDguNjA2czMuNzg2IDguNjA3IDguNDU3IDguNjA3YzMuMDQzIDAgNC44MDYtLjk1OCA2LjMzNy0yLjUxNiAxLjUzLTEuNTU3IDIuMDg3LTMuOTEzIDIuMDg3LTYuMjkgMC0uMzYyLS4wMjMtLjcyMi0uMDY0LTEuMDc5aC04LjI1N3YzLjA0M2g0Ljg1Yy0uMTk3Ljc1OS0uNTMxIDEuNDUtMS4wNTggMS45ODYtLjk0Mi45NTgtMi4wMjggMS41NDgtMy45MDEgMS41NDgtMi44NzYgMC01LjIwOC0yLjM3Mi01LjIwOC01LjI5OSAwLTIuOTI2IDIuMzMyLTUuMjk5IDUuMjA4LTUuMjk5IDEuMzk5IDAgMi42MTguNDA3IDMuNTg0IDEuMjkzbDIuMzgxLTIuMzhjMC0uMDAyLS4wMDMtLjAwNC0uMDA0LS4wMDUtMS41ODgtMS41MjQtMy42Mi0yLjIxNS01Ljk1NS0yLjIxNXptNC40MyA1LjY2bC4wMDMuMDA2di0uMDAzeiIgZmlsbD0iI2ZmZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJNMjE1LjE4NCAyNTEuOTI5bC03Ljk4IDcuOTc5IDI4LjQ3NyAyOC40NzVjLjI4Ny0uNjQ5LjQ0OS0xLjM2Ni40NDktMi4xMjN2LTMxLjE2NWMtLjQ2OS42NzUtLjkzNCAxLjM0OS0xLjM4MiAyLjAwNS0uNzkyIDEuMjc1LTEuNjgyIDIuNjQtMi40NjUgMy45OS0yLjM0NyA0LjA2NS0zLjk4MiA4LjAzOC00LjU4NSAxMy43OTQtLjE2Mi40ODUtLjUyNy43OTgtLjkzLjc5OS0uMzYzLS4wMDEtLjY5Ny0uMjU1LS44NzktLjY2N3YtLjAxMmMtLjU5My01LjgyMi0yLjIzNy05LjgyLTQuNi0xMy45MTQtLjc4My0xLjM1LTEuNjczLTIuNzE1LTIuNDY2LTMuOTktMS4xMzctMS42NjYtMi4zMjctMy40LTMuNjM3LTUuMTY5bC0uMDAyLS4wMDN6IiBmaWxsPSIjYzNjM2MzIi8+PHBhdGggZD0iTTIxMi45ODMgMjQ4LjQ5NWwtMzYuOTUyIDM2Ljk1M3YuODEyYTUuMjI3IDUuMjI3IDAgMCAwIDUuMjM4IDUuMjM4aDEuMDE1bDM1LjY2Ni0zNS42NjZhMTM2LjI3NSAxMzYuMjc1IDAgMCAwLTIuNzY0LTMuOSAzNy41NzUgMzcuNTc1IDAgMCAwLS45ODktMS40NGMtLjI5OS0uNTAzLS42MTYtMS4wMDYtLjk1LTEuNTA4LS4wODMtLjE2Mi0uMTc2LS4zMjYtLjI2NC0uNDg5eiIgZmlsbD0iI2ZkZGM0ZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJNMjExLjk5OCAyNjEuMDgzbC02LjE1MiA2LjE1MSAyNC4yNjQgMjQuMjY0aC43ODFhNS4yMjcgNS4yMjcgMCAwIDAgNS4yMzktNS4yMzh2LTEuMDQ1eiIgZmlsbD0iI2ZmZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48L2c+PC9zdmc+);\n\t}\n\n\t&[data-oembed-url*="facebook.com"] .ck-media__placeholder {\n\t\tbackground: hsl(220, 46%, 48%);\n\n\t\t& .ck-media__placeholder__icon {\n\t\t\tbackground-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIHdpZHRoPSIxMDI0cHgiIGhlaWdodD0iMTAyNHB4IiB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPiAgICAgICAgPHRpdGxlPkZpbGwgMTwvdGl0bGU+ICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPiAgICA8ZGVmcz48L2RlZnM+ICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPiAgICAgICAgPGcgaWQ9ImZMb2dvX1doaXRlIiBmaWxsPSIjRkZGRkZFIj4gICAgICAgICAgICA8cGF0aCBkPSJNOTY3LjQ4NCwwIEw1Ni41MTcsMCBDMjUuMzA0LDAgMCwyNS4zMDQgMCw1Ni41MTcgTDAsOTY3LjQ4MyBDMCw5OTguNjk0IDI1LjI5NywxMDI0IDU2LjUyMiwxMDI0IEw1NDcsMTAyNCBMNTQ3LDYyOCBMNDE0LDYyOCBMNDE0LDQ3MyBMNTQ3LDQ3MyBMNTQ3LDM1OS4wMjkgQzU0NywyMjYuNzY3IDYyNy43NzMsMTU0Ljc0NyA3NDUuNzU2LDE1NC43NDcgQzgwMi4yNjksMTU0Ljc0NyA4NTAuODQyLDE1OC45NTUgODY1LDE2MC44MzYgTDg2NSwyOTkgTDc4My4zODQsMjk5LjAzNyBDNzE5LjM5MSwyOTkuMDM3IDcwNywzMjkuNTI5IDcwNywzNzQuMjczIEw3MDcsNDczIEw4NjAuNDg3LDQ3MyBMODQwLjUwMSw2MjggTDcwNyw2MjggTDcwNywxMDI0IEw5NjcuNDg0LDEwMjQgQzk5OC42OTcsMTAyNCAxMDI0LDk5OC42OTcgMTAyNCw5NjcuNDg0IEwxMDI0LDU2LjUxNSBDMTAyNCwyNS4zMDMgOTk4LjY5NywwIDk2Ny40ODQsMCIgaWQ9IkZpbGwtMSI+PC9wYXRoPiAgICAgICAgPC9nPiAgICA8L2c+PC9zdmc+);\n\t\t}\n\n\t\t& .ck-media__placeholder__url__text {\n\t\t\tcolor: hsl(220, 100%, 90%);\n\n\t\t\t&:hover {\n\t\t\t\tcolor: hsl(0, 0%, 100%);\n\t\t\t}\n\t\t}\n\t}\n\n\t&[data-oembed-url*="instagram.com"] .ck-media__placeholder {\n\t\tbackground: linear-gradient(-135deg,hsl(246, 100%, 39%),hsl(302, 100%, 36%),hsl(0, 100%, 48%));\n\n\t\t& .ck-media__placeholder__icon {\n\t\t\tbackground-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIHdpZHRoPSI1MDRweCIgaGVpZ2h0PSI1MDRweCIgdmlld0JveD0iMCAwIDUwNCA1MDQiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+ICAgICAgICA8dGl0bGU+Z2x5cGgtbG9nb19NYXkyMDE2PC90aXRsZT4gICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+ICAgIDxkZWZzPiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtMSIgcG9pbnRzPSIwIDAuMTU5IDUwMy44NDEgMC4xNTkgNTAzLjg0MSA1MDMuOTQgMCA1MDMuOTQiPjwvcG9seWdvbj4gICAgPC9kZWZzPiAgICA8ZyBpZD0iZ2x5cGgtbG9nb19NYXkyMDE2IiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4gICAgICAgIDxnIGlkPSJHcm91cC0zIj4gICAgICAgICAgICA8bWFzayBpZD0ibWFzay0yIiBmaWxsPSJ3aGl0ZSI+ICAgICAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtMSI+PC91c2U+ICAgICAgICAgICAgPC9tYXNrPiAgICAgICAgICAgIDxnIGlkPSJDbGlwLTIiPjwvZz4gICAgICAgICAgICA8cGF0aCBkPSJNMjUxLjkyMSwwLjE1OSBDMTgzLjUwMywwLjE1OSAxNzQuOTI0LDAuNDQ5IDE0OC4wNTQsMS42NzUgQzEyMS4yNCwyLjg5OCAxMDIuOTI3LDcuMTU3IDg2LjkwMywxMy4zODUgQzcwLjMzNywxOS44MjIgNTYuMjg4LDI4LjQzNiA0Mi4yODIsNDIuNDQxIEMyOC4yNzcsNTYuNDQ3IDE5LjY2Myw3MC40OTYgMTMuMjI2LDg3LjA2MiBDNi45OTgsMTAzLjA4NiAyLjczOSwxMjEuMzk5IDEuNTE2LDE0OC4yMTMgQzAuMjksMTc1LjA4MyAwLDE4My42NjIgMCwyNTIuMDggQzAsMzIwLjQ5NyAwLjI5LDMyOS4wNzYgMS41MTYsMzU1Ljk0NiBDMi43MzksMzgyLjc2IDYuOTk4LDQwMS4wNzMgMTMuMjI2LDQxNy4wOTcgQzE5LjY2Myw0MzMuNjYzIDI4LjI3Nyw0NDcuNzEyIDQyLjI4Miw0NjEuNzE4IEM1Ni4yODgsNDc1LjcyMyA3MC4zMzcsNDg0LjMzNyA4Ni45MDMsNDkwLjc3NSBDMTAyLjkyNyw0OTcuMDAyIDEyMS4yNCw1MDEuMjYxIDE0OC4wNTQsNTAyLjQ4NCBDMTc0LjkyNCw1MDMuNzEgMTgzLjUwMyw1MDQgMjUxLjkyMSw1MDQgQzMyMC4zMzgsNTA0IDMyOC45MTcsNTAzLjcxIDM1NS43ODcsNTAyLjQ4NCBDMzgyLjYwMSw1MDEuMjYxIDQwMC45MTQsNDk3LjAwMiA0MTYuOTM4LDQ5MC43NzUgQzQzMy41MDQsNDg0LjMzNyA0NDcuNTUzLDQ3NS43MjMgNDYxLjU1OSw0NjEuNzE4IEM0NzUuNTY0LDQ0Ny43MTIgNDg0LjE3OCw0MzMuNjYzIDQ5MC42MTYsNDE3LjA5NyBDNDk2Ljg0Myw0MDEuMDczIDUwMS4xMDIsMzgyLjc2IDUwMi4zMjUsMzU1Ljk0NiBDNTAzLjU1MSwzMjkuMDc2IDUwMy44NDEsMzIwLjQ5NyA1MDMuODQxLDI1Mi4wOCBDNTAzLjg0MSwxODMuNjYyIDUwMy41NTEsMTc1LjA4MyA1MDIuMzI1LDE0OC4yMTMgQzUwMS4xMDIsMTIxLjM5OSA0OTYuODQzLDEwMy4wODYgNDkwLjYxNiw4Ny4wNjIgQzQ4NC4xNzgsNzAuNDk2IDQ3NS41NjQsNTYuNDQ3IDQ2MS41NTksNDIuNDQxIEM0NDcuNTUzLDI4LjQzNiA0MzMuNTA0LDE5LjgyMiA0MTYuOTM4LDEzLjM4NSBDNDAwLjkxNCw3LjE1NyAzODIuNjAxLDIuODk4IDM1NS43ODcsMS42NzUgQzMyOC45MTcsMC40NDkgMzIwLjMzOCwwLjE1OSAyNTEuOTIxLDAuMTU5IFogTTI1MS45MjEsNDUuNTUgQzMxOS4xODYsNDUuNTUgMzI3LjE1NCw0NS44MDcgMzUzLjcxOCw0Ny4wMTkgQzM3OC4yOCw0OC4xMzkgMzkxLjYxOSw1Mi4yNDMgNDAwLjQ5Niw1NS42OTMgQzQxMi4yNTUsNjAuMjYzIDQyMC42NDcsNjUuNzIyIDQyOS40NjIsNzQuNTM4IEM0MzguMjc4LDgzLjM1MyA0NDMuNzM3LDkxLjc0NSA0NDguMzA3LDEwMy41MDQgQzQ1MS43NTcsMTEyLjM4MSA0NTUuODYxLDEyNS43MiA0NTYuOTgxLDE1MC4yODIgQzQ1OC4xOTMsMTc2Ljg0NiA0NTguNDUsMTg0LjgxNCA0NTguNDUsMjUyLjA4IEM0NTguNDUsMzE5LjM0NSA0NTguMTkzLDMyNy4zMTMgNDU2Ljk4MSwzNTMuODc3IEM0NTUuODYxLDM3OC40MzkgNDUxLjc1NywzOTEuNzc4IDQ0OC4zMDcsNDAwLjY1NSBDNDQzLjczNyw0MTIuNDE0IDQzOC4yNzgsNDIwLjgwNiA0MjkuNDYyLDQyOS42MjEgQzQyMC42NDcsNDM4LjQzNyA0MTIuMjU1LDQ0My44OTYgNDAwLjQ5Niw0NDguNDY2IEMzOTEuNjE5LDQ1MS45MTYgMzc4LjI4LDQ1Ni4wMiAzNTMuNzE4LDQ1Ny4xNCBDMzI3LjE1OCw0NTguMzUyIDMxOS4xOTEsNDU4LjYwOSAyNTEuOTIxLDQ1OC42MDkgQzE4NC42NSw0NTguNjA5IDE3Ni42ODQsNDU4LjM1MiAxNTAuMTIzLDQ1Ny4xNCBDMTI1LjU2MSw0NTYuMDIgMTEyLjIyMiw0NTEuOTE2IDEwMy4zNDUsNDQ4LjQ2NiBDOTEuNTg2LDQ0My44OTYgODMuMTk0LDQzOC40MzcgNzQuMzc5LDQyOS42MjEgQzY1LjU2NCw0MjAuODA2IDYwLjEwNCw0MTIuNDE0IDU1LjUzNCw0MDAuNjU1IEM1Mi4wODQsMzkxLjc3OCA0Ny45OCwzNzguNDM5IDQ2Ljg2LDM1My44NzcgQzQ1LjY0OCwzMjcuMzEzIDQ1LjM5MSwzMTkuMzQ1IDQ1LjM5MSwyNTIuMDggQzQ1LjM5MSwxODQuODE0IDQ1LjY0OCwxNzYuODQ2IDQ2Ljg2LDE1MC4yODIgQzQ3Ljk4LDEyNS43MiA1Mi4wODQsMTEyLjM4MSA1NS41MzQsMTAzLjUwNCBDNjAuMTA0LDkxLjc0NSA2NS41NjMsODMuMzUzIDc0LjM3OSw3NC41MzggQzgzLjE5NCw2NS43MjIgOTEuNTg2LDYwLjI2MyAxMDMuMzQ1LDU1LjY5MyBDMTEyLjIyMiw1Mi4yNDMgMTI1LjU2MSw0OC4xMzkgMTUwLjEyMyw0Ny4wMTkgQzE3Ni42ODcsNDUuODA3IDE4NC42NTUsNDUuNTUgMjUxLjkyMSw0NS41NSBaIiBpZD0iRmlsbC0xIiBmaWxsPSIjRkZGRkZGIiBtYXNrPSJ1cmwoI21hc2stMikiPjwvcGF0aD4gICAgICAgIDwvZz4gICAgICAgIDxwYXRoIGQ9Ik0yNTEuOTIxLDMzNi4wNTMgQzIwNS41NDMsMzM2LjA1MyAxNjcuOTQ3LDI5OC40NTcgMTY3Ljk0NywyNTIuMDggQzE2Ny45NDcsMjA1LjcwMiAyMDUuNTQzLDE2OC4xMDYgMjUxLjkyMSwxNjguMTA2IEMyOTguMjk4LDE2OC4xMDYgMzM1Ljg5NCwyMDUuNzAyIDMzNS44OTQsMjUyLjA4IEMzMzUuODk0LDI5OC40NTcgMjk4LjI5OCwzMzYuMDUzIDI1MS45MjEsMzM2LjA1MyBaIE0yNTEuOTIxLDEyMi43MTUgQzE4MC40NzQsMTIyLjcxNSAxMjIuNTU2LDE4MC42MzMgMTIyLjU1NiwyNTIuMDggQzEyMi41NTYsMzIzLjUyNiAxODAuNDc0LDM4MS40NDQgMjUxLjkyMSwzODEuNDQ0IEMzMjMuMzY3LDM4MS40NDQgMzgxLjI4NSwzMjMuNTI2IDM4MS4yODUsMjUyLjA4IEMzODEuMjg1LDE4MC42MzMgMzIzLjM2NywxMjIuNzE1IDI1MS45MjEsMTIyLjcxNSBaIiBpZD0iRmlsbC00IiBmaWxsPSIjRkZGRkZGIj48L3BhdGg+ICAgICAgICA8cGF0aCBkPSJNNDE2LjYyNywxMTcuNjA0IEM0MTYuNjI3LDEzNC4zIDQwMy4wOTIsMTQ3LjgzNCAzODYuMzk2LDE0Ny44MzQgQzM2OS43MDEsMTQ3LjgzNCAzNTYuMTY2LDEzNC4zIDM1Ni4xNjYsMTE3LjYwNCBDMzU2LjE2NiwxMDAuOTA4IDM2OS43MDEsODcuMzczIDM4Ni4zOTYsODcuMzczIEM0MDMuMDkyLDg3LjM3MyA0MTYuNjI3LDEwMC45MDggNDE2LjYyNywxMTcuNjA0IiBpZD0iRmlsbC01IiBmaWxsPSIjRkZGRkZGIj48L3BhdGg+ICAgIDwvZz48L3N2Zz4=);\n\t\t}\n\n\t\t/* stylelint-disable-next-line no-descending-specificity */\n\t\t& .ck-media__placeholder__url__text {\n\t\t\tcolor: hsl(302, 100%, 94%);\n\n\t\t\t&:hover {\n\t\t\t\tcolor: hsl(0, 0%, 100%);\n\t\t\t}\n\t\t}\n\t}\n\n\t&[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder {\n\t\t/* Use gradient to contrast with focused widget (ckeditor/ckeditor5-media-embed#22). */\n\t\tbackground: linear-gradient( to right, hsl(201, 85%, 70%), hsl(201, 85%, 35%) );\n\n\t\t& .ck-media__placeholder__icon {\n\t\t\tbackground-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48c3ZnIHZlcnNpb249IjEuMSIgaWQ9IldoaXRlIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIgdmlld0JveD0iMCAwIDQwMCA0MDAiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDQwMCA0MDA7IiB4bWw6c3BhY2U9InByZXNlcnZlIj48c3R5bGUgdHlwZT0idGV4dC9jc3MiPi5zdDB7ZmlsbDojRkZGRkZGO308L3N0eWxlPjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik00MDAsMjAwYzAsMTEwLjUtODkuNSwyMDAtMjAwLDIwMFMwLDMxMC41LDAsMjAwUzg5LjUsMCwyMDAsMFM0MDAsODkuNSw0MDAsMjAweiBNMTYzLjQsMzA1LjVjODguNywwLDEzNy4yLTczLjUsMTM3LjItMTM3LjJjMC0yLjEsMC00LjItMC4xLTYuMmM5LjQtNi44LDE3LjYtMTUuMywyNC4xLTI1Yy04LjYsMy44LTE3LjksNi40LTI3LjcsNy42YzEwLTYsMTcuNi0xNS40LDIxLjItMjYuN2MtOS4zLDUuNS0xOS42LDkuNS0zMC42LDExLjdjLTguOC05LjQtMjEuMy0xNS4yLTM1LjItMTUuMmMtMjYuNiwwLTQ4LjIsMjEuNi00OC4yLDQ4LjJjMCwzLjgsMC40LDcuNSwxLjMsMTFjLTQwLjEtMi03NS42LTIxLjItOTkuNC01MC40Yy00LjEsNy4xLTYuNSwxNS40LTYuNSwyNC4yYzAsMTYuNyw4LjUsMzEuNSwyMS41LDQwLjFjLTcuOS0wLjItMTUuMy0yLjQtMjEuOC02YzAsMC4yLDAsMC40LDAsMC42YzAsMjMuNCwxNi42LDQyLjgsMzguNyw0Ny4zYy00LDEuMS04LjMsMS43LTEyLjcsMS43Yy0zLjEsMC02LjEtMC4zLTkuMS0wLjljNi4xLDE5LjIsMjMuOSwzMy4xLDQ1LDMzLjVjLTE2LjUsMTIuOS0zNy4zLDIwLjYtNTkuOSwyMC42Yy0zLjksMC03LjctMC4yLTExLjUtMC43QzExMC44LDI5Ny41LDEzNi4yLDMwNS41LDE2My40LDMwNS41Ii8+PC9zdmc+);\n\t\t}\n\n\t\t& .ck-media__placeholder__url__text {\n\t\t\tcolor: hsl(201, 100%, 86%);\n\n\t\t\t&:hover {\n\t\t\t\tcolor: hsl(0, 0%, 100%);\n\t\t\t}\n\t\t}\n\t}\n}\n'],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck.ck-media-form{display:flex;align-items:flex-start;flex-direction:row;flex-wrap:nowrap}.ck.ck-media-form .ck-labeled-field-view{display:inline-block}.ck.ck-media-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-media-form{flex-wrap:wrap}.ck.ck-media-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-media-form .ck-button{flex-basis:50%}}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-media-embed/theme/mediaform.css", "webpack://node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css"],
            names: [],
            mappings: "AAOA,kBACC,YAAa,CACb,sBAAuB,CACvB,kBAAmB,CACnB,gBAqBD,CAnBC,yCACC,oBACD,CAEA,4BACC,YACD,CCbA,oCDCD,kBAeE,cAUF,CARE,yCACC,eACD,CAEA,6BACC,cACD,CCtBD",
            sourcesContent: ['/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-media-form {\n\tdisplay: flex;\n\talign-items: flex-start;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\n\t& .ck-labeled-field-view {\n\t\tdisplay: inline-block;\n\t}\n\n\t& .ck-label {\n\t\tdisplay: none;\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-labeled-field-view {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck-content .media{clear:both;margin:1em 0;display:block;min-width:15em}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-media-embed/theme/mediaembed.css"],
            names: [],
            mappings: "AAKA,mBAGC,UAAW,CAGX,YAAa,CAIb,aAAc,CAId,cACD",
            sourcesContent: ['/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content .media {\n\t/* Don\'t allow floated content overlap the media.\n\thttps://github.com/ckeditor/ckeditor5-media-embed/issues/53 */\n\tclear: both;\n\n\t/* Make sure there is some space between the content and the media. */\n\tmargin: 1em 0;\n\n\t/* Make sure media is not overriden with Bootstrap default `flex` value.\n\tSee: https://github.com/ckeditor/ckeditor5/issues/1373. */\n\tdisplay: block;\n\n\t/* Give the media some minimal width in the content to prevent them\n\tfrom being "squashed" in tight spaces, e.g. in table cells (#44) */\n\tmin-width: 15em;\n}\n'],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ":root{--ck-mention-list-max-height:300px}.ck.ck-mentions{max-height:var(--ck-mention-list-max-height);overflow-y:auto;overflow-x:hidden;overscroll-behavior:contain}.ck.ck-mentions>.ck-list__item{overflow:hidden;flex-shrink:0}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-mention/theme/mentionui.css"],
            names: [],
            mappings: "AAKA,MACC,kCACD,CAEA,gBACC,4CAA6C,CAE7C,eAAgB,CAIhB,iBAAkB,CAElB,2BAQD,CAJC,+BACC,eAAgB,CAChB,aACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-mention-list-max-height: 300px;\n}\n\n.ck.ck-mentions {\n\tmax-height: var(--ck-mention-list-max-height);\n\n\toverflow-y: auto;\n\n\t/* Prevent unnecessary horizontal scrollbar in Safari\n\thttps://github.com/ckeditor/ckeditor5-mention/issues/41 */\n\toverflow-x: hidden;\n\n\toverscroll-behavior: contain;\n\n\t/* Prevent unnecessary vertical scrollbar in Safari\n\thttps://github.com/ckeditor/ckeditor5-mention/issues/41 */\n\t& > .ck-list__item {\n\t\toverflow: hidden;\n\t\tflex-shrink: 0;\n\t}\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ":root{--ck-color-mention-background:rgba(153,0,48,0.1);--ck-color-mention-text:#990030}.ck-content .mention{background:var(--ck-color-mention-background);color:var(--ck-color-mention-text)}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-mention/mention.css"],
            names: [],
            mappings: "AAKA,MACC,gDAAwD,CACxD,+BACD,CAEA,qBACC,6CAA8C,CAC9C,kCACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-mention-background: hsla(341, 100%, 30%, 0.1);\n\t--ck-color-mention-text: hsl(341, 100%, 30%);\n}\n\n.ck-content .mention {\n\tbackground: var(--ck-color-mention-background);\n\tcolor: var(--ck-color-mention-text);\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck.ck-form__header{display:flex;flex-direction:row;flex-wrap:nowrap;align-items:center;justify-content:space-between}:root{--ck-form-header-height:38px}.ck.ck-form__header{padding:var(--ck-spacing-small) var(--ck-spacing-large);height:var(--ck-form-header-height);line-height:var(--ck-form-header-height);border-bottom:1px solid var(--ck-color-base-border)}.ck.ck-form__header .ck-form__header__label{font-weight:700}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-ui/theme/components/formheader/formheader.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/formheader/formheader.css"],
            names: [],
            mappings: "AAKA,oBACC,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CACjB,kBAAmB,CACnB,6BACD,CCNA,MACC,4BACD,CAEA,oBACC,uDAAwD,CACxD,mCAAoC,CACpC,wCAAyC,CACzC,mDAKD,CAHC,4CACC,eACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-form__header {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\talign-items: center;\n\tjustify-content: space-between;\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-form-header-height: 38px;\n}\n\n.ck.ck-form__header {\n\tpadding: var(--ck-spacing-small) var(--ck-spacing-large);\n\theight: var(--ck-form-header-height);\n\tline-height: var(--ck-form-header-height);\n\tborder-bottom: 1px solid var(--ck-color-base-border);\n\n\t& .ck-form__header__label {\n\t\tfont-weight: bold;\n\t}\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck.ck-character-grid .ck-character-grid__tiles{display:grid;grid-template-columns:repeat(10,1fr)}:root{--ck-character-grid-tile-size:24px}.ck.ck-character-grid{overflow-y:auto;overflow-x:hidden;width:350px;max-height:200px}.ck.ck-character-grid .ck-character-grid__tiles{margin:var(--ck-spacing-standard) var(--ck-spacing-large);grid-gap:var(--ck-spacing-standard)}.ck.ck-character-grid .ck-character-grid__tile{width:var(--ck-character-grid-tile-size);height:var(--ck-character-grid-tile-size);min-width:var(--ck-character-grid-tile-size);min-height:var(--ck-character-grid-tile-size);font-size:1.2em;padding:0;transition:box-shadow .2s ease;border:0}.ck.ck-character-grid .ck-character-grid__tile:focus:not(.ck-disabled),.ck.ck-character-grid .ck-character-grid__tile:hover:not(.ck-disabled){border:0;box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-focus-border)}.ck.ck-character-grid .ck-character-grid__tile .ck-button__label{line-height:var(--ck-character-grid-tile-size);width:100%;text-align:center}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-special-characters/theme/charactergrid.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-special-characters/charactergrid.css"],
            names: [],
            mappings: "AAMC,gDACC,YAAa,CACb,oCACD,CCFD,MACC,kCACD,CAEA,sBACC,eAAgB,CAChB,iBAAkB,CAClB,WAAY,CACZ,gBA+BD,CA7BC,gDACC,yDAA0D,CAC1D,mCACD,CAEA,+CACC,wCAAyC,CACzC,yCAA0C,CAC1C,4CAA6C,CAC7C,6CAA8C,CAC9C,eAAgB,CAChB,SAAU,CACV,8BAA+B,CAC/B,QAeD,CAbC,8IAGC,QAAS,CACT,iGACD,CAGA,iEACC,8CAA+C,CAC/C,UAAW,CACX,iBACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-character-grid {\n\t& .ck-character-grid__tiles {\n\t\tdisplay: grid;\n\t\tgrid-template-columns: repeat( 10, 1fr );\n\t}\n}\n", '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../mixins/_rounded.css";\n\n:root {\n\t--ck-character-grid-tile-size: 24px;\n}\n\n.ck.ck-character-grid {\n\toverflow-y: auto;\n\toverflow-x: hidden;\n\twidth: 350px;\n\tmax-height: 200px;\n\n\t& .ck-character-grid__tiles {\n\t\tmargin: var(--ck-spacing-standard) var(--ck-spacing-large);\n\t\tgrid-gap: var(--ck-spacing-standard);\n\t}\n\n\t& .ck-character-grid__tile {\n\t\twidth: var(--ck-character-grid-tile-size);\n\t\theight: var(--ck-character-grid-tile-size);\n\t\tmin-width: var(--ck-character-grid-tile-size);\n\t\tmin-height: var(--ck-character-grid-tile-size);\n\t\tfont-size: 1.2em;\n\t\tpadding: 0;\n\t\ttransition: .2s ease box-shadow;\n\t\tborder: 0;\n\n\t\t&:focus:not( .ck-disabled ),\n\t\t&:hover:not( .ck-disabled ) {\n\t\t\t/* Disable the default .ck-button\'s border ring. */\n\t\t\tborder: 0;\n\t\t\tbox-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-focus-border);\n\t\t}\n\n\t\t/* Make sure the glyph is rendered in the center of the button */\n\t\t& .ck-button__label {\n\t\t\tline-height: var(--ck-character-grid-tile-size);\n\t\t\twidth: 100%;\n\t\t\ttext-align: center;\n\t\t}\n\t}\n}\n'],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck.ck-character-info{display:flex;justify-content:space-between;padding:var(--ck-spacing-small) var(--ck-spacing-large);border-top:1px solid var(--ck-color-base-border)}.ck.ck-character-info>*{text-transform:uppercase;font-size:var(--ck-font-size-small)}.ck.ck-character-info .ck-character-info__name{max-width:280px;text-overflow:ellipsis;overflow:hidden}.ck.ck-character-info .ck-character-info__code{opacity:.6}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-special-characters/theme/characterinfo.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-special-characters/characterinfo.css"],
            names: [],
            mappings: "AAKA,sBACC,YAAa,CACb,6BAA8B,CCD9B,uDAAwD,CACxD,gDDCD,CCCC,wBACC,wBAAyB,CACzB,mCACD,CAEA,+CACC,eAAgB,CAChB,sBAAuB,CACvB,eACD,CAEA,+CACC,UACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-character-info {\n\tdisplay: flex;\n\tjustify-content: space-between;\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-character-info {\n\tpadding: var(--ck-spacing-small) var(--ck-spacing-large);\n\tborder-top: 1px solid var(--ck-color-base-border);\n\n\t& > * {\n\t\ttext-transform: uppercase;\n\t\tfont-size: var(--ck-font-size-small);\n\t}\n\n\t& .ck-character-info__name {\n\t\tmax-width: 280px;\n\t\ttext-overflow: ellipsis;\n\t\toverflow: hidden;\n\t}\n\n\t& .ck-character-info__code {\n\t\topacity: .6;\n\t}\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck.ck-special-characters-navigation>.ck-label{max-width:160px;text-overflow:ellipsis;overflow:hidden}.ck.ck-special-characters-navigation>.ck-dropdown .ck-dropdown__panel{max-height:250px;overflow-y:auto;overflow-x:hidden}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-special-characters/specialcharacters.css"],
            names: [],
            mappings: "AASC,+CACC,eAAgB,CAChB,sBAAuB,CACvB,eACD,CAEA,sEAEC,gBAAiB,CACjB,eAAgB,CAChB,iBACD",
            sourcesContent: ['/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-special-characters-navigation {\n\n\t& > .ck-label {\n\t\tmax-width: 160px;\n\t\ttext-overflow: ellipsis;\n\t\toverflow: hidden;\n\t}\n\n\t& > .ck-dropdown .ck-dropdown__panel {\n\t\t/* There could be dozens of categories available. Use scroll to prevent a 10e6px dropdown. */\n\t\tmax-height: 250px;\n\t\toverflow-y: auto;\n\t\toverflow-x: hidden;\n\t}\n}\n'],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ":root{--ck-color-table-focused-cell-background:rgba(158,207,250,0.3)}.ck-widget.table td.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table td.ck-editor__nested-editable:focus,.ck-widget.table th.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table th.ck-editor__nested-editable:focus{background:var(--ck-color-table-focused-cell-background);border-style:none;outline:1px solid var(--ck-color-focus-border);outline-offset:-1px}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/tableediting.css"],
            names: [],
            mappings: "AAKA,MACC,8DACD,CAKE,8QAGC,wDAAyD,CAKzD,iBAAkB,CAClB,8CAA+C,CAC/C,mBACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-table-focused-cell-background: hsla(208, 90%, 80%, .3);\n}\n\n.ck-widget.table {\n\t& td,\n\t& th {\n\t\t&.ck-editor__nested-editable.ck-editor__nested-editable_focused,\n\t\t&.ck-editor__nested-editable:focus {\n\t\t\t/* A very slight background to highlight the focused cell */\n\t\t\tbackground: var(--ck-color-table-focused-cell-background);\n\n\t\t\t/* Fixes the problem where surrounding cells cover the focused cell's border.\n\t\t\tIt does not fix the problem in all places but the UX is improved.\n\t\t\tSee https://github.com/ckeditor/ckeditor5-table/issues/29. */\n\t\t\tborder-style: none;\n\t\t\toutline: 1px solid var(--ck-color-focus-border);\n\t\t\toutline-offset: -1px; /* progressive enhancement - no IE support */\n\t\t}\n\t}\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck .ck-insert-table-dropdown__grid{display:flex;flex-direction:row;flex-wrap:wrap}:root{--ck-insert-table-dropdown-padding:10px;--ck-insert-table-dropdown-box-height:11px;--ck-insert-table-dropdown-box-width:12px;--ck-insert-table-dropdown-box-margin:1px}.ck .ck-insert-table-dropdown__grid{width:calc(var(--ck-insert-table-dropdown-box-width)*10 + var(--ck-insert-table-dropdown-box-margin)*20 + var(--ck-insert-table-dropdown-padding)*2);padding:var(--ck-insert-table-dropdown-padding) var(--ck-insert-table-dropdown-padding) 0}.ck .ck-insert-table-dropdown__label{text-align:center}.ck .ck-insert-table-dropdown-grid-box{width:var(--ck-insert-table-dropdown-box-width);height:var(--ck-insert-table-dropdown-box-height);margin:var(--ck-insert-table-dropdown-box-margin);border:1px solid var(--ck-color-base-border);border-radius:1px}.ck .ck-insert-table-dropdown-grid-box.ck-on{border-color:var(--ck-color-focus-border);background:var(--ck-color-focus-outer-shadow)}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-table/theme/inserttable.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/inserttable.css"],
            names: [],
            mappings: "AAKA,oCACC,YAAa,CACb,kBAAmB,CACnB,cACD,CCJA,MACC,uCAAwC,CACxC,0CAA2C,CAC3C,yCAA0C,CAC1C,yCACD,CAEA,oCAEC,oJAA2J,CAC3J,yFACD,CAEA,qCACC,iBACD,CAEA,uCACC,+CAAgD,CAChD,iDAAkD,CAClD,iDAAkD,CAClD,4CAA6C,CAC7C,iBAMD,CAJC,6CACC,yCAA0C,CAC1C,6CACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-insert-table-dropdown__grid {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: wrap;\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-insert-table-dropdown-padding: 10px;\n\t--ck-insert-table-dropdown-box-height: 11px;\n\t--ck-insert-table-dropdown-box-width: 12px;\n\t--ck-insert-table-dropdown-box-margin: 1px;\n}\n\n.ck .ck-insert-table-dropdown__grid {\n\t/* The width of a container should match 10 items in a row so there will be a 10x10 grid. */\n\twidth: calc(var(--ck-insert-table-dropdown-box-width) * 10 + var(--ck-insert-table-dropdown-box-margin) * 20 + var(--ck-insert-table-dropdown-padding) * 2);\n\tpadding: var(--ck-insert-table-dropdown-padding) var(--ck-insert-table-dropdown-padding) 0;\n}\n\n.ck .ck-insert-table-dropdown__label {\n\ttext-align: center;\n}\n\n.ck .ck-insert-table-dropdown-grid-box {\n\twidth: var(--ck-insert-table-dropdown-box-width);\n\theight: var(--ck-insert-table-dropdown-box-height);\n\tmargin: var(--ck-insert-table-dropdown-box-margin);\n\tborder: 1px solid var(--ck-color-base-border);\n\tborder-radius: 1px;\n\n\t&.ck-on {\n\t\tborder-color: var(--ck-color-focus-border);\n\t\tbackground: var(--ck-color-focus-outer-shadow);\n\t}\n}\n\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ':root{--ck-table-selected-cell-background:rgba(158,207,250,0.3)}.ck.ck-editor__editable .table table td.ck-editor__editable_selected,.ck.ck-editor__editable .table table th.ck-editor__editable_selected{position:relative;caret-color:transparent;outline:unset;box-shadow:unset}.ck.ck-editor__editable .table table td.ck-editor__editable_selected:after,.ck.ck-editor__editable .table table th.ck-editor__editable_selected:after{content:"";pointer-events:none;background-color:var(--ck-table-selected-cell-background);position:absolute;top:0;left:0;right:0;bottom:0}.ck.ck-editor__editable .table table td.ck-editor__editable_selected ::selection,.ck.ck-editor__editable .table table td.ck-editor__editable_selected:focus,.ck.ck-editor__editable .table table th.ck-editor__editable_selected ::selection,.ck.ck-editor__editable .table table th.ck-editor__editable_selected:focus{background-color:transparent}.ck.ck-editor__editable .table table td.ck-editor__editable_selected .ck-widget_selected,.ck.ck-editor__editable .table table th.ck-editor__editable_selected .ck-widget_selected{outline:unset}', "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/tableselection.css"],
            names: [],
            mappings: "AAKA,MACC,yDACD,CAGC,0IAEC,iBAAkB,CAClB,uBAAwB,CACxB,aAAc,CACd,gBAsBD,CAnBC,sJACC,UAAW,CACX,mBAAoB,CACpB,yDAA0D,CAC1D,iBAAkB,CAClB,KAAM,CACN,MAAO,CACP,OAAQ,CACR,QACD,CAEA,wTAEC,4BACD,CAEA,kLACC,aACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-table-selected-cell-background: hsla(208, 90%, 80%, .3);\n}\n\n.ck.ck-editor__editable .table table {\n\t& td.ck-editor__editable_selected,\n\t& th.ck-editor__editable_selected {\n\t\tposition: relative;\n\t\tcaret-color: transparent;\n\t\toutline: unset;\n\t\tbox-shadow: unset;\n\n\t\t/* https://github.com/ckeditor/ckeditor5/issues/6446 */\n\t\t&:after {\n\t\t\tcontent: '';\n\t\t\tpointer-events: none;\n\t\t\tbackground-color: var(--ck-table-selected-cell-background);\n\t\t\tposition: absolute;\n\t\t\ttop: 0;\n\t\t\tleft: 0;\n\t\t\tright: 0;\n\t\t\tbottom: 0;\n\t\t}\n\n\t\t& ::selection,\n\t\t&:focus {\n\t\t\tbackground-color: transparent;\n\t\t}\n\n\t\t& .ck-widget_selected {\n\t\t\toutline: unset;\n\t\t}\n\t}\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck-content .table{margin:1em auto;display:table}.ck-content .table table{border-collapse:collapse;border-spacing:0;width:100%;height:100%;border:1px double #b3b3b3}.ck-content .table table td,.ck-content .table table th{min-width:2em;padding:.4em;border:1px solid #bfbfbf}.ck-content .table table th{font-weight:700;background:hsla(0,0%,0%,5%)}.ck-content[dir=rtl] .table th{text-align:right}.ck-content[dir=ltr] .table th{text-align:left}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-table/theme/table.css"],
            names: [],
            mappings: "AAKA,mBAEC,eAAgB,CAChB,aAgCD,CA9BC,yBAEC,wBAAyB,CACzB,gBAAiB,CAIjB,UAAW,CACX,WAAY,CAIZ,yBAiBD,CAfC,wDAEC,aAAc,CACd,YAAa,CAKb,wBACD,CAEA,4BACC,eAAiB,CACjB,2BACD,CAMF,+BACC,gBACD,CAEA,+BACC,eACD",
            sourcesContent: ['/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content .table {\n\t/* Give the table widget some air and center it horizontally */\n\tmargin: 1em auto;\n\tdisplay: table;\n\n\t& table {\n\t\t/* The table cells should have slight borders */\n\t\tborder-collapse: collapse;\n\t\tborder-spacing: 0;\n\n\t\t/* Table width and height are set on the parent <figure>. Make sure the table inside stretches\n\t\tto the full dimensions of the container (https://github.com/ckeditor/ckeditor5/issues/6186). */\n\t\twidth: 100%;\n\t\theight: 100%;\n\n\t\t/* The outer border of the table should be slightly darker than the inner lines.\n\t\tAlso see https://github.com/ckeditor/ckeditor5-table/issues/50. */\n\t\tborder: 1px double hsl(0, 0%, 70%);\n\n\t\t& td,\n\t\t& th {\n\t\t\tmin-width: 2em;\n\t\t\tpadding: .4em;\n\n\t\t\t/* The border is inherited from .ck-editor__nested-editable styles, so theoretically it\'s not necessary here.\n\t\t\tHowever, the border is a content style, so it should use .ck-content (so it works outside the editor).\n\t\t\tHence, the duplication. See https://github.com/ckeditor/ckeditor5/issues/6314 */\n\t\t\tborder: 1px solid hsl(0, 0%, 75%);\n\t\t}\n\n\t\t& th {\n\t\t\tfont-weight: bold;\n\t\t\tbackground: hsla(0, 0%, 0%, 5%);\n\t\t}\n\t}\n}\n\n/* Text alignment of the table header should match the editor settings and override the native browser styling,\nwhen content is available outside the ediitor. See https://github.com/ckeditor/ckeditor5/issues/6638 */\n.ck-content[dir="rtl"] .table th {\n\ttext-align: right;\n}\n\n.ck-content[dir="ltr"] .table th {\n\ttext-align: left;\n}\n'],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck.ck-input-color{width:100%;display:flex}.ck.ck-input-color>input.ck.ck-input-text{min-width:auto;flex-grow:1}.ck.ck-input-color>input.ck.ck-input-text:active,.ck.ck-input-color>input.ck.ck-input-text:focus{z-index:var(--ck-z-default)}.ck.ck-input-color>div.ck.ck-dropdown{min-width:auto}.ck.ck-input-color>div.ck.ck-dropdown>.ck-input-color__button .ck-dropdown__arrow{display:none}.ck.ck-input-color .ck.ck-input-color__button .ck.ck-input-color__button__preview{position:relative;overflow:hidden}.ck.ck-input-color .ck.ck-input-color__button .ck.ck-input-color__button__preview>.ck.ck-input-color__button__preview__no-color-indicator{position:absolute;display:block}[dir=ltr] .ck.ck-input-color>.ck.ck-input-text{border-top-right-radius:0;border-bottom-right-radius:0}[dir=rtl] .ck.ck-input-color>.ck.ck-input-text{border-top-left-radius:0;border-bottom-left-radius:0}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-input-color__button{padding:0}[dir=ltr] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-input-color__button{border-top-left-radius:0;border-bottom-left-radius:0;margin-left:-1px}[dir=rtl] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-input-color__button{border-top-right-radius:0;border-bottom-right-radius:0;margin-right:-1px}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-input-color__button.ck-disabled{background:var(--ck-color-input-disabled-background)}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-input-color__button>.ck.ck-input-color__button__preview{border-radius:0}.ck-rounded-corners .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-input-color__button>.ck.ck-input-color__button__preview,.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-input-color__button>.ck.ck-input-color__button__preview.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-input-color__button>.ck.ck-input-color__button__preview{width:20px;height:20px;border:1px solid var(--ck-color-input-border)}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-input-color__button>.ck.ck-input-color__button__preview>.ck.ck-input-color__button__preview__no-color-indicator{top:-30%;left:50%;height:150%;width:8%;background:red;border-radius:2px;transform:rotate(45deg);transform-origin:50%}.ck.ck-input-color .ck.ck-input-color__remove-color{width:100%;border-bottom:1px solid var(--ck-color-input-border);padding:calc(var(--ck-spacing-standard)/2) var(--ck-spacing-standard);border-bottom-left-radius:0;border-bottom-right-radius:0}[dir=ltr] .ck.ck-input-color .ck.ck-input-color__remove-color{border-top-right-radius:0}[dir=rtl] .ck.ck-input-color .ck.ck-input-color__remove-color{border-top-left-radius:0}.ck.ck-input-color .ck.ck-input-color__remove-color .ck.ck-icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-input-color .ck.ck-input-color__remove-color .ck.ck-icon{margin-right:0;margin-left:var(--ck-spacing-standard)}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-table/theme/colorinput.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/colorinput.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"],
            names: [],
            mappings: "AAKA,mBACC,UAAW,CACX,YAgCD,CA9BC,0CACC,cAAe,CACf,WAMD,CAJC,iGAEC,2BACD,CAGD,sCACC,cAMD,CAHC,kFACC,YACD,CAIA,kFACC,iBAAkB,CAClB,eAMD,CAJC,0IACC,iBAAkB,CAClB,aACD,CC3BF,+CAEE,yBAA0B,CAC1B,4BAOF,CAVA,+CAOE,wBAAyB,CACzB,2BAEF,CAGC,8DACC,SAoCD,CArCA,wEAIE,wBAAyB,CACzB,2BAA4B,CAC5B,gBA+BF,CArCA,wEAUE,yBAA0B,CAC1B,4BAA6B,CAC7B,iBAyBF,CAtBC,0EACC,oDACD,CAEA,kGC9BF,eD+CE,CAjBA,2OC1BD,qCD2CC,CAjBA,kGAGC,UAAW,CACX,WAAY,CACZ,6CAYD,CAVC,0JACC,QAAS,CACT,QAAS,CACT,WAAY,CACZ,QAAS,CACT,cAA6B,CAC7B,iBAAkB,CAClB,uBAAwB,CACxB,oBACD,CAKH,oDACC,UAAW,CACX,oDAAqD,CACrD,qEAAwE,CAExE,2BAA4B,CAC5B,4BAkBD,CAxBA,8DASE,yBAeF,CAxBA,8DAaE,wBAWF,CARC,gEACC,uCAMD,CAPA,0EAIE,cAAe,CACf,sCAEF",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-input-color {\n\twidth: 100%;\n\tdisplay: flex;\n\n\t& > input.ck.ck-input-text {\n\t\tmin-width: auto;\n\t\tflex-grow: 1;\n\n\t\t&:active,\n\t\t&:focus {\n\t\t\tz-index: var(--ck-z-default);\n\t\t}\n\t}\n\n\t& > div.ck.ck-dropdown {\n\t\tmin-width: auto;\n\n\t\t/* This dropdown has no arrow but a color preview instead. */\n\t\t& > .ck-input-color__button .ck-dropdown__arrow {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t& .ck.ck-input-color__button {\n\t\t& .ck.ck-input-color__button__preview {\n\t\t\tposition: relative;\n\t\t\toverflow: hidden;\n\n\t\t\t& > .ck.ck-input-color__button__preview__no-color-indicator {\n\t\t\t\tposition: absolute;\n\t\t\t\tdisplay: block;\n\t\t\t}\n\t\t}\n\t}\n}\n", '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n@import "../mixins/_rounded.css";\n\n.ck.ck-input-color {\n\t& > .ck.ck-input-text {\n\t\t@mixin ck-dir ltr {\n\t\t\tborder-top-right-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tborder-top-left-radius: 0;\n\t\t\tborder-bottom-left-radius: 0;\n\t\t}\n\t}\n\n\t& > .ck.ck-dropdown {\n\t\t& > .ck.ck-input-color__button {\n\t\t\tpadding: 0;\n\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tborder-top-left-radius: 0;\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t\tmargin-left: -1px;\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tborder-top-right-radius: 0;\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t\tmargin-right: -1px;\n\t\t\t}\n\n\t\t\t&.ck-disabled {\n\t\t\t\tbackground: var(--ck-color-input-disabled-background);\n\t\t\t}\n\n\t\t\t& > .ck.ck-input-color__button__preview {\n\t\t\t\t@mixin ck-rounded-corners;\n\n\t\t\t\twidth: 20px;\n\t\t\t\theight: 20px;\n\t\t\t\tborder: 1px solid var(--ck-color-input-border);\n\n\t\t\t\t& > .ck.ck-input-color__button__preview__no-color-indicator {\n\t\t\t\t\ttop: -30%;\n\t\t\t\t\tleft: 50%;\n\t\t\t\t\theight: 150%;\n\t\t\t\t\twidth: 8%;\n\t\t\t\t\tbackground: hsl(0, 100%, 50%);\n\t\t\t\t\tborder-radius: 2px;\n\t\t\t\t\ttransform: rotate(45deg);\n\t\t\t\t\ttransform-origin: 50%;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t& .ck.ck-input-color__remove-color {\n\t\twidth: 100%;\n\t\tborder-bottom: 1px solid var(--ck-color-input-border);\n\t\tpadding: calc(var(--ck-spacing-standard) / 2) var(--ck-spacing-standard);\n\n\t\tborder-bottom-left-radius: 0;\n\t\tborder-bottom-right-radius: 0;\n\n\t\t@mixin ck-dir ltr {\n\t\t\tborder-top-right-radius: 0;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tborder-top-left-radius: 0;\n\t\t}\n\n\t\t& .ck.ck-icon {\n\t\t\tmargin-right: var(--ck-spacing-standard);\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-right: 0;\n\t\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t\t}\n\t\t}\n\t}\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck.ck-form__row{display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}.ck.ck-form__row>:not(.ck-label){flex-grow:1}.ck.ck-form__row.ck-table-form__action-row .ck-button-cancel,.ck.ck-form__row.ck-table-form__action-row .ck-button-save{justify-content:center}.ck.ck-form__row{padding:var(--ck-spacing-standard) var(--ck-spacing-large) 0}[dir=ltr] .ck.ck-form__row>:not(.ck-label)+*{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-form__row>:not(.ck-label)+*{margin-right:var(--ck-spacing-large)}.ck.ck-form__row>.ck-label{width:100%;min-width:100%}.ck.ck-form__row.ck-table-form__action-row{margin-top:var(--ck-spacing-large)}.ck.ck-form__row.ck-table-form__action-row .ck-button .ck-button__label{color:var(--ck-color-text)}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-table/theme/formrow.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/formrow.css"],
            names: [],
            mappings: "AAKA,iBACC,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CACjB,6BAaD,CAVC,iCACC,WACD,CAGC,wHAEC,sBACD,CCbF,iBACC,4DA2BD,CAvBE,6CAEE,mCAMF,CARA,6CAME,oCAEF,CAGD,2BACC,UAAW,CACX,cACD,CAEA,2CACC,kCAKD,CAHC,wEACC,0BACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-form__row {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\tjustify-content: space-between;\n\n\t/* Ignore labels that work as fieldset legends */\n\t& > *:not(.ck-label) {\n\t\tflex-grow: 1;\n\t}\n\n\t&.ck-table-form__action-row {\n\t\t& .ck-button-save,\n\t\t& .ck-button-cancel {\n\t\t\tjustify-content: center;\n\t\t}\n\t}\n}\n", '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-form__row {\n\tpadding: var(--ck-spacing-standard) var(--ck-spacing-large) 0;\n\n\t/* Ignore labels that work as fieldset legends */\n\t& > *:not(.ck-label) {\n\t\t& + * {\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: var(--ck-spacing-large);\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-right: var(--ck-spacing-large);\n\t\t\t}\n\t\t}\n\t}\n\n\t& > .ck-label {\n\t\twidth: 100%;\n\t\tmin-width: 100%;\n\t}\n\n\t&.ck-table-form__action-row {\n\t\tmargin-top: var(--ck-spacing-large);\n\n\t\t& .ck-button .ck-button__label {\n\t\t\tcolor: var(--ck-color-text);\n\t\t}\n\t}\n}\n'],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck.ck-form{padding:0 0 var(--ck-spacing-large)}.ck.ck-form:focus{outline:none}.ck.ck-form .ck.ck-input-text{min-width:100%;width:0}.ck.ck-form .ck.ck-dropdown{min-width:100%}.ck.ck-form .ck.ck-dropdown .ck-dropdown__button:not(:focus){border:1px solid var(--ck-color-base-border)}.ck.ck-form .ck.ck-dropdown .ck-dropdown__button .ck-button__label{width:100%}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/form.css"],
            names: [],
            mappings: "AAKA,YACC,mCAyBD,CAvBC,kBAEC,YACD,CAEA,8BACC,cAAe,CACf,OACD,CAEA,4BACC,cAWD,CARE,6DACC,4CACD,CAEA,mEACC,UACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-form {\n\tpadding: 0 0 var(--ck-spacing-large);\n\n\t&:focus {\n\t\t/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */\n\t\toutline: none;\n\t}\n\n\t& .ck.ck-input-text {\n\t\tmin-width: 100%;\n\t\twidth: 0;\n\t}\n\n\t& .ck.ck-dropdown {\n\t\tmin-width: 100%;\n\n\t\t& .ck-dropdown__button {\n\t\t\t&:not(:focus) {\n\t\t\t\tborder: 1px solid var(--ck-color-base-border);\n\t\t\t}\n\n\t\t\t& .ck-button__label {\n\t\t\t\twidth: 100%;\n\t\t\t}\n\t\t}\n\t}\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, '.ck.ck-table-form .ck-form__row.ck-table-form__border-row{flex-wrap:wrap}.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-labeled-field-view{display:flex;flex-direction:column-reverse}.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-labeled-field-view .ck.ck-dropdown,.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-table-form__border-style,.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-table-form__border-width{flex-grow:0}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row{flex-wrap:wrap;align-items:center}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-labeled-field-view{display:flex;flex-direction:column-reverse;align-items:center}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-labeled-field-view .ck.ck-dropdown,.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimension-operator{flex-grow:0}.ck.ck-table-form .ck.ck-labeled-field-view{position:relative}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{position:absolute;left:50%;bottom:calc(var(--ck-table-properties-error-arrow-size)*-1);transform:translate(-50%,100%);z-index:1}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status:after{content:"";position:absolute;top:calc(var(--ck-table-properties-error-arrow-size)*-1);left:50%;transform:translateX(-50%)}:root{--ck-table-properties-error-arrow-size:6px;--ck-table-properties-min-error-width:150px}.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-labeled-field-view>.ck-label{font-size:var(--ck-font-size-tiny);text-align:center}.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-table-form__border-style{width:80px;min-width:80px}.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-table-form__border-width{width:50px;min-width:50px}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row{padding:0}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-labeled-field-view>.ck-label{font-size:10px;text-align:center}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimensions-row__height,.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimensions-row__width{margin:0}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimension-operator{align-self:start;display:inline-block;height:var(--ck-ui-component-min-height);line-height:var(--ck-ui-component-min-height);margin:0 var(--ck-spacing-small)}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{border-radius:0}.ck-rounded-corners .ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status,.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{background:var(--ck-color-base-error);color:var(--ck-color-base-background);padding:var(--ck-spacing-small) var(--ck-spacing-medium);min-width:var(--ck-table-properties-min-error-width);text-align:center}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status:after{border-left:var(--ck-table-properties-error-arrow-size) solid transparent;border-bottom:var(--ck-table-properties-error-arrow-size) solid var(--ck-color-base-error);border-right:var(--ck-table-properties-error-arrow-size) solid transparent;border-top:0 solid transparent}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{animation:ck-table-form-labeled-view-status-appear .15s ease both}.ck.ck-table-form .ck.ck-labeled-field-view .ck-input.ck-error:not(:focus)+.ck.ck-labeled-field-view__status{display:none}@keyframes ck-table-form-labeled-view-status-appear{0%{opacity:0}to{opacity:1}}', "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-table/theme/tableform.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/tableform.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"],
            names: [],
            mappings: "AAOE,0DACC,cAkBD,CAhBC,iFACC,YAAa,CACb,6BAKD,CAMA,+QACC,WACD,CAGD,8DACC,cAAe,CACf,kBAeD,CAbC,qFACC,YAAa,CACb,6BAA8B,CAC9B,kBAKD,CAEA,sMACC,WACD,CAIF,4CAEC,iBAoBD,CAlBC,8EACC,iBAAkB,CAClB,QAAS,CACT,2DAAgE,CAChE,8BAA+B,CAG/B,SAUD,CAPC,oFACC,UAAW,CACX,iBAAkB,CAClB,wDAA6D,CAC7D,QAAS,CACT,0BACD,CC7DH,MACC,0CAA2C,CAC3C,2CACD,CAMI,2FACC,kCAAmC,CACnC,iBACD,CAGD,uFACC,UAAW,CACX,cACD,CAEA,uFACC,UAAW,CACX,cACD,CAGD,8DACC,SAmBD,CAjBC,+FACC,cAAe,CACf,iBACD,CAEA,yMAEC,QACD,CAEA,iGACC,gBAAiB,CACjB,oBAAqB,CACrB,wCAAyC,CACzC,6CAA8C,CAC9C,gCACD,CAKD,8EC9CD,eD+DC,CAjBA,mMC1CA,qCD2DA,CAjBA,8EAGC,qCAAsC,CACtC,qCAAsC,CACtC,wDAAyD,CACzD,oDAAqD,CACrD,iBAUD,CAPC,oFAGC,yEAAmB,CAAnB,0FAAmB,CAAnB,0EAAmB,CAAnB,8BACD,CAdD,8EAgBC,iEACD,CAGA,6GACC,YACD,CAIF,oDACC,GACC,SACD,CAEA,GACC,SACD,CACD",
            sourcesContent: ['/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-table-form {\n\t& .ck-form__row {\n\t\t&.ck-table-form__border-row {\n\t\t\tflex-wrap: wrap;\n\n\t\t\t& .ck-labeled-field-view {\n\t\t\t\tdisplay: flex;\n\t\t\t\tflex-direction: column-reverse;\n\n\t\t\t\t& .ck.ck-dropdown {\n\t\t\t\t\tflex-grow: 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t& .ck-table-form__border-style {\n\t\t\t\tflex-grow: 0;\n\t\t\t}\n\n\t\t\t& .ck-table-form__border-width {\n\t\t\t\tflex-grow: 0;\n\t\t\t}\n\t\t}\n\n\t\t&.ck-table-form__dimensions-row {\n\t\t\tflex-wrap: wrap;\n\t\t\talign-items: center;\n\n\t\t\t& .ck-labeled-field-view {\n\t\t\t\tdisplay: flex;\n\t\t\t\tflex-direction: column-reverse;\n\t\t\t\talign-items: center;\n\n\t\t\t\t& .ck.ck-dropdown {\n\t\t\t\t\tflex-grow: 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t& .ck-table-form__dimension-operator {\n\t\t\t\tflex-grow: 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t& .ck.ck-labeled-field-view {\n\t\t/* Allow absolute positioning of the status (error) balloons. */\n\t\tposition: relative;\n\n\t\t& .ck.ck-labeled-field-view__status {\n\t\t\tposition: absolute;\n\t\t\tleft: 50%;\n\t\t\tbottom: calc( -1 * var(--ck-table-properties-error-arrow-size) );\n\t\t\ttransform: translate(-50%,100%);\n\n\t\t\t/* Make sure the balloon status stays on top of other form elements. */\n\t\t\tz-index: 1;\n\n\t\t\t/* The arrow pointing towards the field. */\n\t\t\t&::after {\n\t\t\t\tcontent: "";\n\t\t\t\tposition: absolute;\n\t\t\t\ttop: calc( -1 * var(--ck-table-properties-error-arrow-size) );\n\t\t\t\tleft: 50%;\n\t\t\t\ttransform: translateX( -50% );\n\t\t\t}\n\t\t}\n\t}\n}\n', '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../mixins/_rounded.css";\n\n:root {\n\t--ck-table-properties-error-arrow-size: 6px;\n\t--ck-table-properties-min-error-width: 150px;\n}\n\n.ck.ck-table-form {\n\t& .ck-form__row {\n\t\t&.ck-table-form__border-row {\n\t\t\t& .ck-labeled-field-view {\n\t\t\t\t& > .ck-label {\n\t\t\t\t\tfont-size: var(--ck-font-size-tiny);\n\t\t\t\t\ttext-align: center;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t& .ck-table-form__border-style {\n\t\t\t\twidth: 80px;\n\t\t\t\tmin-width: 80px;\n\t\t\t}\n\n\t\t\t& .ck-table-form__border-width {\n\t\t\t\twidth: 50px;\n\t\t\t\tmin-width: 50px;\n\t\t\t}\n\t\t}\n\n\t\t&.ck-table-form__dimensions-row {\n\t\t\tpadding: 0;\n\n\t\t\t& .ck-labeled-field-view > .ck-label {\n\t\t\t\tfont-size: 10px;\n\t\t\t\ttext-align: center;\n\t\t\t}\n\n\t\t\t& .ck-table-form__dimensions-row__width,\n\t\t\t& .ck-table-form__dimensions-row__height {\n\t\t\t\tmargin: 0\n\t\t\t}\n\n\t\t\t& .ck-table-form__dimension-operator {\n\t\t\t\talign-self: start;\n\t\t\t\tdisplay: inline-block;\n\t\t\t\theight: var(--ck-ui-component-min-height);\n\t\t\t\tline-height: var(--ck-ui-component-min-height);\n\t\t\t\tmargin: 0 var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\t}\n\n\t& .ck.ck-labeled-field-view {\n\t\t& .ck.ck-labeled-field-view__status {\n\t\t\t@mixin ck-rounded-corners;\n\n\t\t\tbackground: var(--ck-color-base-error);\n\t\t\tcolor: var(--ck-color-base-background);\n\t\t\tpadding: var(--ck-spacing-small) var(--ck-spacing-medium);\n\t\t\tmin-width: var(--ck-table-properties-min-error-width);\n\t\t\ttext-align: center;\n\n\t\t\t/* The arrow pointing towards the field. */\n\t\t\t&::after {\n\t\t\t\tborder-color: transparent transparent var(--ck-color-base-error) transparent;\n\t\t\t\tborder-width: 0 var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size);\n\t\t\t\tborder-style: solid;\n\t\t\t}\n\n\t\t\tanimation: ck-table-form-labeled-view-status-appear .15s ease both;\n\t\t}\n\n\t\t/* Hide the error balloon when the field is blurred. Makes the experience much more clear. */\n\t\t& .ck-input.ck-error:not(:focus) + .ck.ck-labeled-field-view__status {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n\n@keyframes ck-table-form-labeled-view-status-appear {\n\t0% {\n\t\topacity: 0;\n\t}\n\n\t100% {\n\t\topacity: 1;\n\t}\n}\n', "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row{flex-wrap:wrap}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar{flex-grow:0}.ck.ck-table-cell-properties-form{width:320px}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__padding-row{padding:0;width:35%}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar{background:none}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-table/theme/tablecellproperties.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/tablecellproperties.css"],
            names: [],
            mappings: "AAOE,6FACC,cAKD,CAHC,4GACC,WACD,CCPH,kCACC,WAcD,CAXE,2FACC,SAAU,CACV,SACD,CAGC,4GACC,eACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-table-cell-properties-form {\n\t& .ck-form__row {\n\t\t&.ck-table-cell-properties-form__alignment-row {\n\t\t\tflex-wrap: wrap;\n\n\t\t\t& .ck.ck-toolbar {\n\t\t\t\tflex-grow: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-table-cell-properties-form {\n\twidth: 320px;\n\n\t& .ck-form__row {\n\t\t&.ck-table-cell-properties-form__padding-row {\n\t\t\tpadding: 0;\n\t\t\twidth: 35%;\n\t\t}\n\n\t\t&.ck-table-cell-properties-form__alignment-row {\n\t\t\t& .ck.ck-toolbar {\n\t\t\t\tbackground: none;\n\t\t\t}\n\t\t}\n\t}\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ".ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row{flex-wrap:wrap;flex-basis:0;align-content:baseline}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar .ck-toolbar__items{flex-wrap:nowrap}.ck.ck-table-properties-form{width:320px}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row{padding:0}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar{background:none}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar .ck-toolbar__items>*{width:40px}", "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-table/theme/tableproperties.css", "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/tableproperties.css"],
            names: [],
            mappings: "AAOE,mFACC,cAAe,CACf,YAAa,CACb,sBAKD,CAHC,qHACC,gBACD,CCTH,6BACC,WAeD,CAZE,mFACC,SASD,CAPC,kGACC,eAKD,CAHC,uHACC,UACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-table-properties-form {\n\t& .ck-form__row {\n\t\t&.ck-table-properties-form__alignment-row {\n\t\t\tflex-wrap: wrap;\n\t\t\tflex-basis: 0;\n\t\t\talign-content: baseline;\n\n\t\t\t& .ck.ck-toolbar .ck-toolbar__items {\n\t\t\t\tflex-wrap: nowrap;\n\t\t\t}\n\t\t}\n\t}\n}\n", "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-table-properties-form {\n\twidth: 320px;\n\n\t& .ck-form__row {\n\t\t&.ck-table-properties-form__alignment-row {\n\t\t\tpadding: 0;\n\n\t\t\t& .ck.ck-toolbar {\n\t\t\t\tbackground: none;\n\n\t\t\t\t& .ck-toolbar__items > * {\n\t\t\t\t\twidth: 40px;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e, n) {
        "use strict";
        var i = n(2);
        var o = n.n(i);
        var r = n(3);
        var s = n.n(r);
        var a = s()(o.a);
        a.push([t.i, ':root{--ck-todo-list-checkmark-size:16px}.ck-content .todo-list{list-style:none}.ck-content .todo-list li{margin-bottom:5px}.ck-content .todo-list li .todo-list{margin-top:5px}.ck-content .todo-list .todo-list__label>input{-webkit-appearance:none;display:inline-block;position:relative;width:var(--ck-todo-list-checkmark-size);height:var(--ck-todo-list-checkmark-size);vertical-align:middle;border:0;left:-25px;margin-right:-15px;right:0;margin-left:0}.ck-content .todo-list .todo-list__label>input:before{display:block;position:absolute;box-sizing:border-box;content:"";width:100%;height:100%;border:1px solid #333;border-radius:2px;transition:box-shadow .25s ease-in-out,background .25s ease-in-out,border .25s ease-in-out}.ck-content .todo-list .todo-list__label>input:after{display:block;position:absolute;box-sizing:content-box;pointer-events:none;content:"";left:calc(var(--ck-todo-list-checkmark-size)/3);top:calc(var(--ck-todo-list-checkmark-size)/5.3);width:calc(var(--ck-todo-list-checkmark-size)/5.3);height:calc(var(--ck-todo-list-checkmark-size)/2.6);border-left:0 solid transparent;border-bottom:calc(var(--ck-todo-list-checkmark-size)/8) solid transparent;border-right:calc(var(--ck-todo-list-checkmark-size)/8) solid transparent;border-top:0 solid transparent;transform:rotate(45deg)}.ck-content .todo-list .todo-list__label>input[checked]:before{background:#26ab33;border-color:#26ab33}.ck-content .todo-list .todo-list__label>input[checked]:after{border-color:#fff}.ck-content .todo-list .todo-list__label .todo-list__label__description{vertical-align:middle}[dir=rtl] .todo-list .todo-list__label>input{left:0;margin-right:0;right:-25px;margin-left:-15px}.ck-editor__editable .todo-list .todo-list__label>input{cursor:pointer}.ck-editor__editable .todo-list .todo-list__label>input:hover:before{box-shadow:0 0 0 5px rgba(0,0,0,.1)}', "", {
            version: 3,
            sources: ["webpack://node_modules/@ckeditor/ckeditor5-list/theme/todolist.css"],
            names: [],
            mappings: "AAKA,MACC,kCACD,CAEA,uBACC,eA0ED,CAxEC,0BACC,iBAKD,CAHC,qCACC,cACD,CAIA,+CACC,uBAAwB,CACxB,oBAAqB,CACrB,iBAAkB,CAClB,wCAAyC,CACzC,yCAA0C,CAC1C,qBAAsB,CAGtB,QAAS,CAGT,UAAW,CACX,kBAAmB,CACnB,OAAQ,CACR,aA0CD,CAxCC,sDACC,aAAc,CACd,iBAAkB,CAClB,qBAAsB,CACtB,UAAW,CACX,UAAW,CACX,WAAY,CACZ,qBAAiC,CACjC,iBAAkB,CAClB,0FACD,CAEA,qDACC,aAAc,CACd,iBAAkB,CAClB,sBAAuB,CACvB,mBAAoB,CACpB,UAAW,CAGX,+CAAoD,CACpD,gDAAqD,CACrD,kDAAuD,CACvD,mDAAwD,CAGxD,+BAA+G,CAA/G,0EAA+G,CAA/G,yEAA+G,CAA/G,8BAA+G,CAC/G,uBACD,CAGC,+DACC,kBAA8B,CAC9B,oBACD,CAEA,8DACC,iBACD,CAIF,wEACC,qBACD,CAKF,6CACC,MAAO,CACP,cAAe,CACf,WAAY,CACZ,iBACD,CAMA,wDACC,cAKD,CAHC,qEACC,mCACD",
            sourcesContent: ["/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-todo-list-checkmark-size: 16px;\n}\n\n.ck-content .todo-list {\n\tlist-style: none;\n\n\t& li {\n\t\tmargin-bottom: 5px;\n\n\t\t& .todo-list {\n\t\t\tmargin-top: 5px;\n\t\t}\n\t}\n\n\t& .todo-list__label {\n\t\t& > input {\n\t\t\t-webkit-appearance: none;\n\t\t\tdisplay: inline-block;\n\t\t\tposition: relative;\n\t\t\twidth: var(--ck-todo-list-checkmark-size);\n\t\t\theight: var(--ck-todo-list-checkmark-size);\n\t\t\tvertical-align: middle;\n\n\t\t\t/* Needed on iOS */\n\t\t\tborder: 0;\n\n\t\t\t/* LTR styles */\n\t\t\tleft: -25px;\n\t\t\tmargin-right: -15px;\n\t\t\tright: 0;\n\t\t\tmargin-left: 0;\n\n\t\t\t&::before {\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: absolute;\n\t\t\t\tbox-sizing: border-box;\n\t\t\t\tcontent: '';\n\t\t\t\twidth: 100%;\n\t\t\t\theight: 100%;\n\t\t\t\tborder: 1px solid hsl(0, 0%, 20%);\n\t\t\t\tborder-radius: 2px;\n\t\t\t\ttransition: 250ms ease-in-out box-shadow, 250ms ease-in-out background, 250ms ease-in-out border;\n\t\t\t}\n\n\t\t\t&::after {\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: absolute;\n\t\t\t\tbox-sizing: content-box;\n\t\t\t\tpointer-events: none;\n\t\t\t\tcontent: '';\n\n\t\t\t\t/* Calculate tick position, size and border-width proportional to the checkmark size. */\n\t\t\t\tleft: calc( var(--ck-todo-list-checkmark-size) / 3 );\n\t\t\t\ttop: calc( var(--ck-todo-list-checkmark-size) / 5.3 );\n\t\t\t\twidth: calc( var(--ck-todo-list-checkmark-size) / 5.3 );\n\t\t\t\theight: calc( var(--ck-todo-list-checkmark-size) / 2.6 );\n\t\t\t\tborder-style: solid;\n\t\t\t\tborder-color: transparent;\n\t\t\t\tborder-width: 0 calc( var(--ck-todo-list-checkmark-size) / 8 ) calc( var(--ck-todo-list-checkmark-size) / 8 ) 0;\n\t\t\t\ttransform: rotate(45deg);\n\t\t\t}\n\n\t\t\t&[checked] {\n\t\t\t\t&::before {\n\t\t\t\t\tbackground: hsl(126, 64%, 41%);\n\t\t\t\t\tborder-color: hsl(126, 64%, 41%);\n\t\t\t\t}\n\n\t\t\t\t&::after {\n\t\t\t\t\tborder-color: hsl(0, 0%, 100%);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t& .todo-list__label__description {\n\t\t\tvertical-align: middle;\n\t\t}\n\t}\n}\n\n/* RTL styles */\n[dir=\"rtl\"] .todo-list .todo-list__label > input {\n\tleft: 0;\n\tmargin-right: 0;\n\tright: -25px;\n\tmargin-left: -15px;\n}\n\n/*\n * To-do list should be interactive only during the editing\n * (https://github.com/ckeditor/ckeditor5/issues/2090).\n */\n.ck-editor__editable .todo-list .todo-list__label > input {\n\tcursor: pointer;\n\n\t&:hover::before {\n\t\tbox-shadow: 0 0 0 5px hsla(0, 0%, 0%, 0.1);\n\t}\n}\n"],
            sourceRoot: ""
        }]);
        e["a"] = a
    }, function (t, e) {
        var n;
        n = function () {
            return this
        }();
        try {
            n = n || new Function("return this")()
        } catch (t) {
            if (typeof window === "object") n = window
        }
        t.exports = n
    }, function (t, e, n) {
        "use strict";

        function i() {
            return false
        }

        e["a"] = i
    }, function (t) {
        t.exports = JSON.parse('{"ar":{"latex":"LaTeX","cancel":"إلغاء","accept":"إدراج","manual":"الدليل","insert_math":"إدراج صيغة رياضية - MathType","insert_chem":"إدراج صيغة كيميائية - ChemType","minimize":"تصغير","maximize":"تكبير","fullscreen":"ملء الشاشة","exit_fullscreen":"الخروج من ملء الشاشة","close":"إغلاق","mathtype":"MathType","title_modalwindow":"نافذة MathType مشروطة","close_modal_warning":"هل تريد المغادرة بالتأكيد؟ ستُفقد التغييرات التي أجريتها.","latex_name_label":"صيغة Latex","browser_no_compatible":"المستعرض غير متوافق مع تقنية AJAX. الرجاء استخدام أحدث إصدار من Mozilla Firefox.","error_convert_accessibility":"حدث خطأ أثناء التحويل من MathML إلى نص قابل للاستخدام.","exception_cross_site":"البرمجة النصية للمواقع المشتركة مسموح بها لـ HTTP فقط.","exception_high_surrogate":"المركّب المرتفع غير متبوع بمركّب منخفض في fixedCharCodeAt()‎","exception_string_length":"سلسلة غير صالحة. يجب أن يكون الطول من مضاعفات العدد 4","exception_key_nonobject":"Object.keys مستدعاة على غير كائن","exception_null_or_undefined":" هذا فارغ أو غير محدد","exception_not_function":" ليست دالة","exception_invalid_date_format":"تنسيق تاريخ غير صالح: ","exception_casting":"لا يمكن الصياغة ","exception_casting_to":" إلى "},"ca":{"latex":"LaTeX","cancel":"Cancel·lar","accept":"Inserir","manual":"Manual","insert_math":"Inserir fórmula matemàtica - MathType","insert_chem":"Inserir fórmula química - ChemType","minimize":"Minimitza","maximize":"Maximitza","fullscreen":"Pantalla completa","exit_fullscreen":"Sortir de la pantalla complera","close":"Tanca","mathtype":"MathType","title_modalwindow":" Finestra modal de MathType","close_modal_warning":"N\'estàs segur que vols sortir? Es perdran els canvis que has fet.","latex_name_label":"Fórmula en Latex","browser_no_compatible":"El teu navegador no és compatible amb AJAX. Si us plau, usa la darrera versió de Mozilla Firefox.","error_convert_accessibility":"Error en convertir de MathML a text accessible.","exception_cross_site":"Els scripts de llocs creuats només estan permesos per HTTP.","exception_high_surrogate":"Subrogat alt no seguit de subrogat baix a fixedCharCodeAt()","exception_string_length":"Cadena invàlida. La longitud ha de ser un múltiple de 4","exception_key_nonobject":"Object.keys anomenat a non-object","exception_null_or_undefined":" això és null o no definit","exception_not_function":" no és una funció","exception_invalid_date_format":"Format de data invàlid : ","exception_casting":"No es pot emetre ","exception_casting_to":" a "},"cs":{"latex":"LaTeX","cancel":"Storno","accept":"Vložit","manual":"Příručka","insert_math":"Vložit matematický vzorec - MathType","insert_chem":"Vložení chemického vzorce – ChemType","minimize":"Minimalizovat","maximize":"Maximalizovat","fullscreen":"Celá obrazovka","exit_fullscreen":"Opustit režim celé obrazovky","close":"Zavřít","mathtype":"MathType","title_modalwindow":"Modální okno MathType","close_modal_warning":"Opravdu chcete okno zavřít? Provedené změny budou ztraceny.","latex_name_label":"Vzorec v LaTeXu","browser_no_compatible":"Váš prohlížeč nepodporuje technologii AJAX. Použijte nejnovější verzi prohlížeče Mozilla Firefox.","error_convert_accessibility":"Při převodu kódu MathML na čitelný text došlo k chybě.","exception_cross_site":"Skriptování mezi více servery je povoleno jen v HTTP.","exception_high_surrogate":"Ve funkci fixedCharCodeAt() nenásleduje po první části kódu znaku druhá část","exception_string_length":"Neplatný řetězec. Délka musí být násobkem 4.","exception_key_nonobject":"Funkce Object.keys byla použita pro prvek, který není objektem","exception_null_or_undefined":" hodnota je null nebo není definovaná","exception_not_function":" není funkce","exception_invalid_date_format":"Neplatný formát data: ","exception_casting":"Nelze přetypovat ","exception_casting_to":" na "},"da":{"latex":"LaTeX","cancel":"Annuller","accept":"Indsæt","manual":"Brugervejledning","insert_math":"Indsæt matematisk formel - MathType","insert_chem":"Indsæt en kemisk formel - ChemType","minimize":"Minimer","maximize":"Maksimer","fullscreen":"Fuld skærm","exit_fullscreen":"Afslut Fuld skærm","close":"Luk","mathtype":"MathType","title_modalwindow":"MathType-modalvindue","close_modal_warning":"Er du sikker på, du vil lukke? Dine ændringer går tabt.","latex_name_label":"LaTex-formel","browser_no_compatible":"Din browser er ikke kompatibel med AJAX-teknologi. Brug den nyeste version af Mozilla Firefox.","error_convert_accessibility":"Fejl under konvertering fra MathML til tilgængelig tekst.","exception_cross_site":"Scripts på tværs af websteder er kun tilladt for HTTP.","exception_high_surrogate":"Et højt erstatningstegn er ikke fulgt af et lavt erstatningstegn i fixedCharCodeAt()","exception_string_length":"Ugyldig streng. Længden skal være et multiplum af 4","exception_key_nonobject":"Object.keys kaldet ved ikke-objekt","exception_null_or_undefined":" dette er nul eller ikke defineret","exception_not_function":" er ikke en funktion","exception_invalid_date_format":"Ugyldigt datoformat: ","exception_casting":"Kan ikke beregne ","exception_casting_to":" til "},"de":{"latex":"LaTeX","cancel":"Abbrechen","accept":"Einfügen","manual":"Handbuch","insert_math":"Mathematische Formel einfügen - MathType","insert_chem":"Eine chemische Formel einfügen – ChemType","minimize":"Verkleinern","maximize":"Vergrößern","fullscreen":"Vollbild","exit_fullscreen":"Vollbild schließen","close":"Schließen","mathtype":"MathType","title_modalwindow":"Modales MathType-Fenster","close_modal_warning":"Bist du sicher, dass du das Programm verlassen willst? Alle vorgenommenen Änderungen gehen damit verloren.","latex_name_label":"Latex-Formel","browser_no_compatible":"Dein Browser ist nicht mit der AJAX-Technologie kompatibel. Verwende bitte die neueste Version von Mozilla Firefox.","error_convert_accessibility":"Fehler beim Konvertieren von MathML in barrierefreien Text.","exception_cross_site":"Cross-Site-Scripting ist nur bei HTTP zulässig.","exception_high_surrogate":"Hoher Ersatz bei bei festerZeichenkodierungbei() nicht von niedrigem Ersatz befolgt.","exception_string_length":"Ungültige Zeichenfolge. Länge muss ein Vielfaches von 4 sein.","exception_key_nonobject":"Object.keys wurde für ein Nicht-Objekt aufgerufen.","exception_null_or_undefined":" Das ist Null oder nicht definiert.","exception_not_function":" ist keine Funktion","exception_invalid_date_format":"Ungültiges Datumsformat: ","exception_casting":"Umwandlung nicht möglich ","exception_casting_to":" zu "},"el":{"latex":"LaTeX","cancel":"Άκυρο","accept":"Εισαγωγή","manual":"Χειροκίνητα","insert_math":"Εισαγωγή μαθηματικού τύπου - MathType","insert_chem":"Εισαγωγή χημικού τύπου - ChemType","minimize":"Ελαχιστοποίηση","maximize":"Μεγιστοποίηση","fullscreen":"Πλήρης οθόνη","exit_fullscreen":"Έξοδος από πλήρη οθόνη","close":"Κλείσιμο","mathtype":"MathType","title_modalwindow":"Τροπικό παράθυρο MathType","close_modal_warning":"Επιθυμείτε σίγουρα αποχώρηση; Θα χαθούν οι αλλαγές που έχετε κάνει.","latex_name_label":"Τύπος LaTeX","browser_no_compatible":"Το πρόγραμμα περιήγησής σας δεν είναι συμβατό με την τεχνολογία AJAX. Χρησιμοποιήστε την πιο πρόσφατη έκδοση του Mozilla Firefox.","error_convert_accessibility":"Σφάλμα κατά τη μετατροπή από MathML σε προσβάσιμο κείμενο.","exception_cross_site":"Το XSS (Cross site scripting) επιτρέπεται μόνο για HTTP.","exception_high_surrogate":"Το υψηλό υποκατάστατο δεν ακολουθείται από χαμηλό υποκατάστατο στο fixedCharCodeAt()","exception_string_length":"Μη έγκυρη συμβολοσειρά. Το μήκος πρέπει να είναι πολλαπλάσιο του 4","exception_key_nonobject":"Έγινε κλήση του Object.keys σε μη αντικείμενο","exception_null_or_undefined":" αυτό είναι μηδενικό ή δεν έχει οριστεί","exception_not_function":" δεν είναι συνάρτηση","exception_invalid_date_format":"Μη έγκυρη μορφή ημερομηνίας: ","exception_casting":"Δεν είναι δυνατή η μετατροπή ","exception_casting_to":" σε "},"en":{"latex":"LaTeX","cancel":"Cancel","accept":"Insert","manual":"Manual","insert_math":"Insert a math equation - MathType","insert_chem":"Insert a chemistry formula - ChemType","minimize":"Minimize","maximize":"Maximize","fullscreen":"Full-screen","exit_fullscreen":"Exit full-screen","close":"Close","mathtype":"MathType","title_modalwindow":"MathType modal window","close_modal_warning":"Are you sure you want to leave? The changes you made will be lost.","latex_name_label":"Latex Formula","browser_no_compatible":"Your browser is not compatible with AJAX technology. Please, use the latest version of Mozilla Firefox.","error_convert_accessibility":"Error converting from MathML to accessible text.","exception_cross_site":"Cross site scripting is only allowed for HTTP.","exception_high_surrogate":"High surrogate not followed by low surrogate in fixedCharCodeAt()","exception_string_length":"Invalid string. Length must be a multiple of 4","exception_key_nonobject":"Object.keys called on non-object","exception_null_or_undefined":" this is null or not defined","exception_not_function":" is not a function","exception_invalid_date_format":"Invalid date format : ","exception_casting":"Cannot cast ","exception_casting_to":" to "},"es":{"latex":"LaTeX","cancel":"Cancelar","accept":"Insertar","manual":"Manual","insert_math":"Insertar fórmula matemática - MathType","insert_chem":"Insertar fórmula química - ChemType","minimize":"Minimizar","maximize":"Maximizar","fullscreen":"Pantalla completa","exit_fullscreen":"Salir de pantalla completa","close":"Cerrar","mathtype":"MathType","title_modalwindow":"Ventana modal de MathType","close_modal_warning":"Seguro que quieres cerrar? Los cambios que has hecho se perderán","latex_name_label":"Formula en Latex","browser_no_compatible":"Tu navegador no es complatible con AJAX. Por favor, usa la última version de Mozilla Firefox.","error_convert_accessibility":"Error conviertiendo una fórmula MathML a texto accesible.","exception_cross_site":"Cross site scripting solo está permitido para HTTP.","exception_high_surrogate":"Subrogado alto no seguido por subrogado bajo en fixedCharCodeAt()","exception_string_length":"Cadena no válida. La longitud debe ser múltiplo de 4","exception_key_nonobject":"Object.keys called on non-object","exception_null_or_undefined":" esto es null o no definido","exception_not_function":" no es una función","exception_invalid_date_format":"Formato de fecha inválido: ","exception_casting":"No se puede emitir","exception_casting_to":" a "},"et":{"latex":"LaTeX","cancel":"Loobu","accept":"Lisa","manual":"Käsiraamat","insert_math":"Lisa matemaatiline valem – WIRIS","insert_chem":"Lisa keemiline valem – ChemType","minimize":"Minimeeri","maximize":"Maksimeeri","fullscreen":"Täiskuva","exit_fullscreen":"Välju täiskuvalt","close":"Sule","mathtype":"MathType","title_modalwindow":"MathType\'i modaalaken","close_modal_warning":"Kas soovite kindlasti lahkuda? Tehtud muudatused lähevad kaduma.","latex_name_label":"Latexi valem","browser_no_compatible":"Teie brauser ei ühildu AJAXi tehnoloogiaga. Palun kasutage Mozilla Firefoxi uusimat versiooni.","error_convert_accessibility":"Tõrge teisendamisel MathML-ist muudetavaks tekstiks.","exception_cross_site":"Ristskriptimine on lubatud ainult HTTP kasutamisel.","exception_high_surrogate":"Funktsioonis fixedCharCodeAt() ei järgne kõrgemale asendusliikmele madalam asendusliige.","exception_string_length":"Vigane string. Pikkus peab olema 4 kordne.","exception_key_nonobject":"Protseduur Object.keys kutsuti mitteobjekti korral.","exception_null_or_undefined":" see on null või määramata","exception_not_function":" ei ole funktsioon","exception_invalid_date_format":"Sobimatu kuupäeva kuju: ","exception_casting":"Esitamine ei õnnestu ","exception_casting_to":" – "},"eu":{"latex":"LaTeX","cancel":"Ezeztatu","accept":"Txertatu","manual":"Gida","insert_math":"Txertatu matematikako formula - MathType","insert_chem":"Txertatu formula kimiko bat - ChemType","minimize":"Ikonotu","maximize":"Maximizatu","fullscreen":"Pantaila osoa","exit_fullscreen":"Irten pantaila osotik","close":"Itxi","mathtype":"MathType","title_modalwindow":"MathType leiho modala","close_modal_warning":"Ziur irten nahi duzula? Egiten dituzun aldaketak galdu egingo dira.","latex_name_label":"LaTex Formula","browser_no_compatible":"Zure arakatzailea ez da bateragarria AJAX teknologiarekin. Erabili Mozilla Firefoxen azken bertsioa.","error_convert_accessibility":"Errorea MathMLtik testu irisgarrira bihurtzean.","exception_cross_site":"Gune arteko scriptak HTTPrako soilik onartzen dira.","exception_high_surrogate":"Ordezko baxuak ez dio ordezko altuari jarraitzen, hemen: fixedCharCodeAt()","exception_string_length":"Kate baliogabea. Luzerak 4ren multiploa izan behar du","exception_key_nonobject":"Object.keys deitu zaio objektua ez den zerbaiti","exception_null_or_undefined":" nulua edo definitu gabea da","exception_not_function":" ez da funtzio bat","exception_invalid_date_format":"Data-formatu baliogabea : ","exception_casting":"Ezin da igorri ","exception_casting_to":" honi "},"fi":{"latex":"LaTeX","cancel":"Peruuta","accept":"Lisää","manual":"Manual","insert_math":"Liitä matemaattinen kaava - MathType","insert_chem":"Lisää kemian kaava - ChemType","minimize":"Pienennä","maximize":"Suurenna","fullscreen":"Koko ruutu","exit_fullscreen":"Poistu koko ruudun tilasta","close":"Sulje","mathtype":"MathType","title_modalwindow":"MathTypen modaalinen ikkuna","close_modal_warning":"Oletko varma, että haluat poistua? Menetät tekemäsi muutokset.","latex_name_label":"Latex-kaava","browser_no_compatible":"Selaimesi ei tue AJAX-tekniikkaa. Ole hyvä ja käytä uusinta Firefox-versiota.","error_convert_accessibility":"Virhe muunnettaessa MathML:stä tekstiksi.","exception_cross_site":"Cross site scripting sallitaan vain HTTP:llä.","exception_high_surrogate":"fixedCharCodeAt(): yläsijaismerkkiä ei seurannut alasijaismerkki","exception_string_length":"Epäkelpo merkkijono. Pituuden on oltava 4:n kerrannainen","exception_key_nonobject":"Object.keys kutsui muuta kuin oliota","exception_null_or_undefined":" tämä on null tai ei määritelty","exception_not_function":" ei ole funktio","exception_invalid_date_format":"Virheellinen päivämäärämuoto : ","exception_casting":"Ei voida muuntaa tyyppiä ","exception_casting_to":" tyyppiin "},"fr":{"latex":"LaTeX","cancel":"Annuler","accept":"Insérer","manual":"Manuel","insert_math":"Insérer une formule mathématique - MathType","insert_chem":"Insérer une formule chimique - ChemType","minimize":"Minimiser","maximize":"Maximiser","fullscreen":"Plein écran","exit_fullscreen":"Quitter le plein écran","close":"Fermer","mathtype":"MathType","title_modalwindow":"Fenêtre modale MathType","close_modal_warning":"Confirmez-vous vouloir fermer ? Les changements effectués seront perdus.","latex_name_label":"Formule LaTeX","browser_no_compatible":"Votre navigateur n’est pas compatible avec la technologie AJAX. Veuillez utiliser la dernière version de Mozilla Firefox.","error_convert_accessibility":"Une erreur de conversion du format MathML en texte accessible est survenue.","exception_cross_site":"Le cross-site scripting n’est autorisé que pour HTTP.","exception_high_surrogate":"Substitut élevé non suivi d’un substitut inférieur dans fixedCharCodeAt()","exception_string_length":"Chaîne non valide. Longueur limitée aux multiples de 4","exception_key_nonobject":"Object.keys appelé sur un non-objet","exception_null_or_undefined":" nul ou non défini","exception_not_function":" n’est pas une fonction","exception_invalid_date_format":"Format de date non valide : ","exception_casting":"Impossible de convertir ","exception_casting_to":" sur "},"gl":{"latex":"LaTeX","cancel":"Cancelar","accept":"Inserir","manual":"Manual","insert_math":"Inserir unha fórmula matemática - MathType","insert_chem":"Inserir unha fórmula química - ChemType","minimize":"Minimizar","maximize":"Maximizar","fullscreen":"Pantalla completa","exit_fullscreen":"Saír da pantalla completa","close":"Pechar","mathtype":"MathType","title_modalwindow":"Ventá modal de MathType","close_modal_warning":"Seguro que quere saír? Perderanse os cambios realizados.","latex_name_label":"Fórmula Latex","browser_no_compatible":"O seu explorador non é compatible coa tecnoloxía AJAX. Use a versión máis recente de Mozilla Firefox.","error_convert_accessibility":"Erro ao converter de MathML a texto accesible.","exception_cross_site":"Os scripts de sitios só se permiten para HTTP.","exception_high_surrogate":"Suplente superior non seguido por suplente inferior en fixedCharCodeAt()","exception_string_length":"Cadea non válida. A lonxitude debe ser un múltiplo de 4","exception_key_nonobject":"Claves de obxecto chamadas en non obxecto","exception_null_or_undefined":" nulo ou non definido","exception_not_function":" non é unha función","exception_invalid_date_format":"Formato de data non válido: ","exception_casting":"Non se pode converter ","exception_casting_to":" a "},"he":{"latex":"LaTeX","cancel":"ביטול","accept":"הוסף","manual":"מדריך","insert_math":"הוסף נוסחה מתמטית - MathType","insert_chem":"הוספת כתיבה כימית - ChemType","minimize":"מזערי","maximize":"מרבי","fullscreen":"מסך מלא","exit_fullscreen":"יציאה ממצב מסך מלא","close":"סגירה","mathtype":"MathType","title_modalwindow":"חלון מודאלי של MathType","close_modal_warning":"האם לצאת? שינויים אשר בוצעו ימחקו.","latex_name_label":"נוסחת Latex","browser_no_compatible":"הדפדפן שלך אינו תואם לטכנולוגיית AJAX. יש להשתמש בגרסה העדכנית ביותר של Mozilla Firefox.","error_convert_accessibility":"שגיאה בהמרה מ-MathML לטקסט נגיש.","exception_cross_site":"סקריפטינג חוצה-אתרים מורשה עבור HTTP בלבד.","exception_high_surrogate":"ערך ממלא מקום גבוה אינו מופיע אחרי ערך ממלא מקום נמוך ב-fixedCharCodeAt()‎","exception_string_length":"מחרוזת לא חוקית. האורך חייב להיות כפולה של 4","exception_key_nonobject":"בוצעה קריאה אל Object.keys ברכיב שאינו אובייקט","exception_null_or_undefined":" הוא Null או לא מוגדר","exception_not_function":"איננה פונקציה","exception_invalid_date_format":"תסדיר תאריך אינו תקין : ","exception_casting":"לא ניתן להמיר ","exception_casting_to":" ל "},"hr":{"latex":"LaTeX","cancel":"Poništi","accept":"Umetni","manual":"Priručnik","insert_math":"Umetnite matematičku formulu - MathType","insert_chem":"Umetnite kemijsku formulu - ChemType","minimize":"Minimiziraj","maximize":"Maksimiziraj","fullscreen":"Cijeli zaslon","exit_fullscreen":"Izlaz iz prikaza na cijelom zaslonu","close":"Zatvori","mathtype":"MathType","title_modalwindow":"MathType modalni prozor","close_modal_warning":"Sigurno želite zatvoriti? Izgubit će se unesene promjene.","latex_name_label":"Latex formula","browser_no_compatible":"Vaš preglednik nije kompatibilan s AJAX tehnologijom. Upotrijebite najnoviju verziju Mozilla Firefoxa.","error_convert_accessibility":"Pogreška konverzije iz MathML-a u dostupni tekst.","exception_cross_site":"Skriptiranje na različitim web-mjestima dopušteno je samo za HTTP.","exception_high_surrogate":"Iza visoke zamjene ne slijedi niska zamjena u fixedCharCodeAt()","exception_string_length":"Nevažeći niz. Duljina mora biti višekratnik broja 4","exception_key_nonobject":"Object.keys pozvano na ne-objekt","exception_null_or_undefined":" ovo je nula ili nije definirano","exception_not_function":" nije funkcija","exception_invalid_date_format":"Nevažeći format datuma : ","exception_casting":"Ne može se poslati ","exception_casting_to":" na "},"hu":{"latex":"LaTeX","cancel":"Mégsem","accept":"Beszúrás","manual":"Kézikönyv","insert_math":"Matematikai képlet beszúrása - MathType","insert_chem":"Kémiai képet beillesztése - ChemType","minimize":"Kis méret","maximize":"Nagy méret","fullscreen":"Teljes képernyő","exit_fullscreen":"Teljes képernyő elhagyása","close":"Bezárás","mathtype":"MathType","title_modalwindow":"MathType modális ablak","close_modal_warning":"Biztosan kilép? A módosítások el fognak veszni.","latex_name_label":"Latex képlet","browser_no_compatible":"A böngészője nem kompatibilis az AJAX technológiával. Használja a Mozilla Firefox legújabb verzióját.","error_convert_accessibility":"Hiba lépett fel a MathML szöveggé történő konvertálása során.","exception_cross_site":"Az oldalak közti scriptelés csak HTTP esetén engedélyezett.","exception_high_surrogate":"A magas helyettesítő karaktert nem alacsony helyettesítő karakter követi a fixedCharCodeAt() esetében","exception_string_length":"Érvénytelen karakterlánc. A hossznak a 4 többszörösének kell lennie","exception_key_nonobject":"Az Object.keys egy nem objektumra került meghívásra","exception_null_or_undefined":" null vagy nem definiált","exception_not_function":" nem függvény","exception_invalid_date_format":"Érvénytelen dátumformátum: ","exception_casting":"Nem alkalmazható ","exception_casting_to":" erre "},"id":{"latex":"LaTeX","cancel":"Membatalkan","accept":"Masukkan","manual":"Manual","insert_math":"Masukkan rumus matematika - MathType","insert_chem":"Masukkan rumus kimia - ChemType","minimize":"Minikan","maximize":"Perbesar","fullscreen":"Layar penuh","exit_fullscreen":"Keluar layar penuh","close":"Tutup","mathtype":"MathType","title_modalwindow":"Jendela modal MathType","close_modal_warning":"Anda yakin ingin keluar? Anda akan kehilangan perubahan yang Anda buat.","latex_name_label":"Rumus Latex","browser_no_compatible":"Penjelajah Anda tidak kompatibel dengan teknologi AJAX. Harap gunakan Mozilla Firefox versi terbaru.","error_convert_accessibility":"Kesalahan konversi dari MathML menjadi teks yang dapat diakses.","exception_cross_site":"Skrip lintas situs hanya diizinkan untuk HTTP.","exception_high_surrogate":"Pengganti tinggi tidak diikuti oleh pengganti rendah di fixedCharCodeAt()","exception_string_length":"String tidak valid. Panjang harus kelipatan 4","exception_key_nonobject":"Object.keys meminta nonobjek","exception_null_or_undefined":" ini tidak berlaku atau tidak didefinisikan","exception_not_function":" bukan sebuah fungsi","exception_invalid_date_format":"Format tanggal tidak valid : ","exception_casting":"Tidak dapat mentransmisikan ","exception_casting_to":" untuk "},"it":{"latex":"LaTeX","cancel":"Annulla","accept":"Inserisci","manual":"Manuale","insert_math":"Inserisci una formula matematica - MathType","insert_chem":"Inserisci una formula chimica - ChemType","minimize":"Riduci a icona","maximize":"Ingrandisci","fullscreen":"Schermo intero","exit_fullscreen":"Esci da schermo intero","close":"Chiudi","mathtype":"MathType","title_modalwindow":"Finestra modale di MathType","close_modal_warning":"Confermi di voler uscire? Le modifiche effettuate andranno perse.","latex_name_label":"Formula LaTeX","browser_no_compatible":"Il tuo browser non è compatibile con la tecnologia AJAX. Utilizza la versione più recente di Mozilla Firefox.","error_convert_accessibility":"Errore durante la conversione da MathML in testo accessibile.","exception_cross_site":"Lo scripting tra siti è consentito solo per HTTP.","exception_high_surrogate":"Surrogato alto non seguito da surrogato basso in fixedCharCodeAt()","exception_string_length":"Stringa non valida. La lunghezza deve essere un multiplo di 4","exception_key_nonobject":"Metodo Object.keys richiamato in un elemento non oggetto","exception_null_or_undefined":" questo è un valore null o non definito","exception_not_function":" non è una funzione","exception_invalid_date_format":"Formato di data non valido: ","exception_casting":"Impossibile eseguire il cast ","exception_casting_to":" a "},"ja":{"latex":"LaTeX","cancel":"キャンセル","accept":"挿入","manual":"マニュアル","insert_math":"数式を挿入 - MathType","insert_chem":"化学式を挿入 - ChemType","minimize":"最小化","maximize":"最大化","fullscreen":"全画面表示","exit_fullscreen":"全画面表示を解除","close":"閉じる","mathtype":"MathType","title_modalwindow":"MathType モードウィンドウ","close_modal_warning":"このページから移動してもよろしいですか？変更内容は失われます。","latex_name_label":"LaTeX 数式","browser_no_compatible":"お使いのブラウザは、AJAX 技術と互換性がありません。Mozilla Firefox の最新バージョンをご使用ください。","error_convert_accessibility":"MathML からアクセシブルなテキストへの変換中にエラーが発生しました。","exception_cross_site":"クロスサイトスクリプティングは、HTTP のみに許可されています。","exception_high_surrogate":"fixedCharCodeAt（）で上位サロゲートの後に下位サロゲートがありません","exception_string_length":"無効な文字列です。長さは4の倍数である必要があります","exception_key_nonobject":"Object.keys が非オブジェクトで呼び出されました","exception_null_or_undefined":" null であるか、定義されていません","exception_not_function":" は関数ではありません","exception_invalid_date_format":"無効な日付形式: ","exception_casting":"次にキャスト ","exception_casting_to":" できません "},"ko":{"latex":"LaTeX","cancel":"취소","accept":"삽입","manual":"설명서","insert_math":"수학 공식 삽입 - MathType","insert_chem":"화학 공식 입력하기 - ChemType","minimize":"최소화","maximize":"최대화","fullscreen":"전체 화면","exit_fullscreen":"전체 화면 나가기","close":"닫기","mathtype":"MathType","title_modalwindow":"MathType 모달 창","close_modal_warning":"정말로 나가시겠습니까? 변경 사항이 손실됩니다.","latex_name_label":"Latex 공식","browser_no_compatible":"사용자의 브라우저는 AJAX 기술과 호환되지 않습니다. Mozilla Firefox 최신 버전을 사용하십시오.","error_convert_accessibility":"MathML로부터 접근 가능한 텍스트로 오류 변환.","exception_cross_site":"사이트 교차 스크립팅은 HTTP 환경에서만 사용할 수 있습니다.","exception_high_surrogate":"fixedCharCodeAt()에서는 상위 서러게이트 뒤에 하위 서러게이트가 붙지 않습니다","exception_string_length":"유효하지 않은 스트링입니다. 길이는 4의 배수여야 합니다","exception_key_nonobject":"Object.keys가 non-object를 요청하였습니다","exception_null_or_undefined":" Null값이거나 정의되지 않았습니다","exception_not_function":" 함수가 아닙니다","exception_invalid_date_format":"유효하지 않은 날짜 포맷 : ","exception_casting":"캐스팅할 수 없습니다 ","exception_casting_to":" (으)로 "},"nl":{"latex":"LaTeX","cancel":"Annuleren","insert_chem":"Een scheikundige formule invoegen - ChemType","minimize":"Minimaliseer","maximize":"Maximaliseer","fullscreen":"Schermvullend","exit_fullscreen":"Verlaat volledig scherm","close":"Sluit","mathtype":"MathType","title_modalwindow":"Modaal venster MathType","close_modal_warning":"Weet je zeker dat je de app wilt sluiten? De gemaakte wijzigingen gaan verloren.","latex_name_label":"LaTeX-formule","browser_no_compatible":"Je browser is niet compatibel met AJAX-technologie. Gebruik de meest recente versie van Mozilla Firefox.","error_convert_accessibility":"Fout bij conversie van MathML naar toegankelijke tekst.","exception_cross_site":"Cross-site scripting is alleen toegestaan voor HTTP.","exception_high_surrogate":"Hoog surrogaat niet gevolgd door laag surrogaat in fixedCharCodeAt()","exception_string_length":"Ongeldige tekenreeks. Lengte moet een veelvoud van 4 zijn","exception_key_nonobject":"Object.keys opgeroepen voor niet-object","exception_null_or_undefined":" dit is nul of niet gedefinieerd","exception_not_function":" is geen functie","exception_invalid_date_format":"Ongeldige datumnotatie: ","exception_casting":"Kan niet weergeven ","exception_casting_to":" op "},"no":{"latex":"LaTeX","cancel":"Avbryt","accept":"Set inn","manual":"Håndbok","insert_math":"Sett inn matematikkformel - MathType","insert_chem":"Set inn ein kjemisk formel – ChemType","minimize":"Minimer","maximize":"Maksimer","fullscreen":"Fullskjerm","exit_fullscreen":"Avslutt fullskjerm","close":"Lukk","mathtype":"MathType","title_modalwindow":"Modalt MathType-vindu","close_modal_warning":"Er du sikker på at du vil gå ut? Endringane du har gjort, vil gå tapt.","latex_name_label":"LaTeX-formel","browser_no_compatible":"Nettlesaren er ikkje kompatibel med AJAX-teknologien. Bruk den nyaste versjonen av Mozilla Firefox.","error_convert_accessibility":"Feil under konvertering frå MathML til tilgjengeleg tekst.","exception_cross_site":"Skripting på tvers av nettstadar er bere tillaten med HTTP.","exception_high_surrogate":"Høgt surrogat er ikkje etterfølgt av lågt surrogat i fixedCharCodeAt()","exception_string_length":"Ugyldig streng. Lengda må vera deleleg på 4","exception_key_nonobject":"Object.keys kalla på eit ikkje-objekt","exception_null_or_undefined":" dette er null eller ikkje definert","exception_not_function":" er ikkje ein funksjon","exception_invalid_date_format":"Ugyldig datoformat: ","exception_casting":"Kan ikkje bruka casting ","exception_casting_to":" til "},"nb":{"latex":"LaTeX","cancel":"Avbryt","accept":"Insert","manual":"Håndbok","insert_math":"Sett inn matematikkformel - MathType","insert_chem":"Sett inn en kjemisk formel – ChemType","minimize":"Minimer","maximize":"Maksimer","fullscreen":"Fullskjerm","exit_fullscreen":"Avslutt fullskjerm","close":"Lukk","mathtype":"MathType","title_modalwindow":"Modalt MathType-vindu","close_modal_warning":"Er du sikker på at du vil gå ut? Endringene du har gjort, vil gå tapt.","latex_name_label":"LaTeX-formel","browser_no_compatible":"Nettleseren er ikke kompatibel med AJAX-teknologien. Bruk den nyeste versjonen av Mozilla Firefox.","error_convert_accessibility":"Feil under konvertering fra MathML til tilgjengelig tekst.","exception_cross_site":"Skripting på tvers av nettsteder er bare tillatt med HTTP.","exception_high_surrogate":"Høyt surrogat etterfølges ikke av lavt surrogat i fixedCharCodeAt()","exception_string_length":"Ugyldig streng. Lengden må være delelig på 4","exception_key_nonobject":"Object.keys kalte på et ikke-objekt","exception_null_or_undefined":" dette er null eller ikke definert","exception_not_function":" er ikke en funksjon","exception_invalid_date_format":"Ugyldig datoformat: ","exception_casting":"Kan ikke bruke casting ","exception_casting_to":" til "},"nn":{"latex":"LaTeX","cancel":"Avbryt","accept":"Set inn","manual":"Håndbok","insert_math":"Sett inn matematikkformel - MathType","insert_chem":"Set inn ein kjemisk formel – ChemType","minimize":"Minimer","maximize":"Maksimer","fullscreen":"Fullskjerm","exit_fullscreen":"Avslutt fullskjerm","close":"Lukk","mathtype":"MathType","title_modalwindow":"Modalt MathType-vindu","close_modal_warning":"Er du sikker på at du vil gå ut? Endringane du har gjort, vil gå tapt.","latex_name_label":"LaTeX-formel","browser_no_compatible":"Nettlesaren er ikkje kompatibel med AJAX-teknologien. Bruk den nyaste versjonen av Mozilla Firefox.","error_convert_accessibility":"Feil under konvertering frå MathML til tilgjengeleg tekst.","exception_cross_site":"Skripting på tvers av nettstadar er bere tillaten med HTTP.","exception_high_surrogate":"Høgt surrogat er ikkje etterfølgt av lågt surrogat i fixedCharCodeAt()","exception_string_length":"Ugyldig streng. Lengda må vera deleleg på 4","exception_key_nonobject":"Object.keys kalla på eit ikkje-objekt","exception_null_or_undefined":" dette er null eller ikkje definert","exception_not_function":" er ikkje ein funksjon","exception_invalid_date_format":"Ugyldig datoformat: ","exception_casting":"Kan ikkje bruka casting ","exception_casting_to":" til "},"pl":{"latex":"LaTeX","cancel":"Anuluj","accept":"Wstaw","manual":"Instrukcja","insert_math":"Wstaw formułę matematyczną - MathType","insert_chem":"Wstaw wzór chemiczny — ChemType","minimize":"Minimalizuj","maximize":"Maksymalizuj","fullscreen":"Pełny ekran","exit_fullscreen":"Opuść tryb pełnoekranowy","close":"Zamknij","mathtype":"MathType","title_modalwindow":"Okno modalne MathType","close_modal_warning":"Czy na pewno chcesz zamknąć? Wprowadzone zmiany zostaną utracone.","latex_name_label":"Wzór Latex","browser_no_compatible":"Twoja przeglądarka jest niezgodna z technologią AJAX Użyj najnowszej wersji Mozilla Firefox.","error_convert_accessibility":"Błąd podczas konwertowania z formatu MathML na dostępny tekst.","exception_cross_site":"Krzyżowanie skryptów witryny jest dozwolone tylko dla HTTP.","exception_high_surrogate":"Brak niskiego surogatu po wysokim surogacie w fixedCharCodeAt()","exception_string_length":"Niewłaściwy ciąg znaków. Długość musi być wielokrotnością liczby 4.","exception_key_nonobject":"Argumentem wywołanej funkcji Object.key nie jest obiekt.","exception_null_or_undefined":" jest zerowy lub niezdefiniowany","exception_not_function":" nie jest funkcją","exception_invalid_date_format":"Nieprawidłowy format daty: ","exception_casting":"Nie można rzutować ","exception_casting_to":" na "},"pt":{"latex":"LaTeX","cancel":"Cancelar","accept":"Inserir","manual":"Manual","insert_math":"Inserir fórmula matemática - MathType","insert_chem":"Inserir uma fórmula química - ChemType","minimize":"Minimizar","maximize":"Maximizar","fullscreen":"Ecrã completo","exit_fullscreen":"Sair do ecrã completo","close":"Fechar","mathtype":"MathType","title_modalwindow":"Janela modal do MathType","close_modal_warning":"Pretende sair? As alterações efetuadas serão perdidas.","latex_name_label":"Fórmula Latex","browser_no_compatible":"O seu navegador não é compatível com a tecnologia AJAX. Utilize a versão mais recente do Mozilla Firefox.","error_convert_accessibility":"Erro ao converter de MathML para texto acessível.","exception_cross_site":"O processamento de scripts em vários sites só é permitido para HTTP.","exception_high_surrogate":"Substituto alto não seguido por um substituto baixo em fixedCharCodeAt()","exception_string_length":"Cadeia inválida. O comprimento tem de ser um múltiplo de 4","exception_key_nonobject":"Object.keys chamou um não-objeto","exception_null_or_undefined":" é nulo ou não está definido","exception_not_function":" não é uma função","exception_invalid_date_format":"Formato de data inválido: ","exception_casting":"Não é possível adicionar ","exception_casting_to":" até "},"pt_br":{"latex":"LaTeX","cancel":"Cancelar","accept":"Inserir","manual":"Manual","insert_math":"Inserir fórmula matemática - MathType","insert_chem":"Insira uma fórmula química - ChemType","minimize":"Minimizar","maximize":"Maximizar","fullscreen":"Tela cheia","exit_fullscreen":"Sair de tela cheia","close":"Fechar","mathtype":"MathType","title_modalwindow":"Janela modal do MathType","close_modal_warning":"Tem certeza de que deseja sair? Todas as alterações serão perdidas.","latex_name_label":"Fórmula LaTeX","browser_no_compatible":"O navegador não é compatível com a tecnologia AJAX. Use a versão mais recente do Mozilla Firefox.","error_convert_accessibility":"Erro ao converter de MathML para texto acessível.","exception_cross_site":"O uso de scripts entre sites só é permitido para HTTP.","exception_high_surrogate":"High surrogate não seguido de low surrogate em fixedCharCodeAt()","exception_string_length":"String inválida. O comprimento deve ser um múltiplo de 4","exception_key_nonobject":"Object.keys chamados em não objeto","exception_null_or_undefined":" isto é nulo ou não definido","exception_not_function":" não é uma função","exception_invalid_date_format":"Formato de data inválido: ","exception_casting":"Não é possível transmitir ","exception_casting_to":" para "},"ro":{"latex":"LaTeX","cancel":"Anulare","accept":"Inserați","manual":"Ghid","insert_math":"Inserați o formulă matematică - MathType","insert_chem":"Inserați o formulă chimică - ChemType","minimize":"Minimizați","maximize":"Maximizați","fullscreen":"Afișați pe tot ecranul","exit_fullscreen":"Opriți afișarea pe tot ecranul","close":"Închideți","mathtype":"MathType","title_modalwindow":"Fereastră modală MathType","close_modal_warning":"Sigur doriți să ieșiți? Modificările realizate se vor pierde.","latex_name_label":"Formulă Latex","browser_no_compatible":"Browserul dvs. nu este compatibil cu tehnologia AJAX. Utilizați cea mai recentă versiune de Mozilla Firefox.","error_convert_accessibility":"Eroare la convertirea din MathML în text accesibil.","exception_cross_site":"Scriptarea între site‑uri este permisă doar pentru HTTP.","exception_high_surrogate":"Surogatul superior nu este urmat de un surogat inferior în fixedCharCodeAt()","exception_string_length":"Șir nevalid. Lungimea trebuie să fie multiplu de 4","exception_key_nonobject":"Object.keys a apelat un non-obiect","exception_null_or_undefined":" este null sau nu este definit","exception_not_function":" nu este funcție","exception_invalid_date_format":"Format de dată nevalid: ","exception_casting":"nu se poate difuza ","exception_casting_to":" către "},"ru":{"latex":"LaTeX","cancel":"отмена","accept":"Вставка","manual":"вручную","insert_math":"Вставить математическую формулу: WIRIS","insert_chem":"Вставить химическую формулу — ChemType","minimize":"Свернуть","maximize":"Развернуть","fullscreen":"На весь экран","exit_fullscreen":"Выйти из полноэкранного режима","close":"Закрыть","mathtype":"MathType","title_modalwindow":"Режимное окно MathType","close_modal_warning":"Вы уверены, что хотите выйти? Все внесенные изменения будут утрачены.","latex_name_label":"Формула Latex","browser_no_compatible":"Ваш браузер несовместим с технологией AJAX. Используйте последнюю версию Mozilla Firefox.","error_convert_accessibility":"При преобразовании формулы в текст допустимого формата произошла ошибка.","exception_cross_site":"Межсайтовые сценарии доступны только для HTTP.","exception_high_surrogate":"Младший символ-заместитель не сопровождает старший символ-заместитель в исправленном методе CharCodeAt()","exception_string_length":"Недопустимая строка. Длинна должна быть кратной 4.","exception_key_nonobject":"Метод Object.keys вызван не для объекта","exception_null_or_undefined":" значение пустое или не определено","exception_not_function":" не функция","exception_invalid_date_format":"Недопустимый формат даты: ","exception_casting":"Не удается привести ","exception_casting_to":" к "},"sv":{"latex":"LaTeX","cancel":"Avbryt","accept":"Infoga","manual":"Bruksanvisning","insert_math":"Infoga matematisk formel - MathType","insert_chem":"Infoga en kemiformel – ChemType","minimize":"Minimera","maximize":"Maximera","fullscreen":"Helskärm","exit_fullscreen":"Stäng helskärm","close":"Stäng","mathtype":"MathType","title_modalwindow":"MathType modulfönster","close_modal_warning":"Vill du avsluta? Inga ändringar kommer att sparas.","latex_name_label":"Latex-formel","browser_no_compatible":"Din webbläsare är inte kompatibel med AJAX-teknik. Använd den senaste versionen av Mozilla Firefox.","error_convert_accessibility":"Det uppstod ett fel vid konvertering från MathML till åtkomlig text.","exception_cross_site":"Skriptkörning över flera sajter är endast tillåtet för HTTP.","exception_high_surrogate":"Hög surrogat följs inte av låg surrogat i fixedCharCodeAt()","exception_string_length":"Ogiltig sträng. Längden måste vara en multipel av 4","exception_key_nonobject":"Object.keys anropade icke-objekt","exception_null_or_undefined":" det är null eller inte definierat","exception_not_function":" är inte en funktion","exception_invalid_date_format":"Ogiltigt datumformat: ","exception_casting":"Går inte att konvertera ","exception_casting_to":" till "},"tr":{"latex":"LaTeX","cancel":"Vazgeç","accept":"Ekle","manual":"Kılavuz","insert_math":"Matematik formülü ekle - MathType","insert_chem":"Kimya formülü ekleyin - ChemType","minimize":"Simge Durumuna Küçült","maximize":"Ekranı Kapla","fullscreen":"Tam Ekran","exit_fullscreen":"Tam Ekrandan Çık","close":"Kapat","mathtype":"MathType","title_modalwindow":"MathType kalıcı penceresi","close_modal_warning":"Çıkmak istediğinizden emin misiniz? Yaptığınız değişiklikler kaybolacak.","latex_name_label":"Latex Formülü","browser_no_compatible":"Tarayıcınız AJAX teknolojisiyle uyumlu değil. Lütfen en güncel Mozilla Firefox sürümünü kullanın.","error_convert_accessibility":"MathML biçiminden erişilebilir metne dönüştürme hatası.","exception_cross_site":"Siteler arası komut dosyası yazma işlemine yalnızca HTTP için izin verilir.","exception_high_surrogate":"fixedCharCodeAt() fonksiyonunda üst vekilin ardından alt vekil gelmiyor","exception_string_length":"Geçersiz dizgi. Uzunluk, 4\'ün katlarından biri olmalıdır","exception_key_nonobject":"Nesne olmayan öğe üzerinde Object.keys çağrıldı","exception_null_or_undefined":" bu değer boş veya tanımlanmamış","exception_not_function":" bir fonksiyon değil","exception_invalid_date_format":"Geçersiz tarih biçimi: ","exception_casting":"Tür dönüştürülemiyor ","exception_casting_to":" hedef: "},"zh":{"latex":"LaTeX","cancel":"取消","accept":"插入","manual":"手册","insert_math":"插入数学公式 - MathType","insert_chem":"插入化学分子式 - ChemType","minimize":"最小化","maximize":"最大化","fullscreen":"全屏幕","exit_fullscreen":"退出全屏幕","close":"关闭","mathtype":"MathType","title_modalwindow":"MathType 模式窗口","close_modal_warning":"您确定要离开吗？您所做的修改将丢失。","latex_name_label":"Latex 分子式","browser_no_compatible":"您的浏览器不兼容 AJAX 技术。请使用最新版 Mozilla Firefox。","error_convert_accessibility":"将 MathML 转换为可访问文本时出错。","exception_cross_site":"仅 HTTP 允许跨站脚本。","exception_high_surrogate":"fixedCharCodeAt() 中的高位代理之后未跟随低位代理","exception_string_length":"无效字符串。长度必须是 4 的倍数","exception_key_nonobject":"非对象调用了 Object.keys","exception_null_or_undefined":" 该值为空或未定义","exception_not_function":" 不是一个函数","exception_invalid_date_format":"无效日期格式： ","exception_casting":"无法转换 ","exception_casting_to":" 为 "},"":{}}')
    }, function (module, __webpack_exports__, __webpack_require__) {
        "use strict";
        var md5;
        var _unused_webpack_default_export = md5;
        (function () {
            var HxOverrides = function () {
            };
            HxOverrides.__name__ = true;
            HxOverrides.dateStr = function (t) {
                var e = t.getMonth() + 1;
                var n = t.getDate();
                var i = t.getHours();
                var o = t.getMinutes();
                var r = t.getSeconds();
                return t.getFullYear() + "-" + (e < 10 ? "0" + e : "" + e) + "-" + (n < 10 ? "0" + n : "" + n) + " " + (i < 10 ? "0" + i : "" + i) + ":" + (o < 10 ? "0" + o : "" + o) + ":" + (r < 10 ? "0" + r : "" + r)
            };
            HxOverrides.strDate = function (t) {
                switch (t.length) {
                    case 8:
                        var e = t.split(":");
                        var n = new Date;
                        n.setTime(0);
                        n.setUTCHours(e[0]);
                        n.setUTCMinutes(e[1]);
                        n.setUTCSeconds(e[2]);
                        return n;
                    case 10:
                        var e = t.split("-");
                        return new Date(e[0], e[1] - 1, e[2], 0, 0, 0);
                    case 19:
                        var e = t.split(" ");
                        var i = e[0].split("-");
                        var o = e[1].split(":");
                        return new Date(i[0], i[1] - 1, i[2], o[0], o[1], o[2]);
                    default:
                        throw"Invalid date format : " + t
                }
            };
            HxOverrides.cca = function (t, e) {
                var n = t.charCodeAt(e);
                if (n != n) return undefined;
                return n
            };
            HxOverrides.substr = function (t, e, n) {
                if (e != null && e != 0 && n != null && n < 0) return "";
                if (n == null) n = t.length;
                if (e < 0) {
                    e = t.length + e;
                    if (e < 0) e = 0
                } else if (n < 0) n = t.length + n - e;
                return t.substr(e, n)
            };
            HxOverrides.remove = function (t, e) {
                var n = 0;
                var i = t.length;
                while (n < i) {
                    if (t[n] == e) {
                        t.splice(n, 1);
                        return true
                    }
                    n++
                }
                return false
            };
            HxOverrides.iter = function (t) {
                return {
                    cur: 0, arr: t, hasNext: function () {
                        return this.cur < this.arr.length
                    }, next: function () {
                        return this.arr[this.cur++]
                    }
                }
            };
            var IntIter = function (t, e) {
                this.min = t;
                this.max = e
            };
            IntIter.__name__ = true;
            IntIter.prototype = {
                next: function () {
                    return this.min++
                }, hasNext: function () {
                    return this.min < this.max
                }, __class__: IntIter
            };
            var Std = function () {
            };
            Std.__name__ = true;
            Std["is"] = function (t, e) {
                return js.Boot.__instanceof(t, e)
            };
            Std.string = function (t) {
                return js.Boot.__string_rec(t, "")
            };
            Std["int"] = function (t) {
                return t | 0
            };
            Std.parseInt = function (t) {
                var e = parseInt(t, 10);
                if (e == 0 && (HxOverrides.cca(t, 1) == 120 || HxOverrides.cca(t, 1) == 88)) e = parseInt(t);
                if (isNaN(e)) return null;
                return e
            };
            Std.parseFloat = function (t) {
                return parseFloat(t)
            };
            Std.random = function (t) {
                return Math.floor(Math.random() * t)
            };
            var com = com || {};
            if (!com.wiris) com.wiris = {};
            if (!com.wiris.js) com.wiris.js = {};
            com.wiris.js.JsPluginTools = function () {
                this.tryReady()
            };
            com.wiris.js.JsPluginTools.__name__ = true;
            com.wiris.js.JsPluginTools.main = function () {
                var t;
                t = com.wiris.js.JsPluginTools.getInstance();
                haxe.Timer.delay($bind(t, t.tryReady), 100)
            };
            com.wiris.js.JsPluginTools.getInstance = function () {
                if (com.wiris.js.JsPluginTools.instance == null) com.wiris.js.JsPluginTools.instance = new com.wiris.js.JsPluginTools;
                return com.wiris.js.JsPluginTools.instance
            };
            com.wiris.js.JsPluginTools.bypassEncapsulation = function () {
                if (window.com == null) window.com = {};
                if (window.com.wiris == null) window.com.wiris = {};
                if (window.com.wiris.js == null) window.com.wiris.js = {};
                if (window.com.wiris.js.JsPluginTools == null) window.com.wiris.js.JsPluginTools = com.wiris.js.JsPluginTools.getInstance()
            };
            com.wiris.js.JsPluginTools.prototype = {
                md5encode: function (t) {
                    return haxe.Md5.encode(t)
                }, doLoad: function () {
                    this.ready = true;
                    com.wiris.js.JsPluginTools.instance = this;
                    com.wiris.js.JsPluginTools.bypassEncapsulation()
                }, tryReady: function () {
                    this.ready = false;
                    if (js.Lib.document.readyState) {
                        this.doLoad();
                        this.ready = true
                    }
                    if (!this.ready) haxe.Timer.delay($bind(this, this.tryReady), 100)
                }, __class__: com.wiris.js.JsPluginTools
            };
            var haxe = haxe || {};
            haxe.Log = function () {
            };
            haxe.Log.__name__ = true;
            haxe.Log.trace = function (t, e) {
                js.Boot.__trace(t, e)
            };
            haxe.Log.clear = function () {
                js.Boot.__clear_trace()
            };
            haxe.Md5 = function () {
            };
            haxe.Md5.__name__ = true;
            haxe.Md5.encode = function (t) {
                return (new haxe.Md5).doEncode(t)
            };
            haxe.Md5.prototype = {
                doEncode: function (t) {
                    var e = this.str2blks(t);
                    var n = 1732584193;
                    var i = -271733879;
                    var o = -1732584194;
                    var r = 271733878;
                    var s;
                    var a = 0;
                    while (a < e.length) {
                        var c = n;
                        var l = i;
                        var d = o;
                        var u = r;
                        s = 0;
                        n = this.ff(n, i, o, r, e[a], 7, -680876936);
                        r = this.ff(r, n, i, o, e[a + 1], 12, -389564586);
                        o = this.ff(o, r, n, i, e[a + 2], 17, 606105819);
                        i = this.ff(i, o, r, n, e[a + 3], 22, -1044525330);
                        n = this.ff(n, i, o, r, e[a + 4], 7, -176418897);
                        r = this.ff(r, n, i, o, e[a + 5], 12, 1200080426);
                        o = this.ff(o, r, n, i, e[a + 6], 17, -1473231341);
                        i = this.ff(i, o, r, n, e[a + 7], 22, -45705983);
                        n = this.ff(n, i, o, r, e[a + 8], 7, 1770035416);
                        r = this.ff(r, n, i, o, e[a + 9], 12, -1958414417);
                        o = this.ff(o, r, n, i, e[a + 10], 17, -42063);
                        i = this.ff(i, o, r, n, e[a + 11], 22, -1990404162);
                        n = this.ff(n, i, o, r, e[a + 12], 7, 1804603682);
                        r = this.ff(r, n, i, o, e[a + 13], 12, -40341101);
                        o = this.ff(o, r, n, i, e[a + 14], 17, -1502002290);
                        i = this.ff(i, o, r, n, e[a + 15], 22, 1236535329);
                        n = this.gg(n, i, o, r, e[a + 1], 5, -165796510);
                        r = this.gg(r, n, i, o, e[a + 6], 9, -1069501632);
                        o = this.gg(o, r, n, i, e[a + 11], 14, 643717713);
                        i = this.gg(i, o, r, n, e[a], 20, -373897302);
                        n = this.gg(n, i, o, r, e[a + 5], 5, -701558691);
                        r = this.gg(r, n, i, o, e[a + 10], 9, 38016083);
                        o = this.gg(o, r, n, i, e[a + 15], 14, -660478335);
                        i = this.gg(i, o, r, n, e[a + 4], 20, -405537848);
                        n = this.gg(n, i, o, r, e[a + 9], 5, 568446438);
                        r = this.gg(r, n, i, o, e[a + 14], 9, -1019803690);
                        o = this.gg(o, r, n, i, e[a + 3], 14, -187363961);
                        i = this.gg(i, o, r, n, e[a + 8], 20, 1163531501);
                        n = this.gg(n, i, o, r, e[a + 13], 5, -1444681467);
                        r = this.gg(r, n, i, o, e[a + 2], 9, -51403784);
                        o = this.gg(o, r, n, i, e[a + 7], 14, 1735328473);
                        i = this.gg(i, o, r, n, e[a + 12], 20, -1926607734);
                        n = this.hh(n, i, o, r, e[a + 5], 4, -378558);
                        r = this.hh(r, n, i, o, e[a + 8], 11, -2022574463);
                        o = this.hh(o, r, n, i, e[a + 11], 16, 1839030562);
                        i = this.hh(i, o, r, n, e[a + 14], 23, -35309556);
                        n = this.hh(n, i, o, r, e[a + 1], 4, -1530992060);
                        r = this.hh(r, n, i, o, e[a + 4], 11, 1272893353);
                        o = this.hh(o, r, n, i, e[a + 7], 16, -155497632);
                        i = this.hh(i, o, r, n, e[a + 10], 23, -1094730640);
                        n = this.hh(n, i, o, r, e[a + 13], 4, 681279174);
                        r = this.hh(r, n, i, o, e[a], 11, -358537222);
                        o = this.hh(o, r, n, i, e[a + 3], 16, -722521979);
                        i = this.hh(i, o, r, n, e[a + 6], 23, 76029189);
                        n = this.hh(n, i, o, r, e[a + 9], 4, -640364487);
                        r = this.hh(r, n, i, o, e[a + 12], 11, -421815835);
                        o = this.hh(o, r, n, i, e[a + 15], 16, 530742520);
                        i = this.hh(i, o, r, n, e[a + 2], 23, -995338651);
                        n = this.ii(n, i, o, r, e[a], 6, -198630844);
                        r = this.ii(r, n, i, o, e[a + 7], 10, 1126891415);
                        o = this.ii(o, r, n, i, e[a + 14], 15, -1416354905);
                        i = this.ii(i, o, r, n, e[a + 5], 21, -57434055);
                        n = this.ii(n, i, o, r, e[a + 12], 6, 1700485571);
                        r = this.ii(r, n, i, o, e[a + 3], 10, -1894986606);
                        o = this.ii(o, r, n, i, e[a + 10], 15, -1051523);
                        i = this.ii(i, o, r, n, e[a + 1], 21, -2054922799);
                        n = this.ii(n, i, o, r, e[a + 8], 6, 1873313359);
                        r = this.ii(r, n, i, o, e[a + 15], 10, -30611744);
                        o = this.ii(o, r, n, i, e[a + 6], 15, -1560198380);
                        i = this.ii(i, o, r, n, e[a + 13], 21, 1309151649);
                        n = this.ii(n, i, o, r, e[a + 4], 6, -145523070);
                        r = this.ii(r, n, i, o, e[a + 11], 10, -1120210379);
                        o = this.ii(o, r, n, i, e[a + 2], 15, 718787259);
                        i = this.ii(i, o, r, n, e[a + 9], 21, -343485551);
                        n = this.addme(n, c);
                        i = this.addme(i, l);
                        o = this.addme(o, d);
                        r = this.addme(r, u);
                        a += 16
                    }
                    return this.rhex(n) + this.rhex(i) + this.rhex(o) + this.rhex(r)
                }, ii: function (t, e, n, i, o, r, s) {
                    return this.cmn(this.bitXOR(n, this.bitOR(e, ~i)), t, e, o, r, s)
                }, hh: function (t, e, n, i, o, r, s) {
                    return this.cmn(this.bitXOR(this.bitXOR(e, n), i), t, e, o, r, s)
                }, gg: function (t, e, n, i, o, r, s) {
                    return this.cmn(this.bitOR(this.bitAND(e, i), this.bitAND(n, ~i)), t, e, o, r, s)
                }, ff: function (t, e, n, i, o, r, s) {
                    return this.cmn(this.bitOR(this.bitAND(e, n), this.bitAND(~e, i)), t, e, o, r, s)
                }, cmn: function (t, e, n, i, o, r) {
                    return this.addme(this.rol(this.addme(this.addme(e, t), this.addme(i, r)), o), n)
                }, rol: function (t, e) {
                    return t << e | t >>> 32 - e
                }, str2blks: function (t) {
                    var e = (t.length + 8 >> 6) + 1;
                    var n = new Array;
                    var i = 0, o = e * 16;
                    while (i < o) {
                        var r = i++;
                        n[r] = 0
                    }
                    var r = 0;
                    while (r < t.length) {
                        n[r >> 2] |= HxOverrides.cca(t, r) << (t.length * 8 + r) % 4 * 8;
                        r++
                    }
                    n[r >> 2] |= 128 << (t.length * 8 + r) % 4 * 8;
                    var s = t.length * 8;
                    var a = e * 16 - 2;
                    n[a] = s & 255;
                    n[a] |= (s >>> 8 & 255) << 8;
                    n[a] |= (s >>> 16 & 255) << 16;
                    n[a] |= (s >>> 24 & 255) << 24;
                    return n
                }, rhex: function (t) {
                    var e = "";
                    var n = "0123456789abcdef";
                    var i = 0;
                    while (i < 4) {
                        var o = i++;
                        e += n.charAt(t >> o * 8 + 4 & 15) + n.charAt(t >> o * 8 & 15)
                    }
                    return e
                }, addme: function (t, e) {
                    var n = (t & 65535) + (e & 65535);
                    var i = (t >> 16) + (e >> 16) + (n >> 16);
                    return i << 16 | n & 65535
                }, bitAND: function (t, e) {
                    var n = t & 1 & (e & 1);
                    var i = t >>> 1 & e >>> 1;
                    return i << 1 | n
                }, bitXOR: function (t, e) {
                    var n = t & 1 ^ e & 1;
                    var i = t >>> 1 ^ e >>> 1;
                    return i << 1 | n
                }, bitOR: function (t, e) {
                    var n = t & 1 | e & 1;
                    var i = t >>> 1 | e >>> 1;
                    return i << 1 | n
                }, __class__: haxe.Md5
            };
            haxe.Timer = function (t) {
                var e = this;
                this.id = window.setInterval((function () {
                    e.run()
                }), t)
            };
            haxe.Timer.__name__ = true;
            haxe.Timer.delay = function (t, e) {
                var n = new haxe.Timer(e);
                n.run = function () {
                    n.stop();
                    t()
                };
                return n
            };
            haxe.Timer.measure = function (t, e) {
                var n = haxe.Timer.stamp();
                var i = t();
                haxe.Log.trace(haxe.Timer.stamp() - n + "s", e);
                return i
            };
            haxe.Timer.stamp = function () {
                return (new Date).getTime() / 1e3
            };
            haxe.Timer.prototype = {
                run: function () {
                }, stop: function () {
                    if (this.id == null) return;
                    window.clearInterval(this.id);
                    this.id = null
                }, __class__: haxe.Timer
            };
            var js = js || {};
            js.Boot = function () {
            };
            js.Boot.__name__ = true;
            js.Boot.__unhtml = function (t) {
                return t.split("&").join("&amp;").split("<").join("&lt;").split(">").join("&gt;")
            };
            js.Boot.__trace = function (t, e) {
                var n = e != null ? e.fileName + ":" + e.lineNumber + ": " : "";
                n += js.Boot.__string_rec(t, "");
                var i;
                if (typeof document != "undefined" && (i = document.getElementById("haxe:trace")) != null) i.innerHTML += js.Boot.__unhtml(n) + "<br/>"; else if (typeof console != "undefined" && console.log != null) console.log(n)
            };
            js.Boot.__clear_trace = function () {
                var t = document.getElementById("haxe:trace");
                if (t != null) t.innerHTML = ""
            };
            js.Boot.isClass = function (t) {
                return t.__name__
            };
            js.Boot.isEnum = function (t) {
                return t.__ename__
            };
            js.Boot.getClass = function (t) {
                return t.__class__
            };
            js.Boot.__string_rec = function (t, e) {
                if (t == null) return "null";
                if (e.length >= 5) return "<...>";
                var n = typeof t;
                if (n == "function" && (t.__name__ || t.__ename__)) n = "object";
                switch (n) {
                    case"object":
                        if (t instanceof Array) {
                            if (t.__enum__) {
                                if (t.length == 2) return t[0];
                                var i = t[0] + "(";
                                e += "\t";
                                var o = 2, r = t.length;
                                while (o < r) {
                                    var s = o++;
                                    if (s != 2) i += "," + js.Boot.__string_rec(t[s], e); else i += js.Boot.__string_rec(t[s], e)
                                }
                                return i + ")"
                            }
                            var a = t.length;
                            var s;
                            var i = "[";
                            e += "\t";
                            var r = 0;
                            while (r < a) {
                                var c = r++;
                                i += (c > 0 ? "," : "") + js.Boot.__string_rec(t[c], e)
                            }
                            i += "]";
                            return i
                        }
                        var l;
                        try {
                            l = t.toString
                        } catch (t) {
                            return "???"
                        }
                        if (l != null && l != Object.toString) {
                            var d = t.toString();
                            if (d != "[object Object]") return d
                        }
                        var u = null;
                        var i = "{\n";
                        e += "\t";
                        var h = t.hasOwnProperty != null;
                        for (var u in t) {
                            if (h && !t.hasOwnProperty(u)) {
                                continue
                            }
                            if (u == "prototype" || u == "__class__" || u == "__super__" || u == "__interfaces__" || u == "__properties__") {
                                continue
                            }
                            if (i.length != 2) i += ", \n";
                            i += e + u + " : " + js.Boot.__string_rec(t[u], e)
                        }
                        e = e.substring(1);
                        i += "\n" + e + "}";
                        return i;
                    case"function":
                        return "<function>";
                    case"string":
                        return t;
                    default:
                        return String(t)
                }
            };
            js.Boot.__interfLoop = function (t, e) {
                if (t == null) return false;
                if (t == e) return true;
                var n = t.__interfaces__;
                if (n != null) {
                    var i = 0, o = n.length;
                    while (i < o) {
                        var r = i++;
                        var s = n[r];
                        if (s == e || js.Boot.__interfLoop(s, e)) return true
                    }
                }
                return js.Boot.__interfLoop(t.__super__, e)
            };
            js.Boot.__instanceof = function (t, e) {
                try {
                    if (t instanceof e) {
                        if (e == Array) return t.__enum__ == null;
                        return true
                    }
                    if (js.Boot.__interfLoop(t.__class__, e)) return true
                } catch (t) {
                    if (e == null) return false
                }
                switch (e) {
                    case Int:
                        return Math.ceil(t % 2147483648) === t;
                    case Float:
                        return typeof t == "number";
                    case Bool:
                        return t === true || t === false;
                    case String:
                        return typeof t == "string";
                    case Dynamic:
                        return true;
                    default:
                        if (t == null) return false;
                        if (e == Class && t.__name__ != null) return true; else null;
                        if (e == Enum && t.__ename__ != null) return true; else null;
                        return t.__enum__ == e
                }
            };
            js.Boot.__cast = function (t, e) {
                if (js.Boot.__instanceof(t, e)) return t; else throw"Cannot cast " + Std.string(t) + " to " + Std.string(e)
            };
            js.Lib = function () {
            };
            js.Lib.__name__ = true;
            js.Lib.debug = function () {
                debugger
            };
            js.Lib.alert = function (t) {
                alert(js.Boot.__string_rec(t, ""))
            };
            js.Lib.eval = function (code) {
                return eval(code)
            };
            js.Lib.setErrorHandler = function (t) {
                js.Lib.onerror = t
            };
            var $_;

            function $bind(t, e) {
                var n = function () {
                    return n.method.apply(n.scope, arguments)
                };
                n.scope = t;
                n.method = e;
                return n
            }

            if (Array.prototype.indexOf) HxOverrides.remove = function (t, e) {
                var n = t.indexOf(e);
                if (n == -1) return false;
                t.splice(n, 1);
                return true
            }; else null;
            Math.__name__ = ["Math"];
            Math.NaN = Number.NaN;
            Math.NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY;
            Math.POSITIVE_INFINITY = Number.POSITIVE_INFINITY;
            Math.isFinite = function (t) {
                return isFinite(t)
            };
            Math.isNaN = function (t) {
                return isNaN(t)
            };
            String.prototype.__class__ = String;
            String.__name__ = true;
            Array.prototype.__class__ = Array;
            Array.__name__ = true;
            Date.prototype.__class__ = Date;
            Date.__name__ = ["Date"];
            var Int = {__name__: ["Int"]};
            var Dynamic = {__name__: ["Dynamic"]};
            var Float = Number;
            Float.__name__ = ["Float"];
            var Bool = Boolean;
            Bool.__ename__ = ["Bool"];
            var Class = {__name__: ["Class"]};
            var Enum = {};
            var Void = {__ename__: ["Void"]};
            if (typeof document != "undefined") js.Lib.document = document;
            if (typeof window != "undefined") {
                js.Lib.window = window;
                js.Lib.window.onerror = function (t, e, n) {
                    var i = js.Lib.onerror;
                    if (i == null) return false;
                    return i(t, [e + ":" + n])
                }
            }
            com.wiris.js.JsPluginTools.main();
            delete Array.prototype.__class__
        })();
        (function () {
            var HxOverrides = function () {
            };
            HxOverrides.__name__ = true;
            HxOverrides.dateStr = function (t) {
                var e = t.getMonth() + 1;
                var n = t.getDate();
                var i = t.getHours();
                var o = t.getMinutes();
                var r = t.getSeconds();
                return t.getFullYear() + "-" + (e < 10 ? "0" + e : "" + e) + "-" + (n < 10 ? "0" + n : "" + n) + " " + (i < 10 ? "0" + i : "" + i) + ":" + (o < 10 ? "0" + o : "" + o) + ":" + (r < 10 ? "0" + r : "" + r)
            };
            HxOverrides.strDate = function (t) {
                switch (t.length) {
                    case 8:
                        var e = t.split(":");
                        var n = new Date;
                        n.setTime(0);
                        n.setUTCHours(e[0]);
                        n.setUTCMinutes(e[1]);
                        n.setUTCSeconds(e[2]);
                        return n;
                    case 10:
                        var e = t.split("-");
                        return new Date(e[0], e[1] - 1, e[2], 0, 0, 0);
                    case 19:
                        var e = t.split(" ");
                        var i = e[0].split("-");
                        var o = e[1].split(":");
                        return new Date(i[0], i[1] - 1, i[2], o[0], o[1], o[2]);
                    default:
                        throw"Invalid date format : " + t
                }
            };
            HxOverrides.cca = function (t, e) {
                var n = t.charCodeAt(e);
                if (n != n) return undefined;
                return n
            };
            HxOverrides.substr = function (t, e, n) {
                if (e != null && e != 0 && n != null && n < 0) return "";
                if (n == null) n = t.length;
                if (e < 0) {
                    e = t.length + e;
                    if (e < 0) e = 0
                } else if (n < 0) n = t.length + n - e;
                return t.substr(e, n)
            };
            HxOverrides.remove = function (t, e) {
                var n = 0;
                var i = t.length;
                while (n < i) {
                    if (t[n] == e) {
                        t.splice(n, 1);
                        return true
                    }
                    n++
                }
                return false
            };
            HxOverrides.iter = function (t) {
                return {
                    cur: 0, arr: t, hasNext: function () {
                        return this.cur < this.arr.length
                    }, next: function () {
                        return this.arr[this.cur++]
                    }
                }
            };
            var IntIter = function (t, e) {
                this.min = t;
                this.max = e
            };
            IntIter.__name__ = true;
            IntIter.prototype = {
                next: function () {
                    return this.min++
                }, hasNext: function () {
                    return this.min < this.max
                }, __class__: IntIter
            };
            var Std = function () {
            };
            Std.__name__ = true;
            Std["is"] = function (t, e) {
                return js.Boot.__instanceof(t, e)
            };
            Std.string = function (t) {
                return js.Boot.__string_rec(t, "")
            };
            Std["int"] = function (t) {
                return t | 0
            };
            Std.parseInt = function (t) {
                var e = parseInt(t, 10);
                if (e == 0 && (HxOverrides.cca(t, 1) == 120 || HxOverrides.cca(t, 1) == 88)) e = parseInt(t);
                if (isNaN(e)) return null;
                return e
            };
            Std.parseFloat = function (t) {
                return parseFloat(t)
            };
            Std.random = function (t) {
                return Math.floor(Math.random() * t)
            };
            var com = com || {};
            if (!com.wiris) com.wiris = {};
            if (!com.wiris.js) com.wiris.js = {};
            com.wiris.js.JsPluginTools = function () {
                this.tryReady()
            };
            com.wiris.js.JsPluginTools.__name__ = true;
            com.wiris.js.JsPluginTools.main = function () {
                var t;
                t = com.wiris.js.JsPluginTools.getInstance();
                haxe.Timer.delay($bind(t, t.tryReady), 100)
            };
            com.wiris.js.JsPluginTools.getInstance = function () {
                if (com.wiris.js.JsPluginTools.instance == null) com.wiris.js.JsPluginTools.instance = new com.wiris.js.JsPluginTools;
                return com.wiris.js.JsPluginTools.instance
            };
            com.wiris.js.JsPluginTools.bypassEncapsulation = function () {
                if (window.com == null) window.com = {};
                if (window.com.wiris == null) window.com.wiris = {};
                if (window.com.wiris.js == null) window.com.wiris.js = {};
                if (window.com.wiris.js.JsPluginTools == null) window.com.wiris.js.JsPluginTools = com.wiris.js.JsPluginTools.getInstance()
            };
            com.wiris.js.JsPluginTools.prototype = {
                md5encode: function (t) {
                    return haxe.Md5.encode(t)
                }, doLoad: function () {
                    this.ready = true;
                    com.wiris.js.JsPluginTools.instance = this;
                    com.wiris.js.JsPluginTools.bypassEncapsulation()
                }, tryReady: function () {
                    this.ready = false;
                    if (js.Lib.document.readyState) {
                        this.doLoad();
                        this.ready = true
                    }
                    if (!this.ready) haxe.Timer.delay($bind(this, this.tryReady), 100)
                }, __class__: com.wiris.js.JsPluginTools
            };
            var haxe = haxe || {};
            haxe.Log = function () {
            };
            haxe.Log.__name__ = true;
            haxe.Log.trace = function (t, e) {
                js.Boot.__trace(t, e)
            };
            haxe.Log.clear = function () {
                js.Boot.__clear_trace()
            };
            haxe.Md5 = function () {
            };
            haxe.Md5.__name__ = true;
            haxe.Md5.encode = function (t) {
                return (new haxe.Md5).doEncode(t)
            };
            haxe.Md5.prototype = {
                doEncode: function (t) {
                    var e = this.str2blks(t);
                    var n = 1732584193;
                    var i = -271733879;
                    var o = -1732584194;
                    var r = 271733878;
                    var s;
                    var a = 0;
                    while (a < e.length) {
                        var c = n;
                        var l = i;
                        var d = o;
                        var u = r;
                        s = 0;
                        n = this.ff(n, i, o, r, e[a], 7, -680876936);
                        r = this.ff(r, n, i, o, e[a + 1], 12, -389564586);
                        o = this.ff(o, r, n, i, e[a + 2], 17, 606105819);
                        i = this.ff(i, o, r, n, e[a + 3], 22, -1044525330);
                        n = this.ff(n, i, o, r, e[a + 4], 7, -176418897);
                        r = this.ff(r, n, i, o, e[a + 5], 12, 1200080426);
                        o = this.ff(o, r, n, i, e[a + 6], 17, -1473231341);
                        i = this.ff(i, o, r, n, e[a + 7], 22, -45705983);
                        n = this.ff(n, i, o, r, e[a + 8], 7, 1770035416);
                        r = this.ff(r, n, i, o, e[a + 9], 12, -1958414417);
                        o = this.ff(o, r, n, i, e[a + 10], 17, -42063);
                        i = this.ff(i, o, r, n, e[a + 11], 22, -1990404162);
                        n = this.ff(n, i, o, r, e[a + 12], 7, 1804603682);
                        r = this.ff(r, n, i, o, e[a + 13], 12, -40341101);
                        o = this.ff(o, r, n, i, e[a + 14], 17, -1502002290);
                        i = this.ff(i, o, r, n, e[a + 15], 22, 1236535329);
                        n = this.gg(n, i, o, r, e[a + 1], 5, -165796510);
                        r = this.gg(r, n, i, o, e[a + 6], 9, -1069501632);
                        o = this.gg(o, r, n, i, e[a + 11], 14, 643717713);
                        i = this.gg(i, o, r, n, e[a], 20, -373897302);
                        n = this.gg(n, i, o, r, e[a + 5], 5, -701558691);
                        r = this.gg(r, n, i, o, e[a + 10], 9, 38016083);
                        o = this.gg(o, r, n, i, e[a + 15], 14, -660478335);
                        i = this.gg(i, o, r, n, e[a + 4], 20, -405537848);
                        n = this.gg(n, i, o, r, e[a + 9], 5, 568446438);
                        r = this.gg(r, n, i, o, e[a + 14], 9, -1019803690);
                        o = this.gg(o, r, n, i, e[a + 3], 14, -187363961);
                        i = this.gg(i, o, r, n, e[a + 8], 20, 1163531501);
                        n = this.gg(n, i, o, r, e[a + 13], 5, -1444681467);
                        r = this.gg(r, n, i, o, e[a + 2], 9, -51403784);
                        o = this.gg(o, r, n, i, e[a + 7], 14, 1735328473);
                        i = this.gg(i, o, r, n, e[a + 12], 20, -1926607734);
                        n = this.hh(n, i, o, r, e[a + 5], 4, -378558);
                        r = this.hh(r, n, i, o, e[a + 8], 11, -2022574463);
                        o = this.hh(o, r, n, i, e[a + 11], 16, 1839030562);
                        i = this.hh(i, o, r, n, e[a + 14], 23, -35309556);
                        n = this.hh(n, i, o, r, e[a + 1], 4, -1530992060);
                        r = this.hh(r, n, i, o, e[a + 4], 11, 1272893353);
                        o = this.hh(o, r, n, i, e[a + 7], 16, -155497632);
                        i = this.hh(i, o, r, n, e[a + 10], 23, -1094730640);
                        n = this.hh(n, i, o, r, e[a + 13], 4, 681279174);
                        r = this.hh(r, n, i, o, e[a], 11, -358537222);
                        o = this.hh(o, r, n, i, e[a + 3], 16, -722521979);
                        i = this.hh(i, o, r, n, e[a + 6], 23, 76029189);
                        n = this.hh(n, i, o, r, e[a + 9], 4, -640364487);
                        r = this.hh(r, n, i, o, e[a + 12], 11, -421815835);
                        o = this.hh(o, r, n, i, e[a + 15], 16, 530742520);
                        i = this.hh(i, o, r, n, e[a + 2], 23, -995338651);
                        n = this.ii(n, i, o, r, e[a], 6, -198630844);
                        r = this.ii(r, n, i, o, e[a + 7], 10, 1126891415);
                        o = this.ii(o, r, n, i, e[a + 14], 15, -1416354905);
                        i = this.ii(i, o, r, n, e[a + 5], 21, -57434055);
                        n = this.ii(n, i, o, r, e[a + 12], 6, 1700485571);
                        r = this.ii(r, n, i, o, e[a + 3], 10, -1894986606);
                        o = this.ii(o, r, n, i, e[a + 10], 15, -1051523);
                        i = this.ii(i, o, r, n, e[a + 1], 21, -2054922799);
                        n = this.ii(n, i, o, r, e[a + 8], 6, 1873313359);
                        r = this.ii(r, n, i, o, e[a + 15], 10, -30611744);
                        o = this.ii(o, r, n, i, e[a + 6], 15, -1560198380);
                        i = this.ii(i, o, r, n, e[a + 13], 21, 1309151649);
                        n = this.ii(n, i, o, r, e[a + 4], 6, -145523070);
                        r = this.ii(r, n, i, o, e[a + 11], 10, -1120210379);
                        o = this.ii(o, r, n, i, e[a + 2], 15, 718787259);
                        i = this.ii(i, o, r, n, e[a + 9], 21, -343485551);
                        n = this.addme(n, c);
                        i = this.addme(i, l);
                        o = this.addme(o, d);
                        r = this.addme(r, u);
                        a += 16
                    }
                    return this.rhex(n) + this.rhex(i) + this.rhex(o) + this.rhex(r)
                }, ii: function (t, e, n, i, o, r, s) {
                    return this.cmn(this.bitXOR(n, this.bitOR(e, ~i)), t, e, o, r, s)
                }, hh: function (t, e, n, i, o, r, s) {
                    return this.cmn(this.bitXOR(this.bitXOR(e, n), i), t, e, o, r, s)
                }, gg: function (t, e, n, i, o, r, s) {
                    return this.cmn(this.bitOR(this.bitAND(e, i), this.bitAND(n, ~i)), t, e, o, r, s)
                }, ff: function (t, e, n, i, o, r, s) {
                    return this.cmn(this.bitOR(this.bitAND(e, n), this.bitAND(~e, i)), t, e, o, r, s)
                }, cmn: function (t, e, n, i, o, r) {
                    return this.addme(this.rol(this.addme(this.addme(e, t), this.addme(i, r)), o), n)
                }, rol: function (t, e) {
                    return t << e | t >>> 32 - e
                }, str2blks: function (t) {
                    var e = (t.length + 8 >> 6) + 1;
                    var n = new Array;
                    var i = 0, o = e * 16;
                    while (i < o) {
                        var r = i++;
                        n[r] = 0
                    }
                    var r = 0;
                    while (r < t.length) {
                        n[r >> 2] |= HxOverrides.cca(t, r) << (t.length * 8 + r) % 4 * 8;
                        r++
                    }
                    n[r >> 2] |= 128 << (t.length * 8 + r) % 4 * 8;
                    var s = t.length * 8;
                    var a = e * 16 - 2;
                    n[a] = s & 255;
                    n[a] |= (s >>> 8 & 255) << 8;
                    n[a] |= (s >>> 16 & 255) << 16;
                    n[a] |= (s >>> 24 & 255) << 24;
                    return n
                }, rhex: function (t) {
                    var e = "";
                    var n = "0123456789abcdef";
                    var i = 0;
                    while (i < 4) {
                        var o = i++;
                        e += n.charAt(t >> o * 8 + 4 & 15) + n.charAt(t >> o * 8 & 15)
                    }
                    return e
                }, addme: function (t, e) {
                    var n = (t & 65535) + (e & 65535);
                    var i = (t >> 16) + (e >> 16) + (n >> 16);
                    return i << 16 | n & 65535
                }, bitAND: function (t, e) {
                    var n = t & 1 & (e & 1);
                    var i = t >>> 1 & e >>> 1;
                    return i << 1 | n
                }, bitXOR: function (t, e) {
                    var n = t & 1 ^ e & 1;
                    var i = t >>> 1 ^ e >>> 1;
                    return i << 1 | n
                }, bitOR: function (t, e) {
                    var n = t & 1 | e & 1;
                    var i = t >>> 1 | e >>> 1;
                    return i << 1 | n
                }, __class__: haxe.Md5
            };
            haxe.Timer = function (t) {
                var e = this;
                this.id = window.setInterval((function () {
                    e.run()
                }), t)
            };
            haxe.Timer.__name__ = true;
            haxe.Timer.delay = function (t, e) {
                var n = new haxe.Timer(e);
                n.run = function () {
                    n.stop();
                    t()
                };
                return n
            };
            haxe.Timer.measure = function (t, e) {
                var n = haxe.Timer.stamp();
                var i = t();
                haxe.Log.trace(haxe.Timer.stamp() - n + "s", e);
                return i
            };
            haxe.Timer.stamp = function () {
                return (new Date).getTime() / 1e3
            };
            haxe.Timer.prototype = {
                run: function () {
                }, stop: function () {
                    if (this.id == null) return;
                    window.clearInterval(this.id);
                    this.id = null
                }, __class__: haxe.Timer
            };
            var js = js || {};
            js.Boot = function () {
            };
            js.Boot.__name__ = true;
            js.Boot.__unhtml = function (t) {
                return t.split("&").join("&amp;").split("<").join("&lt;").split(">").join("&gt;")
            };
            js.Boot.__trace = function (t, e) {
                var n = e != null ? e.fileName + ":" + e.lineNumber + ": " : "";
                n += js.Boot.__string_rec(t, "");
                var i;
                if (typeof document != "undefined" && (i = document.getElementById("haxe:trace")) != null) i.innerHTML += js.Boot.__unhtml(n) + "<br/>"; else if (typeof console != "undefined" && console.log != null) console.log(n)
            };
            js.Boot.__clear_trace = function () {
                var t = document.getElementById("haxe:trace");
                if (t != null) t.innerHTML = ""
            };
            js.Boot.isClass = function (t) {
                return t.__name__
            };
            js.Boot.isEnum = function (t) {
                return t.__ename__
            };
            js.Boot.getClass = function (t) {
                return t.__class__
            };
            js.Boot.__string_rec = function (t, e) {
                if (t == null) return "null";
                if (e.length >= 5) return "<...>";
                var n = typeof t;
                if (n == "function" && (t.__name__ || t.__ename__)) n = "object";
                switch (n) {
                    case"object":
                        if (t instanceof Array) {
                            if (t.__enum__) {
                                if (t.length == 2) return t[0];
                                var i = t[0] + "(";
                                e += "\t";
                                var o = 2, r = t.length;
                                while (o < r) {
                                    var s = o++;
                                    if (s != 2) i += "," + js.Boot.__string_rec(t[s], e); else i += js.Boot.__string_rec(t[s], e)
                                }
                                return i + ")"
                            }
                            var a = t.length;
                            var s;
                            var i = "[";
                            e += "\t";
                            var r = 0;
                            while (r < a) {
                                var c = r++;
                                i += (c > 0 ? "," : "") + js.Boot.__string_rec(t[c], e)
                            }
                            i += "]";
                            return i
                        }
                        var l;
                        try {
                            l = t.toString
                        } catch (t) {
                            return "???"
                        }
                        if (l != null && l != Object.toString) {
                            var d = t.toString();
                            if (d != "[object Object]") return d
                        }
                        var u = null;
                        var i = "{\n";
                        e += "\t";
                        var h = t.hasOwnProperty != null;
                        for (var u in t) {
                            if (h && !t.hasOwnProperty(u)) {
                                continue
                            }
                            if (u == "prototype" || u == "__class__" || u == "__super__" || u == "__interfaces__" || u == "__properties__") {
                                continue
                            }
                            if (i.length != 2) i += ", \n";
                            i += e + u + " : " + js.Boot.__string_rec(t[u], e)
                        }
                        e = e.substring(1);
                        i += "\n" + e + "}";
                        return i;
                    case"function":
                        return "<function>";
                    case"string":
                        return t;
                    default:
                        return String(t)
                }
            };
            js.Boot.__interfLoop = function (t, e) {
                if (t == null) return false;
                if (t == e) return true;
                var n = t.__interfaces__;
                if (n != null) {
                    var i = 0, o = n.length;
                    while (i < o) {
                        var r = i++;
                        var s = n[r];
                        if (s == e || js.Boot.__interfLoop(s, e)) return true
                    }
                }
                return js.Boot.__interfLoop(t.__super__, e)
            };
            js.Boot.__instanceof = function (t, e) {
                try {
                    if (t instanceof e) {
                        if (e == Array) return t.__enum__ == null;
                        return true
                    }
                    if (js.Boot.__interfLoop(t.__class__, e)) return true
                } catch (t) {
                    if (e == null) return false
                }
                switch (e) {
                    case Int:
                        return Math.ceil(t % 2147483648) === t;
                    case Float:
                        return typeof t == "number";
                    case Bool:
                        return t === true || t === false;
                    case String:
                        return typeof t == "string";
                    case Dynamic:
                        return true;
                    default:
                        if (t == null) return false;
                        if (e == Class && t.__name__ != null) return true; else null;
                        if (e == Enum && t.__ename__ != null) return true; else null;
                        return t.__enum__ == e
                }
            };
            js.Boot.__cast = function (t, e) {
                if (js.Boot.__instanceof(t, e)) return t; else throw"Cannot cast " + Std.string(t) + " to " + Std.string(e)
            };
            js.Lib = function () {
            };
            js.Lib.__name__ = true;
            js.Lib.debug = function () {
                debugger
            };
            js.Lib.alert = function (t) {
                alert(js.Boot.__string_rec(t, ""))
            };
            js.Lib.eval = function (code) {
                return eval(code)
            };
            js.Lib.setErrorHandler = function (t) {
                js.Lib.onerror = t
            };
            var $_;

            function $bind(t, e) {
                var n = function () {
                    return n.method.apply(n.scope, arguments)
                };
                n.scope = t;
                n.method = e;
                return n
            }

            if (Array.prototype.indexOf) HxOverrides.remove = function (t, e) {
                var n = t.indexOf(e);
                if (n == -1) return false;
                t.splice(n, 1);
                return true
            }; else null;
            Math.__name__ = ["Math"];
            Math.NaN = Number.NaN;
            Math.NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY;
            Math.POSITIVE_INFINITY = Number.POSITIVE_INFINITY;
            Math.isFinite = function (t) {
                return isFinite(t)
            };
            Math.isNaN = function (t) {
                return isNaN(t)
            };
            String.prototype.__class__ = String;
            String.__name__ = true;
            Array.prototype.__class__ = Array;
            Array.__name__ = true;
            Date.prototype.__class__ = Date;
            Date.__name__ = ["Date"];
            var Int = {__name__: ["Int"]};
            var Dynamic = {__name__: ["Dynamic"]};
            var Float = Number;
            Float.__name__ = ["Float"];
            var Bool = Boolean;
            Bool.__ename__ = ["Bool"];
            var Class = {__name__: ["Class"]};
            var Enum = {};
            var Void = {__ename__: ["Void"]};
            if (typeof document != "undefined") js.Lib.document = document;
            if (typeof window != "undefined") {
                js.Lib.window = window;
                js.Lib.window.onerror = function (t, e, n) {
                    var i = js.Lib.onerror;
                    if (i == null) return false;
                    return i(t, [e + ":" + n])
                }
            }
            com.wiris.js.JsPluginTools.main()
        })();
        delete Array.prototype.__class__
    }, function (t, e, n) {
        "use strict";
        n.r(e);
        var i = n(5);
        var o = i["a"].Symbol;
        var r = o;
        var s = Object.prototype;
        var a = s.hasOwnProperty;
        var c = s.toString;
        var l = r ? r.toStringTag : undefined;

        function d(t) {
            var e = a.call(t, l), n = t[l];
            try {
                t[l] = undefined;
                var i = true
            } catch (t) {
            }
            var o = c.call(t);
            if (i) {
                if (e) {
                    t[l] = n
                } else {
                    delete t[l]
                }
            }
            return o
        }

        var u = d;
        var h = Object.prototype;
        var m = h.toString;

        function g(t) {
            return m.call(t)
        }

        var f = g;
        var p = "[object Null]", b = "[object Undefined]";
        var k = r ? r.toStringTag : undefined;

        function w(t) {
            if (t == null) {
                return t === undefined ? b : p
            }
            return k && k in Object(t) ? u(t) : f(t)
        }

        var A = w;

        function _(t, e) {
            return function (n) {
                return t(e(n))
            }
        }

        var C = _;
        var v = C(Object.getPrototypeOf, Object);
        var y = v;

        function x(t) {
            return t != null && typeof t == "object"
        }

        var E = x;
        var D = "[object Object]";
        var T = Function.prototype, M = Object.prototype;
        var S = T.toString;
        var I = M.hasOwnProperty;
        var B = S.call(Object);

        function L(t) {
            if (!E(t) || A(t) != D) {
                return false
            }
            var e = y(t);
            if (e === null) {
                return true
            }
            var n = I.call(e, "constructor") && e.constructor;
            return typeof n == "function" && n instanceof n && S.call(n) == B
        }

        var z = L;

        function N() {
            this.__data__ = [];
            this.size = 0
        }

        var P = N;

        function O(t, e) {
            return t === e || t !== t && e !== e
        }

        var j = O;

        function R(t, e) {
            var n = t.length;
            while (n--) {
                if (j(t[n][0], e)) {
                    return n
                }
            }
            return -1
        }

        var F = R;
        var V = Array.prototype;
        var H = V.splice;

        function U(t) {
            var e = this.__data__, n = F(e, t);
            if (n < 0) {
                return false
            }
            var i = e.length - 1;
            if (n == i) {
                e.pop()
            } else {
                H.call(e, n, 1)
            }
            --this.size;
            return true
        }

        var W = U;

        function q(t) {
            var e = this.__data__, n = F(e, t);
            return n < 0 ? undefined : e[n][1]
        }

        var K = q;

        function G(t) {
            return F(this.__data__, t) > -1
        }

        var $ = G;

        function Y(t, e) {
            var n = this.__data__, i = F(n, t);
            if (i < 0) {
                ++this.size;
                n.push([t, e])
            } else {
                n[i][1] = e
            }
            return this
        }

        var Q = Y;

        function J(t) {
            var e = -1, n = t == null ? 0 : t.length;
            this.clear();
            while (++e < n) {
                var i = t[e];
                this.set(i[0], i[1])
            }
        }

        J.prototype.clear = P;
        J.prototype["delete"] = W;
        J.prototype.get = K;
        J.prototype.has = $;
        J.prototype.set = Q;
        var X = J;

        function Z() {
            this.__data__ = new X;
            this.size = 0
        }

        var tt = Z;

        function et(t) {
            var e = this.__data__, n = e["delete"](t);
            this.size = e.size;
            return n
        }

        var nt = et;

        function it(t) {
            return this.__data__.get(t)
        }

        var ot = it;

        function rt(t) {
            return this.__data__.has(t)
        }

        var st = rt;

        function at(t) {
            var e = typeof t;
            return t != null && (e == "object" || e == "function")
        }

        var ct = at;
        var lt = "[object AsyncFunction]", dt = "[object Function]", ut = "[object GeneratorFunction]",
            ht = "[object Proxy]";

        function mt(t) {
            if (!ct(t)) {
                return false
            }
            var e = A(t);
            return e == dt || e == ut || e == lt || e == ht
        }

        var gt = mt;
        var ft = i["a"]["__core-js_shared__"];
        var pt = ft;
        var bt = function () {
            var t = /[^.]+$/.exec(pt && pt.keys && pt.keys.IE_PROTO || "");
            return t ? "Symbol(src)_1." + t : ""
        }();

        function kt(t) {
            return !!bt && bt in t
        }

        var wt = kt;
        var At = Function.prototype;
        var _t = At.toString;

        function Ct(t) {
            if (t != null) {
                try {
                    return _t.call(t)
                } catch (t) {
                }
                try {
                    return t + ""
                } catch (t) {
                }
            }
            return ""
        }

        var vt = Ct;
        var yt = /[\\^$.*+?()[\]{}|]/g;
        var xt = /^\[object .+?Constructor\]$/;
        var Et = Function.prototype, Dt = Object.prototype;
        var Tt = Et.toString;
        var Mt = Dt.hasOwnProperty;
        var St = RegExp("^" + Tt.call(Mt).replace(yt, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");

        function It(t) {
            if (!ct(t) || wt(t)) {
                return false
            }
            var e = gt(t) ? St : xt;
            return e.test(vt(t))
        }

        var Bt = It;

        function Lt(t, e) {
            return t == null ? undefined : t[e]
        }

        var zt = Lt;

        function Nt(t, e) {
            var n = zt(t, e);
            return Bt(n) ? n : undefined
        }

        var Pt = Nt;
        var Ot = Pt(i["a"], "Map");
        var jt = Ot;
        var Rt = Pt(Object, "create");
        var Ft = Rt;

        function Vt() {
            this.__data__ = Ft ? Ft(null) : {};
            this.size = 0
        }

        var Ht = Vt;

        function Ut(t) {
            var e = this.has(t) && delete this.__data__[t];
            this.size -= e ? 1 : 0;
            return e
        }

        var Wt = Ut;
        var qt = "__lodash_hash_undefined__";
        var Kt = Object.prototype;
        var Gt = Kt.hasOwnProperty;

        function $t(t) {
            var e = this.__data__;
            if (Ft) {
                var n = e[t];
                return n === qt ? undefined : n
            }
            return Gt.call(e, t) ? e[t] : undefined
        }

        var Yt = $t;
        var Qt = Object.prototype;
        var Jt = Qt.hasOwnProperty;

        function Xt(t) {
            var e = this.__data__;
            return Ft ? e[t] !== undefined : Jt.call(e, t)
        }

        var Zt = Xt;
        var te = "__lodash_hash_undefined__";

        function ee(t, e) {
            var n = this.__data__;
            this.size += this.has(t) ? 0 : 1;
            n[t] = Ft && e === undefined ? te : e;
            return this
        }

        var ne = ee;

        function ie(t) {
            var e = -1, n = t == null ? 0 : t.length;
            this.clear();
            while (++e < n) {
                var i = t[e];
                this.set(i[0], i[1])
            }
        }

        ie.prototype.clear = Ht;
        ie.prototype["delete"] = Wt;
        ie.prototype.get = Yt;
        ie.prototype.has = Zt;
        ie.prototype.set = ne;
        var oe = ie;

        function re() {
            this.size = 0;
            this.__data__ = {hash: new oe, map: new (jt || X), string: new oe}
        }

        var se = re;

        function ae(t) {
            var e = typeof t;
            return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null
        }

        var ce = ae;

        function le(t, e) {
            var n = t.__data__;
            return ce(e) ? n[typeof e == "string" ? "string" : "hash"] : n.map
        }

        var de = le;

        function ue(t) {
            var e = de(this, t)["delete"](t);
            this.size -= e ? 1 : 0;
            return e
        }

        var he = ue;

        function me(t) {
            return de(this, t).get(t)
        }

        var ge = me;

        function fe(t) {
            return de(this, t).has(t)
        }

        var pe = fe;

        function be(t, e) {
            var n = de(this, t), i = n.size;
            n.set(t, e);
            this.size += n.size == i ? 0 : 1;
            return this
        }

        var ke = be;

        function we(t) {
            var e = -1, n = t == null ? 0 : t.length;
            this.clear();
            while (++e < n) {
                var i = t[e];
                this.set(i[0], i[1])
            }
        }

        we.prototype.clear = se;
        we.prototype["delete"] = he;
        we.prototype.get = ge;
        we.prototype.has = pe;
        we.prototype.set = ke;
        var Ae = we;
        var _e = 200;

        function Ce(t, e) {
            var n = this.__data__;
            if (n instanceof X) {
                var i = n.__data__;
                if (!jt || i.length < _e - 1) {
                    i.push([t, e]);
                    this.size = ++n.size;
                    return this
                }
                n = this.__data__ = new Ae(i)
            }
            n.set(t, e);
            this.size = n.size;
            return this
        }

        var ve = Ce;

        function ye(t) {
            var e = this.__data__ = new X(t);
            this.size = e.size
        }

        ye.prototype.clear = tt;
        ye.prototype["delete"] = nt;
        ye.prototype.get = ot;
        ye.prototype.has = st;
        ye.prototype.set = ve;
        var xe = ye;

        function Ee(t, e) {
            var n = -1, i = t == null ? 0 : t.length;
            while (++n < i) {
                if (e(t[n], n, t) === false) {
                    break
                }
            }
            return t
        }

        var De = Ee;
        var Te = function () {
            try {
                var t = Pt(Object, "defineProperty");
                t({}, "", {});
                return t
            } catch (t) {
            }
        }();
        var Me = Te;

        function Se(t, e, n) {
            if (e == "__proto__" && Me) {
                Me(t, e, {configurable: true, enumerable: true, value: n, writable: true})
            } else {
                t[e] = n
            }
        }

        var Ie = Se;
        var Be = Object.prototype;
        var Le = Be.hasOwnProperty;

        function ze(t, e, n) {
            var i = t[e];
            if (!(Le.call(t, e) && j(i, n)) || n === undefined && !(e in t)) {
                Ie(t, e, n)
            }
        }

        var Ne = ze;

        function Pe(t, e, n, i) {
            var o = !n;
            n || (n = {});
            var r = -1, s = e.length;
            while (++r < s) {
                var a = e[r];
                var c = i ? i(n[a], t[a], a, n, t) : undefined;
                if (c === undefined) {
                    c = t[a]
                }
                if (o) {
                    Ie(n, a, c)
                } else {
                    Ne(n, a, c)
                }
            }
            return n
        }

        var Oe = Pe;

        function je(t, e) {
            var n = -1, i = Array(t);
            while (++n < t) {
                i[n] = e(n)
            }
            return i
        }

        var Re = je;
        var Fe = "[object Arguments]";

        function Ve(t) {
            return E(t) && A(t) == Fe
        }

        var He = Ve;
        var Ue = Object.prototype;
        var We = Ue.hasOwnProperty;
        var qe = Ue.propertyIsEnumerable;
        var Ke = He(function () {
            return arguments
        }()) ? He : function (t) {
            return E(t) && We.call(t, "callee") && !qe.call(t, "callee")
        };
        var Ge = Ke;
        var $e = Array.isArray;
        var Ye = $e;
        var Qe = n(6);
        var Je = 9007199254740991;
        var Xe = /^(?:0|[1-9]\d*)$/;

        function Ze(t, e) {
            var n = typeof t;
            e = e == null ? Je : e;
            return !!e && (n == "number" || n != "symbol" && Xe.test(t)) && (t > -1 && t % 1 == 0 && t < e)
        }

        var tn = Ze;
        var en = 9007199254740991;

        function nn(t) {
            return typeof t == "number" && t > -1 && t % 1 == 0 && t <= en
        }

        var on = nn;
        var rn = "[object Arguments]", sn = "[object Array]", an = "[object Boolean]", cn = "[object Date]",
            ln = "[object Error]", dn = "[object Function]", un = "[object Map]", hn = "[object Number]",
            mn = "[object Object]", gn = "[object RegExp]", fn = "[object Set]", pn = "[object String]",
            bn = "[object WeakMap]";
        var kn = "[object ArrayBuffer]", wn = "[object DataView]", An = "[object Float32Array]",
            _n = "[object Float64Array]", Cn = "[object Int8Array]", vn = "[object Int16Array]",
            yn = "[object Int32Array]", xn = "[object Uint8Array]", En = "[object Uint8ClampedArray]",
            Dn = "[object Uint16Array]", Tn = "[object Uint32Array]";
        var Mn = {};
        Mn[An] = Mn[_n] = Mn[Cn] = Mn[vn] = Mn[yn] = Mn[xn] = Mn[En] = Mn[Dn] = Mn[Tn] = true;
        Mn[rn] = Mn[sn] = Mn[kn] = Mn[an] = Mn[wn] = Mn[cn] = Mn[ln] = Mn[dn] = Mn[un] = Mn[hn] = Mn[mn] = Mn[gn] = Mn[fn] = Mn[pn] = Mn[bn] = false;

        function Sn(t) {
            return E(t) && on(t.length) && !!Mn[A(t)]
        }

        var In = Sn;

        function Bn(t) {
            return function (e) {
                return t(e)
            }
        }

        var Ln = Bn;
        var zn = n(7);
        var Nn = zn["a"] && zn["a"].isTypedArray;
        var Pn = Nn ? Ln(Nn) : In;
        var On = Pn;
        var jn = Object.prototype;
        var Rn = jn.hasOwnProperty;

        function Fn(t, e) {
            var n = Ye(t), i = !n && Ge(t), o = !n && !i && Object(Qe["a"])(t), r = !n && !i && !o && On(t),
                s = n || i || o || r, a = s ? Re(t.length, String) : [], c = a.length;
            for (var l in t) {
                if ((e || Rn.call(t, l)) && !(s && (l == "length" || o && (l == "offset" || l == "parent") || r && (l == "buffer" || l == "byteLength" || l == "byteOffset") || tn(l, c)))) {
                    a.push(l)
                }
            }
            return a
        }

        var Vn = Fn;
        var Hn = Object.prototype;

        function Un(t) {
            var e = t && t.constructor, n = typeof e == "function" && e.prototype || Hn;
            return t === n
        }

        var Wn = Un;
        var qn = C(Object.keys, Object);
        var Kn = qn;
        var Gn = Object.prototype;
        var $n = Gn.hasOwnProperty;

        function Yn(t) {
            if (!Wn(t)) {
                return Kn(t)
            }
            var e = [];
            for (var n in Object(t)) {
                if ($n.call(t, n) && n != "constructor") {
                    e.push(n)
                }
            }
            return e
        }

        var Qn = Yn;

        function Jn(t) {
            return t != null && on(t.length) && !gt(t)
        }

        var Xn = Jn;

        function Zn(t) {
            return Xn(t) ? Vn(t) : Qn(t)
        }

        var ti = Zn;

        function ei(t, e) {
            return t && Oe(e, ti(e), t)
        }

        var ni = ei;

        function ii(t) {
            var e = [];
            if (t != null) {
                for (var n in Object(t)) {
                    e.push(n)
                }
            }
            return e
        }

        var oi = ii;
        var ri = Object.prototype;
        var si = ri.hasOwnProperty;

        function ai(t) {
            if (!ct(t)) {
                return oi(t)
            }
            var e = Wn(t), n = [];
            for (var i in t) {
                if (!(i == "constructor" && (e || !si.call(t, i)))) {
                    n.push(i)
                }
            }
            return n
        }

        var ci = ai;

        function li(t) {
            return Xn(t) ? Vn(t, true) : ci(t)
        }

        var di = li;

        function ui(t, e) {
            return t && Oe(e, di(e), t)
        }

        var hi = ui;
        var mi = n(10);

        function gi(t, e) {
            var n = -1, i = t.length;
            e || (e = Array(i));
            while (++n < i) {
                e[n] = t[n]
            }
            return e
        }

        var fi = gi;

        function pi(t, e) {
            var n = -1, i = t == null ? 0 : t.length, o = 0, r = [];
            while (++n < i) {
                var s = t[n];
                if (e(s, n, t)) {
                    r[o++] = s
                }
            }
            return r
        }

        var bi = pi;

        function ki() {
            return []
        }

        var wi = ki;
        var Ai = Object.prototype;
        var _i = Ai.propertyIsEnumerable;
        var Ci = Object.getOwnPropertySymbols;
        var vi = !Ci ? wi : function (t) {
            if (t == null) {
                return []
            }
            t = Object(t);
            return bi(Ci(t), (function (e) {
                return _i.call(t, e)
            }))
        };
        var yi = vi;

        function xi(t, e) {
            return Oe(t, yi(t), e)
        }

        var Ei = xi;

        function Di(t, e) {
            var n = -1, i = e.length, o = t.length;
            while (++n < i) {
                t[o + n] = e[n]
            }
            return t
        }

        var Ti = Di;
        var Mi = Object.getOwnPropertySymbols;
        var Si = !Mi ? wi : function (t) {
            var e = [];
            while (t) {
                Ti(e, yi(t));
                t = y(t)
            }
            return e
        };
        var Ii = Si;

        function Bi(t, e) {
            return Oe(t, Ii(t), e)
        }

        var Li = Bi;

        function zi(t, e, n) {
            var i = e(t);
            return Ye(t) ? i : Ti(i, n(t))
        }

        var Ni = zi;

        function Pi(t) {
            return Ni(t, ti, yi)
        }

        var Oi = Pi;

        function ji(t) {
            return Ni(t, di, Ii)
        }

        var Ri = ji;
        var Fi = Pt(i["a"], "DataView");
        var Vi = Fi;
        var Hi = Pt(i["a"], "Promise");
        var Ui = Hi;
        var Wi = Pt(i["a"], "Set");
        var qi = Wi;
        var Ki = Pt(i["a"], "WeakMap");
        var Gi = Ki;
        var $i = "[object Map]", Yi = "[object Object]", Qi = "[object Promise]", Ji = "[object Set]",
            Xi = "[object WeakMap]";
        var Zi = "[object DataView]";
        var to = vt(Vi), eo = vt(jt), no = vt(Ui), io = vt(qi), oo = vt(Gi);
        var ro = A;
        if (Vi && ro(new Vi(new ArrayBuffer(1))) != Zi || jt && ro(new jt) != $i || Ui && ro(Ui.resolve()) != Qi || qi && ro(new qi) != Ji || Gi && ro(new Gi) != Xi) {
            ro = function (t) {
                var e = A(t), n = e == Yi ? t.constructor : undefined, i = n ? vt(n) : "";
                if (i) {
                    switch (i) {
                        case to:
                            return Zi;
                        case eo:
                            return $i;
                        case no:
                            return Qi;
                        case io:
                            return Ji;
                        case oo:
                            return Xi
                    }
                }
                return e
            }
        }
        var so = ro;
        var ao = Object.prototype;
        var co = ao.hasOwnProperty;

        function lo(t) {
            var e = t.length, n = new t.constructor(e);
            if (e && typeof t[0] == "string" && co.call(t, "index")) {
                n.index = t.index;
                n.input = t.input
            }
            return n
        }

        var uo = lo;
        var ho = i["a"].Uint8Array;
        var mo = ho;

        function go(t) {
            var e = new t.constructor(t.byteLength);
            new mo(e).set(new mo(t));
            return e
        }

        var fo = go;

        function po(t, e) {
            var n = e ? fo(t.buffer) : t.buffer;
            return new t.constructor(n, t.byteOffset, t.byteLength)
        }

        var bo = po;
        var ko = /\w*$/;

        function wo(t) {
            var e = new t.constructor(t.source, ko.exec(t));
            e.lastIndex = t.lastIndex;
            return e
        }

        var Ao = wo;
        var _o = r ? r.prototype : undefined, Co = _o ? _o.valueOf : undefined;

        function vo(t) {
            return Co ? Object(Co.call(t)) : {}
        }

        var yo = vo;

        function xo(t, e) {
            var n = e ? fo(t.buffer) : t.buffer;
            return new t.constructor(n, t.byteOffset, t.length)
        }

        var Eo = xo;
        var Do = "[object Boolean]", To = "[object Date]", Mo = "[object Map]", So = "[object Number]",
            Io = "[object RegExp]", Bo = "[object Set]", Lo = "[object String]", zo = "[object Symbol]";
        var No = "[object ArrayBuffer]", Po = "[object DataView]", Oo = "[object Float32Array]",
            jo = "[object Float64Array]", Ro = "[object Int8Array]", Fo = "[object Int16Array]",
            Vo = "[object Int32Array]", Ho = "[object Uint8Array]", Uo = "[object Uint8ClampedArray]",
            Wo = "[object Uint16Array]", qo = "[object Uint32Array]";

        function Ko(t, e, n) {
            var i = t.constructor;
            switch (e) {
                case No:
                    return fo(t);
                case Do:
                case To:
                    return new i(+t);
                case Po:
                    return bo(t, n);
                case Oo:
                case jo:
                case Ro:
                case Fo:
                case Vo:
                case Ho:
                case Uo:
                case Wo:
                case qo:
                    return Eo(t, n);
                case Mo:
                    return new i;
                case So:
                case Lo:
                    return new i(t);
                case Io:
                    return Ao(t);
                case Bo:
                    return new i;
                case zo:
                    return yo(t)
            }
        }

        var Go = Ko;
        var $o = Object.create;
        var Yo = function () {
            function t() {
            }

            return function (e) {
                if (!ct(e)) {
                    return {}
                }
                if ($o) {
                    return $o(e)
                }
                t.prototype = e;
                var n = new t;
                t.prototype = undefined;
                return n
            }
        }();
        var Qo = Yo;

        function Jo(t) {
            return typeof t.constructor == "function" && !Wn(t) ? Qo(y(t)) : {}
        }

        var Xo = Jo;
        var Zo = "[object Map]";

        function tr(t) {
            return E(t) && so(t) == Zo
        }

        var er = tr;
        var nr = zn["a"] && zn["a"].isMap;
        var ir = nr ? Ln(nr) : er;
        var or = ir;
        var rr = "[object Set]";

        function sr(t) {
            return E(t) && so(t) == rr
        }

        var ar = sr;
        var cr = zn["a"] && zn["a"].isSet;
        var lr = cr ? Ln(cr) : ar;
        var dr = lr;
        var ur = 1, hr = 2, mr = 4;
        var gr = "[object Arguments]", fr = "[object Array]", pr = "[object Boolean]", br = "[object Date]",
            kr = "[object Error]", wr = "[object Function]", Ar = "[object GeneratorFunction]", _r = "[object Map]",
            Cr = "[object Number]", vr = "[object Object]", yr = "[object RegExp]", xr = "[object Set]",
            Er = "[object String]", Dr = "[object Symbol]", Tr = "[object WeakMap]";
        var Mr = "[object ArrayBuffer]", Sr = "[object DataView]", Ir = "[object Float32Array]",
            Br = "[object Float64Array]", Lr = "[object Int8Array]", zr = "[object Int16Array]",
            Nr = "[object Int32Array]", Pr = "[object Uint8Array]", Or = "[object Uint8ClampedArray]",
            jr = "[object Uint16Array]", Rr = "[object Uint32Array]";
        var Fr = {};
        Fr[gr] = Fr[fr] = Fr[Mr] = Fr[Sr] = Fr[pr] = Fr[br] = Fr[Ir] = Fr[Br] = Fr[Lr] = Fr[zr] = Fr[Nr] = Fr[_r] = Fr[Cr] = Fr[vr] = Fr[yr] = Fr[xr] = Fr[Er] = Fr[Dr] = Fr[Pr] = Fr[Or] = Fr[jr] = Fr[Rr] = true;
        Fr[kr] = Fr[wr] = Fr[Tr] = false;

        function Vr(t, e, n, i, o, r) {
            var s, a = e & ur, c = e & hr, l = e & mr;
            if (n) {
                s = o ? n(t, i, o, r) : n(t)
            }
            if (s !== undefined) {
                return s
            }
            if (!ct(t)) {
                return t
            }
            var d = Ye(t);
            if (d) {
                s = uo(t);
                if (!a) {
                    return fi(t, s)
                }
            } else {
                var u = so(t), h = u == wr || u == Ar;
                if (Object(Qe["a"])(t)) {
                    return Object(mi["a"])(t, a)
                }
                if (u == vr || u == gr || h && !o) {
                    s = c || h ? {} : Xo(t);
                    if (!a) {
                        return c ? Li(t, hi(s, t)) : Ei(t, ni(s, t))
                    }
                } else {
                    if (!Fr[u]) {
                        return o ? t : {}
                    }
                    s = Go(t, u, a)
                }
            }
            r || (r = new xe);
            var m = r.get(t);
            if (m) {
                return m
            }
            r.set(t, s);
            if (dr(t)) {
                t.forEach((function (i) {
                    s.add(Vr(i, e, n, i, t, r))
                }))
            } else if (or(t)) {
                t.forEach((function (i, o) {
                    s.set(o, Vr(i, e, n, o, t, r))
                }))
            }
            var g = l ? c ? Ri : Oi : c ? keysIn : ti;
            var f = d ? undefined : g(t);
            De(f || t, (function (i, o) {
                if (f) {
                    o = i;
                    i = t[o]
                }
                Ne(s, o, Vr(i, e, n, o, t, r))
            }));
            return s
        }

        var Hr = Vr;
        var Ur = 1, Wr = 4;

        function qr(t, e) {
            e = typeof e == "function" ? e : undefined;
            return Hr(t, Ur | Wr, e)
        }

        var Kr = qr;

        function Gr(t) {
            return E(t) && t.nodeType === 1 && !z(t)
        }

        var $r = Gr;

        class Yr {
            constructor(t, e) {
                this._config = {};
                if (e) {
                    this.define(Qr(e))
                }
                if (t) {
                    this._setObjectToTarget(this._config, t)
                }
            }

            set(t, e) {
                this._setToTarget(this._config, t, e)
            }

            define(t, e) {
                const n = true;
                this._setToTarget(this._config, t, e, n)
            }

            get(t) {
                return this._getFromSource(this._config, t)
            }

            * names() {
                for (const t of Object.keys(this._config)) {
                    yield t
                }
            }

            _setToTarget(t, e, n, i = false) {
                if (z(e)) {
                    this._setObjectToTarget(t, e, i);
                    return
                }
                const o = e.split(".");
                e = o.pop();
                for (const e of o) {
                    if (!z(t[e])) {
                        t[e] = {}
                    }
                    t = t[e]
                }
                if (z(n)) {
                    if (!z(t[e])) {
                        t[e] = {}
                    }
                    t = t[e];
                    this._setObjectToTarget(t, n, i);
                    return
                }
                if (i && typeof t[e] != "undefined") {
                    return
                }
                t[e] = n
            }

            _getFromSource(t, e) {
                const n = e.split(".");
                e = n.pop();
                for (const e of n) {
                    if (!z(t[e])) {
                        t = null;
                        break
                    }
                    t = t[e]
                }
                return t ? Qr(t[e]) : undefined
            }

            _setObjectToTarget(t, e, n) {
                Object.keys(e).forEach((i => {
                    this._setToTarget(t, i, e[i], n)
                }))
            }
        }

        function Qr(t) {
            return Kr(t, Jr)
        }

        function Jr(t) {
            return $r(t) ? t : undefined
        }

        function Xr() {
            return function t() {
                t.called = true
            }
        }

        var Zr = Xr;

        class ts {
            constructor(t, e) {
                this.source = t;
                this.name = e;
                this.path = [];
                this.stop = Zr();
                this.off = Zr()
            }
        }

        const es = new Array(256).fill().map(((t, e) => ("0" + e.toString(16)).slice(-2)));

        function ns() {
            const t = Math.random() * 4294967296 >>> 0;
            const e = Math.random() * 4294967296 >>> 0;
            const n = Math.random() * 4294967296 >>> 0;
            const i = Math.random() * 4294967296 >>> 0;
            return "e" + es[t >> 0 & 255] + es[t >> 8 & 255] + es[t >> 16 & 255] + es[t >> 24 & 255] + es[e >> 0 & 255] + es[e >> 8 & 255] + es[e >> 16 & 255] + es[e >> 24 & 255] + es[n >> 0 & 255] + es[n >> 8 & 255] + es[n >> 16 & 255] + es[n >> 24 & 255] + es[i >> 0 & 255] + es[i >> 8 & 255] + es[i >> 16 & 255] + es[i >> 24 & 255]
        }

        const is = {
            get(t) {
                if (typeof t != "number") {
                    return this[t] || this.normal
                } else {
                    return t
                }
            }, highest: 1e5, high: 1e3, normal: 0, low: -1e3, lowest: -1e5
        };
        var os = is;
        var rs = n(8);
        var ss = n(0);
        const as = Symbol("listeningTo");
        const cs = Symbol("emitterId");
        const ls = {
            on(t, e, n = {}) {
                this.listenTo(this, t, e, n)
            }, once(t, e, n) {
                let i = false;
                const o = function (t, ...n) {
                    if (!i) {
                        i = true;
                        t.off();
                        e.call(this, t, ...n)
                    }
                };
                this.listenTo(this, t, o, n)
            }, off(t, e) {
                this.stopListening(this, t, e)
            }, listenTo(t, e, n, i = {}) {
                let o, r;
                if (!this[as]) {
                    this[as] = {}
                }
                const s = this[as];
                if (!ms(t)) {
                    hs(t)
                }
                const a = ms(t);
                if (!(o = s[a])) {
                    o = s[a] = {emitter: t, callbacks: {}}
                }
                if (!(r = o.callbacks[e])) {
                    r = o.callbacks[e] = []
                }
                r.push(n);
                ps(t, e);
                const c = bs(t, e);
                const l = os.get(i.priority);
                const d = {callback: n, priority: l};
                for (const t of c) {
                    let e = false;
                    for (let n = 0; n < t.length; n++) {
                        if (t[n].priority < l) {
                            t.splice(n, 0, d);
                            e = true;
                            break
                        }
                    }
                    if (!e) {
                        t.push(d)
                    }
                }
            }, stopListening(t, e, n) {
                const i = this[as];
                let o = t && ms(t);
                const r = i && o && i[o];
                const s = r && e && r.callbacks[e];
                if (!i || t && !r || e && !s) {
                    return
                }
                if (n) {
                    As(t, e, n)
                } else if (s) {
                    while (n = s.pop()) {
                        As(t, e, n)
                    }
                    delete r.callbacks[e]
                } else if (r) {
                    for (e in r.callbacks) {
                        this.stopListening(t, e)
                    }
                    delete i[o]
                } else {
                    for (o in i) {
                        this.stopListening(i[o].emitter)
                    }
                    delete this[as]
                }
            }, fire(t, ...e) {
                try {
                    const n = t instanceof ts ? t : new ts(this, t);
                    const i = n.name;
                    let o = ks(this, i);
                    n.path.push(this);
                    if (o) {
                        const t = [n, ...e];
                        o = Array.from(o);
                        for (let e = 0; e < o.length; e++) {
                            o[e].callback.apply(this, t);
                            if (n.off.called) {
                                delete n.off.called;
                                As(this, i, o[e].callback)
                            }
                            if (n.stop.called) {
                                break
                            }
                        }
                    }
                    if (this._delegations) {
                        const t = this._delegations.get(i);
                        const o = this._delegations.get("*");
                        if (t) {
                            ws(t, n, e)
                        }
                        if (o) {
                            ws(o, n, e)
                        }
                    }
                    return n.return
                } catch (t) {
                    ss["a"].rethrowUnexpectedError(t, this)
                }
            }, delegate(...t) {
                return {
                    to: (e, n) => {
                        if (!this._delegations) {
                            this._delegations = new Map
                        }
                        t.forEach((t => {
                            const i = this._delegations.get(t);
                            if (!i) {
                                this._delegations.set(t, new Map([[e, n]]))
                            } else {
                                i.set(e, n)
                            }
                        }))
                    }
                }
            }, stopDelegating(t, e) {
                if (!this._delegations) {
                    return
                }
                if (!t) {
                    this._delegations.clear()
                } else if (!e) {
                    this._delegations.delete(t)
                } else {
                    const n = this._delegations.get(t);
                    if (n) {
                        n.delete(e)
                    }
                }
            }
        };
        var ds = ls;

        function us(t, e) {
            if (t[as] && t[as][e]) {
                return t[as][e].emitter
            }
            return null
        }

        function hs(t, e) {
            if (!t[cs]) {
                t[cs] = e || ns()
            }
        }

        function ms(t) {
            return t[cs]
        }

        function gs(t) {
            if (!t._events) {
                Object.defineProperty(t, "_events", {value: {}})
            }
            return t._events
        }

        function fs() {
            return {callbacks: [], childEvents: []}
        }

        function ps(t, e) {
            const n = gs(t);
            if (n[e]) {
                return
            }
            let i = e;
            let o = null;
            const r = [];
            while (i !== "") {
                if (n[i]) {
                    break
                }
                n[i] = fs();
                r.push(n[i]);
                if (o) {
                    n[i].childEvents.push(o)
                }
                o = i;
                i = i.substr(0, i.lastIndexOf(":"))
            }
            if (i !== "") {
                for (const t of r) {
                    t.callbacks = n[i].callbacks.slice()
                }
                n[i].childEvents.push(o)
            }
        }

        function bs(t, e) {
            const n = gs(t)[e];
            if (!n) {
                return []
            }
            let i = [n.callbacks];
            for (let e = 0; e < n.childEvents.length; e++) {
                const o = bs(t, n.childEvents[e]);
                i = i.concat(o)
            }
            return i
        }

        function ks(t, e) {
            let n;
            if (!t._events || !(n = t._events[e]) || !n.callbacks.length) {
                if (e.indexOf(":") > -1) {
                    return ks(t, e.substr(0, e.lastIndexOf(":")))
                } else {
                    return null
                }
            }
            return n.callbacks
        }

        function ws(t, e, n) {
            for (let [i, o] of t) {
                if (!o) {
                    o = e.name
                } else if (typeof o == "function") {
                    o = o(e.name)
                }
                const t = new ts(e.source, o);
                t.path = [...e.path];
                i.fire(t, ...n)
            }
        }

        function As(t, e, n) {
            const i = bs(t, e);
            for (const t of i) {
                for (let e = 0; e < t.length; e++) {
                    if (t[e].callback == n) {
                        t.splice(e, 1);
                        e--
                    }
                }
            }
        }

        function _s(t) {
            return !!(t && t[Symbol.iterator])
        }

        function Cs(t, ...e) {
            e.forEach((e => {
                Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e)).forEach((n => {
                    if (n in t.prototype) {
                        return
                    }
                    const i = Object.getOwnPropertyDescriptor(e, n);
                    i.enumerable = false;
                    Object.defineProperty(t.prototype, n, i)
                }))
            }))
        }

        class vs {
            constructor(t = {}, e = {}) {
                const n = _s(t);
                if (!n) {
                    e = t
                }
                this._items = [];
                this._itemMap = new Map;
                this._idProperty = e.idProperty || "id";
                this._bindToExternalToInternalMap = new WeakMap;
                this._bindToInternalToExternalMap = new WeakMap;
                this._skippedIndexesFromExternal = [];
                if (n) {
                    for (const e of t) {
                        this._items.push(e);
                        this._itemMap.set(this._getItemIdBeforeAdding(e), e)
                    }
                }
            }

            get length() {
                return this._items.length
            }

            get first() {
                return this._items[0] || null
            }

            get last() {
                return this._items[this.length - 1] || null
            }

            add(t, e) {
                return this.addMany([t], e)
            }

            addMany(t, e) {
                if (e === undefined) {
                    e = this._items.length
                } else if (e > this._items.length || e < 0) {
                    throw new ss["a"]("collection-add-item-invalid-index", this)
                }
                for (let n = 0; n < t.length; n++) {
                    const i = t[n];
                    const o = this._getItemIdBeforeAdding(i);
                    const r = e + n;
                    this._items.splice(r, 0, i);
                    this._itemMap.set(o, i);
                    this.fire("add", i, r)
                }
                this.fire("change", {added: t, removed: [], index: e});
                return this
            }

            get(t) {
                let e;
                if (typeof t == "string") {
                    e = this._itemMap.get(t)
                } else if (typeof t == "number") {
                    e = this._items[t]
                } else {
                    throw new ss["a"]("collection-get-invalid-arg", this)
                }
                return e || null
            }

            has(t) {
                if (typeof t == "string") {
                    return this._itemMap.has(t)
                } else {
                    const e = this._idProperty;
                    const n = t[e];
                    return this._itemMap.has(n)
                }
            }

            getIndex(t) {
                let e;
                if (typeof t == "string") {
                    e = this._itemMap.get(t)
                } else {
                    e = t
                }
                return this._items.indexOf(e)
            }

            remove(t) {
                const [e, n] = this._remove(t);
                this.fire("change", {added: [], removed: [e], index: n});
                return e
            }

            map(t, e) {
                return this._items.map(t, e)
            }

            find(t, e) {
                return this._items.find(t, e)
            }

            filter(t, e) {
                return this._items.filter(t, e)
            }

            clear() {
                if (this._bindToCollection) {
                    this.stopListening(this._bindToCollection);
                    this._bindToCollection = null
                }
                const t = Array.from(this._items);
                while (this.length) {
                    this._remove(0)
                }
                this.fire("change", {added: [], removed: t, index: 0})
            }

            bindTo(t) {
                if (this._bindToCollection) {
                    throw new ss["a"]("collection-bind-to-rebind", this)
                }
                this._bindToCollection = t;
                return {
                    as: t => {
                        this._setUpBindToBinding((e => new t(e)))
                    }, using: t => {
                        if (typeof t == "function") {
                            this._setUpBindToBinding((e => t(e)))
                        } else {
                            this._setUpBindToBinding((e => e[t]))
                        }
                    }
                }
            }

            _setUpBindToBinding(t) {
                const e = this._bindToCollection;
                const n = (n, i, o) => {
                    const r = e._bindToCollection == this;
                    const s = e._bindToInternalToExternalMap.get(i);
                    if (r && s) {
                        this._bindToExternalToInternalMap.set(i, s);
                        this._bindToInternalToExternalMap.set(s, i)
                    } else {
                        const n = t(i);
                        if (!n) {
                            this._skippedIndexesFromExternal.push(o);
                            return
                        }
                        let r = o;
                        for (const t of this._skippedIndexesFromExternal) {
                            if (o > t) {
                                r--
                            }
                        }
                        for (const t of e._skippedIndexesFromExternal) {
                            if (r >= t) {
                                r++
                            }
                        }
                        this._bindToExternalToInternalMap.set(i, n);
                        this._bindToInternalToExternalMap.set(n, i);
                        this.add(n, r);
                        for (let t = 0; t < e._skippedIndexesFromExternal.length; t++) {
                            if (r <= e._skippedIndexesFromExternal[t]) {
                                e._skippedIndexesFromExternal[t]++
                            }
                        }
                    }
                };
                for (const t of e) {
                    n(null, t, e.getIndex(t))
                }
                this.listenTo(e, "add", n);
                this.listenTo(e, "remove", ((t, e, n) => {
                    const i = this._bindToExternalToInternalMap.get(e);
                    if (i) {
                        this.remove(i)
                    }
                    this._skippedIndexesFromExternal = this._skippedIndexesFromExternal.reduce(((t, e) => {
                        if (n < e) {
                            t.push(e - 1)
                        }
                        if (n > e) {
                            t.push(e)
                        }
                        return t
                    }), [])
                }))
            }

            _getItemIdBeforeAdding(t) {
                const e = this._idProperty;
                let n;
                if (e in t) {
                    n = t[e];
                    if (typeof n != "string") {
                        throw new ss["a"]("collection-add-invalid-id", this)
                    }
                    if (this.get(n)) {
                        throw new ss["a"]("collection-add-item-already-exists", this)
                    }
                } else {
                    t[e] = n = ns()
                }
                return n
            }

            _remove(t) {
                let e, n, i;
                let o = false;
                const r = this._idProperty;
                if (typeof t == "string") {
                    n = t;
                    i = this._itemMap.get(n);
                    o = !i;
                    if (i) {
                        e = this._items.indexOf(i)
                    }
                } else if (typeof t == "number") {
                    e = t;
                    i = this._items[e];
                    o = !i;
                    if (i) {
                        n = i[r]
                    }
                } else {
                    i = t;
                    n = i[r];
                    e = this._items.indexOf(i);
                    o = e == -1 || !this._itemMap.get(n)
                }
                if (o) {
                    throw new ss["a"]("collection-remove-404", this)
                }
                this._items.splice(e, 1);
                this._itemMap.delete(n);
                const s = this._bindToInternalToExternalMap.get(i);
                this._bindToInternalToExternalMap.delete(i);
                this._bindToExternalToInternalMap.delete(s);
                this.fire("remove", i, e);
                return [i, e]
            }

            [Symbol.iterator]() {
                return this._items[Symbol.iterator]()
            }
        }

        Cs(vs, ds);

        class ys {
            constructor(t, e = [], n = []) {
                this._context = t;
                this._plugins = new Map;
                this._availablePlugins = new Map;
                for (const t of e) {
                    if (t.pluginName) {
                        this._availablePlugins.set(t.pluginName, t)
                    }
                }
                this._contextPlugins = new Map;
                for (const [t, e] of n) {
                    this._contextPlugins.set(t, e);
                    this._contextPlugins.set(e, t);
                    if (t.pluginName) {
                        this._availablePlugins.set(t.pluginName, t)
                    }
                }
            }

            * [Symbol.iterator]() {
                for (const t of this._plugins) {
                    if (typeof t[0] == "function") {
                        yield t
                    }
                }
            }

            get(t) {
                const e = this._plugins.get(t);
                if (!e) {
                    let e = t;
                    if (typeof t == "function") {
                        e = t.pluginName || t.name
                    }
                    throw new ss["a"]("plugincollection-plugin-not-loaded", this._context, {plugin: e})
                }
                return e
            }

            has(t) {
                return this._plugins.has(t)
            }

            init(t, e = []) {
                const n = this;
                const i = this._context;
                const o = new Set;
                const r = [];
                const s = g(t);
                const a = g(e);
                const c = m(t);
                if (c) {
                    const t = "plugincollection-plugin-not-found";
                    Object(ss["b"])(t, {plugins: c});
                    return Promise.reject(new ss["a"](t, i, {plugins: c}))
                }
                return Promise.all(s.map(l)).then((() => d(r, "init"))).then((() => d(r, "afterInit"))).then((() => r));

                function l(t) {
                    if (a.includes(t)) {
                        return
                    }
                    if (n._plugins.has(t) || o.has(t)) {
                        return
                    }
                    return u(t).catch((e => {
                        Object(ss["b"])("plugincollection-load", {plugin: t});
                        throw e
                    }))
                }

                function d(t, e) {
                    return t.reduce(((t, i) => {
                        if (!i[e]) {
                            return t
                        }
                        if (n._contextPlugins.has(i)) {
                            return t
                        }
                        return t.then(i[e].bind(i))
                    }), Promise.resolve())
                }

                function u(t) {
                    return new Promise((s => {
                        o.add(t);
                        if (t.requires) {
                            t.requires.forEach((n => {
                                const o = h(n);
                                if (t.isContextPlugin && !o.isContextPlugin) {
                                    throw new ss["a"]("plugincollection-context-required", null, {
                                        plugin: o.name,
                                        requiredBy: t.name
                                    })
                                }
                                if (e.includes(o)) {
                                    throw new ss["a"]("plugincollection-required", i, {
                                        plugin: o.name,
                                        requiredBy: t.name
                                    })
                                }
                                l(o)
                            }))
                        }
                        const a = n._contextPlugins.get(t) || new t(i);
                        n._add(t, a);
                        r.push(a);
                        s()
                    }))
                }

                function h(t) {
                    if (typeof t == "function") {
                        return t
                    }
                    return n._availablePlugins.get(t)
                }

                function m(t) {
                    const e = [];
                    for (const n of t) {
                        if (!h(n)) {
                            e.push(n)
                        }
                    }
                    return e.length ? e : null
                }

                function g(t) {
                    return t.map((t => h(t))).filter((t => !!t))
                }
            }

            destroy() {
                const t = [];
                for (const [, e] of this) {
                    if (typeof e.destroy == "function" && !this._contextPlugins.has(e)) {
                        t.push(e.destroy())
                    }
                }
                return Promise.all(t)
            }

            _add(t, e) {
                this._plugins.set(t, e);
                const n = t.pluginName;
                if (!n) {
                    return
                }
                if (this._plugins.has(n)) {
                    throw new ss["a"]("plugincollection-plugin-name-conflict", null, {
                        pluginName: n,
                        plugin1: this._plugins.get(n).constructor,
                        plugin2: t
                    })
                }
                this._plugins.set(n, e)
            }
        }

        Cs(ys, ds);
        if (!window.CKEDITOR_TRANSLATIONS) {
            window.CKEDITOR_TRANSLATIONS = {}
        }

        function xs(t, e, n) {
            if (!window.CKEDITOR_TRANSLATIONS[t]) {
                window.CKEDITOR_TRANSLATIONS[t] = {}
            }
            const i = window.CKEDITOR_TRANSLATIONS[t];
            i.dictionary = i.dictionary || {};
            i.getPluralForm = n || i.getPluralForm;
            Object.assign(i.dictionary, e)
        }

        function Es(t, e, n = 1) {
            if (typeof n !== "number") {
                throw new ss["a"]("translation-service-quantity-not-a-number", null, {quantity: n})
            }
            const i = Ms();
            if (i === 1) {
                t = Object.keys(window.CKEDITOR_TRANSLATIONS)[0]
            }
            const o = e.id || e.string;
            if (i === 0 || !Ts(t, o)) {
                if (n !== 1) {
                    return e.plural
                }
                return e.string
            }
            const r = window.CKEDITOR_TRANSLATIONS[t].dictionary;
            const s = window.CKEDITOR_TRANSLATIONS[t].getPluralForm || (t => t === 1 ? 0 : 1);
            if (typeof r[o] === "string") {
                return r[o]
            }
            const a = Number(s(n));
            return r[o][a]
        }

        function Ds() {
            window.CKEDITOR_TRANSLATIONS = {}
        }

        function Ts(t, e) {
            return !!window.CKEDITOR_TRANSLATIONS[t] && !!window.CKEDITOR_TRANSLATIONS[t].dictionary[e]
        }

        function Ms() {
            return Object.keys(window.CKEDITOR_TRANSLATIONS).length
        }

        const Ss = ["ar", "fa", "he", "ku", "ug"];

        class Is {
            constructor(t = {}) {
                this.uiLanguage = t.uiLanguage || "en";
                this.contentLanguage = t.contentLanguage || this.uiLanguage;
                this.uiLanguageDirection = Ls(this.uiLanguage);
                this.contentLanguageDirection = Ls(this.contentLanguage);
                this.t = (t, e) => this._t(t, e)
            }

            get language() {
                console.warn("locale-deprecated-language-property: " + "The Locale#language property has been deprecated and will be removed in the near future. " + "Please use #uiLanguage and #contentLanguage properties instead.");
                return this.uiLanguage
            }

            _t(t, e = []) {
                if (!Array.isArray(e)) {
                    e = [e]
                }
                if (typeof t === "string") {
                    t = {string: t}
                }
                const n = !!t.plural;
                const i = n ? e[0] : 1;
                const o = Es(this.uiLanguage, t, i);
                return Bs(o, e)
            }
        }

        function Bs(t, e) {
            return t.replace(/%(\d+)/g, ((t, n) => n < e.length ? e[n] : t))
        }

        function Ls(t) {
            return Ss.includes(t) ? "rtl" : "ltr"
        }

        class zs {
            constructor(t) {
                this.config = new Yr(t, this.constructor.defaultConfig);
                const e = this.constructor.builtinPlugins;
                this.config.define("plugins", e);
                this.plugins = new ys(this, e);
                const n = this.config.get("language") || {};
                this.locale = new Is({
                    uiLanguage: typeof n === "string" ? n : n.ui,
                    contentLanguage: this.config.get("language.content")
                });
                this.t = this.locale.t;
                this.editors = new vs;
                this._contextOwner = null
            }

            initPlugins() {
                const t = this.config.get("plugins") || [];
                for (const e of t) {
                    if (typeof e != "function") {
                        throw new ss["a"]("context-initplugins-constructor-only", null, {Plugin: e})
                    }
                    if (e.isContextPlugin !== true) {
                        throw new ss["a"]("context-initplugins-invalid-plugin", null, {Plugin: e})
                    }
                }
                return this.plugins.init(t)
            }

            destroy() {
                return Promise.all(Array.from(this.editors, (t => t.destroy()))).then((() => this.plugins.destroy()))
            }

            _addEditor(t, e) {
                if (this._contextOwner) {
                    throw new ss["a"]("context-addeditor-private-context")
                }
                this.editors.add(t);
                if (e) {
                    this._contextOwner = t
                }
            }

            _removeEditor(t) {
                if (this.editors.has(t)) {
                    this.editors.remove(t)
                }
                if (this._contextOwner === t) {
                    return this.destroy()
                }
                return Promise.resolve()
            }

            _getEditorConfig() {
                const t = {};
                for (const e of this.config.names()) {
                    if (!["plugins", "removePlugins", "extraPlugins"].includes(e)) {
                        t[e] = this.config.get(e)
                    }
                }
                return t
            }

            static create(t) {
                return new Promise((e => {
                    const n = new this(t);
                    e(n.initPlugins().then((() => n)))
                }))
            }
        }

        function Ns(t, e) {
            const n = Math.min(t.length, e.length);
            for (let i = 0; i < n; i++) {
                if (t[i] != e[i]) {
                    return i
                }
            }
            if (t.length == e.length) {
                return "same"
            } else if (t.length < e.length) {
                return "prefix"
            } else {
                return "extension"
            }
        }

        var Ps = 4;

        function Os(t) {
            return Hr(t, Ps)
        }

        var js = Os;

        class Rs {
            constructor(t) {
                this.document = t;
                this.parent = null
            }

            get index() {
                let t;
                if (!this.parent) {
                    return null
                }
                if ((t = this.parent.getChildIndex(this)) == -1) {
                    throw new ss["a"]("view-node-not-found-in-parent", this)
                }
                return t
            }

            get nextSibling() {
                const t = this.index;
                return t !== null && this.parent.getChild(t + 1) || null
            }

            get previousSibling() {
                const t = this.index;
                return t !== null && this.parent.getChild(t - 1) || null
            }

            get root() {
                let t = this;
                while (t.parent) {
                    t = t.parent
                }
                return t
            }

            isAttached() {
                return this.root.is("rootElement")
            }

            getPath() {
                const t = [];
                let e = this;
                while (e.parent) {
                    t.unshift(e.index);
                    e = e.parent
                }
                return t
            }

            getAncestors(t = {includeSelf: false, parentFirst: false}) {
                const e = [];
                let n = t.includeSelf ? this : this.parent;
                while (n) {
                    e[t.parentFirst ? "push" : "unshift"](n);
                    n = n.parent
                }
                return e
            }

            getCommonAncestor(t, e = {}) {
                const n = this.getAncestors(e);
                const i = t.getAncestors(e);
                let o = 0;
                while (n[o] == i[o] && n[o]) {
                    o++
                }
                return o === 0 ? null : n[o - 1]
            }

            isBefore(t) {
                if (this == t) {
                    return false
                }
                if (this.root !== t.root) {
                    return false
                }
                const e = this.getPath();
                const n = t.getPath();
                const i = Ns(e, n);
                switch (i) {
                    case"prefix":
                        return true;
                    case"extension":
                        return false;
                    default:
                        return e[i] < n[i]
                }
            }

            isAfter(t) {
                if (this == t) {
                    return false
                }
                if (this.root !== t.root) {
                    return false
                }
                return !this.isBefore(t)
            }

            _remove() {
                this.parent._removeChildren(this.index)
            }

            _fireChange(t, e) {
                this.fire("change:" + t, e);
                if (this.parent) {
                    this.parent._fireChange(t, e)
                }
            }

            toJSON() {
                const t = js(this);
                delete t.parent;
                return t
            }

            is(t) {
                return t === "node" || t === "view:node"
            }
        }

        Cs(Rs, ds);

        class Fs extends Rs {
            constructor(t, e) {
                super(t);
                this._textData = e
            }

            is(t) {
                return t === "$text" || t === "view:$text" || t === "text" || t === "view:text" || t === "node" || t === "view:node"
            }

            get data() {
                return this._textData
            }

            get _data() {
                return this.data
            }

            set _data(t) {
                this._fireChange("text", this);
                this._textData = t
            }

            isSimilar(t) {
                if (!(t instanceof Fs)) {
                    return false
                }
                return this === t || this.data === t.data
            }

            _clone() {
                return new Fs(this.document, this.data)
            }
        }

        class Vs {
            constructor(t, e, n) {
                this.textNode = t;
                if (e < 0 || e > t.data.length) {
                    throw new ss["a"]("view-textproxy-wrong-offsetintext", this)
                }
                if (n < 0 || e + n > t.data.length) {
                    throw new ss["a"]("view-textproxy-wrong-length", this)
                }
                this.data = t.data.substring(e, e + n);
                this.offsetInText = e
            }

            get offsetSize() {
                return this.data.length
            }

            get isPartial() {
                return this.data.length !== this.textNode.data.length
            }

            get parent() {
                return this.textNode.parent
            }

            get root() {
                return this.textNode.root
            }

            get document() {
                return this.textNode.document
            }

            is(t) {
                return t === "$textProxy" || t === "view:$textProxy" || t === "textProxy" || t === "view:textProxy"
            }

            getAncestors(t = {includeSelf: false, parentFirst: false}) {
                const e = [];
                let n = t.includeSelf ? this.textNode : this.parent;
                while (n !== null) {
                    e[t.parentFirst ? "push" : "unshift"](n);
                    n = n.parent
                }
                return e
            }
        }

        function Hs(t) {
            const e = new Map;
            for (const n in t) {
                e.set(n, t[n])
            }
            return e
        }

        function Us(t) {
            if (_s(t)) {
                return new Map(t)
            } else {
                return Hs(t)
            }
        }

        class Ws {
            constructor(...t) {
                this._patterns = [];
                this.add(...t)
            }

            add(...t) {
                for (let e of t) {
                    if (typeof e == "string" || e instanceof RegExp) {
                        e = {name: e}
                    }
                    if (e.classes && (typeof e.classes == "string" || e.classes instanceof RegExp)) {
                        e.classes = [e.classes]
                    }
                    this._patterns.push(e)
                }
            }

            match(...t) {
                for (const e of t) {
                    for (const t of this._patterns) {
                        const n = qs(e, t);
                        if (n) {
                            return {element: e, pattern: t, match: n}
                        }
                    }
                }
                return null
            }

            matchAll(...t) {
                const e = [];
                for (const n of t) {
                    for (const t of this._patterns) {
                        const i = qs(n, t);
                        if (i) {
                            e.push({element: n, pattern: t, match: i})
                        }
                    }
                }
                return e.length > 0 ? e : null
            }

            getElementName() {
                if (this._patterns.length !== 1) {
                    return null
                }
                const t = this._patterns[0];
                const e = t.name;
                return typeof t != "function" && e && !(e instanceof RegExp) ? e : null
            }
        }

        function qs(t, e) {
            if (typeof e == "function") {
                return e(t)
            }
            const n = {};
            if (e.name) {
                n.name = Ks(e.name, t.name);
                if (!n.name) {
                    return null
                }
            }
            if (e.attributes) {
                n.attributes = Gs(e.attributes, t);
                if (!n.attributes) {
                    return null
                }
            }
            if (e.classes) {
                n.classes = $s(e.classes, t);
                if (!n.classes) {
                    return false
                }
            }
            if (e.styles) {
                n.styles = Ys(e.styles, t);
                if (!n.styles) {
                    return false
                }
            }
            return n
        }

        function Ks(t, e) {
            if (t instanceof RegExp) {
                return t.test(e)
            }
            return t === e
        }

        function Gs(t, e) {
            const n = [];
            for (const i in t) {
                const o = t[i];
                if (e.hasAttribute(i)) {
                    const t = e.getAttribute(i);
                    if (o === true) {
                        n.push(i)
                    } else if (o instanceof RegExp) {
                        if (o.test(t)) {
                            n.push(i)
                        } else {
                            return null
                        }
                    } else if (t === o) {
                        n.push(i)
                    } else {
                        return null
                    }
                } else {
                    return null
                }
            }
            return n
        }

        function $s(t, e) {
            const n = [];
            for (const i of t) {
                if (i instanceof RegExp) {
                    const t = e.getClassNames();
                    for (const e of t) {
                        if (i.test(e)) {
                            n.push(e)
                        }
                    }
                    if (n.length === 0) {
                        return null
                    }
                } else if (e.hasClass(i)) {
                    n.push(i)
                } else {
                    return null
                }
            }
            return n
        }

        function Ys(t, e) {
            const n = [];
            for (const i in t) {
                const o = t[i];
                if (e.hasStyle(i)) {
                    const t = e.getStyle(i);
                    if (o instanceof RegExp) {
                        if (o.test(t)) {
                            n.push(i)
                        } else {
                            return null
                        }
                    } else if (t === o) {
                        n.push(i)
                    } else {
                        return null
                    }
                } else {
                    return null
                }
            }
            return n
        }

        var Qs = "[object Symbol]";

        function Js(t) {
            return typeof t == "symbol" || E(t) && A(t) == Qs
        }

        var Xs = Js;
        var Zs = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, ta = /^\w*$/;

        function ea(t, e) {
            if (Ye(t)) {
                return false
            }
            var n = typeof t;
            if (n == "number" || n == "symbol" || n == "boolean" || t == null || Xs(t)) {
                return true
            }
            return ta.test(t) || !Zs.test(t) || e != null && t in Object(e)
        }

        var na = ea;
        var ia = "Expected a function";

        function oa(t, e) {
            if (typeof t != "function" || e != null && typeof e != "function") {
                throw new TypeError(ia)
            }
            var n = function () {
                var i = arguments, o = e ? e.apply(this, i) : i[0], r = n.cache;
                if (r.has(o)) {
                    return r.get(o)
                }
                var s = t.apply(this, i);
                n.cache = r.set(o, s) || r;
                return s
            };
            n.cache = new (oa.Cache || Ae);
            return n
        }

        oa.Cache = Ae;
        var ra = oa;
        var sa = 500;

        function aa(t) {
            var e = ra(t, (function (t) {
                if (n.size === sa) {
                    n.clear()
                }
                return t
            }));
            var n = e.cache;
            return e
        }

        var ca = aa;
        var la = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
        var da = /\\(\\)?/g;
        var ua = ca((function (t) {
            var e = [];
            if (t.charCodeAt(0) === 46) {
                e.push("")
            }
            t.replace(la, (function (t, n, i, o) {
                e.push(i ? o.replace(da, "$1") : n || t)
            }));
            return e
        }));
        var ha = ua;

        function ma(t, e) {
            var n = -1, i = t == null ? 0 : t.length, o = Array(i);
            while (++n < i) {
                o[n] = e(t[n], n, t)
            }
            return o
        }

        var ga = ma;
        var fa = 1 / 0;
        var pa = r ? r.prototype : undefined, ba = pa ? pa.toString : undefined;

        function ka(t) {
            if (typeof t == "string") {
                return t
            }
            if (Ye(t)) {
                return ga(t, ka) + ""
            }
            if (Xs(t)) {
                return ba ? ba.call(t) : ""
            }
            var e = t + "";
            return e == "0" && 1 / t == -fa ? "-0" : e
        }

        var wa = ka;

        function Aa(t) {
            return t == null ? "" : wa(t)
        }

        var _a = Aa;

        function Ca(t, e) {
            if (Ye(t)) {
                return t
            }
            return na(t, e) ? [t] : ha(_a(t))
        }

        var va = Ca;

        function ya(t) {
            var e = t == null ? 0 : t.length;
            return e ? t[e - 1] : undefined
        }

        var xa = ya;
        var Ea = 1 / 0;

        function Da(t) {
            if (typeof t == "string" || Xs(t)) {
                return t
            }
            var e = t + "";
            return e == "0" && 1 / t == -Ea ? "-0" : e
        }

        var Ta = Da;

        function Ma(t, e) {
            e = va(e, t);
            var n = 0, i = e.length;
            while (t != null && n < i) {
                t = t[Ta(e[n++])]
            }
            return n && n == i ? t : undefined
        }

        var Sa = Ma;

        function Ia(t, e, n) {
            var i = -1, o = t.length;
            if (e < 0) {
                e = -e > o ? 0 : o + e
            }
            n = n > o ? o : n;
            if (n < 0) {
                n += o
            }
            o = e > n ? 0 : n - e >>> 0;
            e >>>= 0;
            var r = Array(o);
            while (++i < o) {
                r[i] = t[i + e]
            }
            return r
        }

        var Ba = Ia;

        function La(t, e) {
            return e.length < 2 ? t : Sa(t, Ba(e, 0, -1))
        }

        var za = La;

        function Na(t, e) {
            e = va(e, t);
            t = za(t, e);
            return t == null || delete t[Ta(xa(e))]
        }

        var Pa = Na;

        function Oa(t, e) {
            return t == null ? true : Pa(t, e)
        }

        var ja = Oa;

        function Ra(t, e, n) {
            var i = t == null ? undefined : Sa(t, e);
            return i === undefined ? n : i
        }

        var Fa = Ra;

        function Va(t, e, n) {
            if (n !== undefined && !j(t[e], n) || n === undefined && !(e in t)) {
                Ie(t, e, n)
            }
        }

        var Ha = Va;

        function Ua(t) {
            return function (e, n, i) {
                var o = -1, r = Object(e), s = i(e), a = s.length;
                while (a--) {
                    var c = s[t ? a : ++o];
                    if (n(r[c], c, r) === false) {
                        break
                    }
                }
                return e
            }
        }

        var Wa = Ua;
        var qa = Wa();
        var Ka = qa;

        function Ga(t) {
            return E(t) && Xn(t)
        }

        var $a = Ga;

        function Ya(t, e) {
            if (e === "constructor" && typeof t[e] === "function") {
                return
            }
            if (e == "__proto__") {
                return
            }
            return t[e]
        }

        var Qa = Ya;

        function Ja(t) {
            return Oe(t, di(t))
        }

        var Xa = Ja;

        function Za(t, e, n, i, o, r, s) {
            var a = Qa(t, n), c = Qa(e, n), l = s.get(c);
            if (l) {
                Ha(t, n, l);
                return
            }
            var d = r ? r(a, c, n + "", t, e, s) : undefined;
            var u = d === undefined;
            if (u) {
                var h = Ye(c), m = !h && Object(Qe["a"])(c), g = !h && !m && On(c);
                d = c;
                if (h || m || g) {
                    if (Ye(a)) {
                        d = a
                    } else if ($a(a)) {
                        d = fi(a)
                    } else if (m) {
                        u = false;
                        d = Object(mi["a"])(c, true)
                    } else if (g) {
                        u = false;
                        d = Eo(c, true)
                    } else {
                        d = []
                    }
                } else if (z(c) || Ge(c)) {
                    d = a;
                    if (Ge(a)) {
                        d = Xa(a)
                    } else if (!ct(a) || gt(a)) {
                        d = Xo(c)
                    }
                } else {
                    u = false
                }
            }
            if (u) {
                s.set(c, d);
                o(d, c, i, r, s);
                s["delete"](c)
            }
            Ha(t, n, d)
        }

        var tc = Za;

        function ec(t, e, n, i, o) {
            if (t === e) {
                return
            }
            Ka(e, (function (r, s) {
                o || (o = new xe);
                if (ct(r)) {
                    tc(t, e, s, n, ec, i, o)
                } else {
                    var a = i ? i(Qa(t, s), r, s + "", t, e, o) : undefined;
                    if (a === undefined) {
                        a = r
                    }
                    Ha(t, s, a)
                }
            }), di)
        }

        var nc = ec;

        function ic(t) {
            return t
        }

        var oc = ic;

        function rc(t, e, n) {
            switch (n.length) {
                case 0:
                    return t.call(e);
                case 1:
                    return t.call(e, n[0]);
                case 2:
                    return t.call(e, n[0], n[1]);
                case 3:
                    return t.call(e, n[0], n[1], n[2])
            }
            return t.apply(e, n)
        }

        var sc = rc;
        var ac = Math.max;

        function cc(t, e, n) {
            e = ac(e === undefined ? t.length - 1 : e, 0);
            return function () {
                var i = arguments, o = -1, r = ac(i.length - e, 0), s = Array(r);
                while (++o < r) {
                    s[o] = i[e + o]
                }
                o = -1;
                var a = Array(e + 1);
                while (++o < e) {
                    a[o] = i[o]
                }
                a[e] = n(s);
                return sc(t, this, a)
            }
        }

        var lc = cc;

        function dc(t) {
            return function () {
                return t
            }
        }

        var uc = dc;
        var hc = !Me ? oc : function (t, e) {
            return Me(t, "toString", {configurable: true, enumerable: false, value: uc(e), writable: true})
        };
        var mc = hc;
        var gc = 800, fc = 16;
        var pc = Date.now;

        function bc(t) {
            var e = 0, n = 0;
            return function () {
                var i = pc(), o = fc - (i - n);
                n = i;
                if (o > 0) {
                    if (++e >= gc) {
                        return arguments[0]
                    }
                } else {
                    e = 0
                }
                return t.apply(undefined, arguments)
            }
        }

        var kc = bc;
        var wc = kc(mc);
        var Ac = wc;

        function _c(t, e) {
            return Ac(lc(t, e, oc), t + "")
        }

        var Cc = _c;

        function vc(t, e, n) {
            if (!ct(n)) {
                return false
            }
            var i = typeof e;
            if (i == "number" ? Xn(n) && tn(e, n.length) : i == "string" && e in n) {
                return j(n[e], t)
            }
            return false
        }

        var yc = vc;

        function xc(t) {
            return Cc((function (e, n) {
                var i = -1, o = n.length, r = o > 1 ? n[o - 1] : undefined, s = o > 2 ? n[2] : undefined;
                r = t.length > 3 && typeof r == "function" ? (o--, r) : undefined;
                if (s && yc(n[0], n[1], s)) {
                    r = o < 3 ? undefined : r;
                    o = 1
                }
                e = Object(e);
                while (++i < o) {
                    var a = n[i];
                    if (a) {
                        t(e, a, i, r)
                    }
                }
                return e
            }))
        }

        var Ec = xc;
        var Dc = Ec((function (t, e, n) {
            nc(t, e, n)
        }));
        var Tc = Dc;

        function Mc(t, e, n, i) {
            if (!ct(t)) {
                return t
            }
            e = va(e, t);
            var o = -1, r = e.length, s = r - 1, a = t;
            while (a != null && ++o < r) {
                var c = Ta(e[o]), l = n;
                if (o != s) {
                    var d = a[c];
                    l = i ? i(d, c, a) : undefined;
                    if (l === undefined) {
                        l = ct(d) ? d : tn(e[o + 1]) ? [] : {}
                    }
                }
                Ne(a, c, l);
                a = a[c]
            }
            return t
        }

        var Sc = Mc;

        function Ic(t, e, n) {
            return t == null ? t : Sc(t, e, n)
        }

        var Bc = Ic;

        class Lc {
            constructor(t) {
                this._styles = {};
                this._styleProcessor = t
            }

            get isEmpty() {
                const t = Object.entries(this._styles);
                const e = Array.from(t);
                return !e.length
            }

            get size() {
                if (this.isEmpty) {
                    return 0
                }
                return this.getStyleNames().length
            }

            setTo(t) {
                this.clear();
                const e = Array.from(Nc(t).entries());
                for (const [t, n] of e) {
                    this._styleProcessor.toNormalizedForm(t, n, this._styles)
                }
            }

            has(t) {
                if (this.isEmpty) {
                    return false
                }
                const e = this._styleProcessor.getReducedForm(t, this._styles);
                const n = e.find((([e]) => e === t));
                return Array.isArray(n)
            }

            set(t, e) {
                if (ct(t)) {
                    for (const [e, n] of Object.entries(t)) {
                        this._styleProcessor.toNormalizedForm(e, n, this._styles)
                    }
                } else {
                    this._styleProcessor.toNormalizedForm(t, e, this._styles)
                }
            }

            remove(t) {
                const e = Pc(t);
                ja(this._styles, e);
                delete this._styles[t];
                this._cleanEmptyObjectsOnPath(e)
            }

            getNormalized(t) {
                return this._styleProcessor.getNormalized(t, this._styles)
            }

            toString() {
                if (this.isEmpty) {
                    return ""
                }
                return this._getStylesEntries().map((t => t.join(":"))).sort().join(";") + ";"
            }

            getAsString(t) {
                if (this.isEmpty) {
                    return
                }
                if (this._styles[t] && !ct(this._styles[t])) {
                    return this._styles[t]
                }
                const e = this._styleProcessor.getReducedForm(t, this._styles);
                const n = e.find((([e]) => e === t));
                if (Array.isArray(n)) {
                    return n[1]
                }
            }

            getStyleNames() {
                if (this.isEmpty) {
                    return []
                }
                const t = this._getStylesEntries();
                return t.map((([t]) => t))
            }

            clear() {
                this._styles = {}
            }

            _getStylesEntries() {
                const t = [];
                const e = Object.keys(this._styles);
                for (const n of e) {
                    t.push(...this._styleProcessor.getReducedForm(n, this._styles))
                }
                return t
            }

            _cleanEmptyObjectsOnPath(t) {
                const e = t.split(".");
                const n = e.length > 1;
                if (!n) {
                    return
                }
                const i = e.splice(0, e.length - 1).join(".");
                const o = Fa(this._styles, i);
                if (!o) {
                    return
                }
                const r = !Array.from(Object.keys(o)).length;
                if (r) {
                    this.remove(i)
                }
            }
        }

        class zc {
            constructor() {
                this._normalizers = new Map;
                this._extractors = new Map;
                this._reducers = new Map;
                this._consumables = new Map
            }

            toNormalizedForm(t, e, n) {
                if (ct(e)) {
                    Oc(n, Pc(t), e);
                    return
                }
                if (this._normalizers.has(t)) {
                    const i = this._normalizers.get(t);
                    const {path: o, value: r} = i(e);
                    Oc(n, o, r)
                } else {
                    Oc(n, t, e)
                }
            }

            getNormalized(t, e) {
                if (!t) {
                    return Tc({}, e)
                }
                if (e[t] !== undefined) {
                    return e[t]
                }
                if (this._extractors.has(t)) {
                    const n = this._extractors.get(t);
                    if (typeof n === "string") {
                        return Fa(e, n)
                    }
                    const i = n(t, e);
                    if (i) {
                        return i
                    }
                }
                return Fa(e, Pc(t))
            }

            getReducedForm(t, e) {
                const n = this.getNormalized(t, e);
                if (n === undefined) {
                    return []
                }
                if (this._reducers.has(t)) {
                    const e = this._reducers.get(t);
                    return e(n)
                }
                return [[t, n]]
            }

            getRelatedStyles(t) {
                return this._consumables.get(t) || []
            }

            setNormalizer(t, e) {
                this._normalizers.set(t, e)
            }

            setExtractor(t, e) {
                this._extractors.set(t, e)
            }

            setReducer(t, e) {
                this._reducers.set(t, e)
            }

            setStyleRelation(t, e) {
                this._mapStyleNames(t, e);
                for (const n of e) {
                    this._mapStyleNames(n, [t])
                }
            }

            _mapStyleNames(t, e) {
                if (!this._consumables.has(t)) {
                    this._consumables.set(t, [])
                }
                this._consumables.get(t).push(...e)
            }
        }

        function Nc(t) {
            let e = null;
            let n = 0;
            let i = 0;
            let o = null;
            const r = new Map;
            if (t === "") {
                return r
            }
            if (t.charAt(t.length - 1) != ";") {
                t = t + ";"
            }
            for (let s = 0; s < t.length; s++) {
                const a = t.charAt(s);
                if (e === null) {
                    switch (a) {
                        case":":
                            if (!o) {
                                o = t.substr(n, s - n);
                                i = s + 1
                            }
                            break;
                        case'"':
                        case"'":
                            e = a;
                            break;
                        case";": {
                            const e = t.substr(i, s - i);
                            if (o) {
                                r.set(o.trim(), e.trim())
                            }
                            o = null;
                            n = s + 1;
                            break
                        }
                    }
                } else if (a === e) {
                    e = null
                }
            }
            return r
        }

        function Pc(t) {
            return t.replace("-", ".")
        }

        function Oc(t, e, n) {
            let i = n;
            if (ct(n)) {
                i = Tc({}, Fa(t, e), n)
            }
            Bc(t, e, i)
        }

        class jc extends Rs {
            constructor(t, e, n, i) {
                super(t);
                this.name = e;
                this._attrs = Rc(n);
                this._children = [];
                if (i) {
                    this._insertChild(0, i)
                }
                this._classes = new Set;
                if (this._attrs.has("class")) {
                    const t = this._attrs.get("class");
                    Fc(this._classes, t);
                    this._attrs.delete("class")
                }
                this._styles = new Lc(this.document.stylesProcessor);
                if (this._attrs.has("style")) {
                    this._styles.setTo(this._attrs.get("style"));
                    this._attrs.delete("style")
                }
                this._customProperties = new Map
            }

            get childCount() {
                return this._children.length
            }

            get isEmpty() {
                return this._children.length === 0
            }

            is(t, e = null) {
                if (!e) {
                    return t === "element" || t === "view:element" || t === "node" || t === "view:node"
                } else {
                    return e === this.name && (t === "element" || t === "view:element")
                }
            }

            getChild(t) {
                return this._children[t]
            }

            getChildIndex(t) {
                return this._children.indexOf(t)
            }

            getChildren() {
                return this._children[Symbol.iterator]()
            }

            * getAttributeKeys() {
                if (this._classes.size > 0) {
                    yield"class"
                }
                if (!this._styles.isEmpty) {
                    yield"style"
                }
                yield* this._attrs.keys()
            }

            * getAttributes() {
                yield* this._attrs.entries();
                if (this._classes.size > 0) {
                    yield["class", this.getAttribute("class")]
                }
                if (!this._styles.isEmpty) {
                    yield["style", this.getAttribute("style")]
                }
            }

            getAttribute(t) {
                if (t == "class") {
                    if (this._classes.size > 0) {
                        return [...this._classes].join(" ")
                    }
                    return undefined
                }
                if (t == "style") {
                    const t = this._styles.toString();
                    return t == "" ? undefined : t
                }
                return this._attrs.get(t)
            }

            hasAttribute(t) {
                if (t == "class") {
                    return this._classes.size > 0
                }
                if (t == "style") {
                    return !this._styles.isEmpty
                }
                return this._attrs.has(t)
            }

            isSimilar(t) {
                if (!(t instanceof jc)) {
                    return false
                }
                if (this === t) {
                    return true
                }
                if (this.name != t.name) {
                    return false
                }
                if (this._attrs.size !== t._attrs.size || this._classes.size !== t._classes.size || this._styles.size !== t._styles.size) {
                    return false
                }
                for (const [e, n] of this._attrs) {
                    if (!t._attrs.has(e) || t._attrs.get(e) !== n) {
                        return false
                    }
                }
                for (const e of this._classes) {
                    if (!t._classes.has(e)) {
                        return false
                    }
                }
                for (const e of this._styles.getStyleNames()) {
                    if (!t._styles.has(e) || t._styles.getAsString(e) !== this._styles.getAsString(e)) {
                        return false
                    }
                }
                return true
            }

            hasClass(...t) {
                for (const e of t) {
                    if (!this._classes.has(e)) {
                        return false
                    }
                }
                return true
            }

            getClassNames() {
                return this._classes.keys()
            }

            getStyle(t) {
                return this._styles.getAsString(t)
            }

            getNormalizedStyle(t) {
                return this._styles.getNormalized(t)
            }

            getStyleNames() {
                return this._styles.getStyleNames()
            }

            hasStyle(...t) {
                for (const e of t) {
                    if (!this._styles.has(e)) {
                        return false
                    }
                }
                return true
            }

            findAncestor(...t) {
                const e = new Ws(...t);
                let n = this.parent;
                while (n) {
                    if (e.match(n)) {
                        return n
                    }
                    n = n.parent
                }
                return null
            }

            getCustomProperty(t) {
                return this._customProperties.get(t)
            }

            * getCustomProperties() {
                yield* this._customProperties.entries()
            }

            getIdentity() {
                const t = Array.from(this._classes).sort().join(",");
                const e = this._styles.toString();
                const n = Array.from(this._attrs).map((t => `${t[0]}="${t[1]}"`)).sort().join(" ");
                return this.name + (t == "" ? "" : ` class="${t}"`) + (!e ? "" : ` style="${e}"`) + (n == "" ? "" : ` ${n}`)
            }

            _clone(t = false) {
                const e = [];
                if (t) {
                    for (const n of this.getChildren()) {
                        e.push(n._clone(t))
                    }
                }
                const n = new this.constructor(this.document, this.name, this._attrs, e);
                n._classes = new Set(this._classes);
                n._styles.set(this._styles.getNormalized());
                n._customProperties = new Map(this._customProperties);
                n.getFillerOffset = this.getFillerOffset;
                return n
            }

            _appendChild(t) {
                return this._insertChild(this.childCount, t)
            }

            _insertChild(t, e) {
                this._fireChange("children", this);
                let n = 0;
                const i = Vc(this.document, e);
                for (const e of i) {
                    if (e.parent !== null) {
                        e._remove()
                    }
                    e.parent = this;
                    e.document = this.document;
                    this._children.splice(t, 0, e);
                    t++;
                    n++
                }
                return n
            }

            _removeChildren(t, e = 1) {
                this._fireChange("children", this);
                for (let n = t; n < t + e; n++) {
                    this._children[n].parent = null
                }
                return this._children.splice(t, e)
            }

            _setAttribute(t, e) {
                e = String(e);
                this._fireChange("attributes", this);
                if (t == "class") {
                    Fc(this._classes, e)
                } else if (t == "style") {
                    this._styles.setTo(e)
                } else {
                    this._attrs.set(t, e)
                }
            }

            _removeAttribute(t) {
                this._fireChange("attributes", this);
                if (t == "class") {
                    if (this._classes.size > 0) {
                        this._classes.clear();
                        return true
                    }
                    return false
                }
                if (t == "style") {
                    if (!this._styles.isEmpty) {
                        this._styles.clear();
                        return true
                    }
                    return false
                }
                return this._attrs.delete(t)
            }

            _addClass(t) {
                this._fireChange("attributes", this);
                t = Array.isArray(t) ? t : [t];
                t.forEach((t => this._classes.add(t)))
            }

            _removeClass(t) {
                this._fireChange("attributes", this);
                t = Array.isArray(t) ? t : [t];
                t.forEach((t => this._classes.delete(t)))
            }

            _setStyle(t, e) {
                this._fireChange("attributes", this);
                this._styles.set(t, e)
            }

            _removeStyle(t) {
                this._fireChange("attributes", this);
                t = Array.isArray(t) ? t : [t];
                t.forEach((t => this._styles.remove(t)))
            }

            _setCustomProperty(t, e) {
                this._customProperties.set(t, e)
            }

            _removeCustomProperty(t) {
                return this._customProperties.delete(t)
            }
        }

        function Rc(t) {
            t = Us(t);
            for (const [e, n] of t) {
                if (n === null) {
                    t.delete(e)
                } else if (typeof n != "string") {
                    t.set(e, String(n))
                }
            }
            return t
        }

        function Fc(t, e) {
            const n = e.split(/\s+/);
            t.clear();
            n.forEach((e => t.add(e)))
        }

        function Vc(t, e) {
            if (typeof e == "string") {
                return [new Fs(t, e)]
            }
            if (!_s(e)) {
                e = [e]
            }
            return Array.from(e).map((e => {
                if (typeof e == "string") {
                    return new Fs(t, e)
                }
                if (e instanceof Vs) {
                    return new Fs(t, e.data)
                }
                return e
            }))
        }

        class Hc extends jc {
            constructor(t, e, n, i) {
                super(t, e, n, i);
                this.getFillerOffset = Uc
            }

            is(t, e = null) {
                if (!e) {
                    return t === "containerElement" || t === "view:containerElement" || t === "element" || t === "view:element" || t === "node" || t === "view:node"
                } else {
                    return e === this.name && (t === "containerElement" || t === "view:containerElement" || t === "element" || t === "view:element")
                }
            }
        }

        function Uc() {
            const t = [...this.getChildren()];
            const e = t[this.childCount - 1];
            if (e && e.is("element", "br")) {
                return this.childCount
            }
            for (const e of t) {
                if (!e.is("uiElement")) {
                    return null
                }
            }
            return this.childCount
        }

        var Wc = Ec((function (t, e) {
            Oe(e, di(e), t)
        }));
        var qc = Wc;
        const Kc = Symbol("observableProperties");
        const Gc = Symbol("boundObservables");
        const $c = Symbol("boundProperties");
        const Yc = {
            set(t, e) {
                if (ct(t)) {
                    Object.keys(t).forEach((e => {
                        this.set(e, t[e])
                    }), this);
                    return
                }
                Jc(this);
                const n = this[Kc];
                if (t in this && !n.has(t)) {
                    throw new ss["a"]("observable-set-cannot-override", this)
                }
                Object.defineProperty(this, t, {
                    enumerable: true, configurable: true, get() {
                        return n.get(t)
                    }, set(e) {
                        const i = n.get(t);
                        let o = this.fire("set:" + t, t, e, i);
                        if (o === undefined) {
                            o = e
                        }
                        if (i !== o || !n.has(t)) {
                            n.set(t, o);
                            this.fire("change:" + t, t, o, i)
                        }
                    }
                });
                this[t] = e
            }, bind(...t) {
                if (!t.length || !el(t)) {
                    throw new ss["a"]("observable-bind-wrong-properties", this)
                }
                if (new Set(t).size !== t.length) {
                    throw new ss["a"]("observable-bind-duplicate-properties", this)
                }
                Jc(this);
                const e = this[$c];
                t.forEach((t => {
                    if (e.has(t)) {
                        throw new ss["a"]("observable-bind-rebind", this)
                    }
                }));
                const n = new Map;
                t.forEach((t => {
                    const i = {property: t, to: []};
                    e.set(t, i);
                    n.set(t, i)
                }));
                return {to: Xc, toMany: Zc, _observable: this, _bindProperties: t, _to: [], _bindings: n}
            }, unbind(...t) {
                if (!this[Kc]) {
                    return
                }
                const e = this[$c];
                const n = this[Gc];
                if (t.length) {
                    if (!el(t)) {
                        throw new ss["a"]("observable-unbind-wrong-properties", this)
                    }
                    t.forEach((t => {
                        const i = e.get(t);
                        if (!i) {
                            return
                        }
                        let o, r, s, a;
                        i.to.forEach((t => {
                            o = t[0];
                            r = t[1];
                            s = n.get(o);
                            a = s[r];
                            a.delete(i);
                            if (!a.size) {
                                delete s[r]
                            }
                            if (!Object.keys(s).length) {
                                n.delete(o);
                                this.stopListening(o, "change")
                            }
                        }));
                        e.delete(t)
                    }))
                } else {
                    n.forEach(((t, e) => {
                        this.stopListening(e, "change")
                    }));
                    n.clear();
                    e.clear()
                }
            }, decorate(t) {
                const e = this[t];
                if (!e) {
                    throw new ss["a"]("observablemixin-cannot-decorate-undefined", this, {object: this, methodName: t})
                }
                this.on(t, ((t, n) => {
                    t.return = e.apply(this, n)
                }));
                this[t] = function (...e) {
                    return this.fire(t, e)
                }
            }
        };
        qc(Yc, ds);
        var Qc = Yc;

        function Jc(t) {
            if (t[Kc]) {
                return
            }
            Object.defineProperty(t, Kc, {value: new Map});
            Object.defineProperty(t, Gc, {value: new Map});
            Object.defineProperty(t, $c, {value: new Map})
        }

        function Xc(...t) {
            const e = nl(...t);
            const n = Array.from(this._bindings.keys());
            const i = n.length;
            if (!e.callback && e.to.length > 1) {
                throw new ss["a"]("observable-bind-to-no-callback", this)
            }
            if (i > 1 && e.callback) {
                throw new ss["a"]("observable-bind-to-extra-callback", this)
            }
            e.to.forEach((t => {
                if (t.properties.length && t.properties.length !== i) {
                    throw new ss["a"]("observable-bind-to-properties-length", this)
                }
                if (!t.properties.length) {
                    t.properties = this._bindProperties
                }
            }));
            this._to = e.to;
            if (e.callback) {
                this._bindings.get(n[0]).callback = e.callback
            }
            sl(this._observable, this._to);
            ol(this);
            this._bindProperties.forEach((t => {
                rl(this._observable, t)
            }))
        }

        function Zc(t, e, n) {
            if (this._bindings.size > 1) {
                throw new ss["a"]("observable-bind-to-many-not-one-binding", this)
            }
            this.to(...tl(t, e), n)
        }

        function tl(t, e) {
            const n = t.map((t => [t, e]));
            return Array.prototype.concat.apply([], n)
        }

        function el(t) {
            return t.every((t => typeof t == "string"))
        }

        function nl(...t) {
            if (!t.length) {
                throw new ss["a"]("observable-bind-to-parse-error", null)
            }
            const e = {to: []};
            let n;
            if (typeof t[t.length - 1] == "function") {
                e.callback = t.pop()
            }
            t.forEach((t => {
                if (typeof t == "string") {
                    n.properties.push(t)
                } else if (typeof t == "object") {
                    n = {observable: t, properties: []};
                    e.to.push(n)
                } else {
                    throw new ss["a"]("observable-bind-to-parse-error", null)
                }
            }));
            return e
        }

        function il(t, e, n, i) {
            const o = t[Gc];
            const r = o.get(n);
            const s = r || {};
            if (!s[i]) {
                s[i] = new Set
            }
            s[i].add(e);
            if (!r) {
                o.set(n, s)
            }
        }

        function ol(t) {
            let e;
            t._bindings.forEach(((n, i) => {
                t._to.forEach((o => {
                    e = o.properties[n.callback ? 0 : t._bindProperties.indexOf(i)];
                    n.to.push([o.observable, e]);
                    il(t._observable, n, o.observable, e)
                }))
            }))
        }

        function rl(t, e) {
            const n = t[$c];
            const i = n.get(e);
            let o;
            if (i.callback) {
                o = i.callback.apply(t, i.to.map((t => t[0][t[1]])))
            } else {
                o = i.to[0];
                o = o[0][o[1]]
            }
            if (Object.prototype.hasOwnProperty.call(t, e)) {
                t[e] = o
            } else {
                t.set(e, o)
            }
        }

        function sl(t, e) {
            e.forEach((e => {
                const n = t[Gc];
                let i;
                if (!n.get(e.observable)) {
                    t.listenTo(e.observable, "change", ((o, r) => {
                        i = n.get(e.observable)[r];
                        if (i) {
                            i.forEach((e => {
                                rl(t, e.property)
                            }))
                        }
                    }))
                }
            }))
        }

        class al extends Hc {
            constructor(t, e, n, i) {
                super(t, e, n, i);
                this.set("isReadOnly", false);
                this.set("isFocused", false);
                this.bind("isReadOnly").to(t);
                this.bind("isFocused").to(t, "isFocused", (e => e && t.selection.editableElement == this));
                this.listenTo(t.selection, "change", (() => {
                    this.isFocused = t.isFocused && t.selection.editableElement == this
                }))
            }

            is(t, e = null) {
                if (!e) {
                    return t === "editableElement" || t === "view:editableElement" || t === "containerElement" || t === "view:containerElement" || t === "element" || t === "view:element" || t === "node" || t === "view:node"
                } else {
                    return e === this.name && (t === "editableElement" || t === "view:editableElement" || t === "containerElement" || t === "view:containerElement" || t === "element" || t === "view:element")
                }
            }

            destroy() {
                this.stopListening()
            }
        }

        Cs(al, Qc);
        const cl = Symbol("rootName");

        class ll extends al {
            constructor(t, e) {
                super(t, e);
                this.rootName = "main"
            }

            is(t, e = null) {
                if (!e) {
                    return t === "rootElement" || t === "view:rootElement" || t === "editableElement" || t === "view:editableElement" || t === "containerElement" || t === "view:containerElement" || t === "element" || t === "view:element" || t === "node" || t === "view:node"
                } else {
                    return e === this.name && (t === "rootElement" || t === "view:rootElement" || t === "editableElement" || t === "view:editableElement" || t === "containerElement" || t === "view:containerElement" || t === "element" || t === "view:element")
                }
            }

            get rootName() {
                return this.getCustomProperty(cl)
            }

            set rootName(t) {
                this._setCustomProperty(cl, t)
            }

            set _name(t) {
                this.name = t
            }
        }

        class dl {
            constructor(t = {}) {
                if (!t.boundaries && !t.startPosition) {
                    throw new ss["a"]("view-tree-walker-no-start-position", null)
                }
                if (t.direction && t.direction != "forward" && t.direction != "backward") {
                    throw new ss["a"]("view-tree-walker-unknown-direction", t.startPosition, {direction: t.direction})
                }
                this.boundaries = t.boundaries || null;
                if (t.startPosition) {
                    this.position = ul._createAt(t.startPosition)
                } else {
                    this.position = ul._createAt(t.boundaries[t.direction == "backward" ? "end" : "start"])
                }
                this.direction = t.direction || "forward";
                this.singleCharacters = !!t.singleCharacters;
                this.shallow = !!t.shallow;
                this.ignoreElementEnd = !!t.ignoreElementEnd;
                this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;
                this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null
            }

            [Symbol.iterator]() {
                return this
            }

            skip(t) {
                let e, n, i;
                do {
                    i = this.position;
                    ({done: e, value: n} = this.next())
                } while (!e && t(n));
                if (!e) {
                    this.position = i
                }
            }

            next() {
                if (this.direction == "forward") {
                    return this._next()
                } else {
                    return this._previous()
                }
            }

            _next() {
                let t = this.position.clone();
                const e = this.position;
                const n = t.parent;
                if (n.parent === null && t.offset === n.childCount) {
                    return {done: true}
                }
                if (n === this._boundaryEndParent && t.offset == this.boundaries.end.offset) {
                    return {done: true}
                }
                let i;
                if (n instanceof Fs) {
                    if (t.isAtEnd) {
                        this.position = ul._createAfter(n);
                        return this._next()
                    }
                    i = n.data[t.offset]
                } else {
                    i = n.getChild(t.offset)
                }
                if (i instanceof jc) {
                    if (!this.shallow) {
                        t = new ul(i, 0)
                    } else {
                        t.offset++
                    }
                    this.position = t;
                    return this._formatReturnValue("elementStart", i, e, t, 1)
                } else if (i instanceof Fs) {
                    if (this.singleCharacters) {
                        t = new ul(i, 0);
                        this.position = t;
                        return this._next()
                    } else {
                        let n = i.data.length;
                        let o;
                        if (i == this._boundaryEndParent) {
                            n = this.boundaries.end.offset;
                            o = new Vs(i, 0, n);
                            t = ul._createAfter(o)
                        } else {
                            o = new Vs(i, 0, i.data.length);
                            t.offset++
                        }
                        this.position = t;
                        return this._formatReturnValue("text", o, e, t, n)
                    }
                } else if (typeof i == "string") {
                    let i;
                    if (this.singleCharacters) {
                        i = 1
                    } else {
                        const e = n === this._boundaryEndParent ? this.boundaries.end.offset : n.data.length;
                        i = e - t.offset
                    }
                    const o = new Vs(n, t.offset, i);
                    t.offset += i;
                    this.position = t;
                    return this._formatReturnValue("text", o, e, t, i)
                } else {
                    t = ul._createAfter(n);
                    this.position = t;
                    if (this.ignoreElementEnd) {
                        return this._next()
                    } else {
                        return this._formatReturnValue("elementEnd", n, e, t)
                    }
                }
            }

            _previous() {
                let t = this.position.clone();
                const e = this.position;
                const n = t.parent;
                if (n.parent === null && t.offset === 0) {
                    return {done: true}
                }
                if (n == this._boundaryStartParent && t.offset == this.boundaries.start.offset) {
                    return {done: true}
                }
                let i;
                if (n instanceof Fs) {
                    if (t.isAtStart) {
                        this.position = ul._createBefore(n);
                        return this._previous()
                    }
                    i = n.data[t.offset - 1]
                } else {
                    i = n.getChild(t.offset - 1)
                }
                if (i instanceof jc) {
                    if (!this.shallow) {
                        t = new ul(i, i.childCount);
                        this.position = t;
                        if (this.ignoreElementEnd) {
                            return this._previous()
                        } else {
                            return this._formatReturnValue("elementEnd", i, e, t)
                        }
                    } else {
                        t.offset--;
                        this.position = t;
                        return this._formatReturnValue("elementStart", i, e, t, 1)
                    }
                } else if (i instanceof Fs) {
                    if (this.singleCharacters) {
                        t = new ul(i, i.data.length);
                        this.position = t;
                        return this._previous()
                    } else {
                        let n = i.data.length;
                        let o;
                        if (i == this._boundaryStartParent) {
                            const e = this.boundaries.start.offset;
                            o = new Vs(i, e, i.data.length - e);
                            n = o.data.length;
                            t = ul._createBefore(o)
                        } else {
                            o = new Vs(i, 0, i.data.length);
                            t.offset--
                        }
                        this.position = t;
                        return this._formatReturnValue("text", o, e, t, n)
                    }
                } else if (typeof i == "string") {
                    let i;
                    if (!this.singleCharacters) {
                        const e = n === this._boundaryStartParent ? this.boundaries.start.offset : 0;
                        i = t.offset - e
                    } else {
                        i = 1
                    }
                    t.offset -= i;
                    const o = new Vs(n, t.offset, i);
                    this.position = t;
                    return this._formatReturnValue("text", o, e, t, i)
                } else {
                    t = ul._createBefore(n);
                    this.position = t;
                    return this._formatReturnValue("elementStart", n, e, t, 1)
                }
            }

            _formatReturnValue(t, e, n, i, o) {
                if (e instanceof Vs) {
                    if (e.offsetInText + e.data.length == e.textNode.data.length) {
                        if (this.direction == "forward" && !(this.boundaries && this.boundaries.end.isEqual(this.position))) {
                            i = ul._createAfter(e.textNode);
                            this.position = i
                        } else {
                            n = ul._createAfter(e.textNode)
                        }
                    }
                    if (e.offsetInText === 0) {
                        if (this.direction == "backward" && !(this.boundaries && this.boundaries.start.isEqual(this.position))) {
                            i = ul._createBefore(e.textNode);
                            this.position = i
                        } else {
                            n = ul._createBefore(e.textNode)
                        }
                    }
                }
                return {done: false, value: {type: t, item: e, previousPosition: n, nextPosition: i, length: o}}
            }
        }

        class ul {
            constructor(t, e) {
                this.parent = t;
                this.offset = e
            }

            get nodeAfter() {
                if (this.parent.is("$text")) {
                    return null
                }
                return this.parent.getChild(this.offset) || null
            }

            get nodeBefore() {
                if (this.parent.is("$text")) {
                    return null
                }
                return this.parent.getChild(this.offset - 1) || null
            }

            get isAtStart() {
                return this.offset === 0
            }

            get isAtEnd() {
                const t = this.parent.is("$text") ? this.parent.data.length : this.parent.childCount;
                return this.offset === t
            }

            get root() {
                return this.parent.root
            }

            get editableElement() {
                let t = this.parent;
                while (!(t instanceof al)) {
                    if (t.parent) {
                        t = t.parent
                    } else {
                        return null
                    }
                }
                return t
            }

            getShiftedBy(t) {
                const e = ul._createAt(this);
                const n = e.offset + t;
                e.offset = n < 0 ? 0 : n;
                return e
            }

            getLastMatchingPosition(t, e = {}) {
                e.startPosition = this;
                const n = new dl(e);
                n.skip(t);
                return n.position
            }

            getAncestors() {
                if (this.parent.is("documentFragment")) {
                    return [this.parent]
                } else {
                    return this.parent.getAncestors({includeSelf: true})
                }
            }

            getCommonAncestor(t) {
                const e = this.getAncestors();
                const n = t.getAncestors();
                let i = 0;
                while (e[i] == n[i] && e[i]) {
                    i++
                }
                return i === 0 ? null : e[i - 1]
            }

            is(t) {
                return t === "position" || t === "view:position"
            }

            isEqual(t) {
                return this.parent == t.parent && this.offset == t.offset
            }

            isBefore(t) {
                return this.compareWith(t) == "before"
            }

            isAfter(t) {
                return this.compareWith(t) == "after"
            }

            compareWith(t) {
                if (this.root !== t.root) {
                    return "different"
                }
                if (this.isEqual(t)) {
                    return "same"
                }
                const e = this.parent.is("node") ? this.parent.getPath() : [];
                const n = t.parent.is("node") ? t.parent.getPath() : [];
                e.push(this.offset);
                n.push(t.offset);
                const i = Ns(e, n);
                switch (i) {
                    case"prefix":
                        return "before";
                    case"extension":
                        return "after";
                    default:
                        return e[i] < n[i] ? "before" : "after"
                }
            }

            getWalker(t = {}) {
                t.startPosition = this;
                return new dl(t)
            }

            clone() {
                return new ul(this.parent, this.offset)
            }

            static _createAt(t, e) {
                if (t instanceof ul) {
                    return new this(t.parent, t.offset)
                } else {
                    const n = t;
                    if (e == "end") {
                        e = n.is("$text") ? n.data.length : n.childCount
                    } else if (e == "before") {
                        return this._createBefore(n)
                    } else if (e == "after") {
                        return this._createAfter(n)
                    } else if (e !== 0 && !e) {
                        throw new ss["a"]("view-createpositionat-offset-required", n)
                    }
                    return new ul(n, e)
                }
            }

            static _createAfter(t) {
                if (t.is("$textProxy")) {
                    return new ul(t.textNode, t.offsetInText + t.data.length)
                }
                if (!t.parent) {
                    throw new ss["a"]("view-position-after-root", t, {root: t})
                }
                return new ul(t.parent, t.index + 1)
            }

            static _createBefore(t) {
                if (t.is("$textProxy")) {
                    return new ul(t.textNode, t.offsetInText)
                }
                if (!t.parent) {
                    throw new ss["a"]("view-position-before-root", t, {root: t})
                }
                return new ul(t.parent, t.index)
            }
        }

        class hl {
            constructor(t, e = null) {
                this.start = t.clone();
                this.end = e ? e.clone() : t.clone()
            }

            * [Symbol.iterator]() {
                yield* new dl({boundaries: this, ignoreElementEnd: true})
            }

            get isCollapsed() {
                return this.start.isEqual(this.end)
            }

            get isFlat() {
                return this.start.parent === this.end.parent
            }

            get root() {
                return this.start.root
            }

            getEnlarged() {
                let t = this.start.getLastMatchingPosition(ml, {direction: "backward"});
                let e = this.end.getLastMatchingPosition(ml);
                if (t.parent.is("$text") && t.isAtStart) {
                    t = ul._createBefore(t.parent)
                }
                if (e.parent.is("$text") && e.isAtEnd) {
                    e = ul._createAfter(e.parent)
                }
                return new hl(t, e)
            }

            getTrimmed() {
                let t = this.start.getLastMatchingPosition(ml);
                if (t.isAfter(this.end) || t.isEqual(this.end)) {
                    return new hl(t, t)
                }
                let e = this.end.getLastMatchingPosition(ml, {direction: "backward"});
                const n = t.nodeAfter;
                const i = e.nodeBefore;
                if (n && n.is("$text")) {
                    t = new ul(n, 0)
                }
                if (i && i.is("$text")) {
                    e = new ul(i, i.data.length)
                }
                return new hl(t, e)
            }

            isEqual(t) {
                return this == t || this.start.isEqual(t.start) && this.end.isEqual(t.end)
            }

            containsPosition(t) {
                return t.isAfter(this.start) && t.isBefore(this.end)
            }

            containsRange(t, e = false) {
                if (t.isCollapsed) {
                    e = false
                }
                const n = this.containsPosition(t.start) || e && this.start.isEqual(t.start);
                const i = this.containsPosition(t.end) || e && this.end.isEqual(t.end);
                return n && i
            }

            getDifference(t) {
                const e = [];
                if (this.isIntersecting(t)) {
                    if (this.containsPosition(t.start)) {
                        e.push(new hl(this.start, t.start))
                    }
                    if (this.containsPosition(t.end)) {
                        e.push(new hl(t.end, this.end))
                    }
                } else {
                    e.push(this.clone())
                }
                return e
            }

            getIntersection(t) {
                if (this.isIntersecting(t)) {
                    let e = this.start;
                    let n = this.end;
                    if (this.containsPosition(t.start)) {
                        e = t.start
                    }
                    if (this.containsPosition(t.end)) {
                        n = t.end
                    }
                    return new hl(e, n)
                }
                return null
            }

            getWalker(t = {}) {
                t.boundaries = this;
                return new dl(t)
            }

            getCommonAncestor() {
                return this.start.getCommonAncestor(this.end)
            }

            getContainedElement() {
                if (this.isCollapsed) {
                    return null
                }
                let t = this.start.nodeAfter;
                let e = this.end.nodeBefore;
                if (this.start.parent.is("$text") && this.start.isAtEnd && this.start.parent.nextSibling) {
                    t = this.start.parent.nextSibling
                }
                if (this.end.parent.is("$text") && this.end.isAtStart && this.end.parent.previousSibling) {
                    e = this.end.parent.previousSibling
                }
                if (t && t.is("element") && t === e) {
                    return t
                }
                return null
            }

            clone() {
                return new hl(this.start, this.end)
            }

            * getItems(t = {}) {
                t.boundaries = this;
                t.ignoreElementEnd = true;
                const e = new dl(t);
                for (const t of e) {
                    yield t.item
                }
            }

            * getPositions(t = {}) {
                t.boundaries = this;
                const e = new dl(t);
                yield e.position;
                for (const t of e) {
                    yield t.nextPosition
                }
            }

            is(t) {
                return t === "range" || t === "view:range"
            }

            isIntersecting(t) {
                return this.start.isBefore(t.end) && this.end.isAfter(t.start)
            }

            static _createFromParentsAndOffsets(t, e, n, i) {
                return new this(new ul(t, e), new ul(n, i))
            }

            static _createFromPositionAndShift(t, e) {
                const n = t;
                const i = t.getShiftedBy(e);
                return e > 0 ? new this(n, i) : new this(i, n)
            }

            static _createIn(t) {
                return this._createFromParentsAndOffsets(t, 0, t, t.childCount)
            }

            static _createOn(t) {
                const e = t.is("$textProxy") ? t.offsetSize : 1;
                return this._createFromPositionAndShift(ul._createBefore(t), e)
            }
        }

        function ml(t) {
            if (t.item.is("attributeElement") || t.item.is("uiElement")) {
                return true
            }
            return false
        }

        function gl(t) {
            let e = 0;
            for (const n of t) {
                e++
            }
            return e
        }

        class fl {
            constructor(t = null, e, n) {
                this._ranges = [];
                this._lastRangeBackward = false;
                this._isFake = false;
                this._fakeSelectionLabel = "";
                this.setTo(t, e, n)
            }

            get isFake() {
                return this._isFake
            }

            get fakeSelectionLabel() {
                return this._fakeSelectionLabel
            }

            get anchor() {
                if (!this._ranges.length) {
                    return null
                }
                const t = this._ranges[this._ranges.length - 1];
                const e = this._lastRangeBackward ? t.end : t.start;
                return e.clone()
            }

            get focus() {
                if (!this._ranges.length) {
                    return null
                }
                const t = this._ranges[this._ranges.length - 1];
                const e = this._lastRangeBackward ? t.start : t.end;
                return e.clone()
            }

            get isCollapsed() {
                return this.rangeCount === 1 && this._ranges[0].isCollapsed
            }

            get rangeCount() {
                return this._ranges.length
            }

            get isBackward() {
                return !this.isCollapsed && this._lastRangeBackward
            }

            get editableElement() {
                if (this.anchor) {
                    return this.anchor.editableElement
                }
                return null
            }

            * getRanges() {
                for (const t of this._ranges) {
                    yield t.clone()
                }
            }

            getFirstRange() {
                let t = null;
                for (const e of this._ranges) {
                    if (!t || e.start.isBefore(t.start)) {
                        t = e
                    }
                }
                return t ? t.clone() : null
            }

            getLastRange() {
                let t = null;
                for (const e of this._ranges) {
                    if (!t || e.end.isAfter(t.end)) {
                        t = e
                    }
                }
                return t ? t.clone() : null
            }

            getFirstPosition() {
                const t = this.getFirstRange();
                return t ? t.start.clone() : null
            }

            getLastPosition() {
                const t = this.getLastRange();
                return t ? t.end.clone() : null
            }

            isEqual(t) {
                if (this.isFake != t.isFake) {
                    return false
                }
                if (this.isFake && this.fakeSelectionLabel != t.fakeSelectionLabel) {
                    return false
                }
                if (this.rangeCount != t.rangeCount) {
                    return false
                } else if (this.rangeCount === 0) {
                    return true
                }
                if (!this.anchor.isEqual(t.anchor) || !this.focus.isEqual(t.focus)) {
                    return false
                }
                for (const e of this._ranges) {
                    let n = false;
                    for (const i of t._ranges) {
                        if (e.isEqual(i)) {
                            n = true;
                            break
                        }
                    }
                    if (!n) {
                        return false
                    }
                }
                return true
            }

            isSimilar(t) {
                if (this.isBackward != t.isBackward) {
                    return false
                }
                const e = gl(this.getRanges());
                const n = gl(t.getRanges());
                if (e != n) {
                    return false
                }
                if (e == 0) {
                    return true
                }
                for (let e of this.getRanges()) {
                    e = e.getTrimmed();
                    let n = false;
                    for (let i of t.getRanges()) {
                        i = i.getTrimmed();
                        if (e.start.isEqual(i.start) && e.end.isEqual(i.end)) {
                            n = true;
                            break
                        }
                    }
                    if (!n) {
                        return false
                    }
                }
                return true
            }

            getSelectedElement() {
                if (this.rangeCount !== 1) {
                    return null
                }
                return this.getFirstRange().getContainedElement()
            }

            setTo(t, e, n) {
                if (t === null) {
                    this._setRanges([]);
                    this._setFakeOptions(e)
                } else if (t instanceof fl || t instanceof pl) {
                    this._setRanges(t.getRanges(), t.isBackward);
                    this._setFakeOptions({fake: t.isFake, label: t.fakeSelectionLabel})
                } else if (t instanceof hl) {
                    this._setRanges([t], e && e.backward);
                    this._setFakeOptions(e)
                } else if (t instanceof ul) {
                    this._setRanges([new hl(t)]);
                    this._setFakeOptions(e)
                } else if (t instanceof Rs) {
                    const i = !!n && !!n.backward;
                    let o;
                    if (e === undefined) {
                        throw new ss["a"]("view-selection-setto-required-second-parameter", this)
                    } else if (e == "in") {
                        o = hl._createIn(t)
                    } else if (e == "on") {
                        o = hl._createOn(t)
                    } else {
                        o = new hl(ul._createAt(t, e))
                    }
                    this._setRanges([o], i);
                    this._setFakeOptions(n)
                } else if (_s(t)) {
                    this._setRanges(t, e && e.backward);
                    this._setFakeOptions(e)
                } else {
                    throw new ss["a"]("view-selection-setto-not-selectable", this)
                }
                this.fire("change")
            }

            setFocus(t, e) {
                if (this.anchor === null) {
                    throw new ss["a"]("view-selection-setfocus-no-ranges", this)
                }
                const n = ul._createAt(t, e);
                if (n.compareWith(this.focus) == "same") {
                    return
                }
                const i = this.anchor;
                this._ranges.pop();
                if (n.compareWith(i) == "before") {
                    this._addRange(new hl(n, i), true)
                } else {
                    this._addRange(new hl(i, n))
                }
                this.fire("change")
            }

            is(t) {
                return t === "selection" || t === "view:selection"
            }

            _setRanges(t, e = false) {
                t = Array.from(t);
                this._ranges = [];
                for (const e of t) {
                    this._addRange(e)
                }
                this._lastRangeBackward = !!e
            }

            _setFakeOptions(t = {}) {
                this._isFake = !!t.fake;
                this._fakeSelectionLabel = t.fake ? t.label || "" : ""
            }

            _addRange(t, e = false) {
                if (!(t instanceof hl)) {
                    throw new ss["a"]("view-selection-add-range-not-range", this)
                }
                this._pushRange(t);
                this._lastRangeBackward = !!e
            }

            _pushRange(t) {
                for (const e of this._ranges) {
                    if (t.isIntersecting(e)) {
                        throw new ss["a"]("view-selection-range-intersects", this, {
                            addedRange: t,
                            intersectingRange: e
                        })
                    }
                }
                this._ranges.push(new hl(t.start, t.end))
            }
        }

        Cs(fl, ds);

        class pl {
            constructor(t = null, e, n) {
                this._selection = new fl;
                this._selection.delegate("change").to(this);
                this._selection.setTo(t, e, n)
            }

            get isFake() {
                return this._selection.isFake
            }

            get fakeSelectionLabel() {
                return this._selection.fakeSelectionLabel
            }

            get anchor() {
                return this._selection.anchor
            }

            get focus() {
                return this._selection.focus
            }

            get isCollapsed() {
                return this._selection.isCollapsed
            }

            get rangeCount() {
                return this._selection.rangeCount
            }

            get isBackward() {
                return this._selection.isBackward
            }

            get editableElement() {
                return this._selection.editableElement
            }

            get _ranges() {
                return this._selection._ranges
            }

            * getRanges() {
                yield* this._selection.getRanges()
            }

            getFirstRange() {
                return this._selection.getFirstRange()
            }

            getLastRange() {
                return this._selection.getLastRange()
            }

            getFirstPosition() {
                return this._selection.getFirstPosition()
            }

            getLastPosition() {
                return this._selection.getLastPosition()
            }

            getSelectedElement() {
                return this._selection.getSelectedElement()
            }

            isEqual(t) {
                return this._selection.isEqual(t)
            }

            isSimilar(t) {
                return this._selection.isSimilar(t)
            }

            is(t) {
                return t === "selection" || t == "documentSelection" || t == "view:selection" || t == "view:documentSelection"
            }

            _setTo(t, e, n) {
                this._selection.setTo(t, e, n)
            }

            _setFocus(t, e) {
                this._selection.setFocus(t, e)
            }
        }

        Cs(pl, ds);

        class bl {
            constructor(t) {
                this.selection = new pl;
                this.roots = new vs({idProperty: "rootName"});
                this.stylesProcessor = t;
                this.set("isReadOnly", false);
                this.set("isFocused", false);
                this.set("isComposing", false);
                this._postFixers = new Set
            }

            getRoot(t = "main") {
                return this.roots.get(t)
            }

            registerPostFixer(t) {
                this._postFixers.add(t)
            }

            destroy() {
                this.roots.map((t => t.destroy()));
                this.stopListening()
            }

            _callPostFixers(t) {
                let e = false;
                do {
                    for (const n of this._postFixers) {
                        e = n(t);
                        if (e) {
                            break
                        }
                    }
                } while (e)
            }
        }

        Cs(bl, Qc);
        const kl = 10;

        class wl extends jc {
            constructor(t, e, n, i) {
                super(t, e, n, i);
                this.getFillerOffset = Al;
                this._priority = kl;
                this._id = null;
                this._clonesGroup = null
            }

            get priority() {
                return this._priority
            }

            get id() {
                return this._id
            }

            getElementsWithSameId() {
                if (this.id === null) {
                    throw new ss["a"]("attribute-element-get-elements-with-same-id-no-id", this)
                }
                return new Set(this._clonesGroup)
            }

            is(t, e = null) {
                if (!e) {
                    return t === "attributeElement" || t === "view:attributeElement" || t === "element" || t === "view:element" || t === "node" || t === "view:node"
                } else {
                    return e === this.name && (t === "attributeElement" || t === "view:attributeElement" || t === "element" || t === "view:element")
                }
            }

            isSimilar(t) {
                if (this.id !== null || t.id !== null) {
                    return this.id === t.id
                }
                return super.isSimilar(t) && this.priority == t.priority
            }

            _clone(t) {
                const e = super._clone(t);
                e._priority = this._priority;
                e._id = this._id;
                return e
            }
        }

        wl.DEFAULT_PRIORITY = kl;

        function Al() {
            if (_l(this)) {
                return null
            }
            let t = this.parent;
            while (t && t.is("attributeElement")) {
                if (_l(t) > 1) {
                    return null
                }
                t = t.parent
            }
            if (!t || _l(t) > 1) {
                return null
            }
            return this.childCount
        }

        function _l(t) {
            return Array.from(t.getChildren()).filter((t => !t.is("uiElement"))).length
        }

        class Cl extends jc {
            constructor(t, e, n, i) {
                super(t, e, n, i);
                this.getFillerOffset = vl
            }

            is(t, e = null) {
                if (!e) {
                    return t === "emptyElement" || t === "view:emptyElement" || t === "element" || t === "view:element" || t === "node" || t === "view:node"
                } else {
                    return e === this.name && (t === "emptyElement" || t === "view:emptyElement" || t === "element" || t === "view:element")
                }
            }

            _insertChild(t, e) {
                if (e && (e instanceof Rs || Array.from(e).length > 0)) {
                    throw new ss["a"]("view-emptyelement-cannot-add", [this, e])
                }
            }
        }

        function vl() {
            return null
        }

        const yl = navigator.userAgent.toLowerCase();
        const xl = {
            isMac: Dl(yl),
            isGecko: Tl(yl),
            isSafari: Ml(yl),
            isAndroid: Sl(yl),
            isBlink: Il(yl),
            features: {isRegExpUnicodePropertySupported: Bl()}
        };
        var El = xl;

        function Dl(t) {
            return t.indexOf("macintosh") > -1
        }

        function Tl(t) {
            return !!t.match(/gecko\/\d+/)
        }

        function Ml(t) {
            return t.indexOf(" applewebkit/") > -1 && t.indexOf("chrome") === -1
        }

        function Sl(t) {
            return t.indexOf("android") > -1
        }

        function Il(t) {
            return t.indexOf("chrome/") > -1 && t.indexOf("edge/") < 0
        }

        function Bl() {
            let t = false;
            try {
                t = "ć".search(new RegExp("[\\p{L}]", "u")) === 0
            } catch (t) {
            }
            return t
        }

        const Ll = {"⌘": "ctrl", "⇧": "shift", "⌥": "alt"};
        const zl = {ctrl: "⌘", shift: "⇧", alt: "⌥"};
        const Nl = Hl();

        function Pl(t) {
            let e;
            if (typeof t == "string") {
                e = Nl[t.toLowerCase()];
                if (!e) {
                    throw new ss["a"]("keyboard-unknown-key", null, {key: t})
                }
            } else {
                e = t.keyCode + (t.altKey ? Nl.alt : 0) + (t.ctrlKey ? Nl.ctrl : 0) + (t.shiftKey ? Nl.shift : 0)
            }
            return e
        }

        function Ol(t) {
            if (typeof t == "string") {
                t = Ul(t)
            }
            return t.map((t => typeof t == "string" ? Pl(t) : t)).reduce(((t, e) => e + t), 0)
        }

        function jl(t) {
            if (!El.isMac) {
                return t
            }
            return Ul(t).map((t => zl[t.toLowerCase()] || t)).reduce(((t, e) => {
                if (t.slice(-1) in Ll) {
                    return t + e
                } else {
                    return t + "+" + e
                }
            }))
        }

        function Rl(t) {
            return t == Nl.arrowright || t == Nl.arrowleft || t == Nl.arrowup || t == Nl.arrowdown
        }

        function Fl(t, e) {
            const n = e === "ltr";
            switch (t) {
                case Nl.arrowleft:
                    return n ? "left" : "right";
                case Nl.arrowright:
                    return n ? "right" : "left";
                case Nl.arrowup:
                    return "up";
                case Nl.arrowdown:
                    return "down"
            }
        }

        function Vl(t, e) {
            const n = Fl(t, e);
            return n === "down" || n === "right"
        }

        function Hl() {
            const t = {
                arrowleft: 37,
                arrowup: 38,
                arrowright: 39,
                arrowdown: 40,
                backspace: 8,
                delete: 46,
                enter: 13,
                space: 32,
                esc: 27,
                tab: 9,
                ctrl: 1114112,
                cmd: 1114112,
                shift: 2228224,
                alt: 4456448
            };
            for (let e = 65; e <= 90; e++) {
                const n = String.fromCharCode(e);
                t[n.toLowerCase()] = e
            }
            for (let e = 48; e <= 57; e++) {
                t[e - 48] = e
            }
            for (let e = 112; e <= 123; e++) {
                t["f" + (e - 111)] = e
            }
            return t
        }

        function Ul(t) {
            return t.split(/\s*\+\s*/)
        }

        class Wl extends jc {
            constructor(t, e, n, i) {
                super(t, e, n, i);
                this.getFillerOffset = Kl
            }

            is(t, e = null) {
                if (!e) {
                    return t === "uiElement" || t === "view:uiElement" || t === "element" || t === "view:element" || t === "node" || t === "view:node"
                } else {
                    return e === this.name && (t === "uiElement" || t === "view:uiElement" || t === "element" || t === "view:element")
                }
            }

            _insertChild(t, e) {
                if (e && (e instanceof Rs || Array.from(e).length > 0)) {
                    throw new ss["a"]("view-uielement-cannot-add", this)
                }
            }

            render(t) {
                return this.toDomElement(t)
            }

            toDomElement(t) {
                const e = t.createElement(this.name);
                for (const t of this.getAttributeKeys()) {
                    e.setAttribute(t, this.getAttribute(t))
                }
                return e
            }
        }

        function ql(t) {
            t.document.on("keydown", ((e, n) => Gl(e, n, t.domConverter)))
        }

        function Kl() {
            return null
        }

        function Gl(t, e, n) {
            if (e.keyCode == Nl.arrowright) {
                const t = e.domTarget.ownerDocument.defaultView.getSelection();
                const i = t.rangeCount == 1 && t.getRangeAt(0).collapsed;
                if (i || e.shiftKey) {
                    const e = t.focusNode;
                    const o = t.focusOffset;
                    const r = n.domPositionToView(e, o);
                    if (r === null) {
                        return
                    }
                    let s = false;
                    const a = r.getLastMatchingPosition((t => {
                        if (t.item.is("uiElement")) {
                            s = true
                        }
                        if (t.item.is("uiElement") || t.item.is("attributeElement")) {
                            return true
                        }
                        return false
                    }));
                    if (s) {
                        const e = n.viewPositionToDom(a);
                        if (i) {
                            t.collapse(e.parent, e.offset)
                        } else {
                            t.extend(e.parent, e.offset)
                        }
                    }
                }
            }
        }

        class $l extends jc {
            constructor(t, e, n, i) {
                super(t, e, n, i);
                this.getFillerOffset = Yl
            }

            is(t, e = null) {
                if (!e) {
                    return t === "rawElement" || t === "view:rawElement" || t === this.name || t === "view:" + this.name || t === "element" || t === "view:element" || t === "node" || t === "view:node"
                } else {
                    return e === this.name && (t === "rawElement" || t === "view:rawElement" || t === "element" || t === "view:element")
                }
            }

            _insertChild(t, e) {
                if (e && (e instanceof Rs || Array.from(e).length > 0)) {
                    throw new ss["a"]("view-rawelement-cannot-add", [this, e])
                }
            }
        }

        function Yl() {
            return null
        }

        class Ql {
            constructor(t, e) {
                this.document = t;
                this._children = [];
                if (e) {
                    this._insertChild(0, e)
                }
            }

            [Symbol.iterator]() {
                return this._children[Symbol.iterator]()
            }

            get childCount() {
                return this._children.length
            }

            get isEmpty() {
                return this.childCount === 0
            }

            get root() {
                return this
            }

            get parent() {
                return null
            }

            is(t) {
                return t === "documentFragment" || t === "view:documentFragment"
            }

            _appendChild(t) {
                return this._insertChild(this.childCount, t)
            }

            getChild(t) {
                return this._children[t]
            }

            getChildIndex(t) {
                return this._children.indexOf(t)
            }

            getChildren() {
                return this._children[Symbol.iterator]()
            }

            _insertChild(t, e) {
                this._fireChange("children", this);
                let n = 0;
                const i = Jl(this.document, e);
                for (const e of i) {
                    if (e.parent !== null) {
                        e._remove()
                    }
                    e.parent = this;
                    this._children.splice(t, 0, e);
                    t++;
                    n++
                }
                return n
            }

            _removeChildren(t, e = 1) {
                this._fireChange("children", this);
                for (let n = t; n < t + e; n++) {
                    this._children[n].parent = null
                }
                return this._children.splice(t, e)
            }

            _fireChange(t, e) {
                this.fire("change:" + t, e)
            }
        }

        Cs(Ql, ds);

        function Jl(t, e) {
            if (typeof e == "string") {
                return [new Fs(t, e)]
            }
            if (!_s(e)) {
                e = [e]
            }
            return Array.from(e).map((e => {
                if (typeof e == "string") {
                    return new Fs(t, e)
                }
                if (e instanceof Vs) {
                    return new Fs(t, e.data)
                }
                return e
            }))
        }

        class Xl {
            constructor(t) {
                this.document = t;
                this._cloneGroups = new Map
            }

            setSelection(t, e, n) {
                this.document.selection._setTo(t, e, n)
            }

            setSelectionFocus(t, e) {
                this.document.selection._setFocus(t, e)
            }

            createText(t) {
                return new Fs(this.document, t)
            }

            createAttributeElement(t, e, n = {}) {
                const i = new wl(this.document, t, e);
                if (n.priority) {
                    i._priority = n.priority
                }
                if (n.id) {
                    i._id = n.id
                }
                return i
            }

            createContainerElement(t, e) {
                return new Hc(this.document, t, e)
            }

            createEditableElement(t, e) {
                const n = new al(this.document, t, e);
                n._document = this.document;
                return n
            }

            createEmptyElement(t, e) {
                return new Cl(this.document, t, e)
            }

            createUIElement(t, e, n) {
                const i = new Wl(this.document, t, e);
                if (n) {
                    i.render = n
                }
                return i
            }

            createRawElement(t, e, n) {
                const i = new $l(this.document, t, e);
                i.render = n || (() => {
                });
                return i
            }

            setAttribute(t, e, n) {
                n._setAttribute(t, e)
            }

            removeAttribute(t, e) {
                e._removeAttribute(t)
            }

            addClass(t, e) {
                e._addClass(t)
            }

            removeClass(t, e) {
                e._removeClass(t)
            }

            setStyle(t, e, n) {
                if (z(t) && n === undefined) {
                    n = e
                }
                n._setStyle(t, e)
            }

            removeStyle(t, e) {
                e._removeStyle(t)
            }

            setCustomProperty(t, e, n) {
                n._setCustomProperty(t, e)
            }

            removeCustomProperty(t, e) {
                return e._removeCustomProperty(t)
            }

            breakAttributes(t) {
                if (t instanceof ul) {
                    return this._breakAttributes(t)
                } else {
                    return this._breakAttributesRange(t)
                }
            }

            breakContainer(t) {
                const e = t.parent;
                if (!e.is("containerElement")) {
                    throw new ss["a"]("view-writer-break-non-container-element", this.document)
                }
                if (!e.parent) {
                    throw new ss["a"]("view-writer-break-root", this.document)
                }
                if (t.isAtStart) {
                    return ul._createBefore(e)
                } else if (!t.isAtEnd) {
                    const n = e._clone(false);
                    this.insert(ul._createAfter(e), n);
                    const i = new hl(t, ul._createAt(e, "end"));
                    const o = new ul(n, 0);
                    this.move(i, o)
                }
                return ul._createAfter(e)
            }

            mergeAttributes(t) {
                const e = t.offset;
                const n = t.parent;
                if (n.is("$text")) {
                    return t
                }
                if (n.is("attributeElement") && n.childCount === 0) {
                    const t = n.parent;
                    const e = n.index;
                    n._remove();
                    this._removeFromClonedElementsGroup(n);
                    return this.mergeAttributes(new ul(t, e))
                }
                const i = n.getChild(e - 1);
                const o = n.getChild(e);
                if (!i || !o) {
                    return t
                }
                if (i.is("$text") && o.is("$text")) {
                    return od(i, o)
                } else if (i.is("attributeElement") && o.is("attributeElement") && i.isSimilar(o)) {
                    const t = i.childCount;
                    i._appendChild(o.getChildren());
                    o._remove();
                    this._removeFromClonedElementsGroup(o);
                    return this.mergeAttributes(new ul(i, t))
                }
                return t
            }

            mergeContainers(t) {
                const e = t.nodeBefore;
                const n = t.nodeAfter;
                if (!e || !n || !e.is("containerElement") || !n.is("containerElement")) {
                    throw new ss["a"]("view-writer-merge-containers-invalid-position", this.document)
                }
                const i = e.getChild(e.childCount - 1);
                const o = i instanceof Fs ? ul._createAt(i, "end") : ul._createAt(e, "end");
                this.move(hl._createIn(n), ul._createAt(e, "end"));
                this.remove(hl._createOn(n));
                return o
            }

            insert(t, e) {
                e = _s(e) ? [...e] : [e];
                rd(e, this.document);
                const n = td(t);
                if (!n) {
                    throw new ss["a"]("view-writer-invalid-position-container", this.document)
                }
                const i = this._breakAttributes(t, true);
                const o = n._insertChild(i.offset, e);
                for (const t of e) {
                    this._addToClonedElementsGroup(t)
                }
                const r = i.getShiftedBy(o);
                const s = this.mergeAttributes(i);
                if (o === 0) {
                    return new hl(s, s)
                } else {
                    if (!s.isEqual(i)) {
                        r.offset--
                    }
                    const t = this.mergeAttributes(r);
                    return new hl(s, t)
                }
            }

            remove(t) {
                const e = t instanceof hl ? t : hl._createOn(t);
                cd(e, this.document);
                if (e.isCollapsed) {
                    return new Ql(this.document)
                }
                const {start: n, end: i} = this._breakAttributesRange(e, true);
                const o = n.parent;
                const r = i.offset - n.offset;
                const s = o._removeChildren(n.offset, r);
                for (const t of s) {
                    this._removeFromClonedElementsGroup(t)
                }
                const a = this.mergeAttributes(n);
                e.start = a;
                e.end = a.clone();
                return new Ql(this.document, s)
            }

            clear(t, e) {
                cd(t, this.document);
                const n = t.getWalker({direction: "backward", ignoreElementEnd: true});
                for (const i of n) {
                    const n = i.item;
                    let o;
                    if (n.is("element") && e.isSimilar(n)) {
                        o = hl._createOn(n)
                    } else if (!i.nextPosition.isAfter(t.start) && n.is("$textProxy")) {
                        const t = n.getAncestors().find((t => t.is("element") && e.isSimilar(t)));
                        if (t) {
                            o = hl._createIn(t)
                        }
                    }
                    if (o) {
                        if (o.end.isAfter(t.end)) {
                            o.end = t.end
                        }
                        if (o.start.isBefore(t.start)) {
                            o.start = t.start
                        }
                        this.remove(o)
                    }
                }
            }

            move(t, e) {
                let n;
                if (e.isAfter(t.end)) {
                    e = this._breakAttributes(e, true);
                    const i = e.parent;
                    const o = i.childCount;
                    t = this._breakAttributesRange(t, true);
                    n = this.remove(t);
                    e.offset += i.childCount - o
                } else {
                    n = this.remove(t)
                }
                return this.insert(e, n)
            }

            wrap(t, e) {
                if (!(e instanceof wl)) {
                    throw new ss["a"]("view-writer-wrap-invalid-attribute", this.document)
                }
                cd(t, this.document);
                if (!t.isCollapsed) {
                    return this._wrapRange(t, e)
                } else {
                    let n = t.start;
                    if (n.parent.is("element") && !Zl(n.parent)) {
                        n = n.getLastMatchingPosition((t => t.item.is("uiElement")))
                    }
                    n = this._wrapPosition(n, e);
                    const i = this.document.selection;
                    if (i.isCollapsed && i.getFirstPosition().isEqual(t.start)) {
                        this.setSelection(n)
                    }
                    return new hl(n)
                }
            }

            unwrap(t, e) {
                if (!(e instanceof wl)) {
                    throw new ss["a"]("view-writer-unwrap-invalid-attribute", this.document)
                }
                cd(t, this.document);
                if (t.isCollapsed) {
                    return t
                }
                const {start: n, end: i} = this._breakAttributesRange(t, true);
                const o = n.parent;
                const r = this._unwrapChildren(o, n.offset, i.offset, e);
                const s = this.mergeAttributes(r.start);
                if (!s.isEqual(r.start)) {
                    r.end.offset--
                }
                const a = this.mergeAttributes(r.end);
                return new hl(s, a)
            }

            rename(t, e) {
                const n = new Hc(this.document, t, e.getAttributes());
                this.insert(ul._createAfter(e), n);
                this.move(hl._createIn(e), ul._createAt(n, 0));
                this.remove(hl._createOn(e));
                return n
            }

            clearClonedElementsGroup(t) {
                this._cloneGroups.delete(t)
            }

            createPositionAt(t, e) {
                return ul._createAt(t, e)
            }

            createPositionAfter(t) {
                return ul._createAfter(t)
            }

            createPositionBefore(t) {
                return ul._createBefore(t)
            }

            createRange(t, e) {
                return new hl(t, e)
            }

            createRangeOn(t) {
                return hl._createOn(t)
            }

            createRangeIn(t) {
                return hl._createIn(t)
            }

            createSelection(t, e, n) {
                return new fl(t, e, n)
            }

            _wrapChildren(t, e, n, i) {
                let o = e;
                const r = [];
                while (o < n) {
                    const e = t.getChild(o);
                    const n = e.is("$text");
                    const s = e.is("attributeElement");
                    const a = e.is("emptyElement");
                    const c = e.is("uiElement");
                    const l = e.is("rawElement");
                    if (s && this._wrapAttributeElement(i, e)) {
                        r.push(new ul(t, o))
                    } else if (n || a || c || l || s && ed(i, e)) {
                        const n = i._clone();
                        e._remove();
                        n._appendChild(e);
                        t._insertChild(o, n);
                        this._addToClonedElementsGroup(n);
                        r.push(new ul(t, o))
                    } else if (s) {
                        this._wrapChildren(e, 0, e.childCount, i)
                    }
                    o++
                }
                let s = 0;
                for (const t of r) {
                    t.offset -= s;
                    if (t.offset == e) {
                        continue
                    }
                    const i = this.mergeAttributes(t);
                    if (!i.isEqual(t)) {
                        s++;
                        n--
                    }
                }
                return hl._createFromParentsAndOffsets(t, e, t, n)
            }

            _unwrapChildren(t, e, n, i) {
                let o = e;
                const r = [];
                while (o < n) {
                    const e = t.getChild(o);
                    if (!e.is("attributeElement")) {
                        o++;
                        continue
                    }
                    if (e.isSimilar(i)) {
                        const i = e.getChildren();
                        const s = e.childCount;
                        e._remove();
                        t._insertChild(o, i);
                        this._removeFromClonedElementsGroup(e);
                        r.push(new ul(t, o), new ul(t, o + s));
                        o += s;
                        n += s - 1;
                        continue
                    }
                    if (this._unwrapAttributeElement(i, e)) {
                        r.push(new ul(t, o), new ul(t, o + 1));
                        o++;
                        continue
                    }
                    this._unwrapChildren(e, 0, e.childCount, i);
                    o++
                }
                let s = 0;
                for (const t of r) {
                    t.offset -= s;
                    if (t.offset == e || t.offset == n) {
                        continue
                    }
                    const i = this.mergeAttributes(t);
                    if (!i.isEqual(t)) {
                        s++;
                        n--
                    }
                }
                return hl._createFromParentsAndOffsets(t, e, t, n)
            }

            _wrapRange(t, e) {
                const {start: n, end: i} = this._breakAttributesRange(t, true);
                const o = n.parent;
                const r = this._wrapChildren(o, n.offset, i.offset, e);
                const s = this.mergeAttributes(r.start);
                if (!s.isEqual(r.start)) {
                    r.end.offset--
                }
                const a = this.mergeAttributes(r.end);
                return new hl(s, a)
            }

            _wrapPosition(t, e) {
                if (e.isSimilar(t.parent)) {
                    return nd(t.clone())
                }
                if (t.parent.is("$text")) {
                    t = id(t)
                }
                const n = this.createAttributeElement();
                n._priority = Number.POSITIVE_INFINITY;
                n.isSimilar = () => false;
                t.parent._insertChild(t.offset, n);
                const i = new hl(t, t.getShiftedBy(1));
                this.wrap(i, e);
                const o = new ul(n.parent, n.index);
                n._remove();
                const r = o.nodeBefore;
                const s = o.nodeAfter;
                if (r instanceof Fs && s instanceof Fs) {
                    return od(r, s)
                }
                return nd(o)
            }

            _wrapAttributeElement(t, e) {
                if (!ld(t, e)) {
                    return false
                }
                if (t.name !== e.name || t.priority !== e.priority) {
                    return false
                }
                for (const n of t.getAttributeKeys()) {
                    if (n === "class" || n === "style") {
                        continue
                    }
                    if (e.hasAttribute(n) && e.getAttribute(n) !== t.getAttribute(n)) {
                        return false
                    }
                }
                for (const n of t.getStyleNames()) {
                    if (e.hasStyle(n) && e.getStyle(n) !== t.getStyle(n)) {
                        return false
                    }
                }
                for (const n of t.getAttributeKeys()) {
                    if (n === "class" || n === "style") {
                        continue
                    }
                    if (!e.hasAttribute(n)) {
                        this.setAttribute(n, t.getAttribute(n), e)
                    }
                }
                for (const n of t.getStyleNames()) {
                    if (!e.hasStyle(n)) {
                        this.setStyle(n, t.getStyle(n), e)
                    }
                }
                for (const n of t.getClassNames()) {
                    if (!e.hasClass(n)) {
                        this.addClass(n, e)
                    }
                }
                return true
            }

            _unwrapAttributeElement(t, e) {
                if (!ld(t, e)) {
                    return false
                }
                if (t.name !== e.name || t.priority !== e.priority) {
                    return false
                }
                for (const n of t.getAttributeKeys()) {
                    if (n === "class" || n === "style") {
                        continue
                    }
                    if (!e.hasAttribute(n) || e.getAttribute(n) !== t.getAttribute(n)) {
                        return false
                    }
                }
                if (!e.hasClass(...t.getClassNames())) {
                    return false
                }
                for (const n of t.getStyleNames()) {
                    if (!e.hasStyle(n) || e.getStyle(n) !== t.getStyle(n)) {
                        return false
                    }
                }
                for (const n of t.getAttributeKeys()) {
                    if (n === "class" || n === "style") {
                        continue
                    }
                    this.removeAttribute(n, e)
                }
                this.removeClass(Array.from(t.getClassNames()), e);
                this.removeStyle(Array.from(t.getStyleNames()), e);
                return true
            }

            _breakAttributesRange(t, e = false) {
                const n = t.start;
                const i = t.end;
                cd(t, this.document);
                if (t.isCollapsed) {
                    const n = this._breakAttributes(t.start, e);
                    return new hl(n, n)
                }
                const o = this._breakAttributes(i, e);
                const r = o.parent.childCount;
                const s = this._breakAttributes(n, e);
                o.offset += o.parent.childCount - r;
                return new hl(s, o)
            }

            _breakAttributes(t, e = false) {
                const n = t.offset;
                const i = t.parent;
                if (t.parent.is("emptyElement")) {
                    throw new ss["a"]("view-writer-cannot-break-empty-element", this.document)
                }
                if (t.parent.is("uiElement")) {
                    throw new ss["a"]("view-writer-cannot-break-ui-element", this.document)
                }
                if (t.parent.is("rawElement")) {
                    throw new ss["a"]("view-writer-cannot-break-raw-element", this.document)
                }
                if (!e && i.is("$text") && ad(i.parent)) {
                    return t.clone()
                }
                if (ad(i)) {
                    return t.clone()
                }
                if (i.is("$text")) {
                    return this._breakAttributes(id(t), e)
                }
                const o = i.childCount;
                if (n == o) {
                    const t = new ul(i.parent, i.index + 1);
                    return this._breakAttributes(t, e)
                } else {
                    if (n === 0) {
                        const t = new ul(i.parent, i.index);
                        return this._breakAttributes(t, e)
                    } else {
                        const t = i.index + 1;
                        const o = i._clone();
                        i.parent._insertChild(t, o);
                        this._addToClonedElementsGroup(o);
                        const r = i.childCount - n;
                        const s = i._removeChildren(n, r);
                        o._appendChild(s);
                        const a = new ul(i.parent, t);
                        return this._breakAttributes(a, e)
                    }
                }
            }

            _addToClonedElementsGroup(t) {
                if (!t.root.is("rootElement")) {
                    return
                }
                if (t.is("element")) {
                    for (const e of t.getChildren()) {
                        this._addToClonedElementsGroup(e)
                    }
                }
                const e = t.id;
                if (!e) {
                    return
                }
                let n = this._cloneGroups.get(e);
                if (!n) {
                    n = new Set;
                    this._cloneGroups.set(e, n)
                }
                n.add(t);
                t._clonesGroup = n
            }

            _removeFromClonedElementsGroup(t) {
                if (t.is("element")) {
                    for (const e of t.getChildren()) {
                        this._removeFromClonedElementsGroup(e)
                    }
                }
                const e = t.id;
                if (!e) {
                    return
                }
                const n = this._cloneGroups.get(e);
                if (!n) {
                    return
                }
                n.delete(t)
            }
        }

        function Zl(t) {
            return Array.from(t.getChildren()).some((t => !t.is("uiElement")))
        }

        function td(t) {
            let e = t.parent;
            while (!ad(e)) {
                if (!e) {
                    return undefined
                }
                e = e.parent
            }
            return e
        }

        function ed(t, e) {
            if (t.priority < e.priority) {
                return true
            } else if (t.priority > e.priority) {
                return false
            }
            return t.getIdentity() < e.getIdentity()
        }

        function nd(t) {
            const e = t.nodeBefore;
            if (e && e.is("$text")) {
                return new ul(e, e.data.length)
            }
            const n = t.nodeAfter;
            if (n && n.is("$text")) {
                return new ul(n, 0)
            }
            return t
        }

        function id(t) {
            if (t.offset == t.parent.data.length) {
                return new ul(t.parent.parent, t.parent.index + 1)
            }
            if (t.offset === 0) {
                return new ul(t.parent.parent, t.parent.index)
            }
            const e = t.parent.data.slice(t.offset);
            t.parent._data = t.parent.data.slice(0, t.offset);
            t.parent.parent._insertChild(t.parent.index + 1, new Fs(t.root.document, e));
            return new ul(t.parent.parent, t.parent.index + 1)
        }

        function od(t, e) {
            const n = t.data.length;
            t._data += e.data;
            e._remove();
            return new ul(t, n)
        }

        function rd(t, e) {
            for (const n of t) {
                if (!sd.some((t => n instanceof t))) {
                    throw new ss["a"]("view-writer-insert-invalid-node-type", e)
                }
                if (!n.is("$text")) {
                    rd(n.getChildren(), e)
                }
            }
        }

        const sd = [Fs, wl, Hc, Cl, $l, Wl];

        function ad(t) {
            return t && (t.is("containerElement") || t.is("documentFragment"))
        }

        function cd(t, e) {
            const n = td(t.start);
            const i = td(t.end);
            if (!n || !i || n !== i) {
                throw new ss["a"]("view-writer-invalid-range-container", e)
            }
        }

        function ld(t, e) {
            return t.id === null && e.id === null
        }

        function dd(t) {
            return Object.prototype.toString.call(t) == "[object Text]"
        }

        const ud = t => t.createTextNode(" ");
        const hd = t => {
            const e = t.createElement("br");
            e.dataset.ckeFiller = true;
            return e
        };
        const md = 7;
        const gd = (() => {
            let t = "";
            for (let e = 0; e < md; e++) {
                t += "​"
            }
            return t
        })();

        function fd(t) {
            return dd(t) && t.data.substr(0, md) === gd
        }

        function pd(t) {
            return t.data.length == md && fd(t)
        }

        function bd(t) {
            if (fd(t)) {
                return t.data.slice(md)
            } else {
                return t.data
            }
        }

        function kd(t) {
            t.document.on("keydown", wd)
        }

        function wd(t, e) {
            if (e.keyCode == Nl.arrowleft) {
                const t = e.domTarget.ownerDocument.defaultView.getSelection();
                if (t.rangeCount == 1 && t.getRangeAt(0).collapsed) {
                    const e = t.getRangeAt(0).startContainer;
                    const n = t.getRangeAt(0).startOffset;
                    if (fd(e) && n <= md) {
                        t.collapse(e, 0)
                    }
                }
            }
        }

        function Ad(t, e, n, i = false) {
            n = n || function (t, e) {
                return t === e
            };
            if (!Array.isArray(t)) {
                t = Array.prototype.slice.call(t)
            }
            if (!Array.isArray(e)) {
                e = Array.prototype.slice.call(e)
            }
            const o = _d(t, e, n);
            return i ? xd(o, e.length) : yd(e, o)
        }

        function _d(t, e, n) {
            const i = Cd(t, e, n);
            if (i === -1) {
                return {firstIndex: -1, lastIndexOld: -1, lastIndexNew: -1}
            }
            const o = vd(t, i);
            const r = vd(e, i);
            const s = Cd(o, r, n);
            const a = t.length - s;
            const c = e.length - s;
            return {firstIndex: i, lastIndexOld: a, lastIndexNew: c}
        }

        function Cd(t, e, n) {
            for (let i = 0; i < Math.max(t.length, e.length); i++) {
                if (t[i] === undefined || e[i] === undefined || !n(t[i], e[i])) {
                    return i
                }
            }
            return -1
        }

        function vd(t, e) {
            return t.slice(e).reverse()
        }

        function yd(t, e) {
            const n = [];
            const {firstIndex: i, lastIndexOld: o, lastIndexNew: r} = e;
            if (r - i > 0) {
                n.push({index: i, type: "insert", values: t.slice(i, r)})
            }
            if (o - i > 0) {
                n.push({index: i + (r - i), type: "delete", howMany: o - i})
            }
            return n
        }

        function xd(t, e) {
            const {firstIndex: n, lastIndexOld: i, lastIndexNew: o} = t;
            if (n === -1) {
                return Array(e).fill("equal")
            }
            let r = [];
            if (n > 0) {
                r = r.concat(Array(n).fill("equal"))
            }
            if (o - n > 0) {
                r = r.concat(Array(o - n).fill("insert"))
            }
            if (i - n > 0) {
                r = r.concat(Array(i - n).fill("delete"))
            }
            if (o < e) {
                r = r.concat(Array(e - o).fill("equal"))
            }
            return r
        }

        function Ed(t, e, n) {
            n = n || function (t, e) {
                return t === e
            };
            const i = t.length;
            const o = e.length;
            if (i > 200 || o > 200 || i + o > 300) {
                return Ed.fastDiff(t, e, n, true)
            }
            let r, s;
            if (o < i) {
                const n = t;
                t = e;
                e = n;
                r = "delete";
                s = "insert"
            } else {
                r = "insert";
                s = "delete"
            }
            const a = t.length;
            const c = e.length;
            const l = c - a;
            const d = {};
            const u = {};

            function h(i) {
                const o = (u[i - 1] !== undefined ? u[i - 1] : -1) + 1;
                const l = u[i + 1] !== undefined ? u[i + 1] : -1;
                const h = o > l ? -1 : 1;
                if (d[i + h]) {
                    d[i] = d[i + h].slice(0)
                }
                if (!d[i]) {
                    d[i] = []
                }
                d[i].push(o > l ? r : s);
                let m = Math.max(o, l);
                let g = m - i;
                while (g < a && m < c && n(t[g], e[m])) {
                    g++;
                    m++;
                    d[i].push("equal")
                }
                return m
            }

            let m = 0;
            let g;
            do {
                for (g = -m; g < l; g++) {
                    u[g] = h(g)
                }
                for (g = l + m; g > l; g--) {
                    u[g] = h(g)
                }
                u[l] = h(l);
                m++
            } while (u[l] !== c);
            return d[l].slice(1)
        }

        Ed.fastDiff = Ad;

        function Dd(t, e, n) {
            t.insertBefore(n, t.childNodes[e] || null)
        }

        function Td(t) {
            const e = t.parentNode;
            if (e) {
                e.removeChild(t)
            }
        }

        function Md(t) {
            if (t) {
                if (t.defaultView) {
                    return t instanceof t.defaultView.Document
                } else if (t.ownerDocument && t.ownerDocument.defaultView) {
                    return t instanceof t.ownerDocument.defaultView.Node
                }
            }
            return false
        }

        class Sd {
            constructor(t, e) {
                this.domDocuments = new Set;
                this.domConverter = t;
                this.markedAttributes = new Set;
                this.markedChildren = new Set;
                this.markedTexts = new Set;
                this.selection = e;
                this.isFocused = false;
                this._inlineFiller = null;
                this._fakeSelectionContainer = null
            }

            markToSync(t, e) {
                if (t === "text") {
                    if (this.domConverter.mapViewToDom(e.parent)) {
                        this.markedTexts.add(e)
                    }
                } else {
                    if (!this.domConverter.mapViewToDom(e)) {
                        return
                    }
                    if (t === "attributes") {
                        this.markedAttributes.add(e)
                    } else if (t === "children") {
                        this.markedChildren.add(e)
                    } else {
                        throw new ss["a"]("view-renderer-unknown-type", this)
                    }
                }
            }

            render() {
                let t;
                for (const t of this.markedChildren) {
                    this._updateChildrenMappings(t)
                }
                if (this._inlineFiller && !this._isSelectionInInlineFiller()) {
                    this._removeInlineFiller()
                }
                if (this._inlineFiller) {
                    t = this._getInlineFillerPosition()
                } else if (this._needsInlineFillerAtSelection()) {
                    t = this.selection.getFirstPosition();
                    this.markedChildren.add(t.parent)
                }
                for (const t of this.markedAttributes) {
                    this._updateAttrs(t)
                }
                for (const e of this.markedChildren) {
                    this._updateChildren(e, {inlineFillerPosition: t})
                }
                for (const e of this.markedTexts) {
                    if (!this.markedChildren.has(e.parent) && this.domConverter.mapViewToDom(e.parent)) {
                        this._updateText(e, {inlineFillerPosition: t})
                    }
                }
                if (t) {
                    const e = this.domConverter.viewPositionToDom(t);
                    const n = e.parent.ownerDocument;
                    if (!fd(e.parent)) {
                        this._inlineFiller = Bd(n, e.parent, e.offset)
                    } else {
                        this._inlineFiller = e.parent
                    }
                } else {
                    this._inlineFiller = null
                }
                this._updateSelection();
                this._updateFocus();
                this.markedTexts.clear();
                this.markedAttributes.clear();
                this.markedChildren.clear()
            }

            _updateChildrenMappings(t) {
                const e = this.domConverter.mapViewToDom(t);
                if (!e) {
                    return
                }
                const n = this.domConverter.mapViewToDom(t).childNodes;
                const i = Array.from(this.domConverter.viewChildrenToDom(t, e.ownerDocument, {withChildren: false}));
                const o = this._diffNodeLists(n, i);
                const r = this._findReplaceActions(o, n, i);
                if (r.indexOf("replace") !== -1) {
                    const e = {equal: 0, insert: 0, delete: 0};
                    for (const o of r) {
                        if (o === "replace") {
                            const o = e.equal + e.insert;
                            const r = e.equal + e.delete;
                            const s = t.getChild(o);
                            if (s && !(s.is("uiElement") || s.is("rawElement"))) {
                                this._updateElementMappings(s, n[r])
                            }
                            Td(i[o]);
                            e.equal++
                        } else {
                            e[o]++
                        }
                    }
                }
            }

            _updateElementMappings(t, e) {
                this.domConverter.unbindDomElement(e);
                this.domConverter.bindElements(e, t);
                this.markedChildren.add(t);
                this.markedAttributes.add(t)
            }

            _getInlineFillerPosition() {
                const t = this.selection.getFirstPosition();
                if (t.parent.is("$text")) {
                    return ul._createBefore(this.selection.getFirstPosition().parent)
                } else {
                    return t
                }
            }

            _isSelectionInInlineFiller() {
                if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {
                    return false
                }
                const t = this.selection.getFirstPosition();
                const e = this.domConverter.viewPositionToDom(t);
                if (e && dd(e.parent) && fd(e.parent)) {
                    return true
                }
                return false
            }

            _removeInlineFiller() {
                const t = this._inlineFiller;
                if (!fd(t)) {
                    throw new ss["a"]("view-renderer-filler-was-lost", this)
                }
                if (pd(t)) {
                    t.parentNode.removeChild(t)
                } else {
                    t.data = t.data.substr(md)
                }
                this._inlineFiller = null
            }

            _needsInlineFillerAtSelection() {
                if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {
                    return false
                }
                const t = this.selection.getFirstPosition();
                const e = t.parent;
                const n = t.offset;
                if (!this.domConverter.mapViewToDom(e.root)) {
                    return false
                }
                if (!e.is("element")) {
                    return false
                }
                if (!Id(e)) {
                    return false
                }
                if (n === e.getFillerOffset()) {
                    return false
                }
                const i = t.nodeBefore;
                const o = t.nodeAfter;
                if (i instanceof Fs || o instanceof Fs) {
                    return false
                }
                return true
            }

            _updateText(t, e) {
                const n = this.domConverter.findCorrespondingDomText(t);
                const i = this.domConverter.viewToDom(t, n.ownerDocument);
                const o = n.data;
                let r = i.data;
                const s = e.inlineFillerPosition;
                if (s && s.parent == t.parent && s.offset == t.index) {
                    r = gd + r
                }
                if (o != r) {
                    const t = Ad(o, r);
                    for (const e of t) {
                        if (e.type === "insert") {
                            n.insertData(e.index, e.values.join(""))
                        } else {
                            n.deleteData(e.index, e.howMany)
                        }
                    }
                }
            }

            _updateAttrs(t) {
                const e = this.domConverter.mapViewToDom(t);
                if (!e) {
                    return
                }
                const n = Array.from(e.attributes).map((t => t.name));
                const i = t.getAttributeKeys();
                for (const n of i) {
                    e.setAttribute(n, t.getAttribute(n))
                }
                for (const i of n) {
                    if (!t.hasAttribute(i)) {
                        e.removeAttribute(i)
                    }
                }
            }

            _updateChildren(t, e) {
                const n = this.domConverter.mapViewToDom(t);
                if (!n) {
                    return
                }
                const i = e.inlineFillerPosition;
                const o = this.domConverter.mapViewToDom(t).childNodes;
                const r = Array.from(this.domConverter.viewChildrenToDom(t, n.ownerDocument, {
                    bind: true,
                    inlineFillerPosition: i
                }));
                if (i && i.parent === t) {
                    Bd(n.ownerDocument, r, i.offset)
                }
                const s = this._diffNodeLists(o, r);
                let a = 0;
                const c = new Set;
                for (const t of s) {
                    if (t === "delete") {
                        c.add(o[a]);
                        Td(o[a])
                    } else if (t === "equal") {
                        a++
                    }
                }
                a = 0;
                for (const t of s) {
                    if (t === "insert") {
                        Dd(n, a, r[a]);
                        a++
                    } else if (t === "equal") {
                        this._markDescendantTextToSync(this.domConverter.domToView(r[a]));
                        a++
                    }
                }
                for (const t of c) {
                    if (!t.parentNode) {
                        this.domConverter.unbindDomElement(t)
                    }
                }
            }

            _diffNodeLists(t, e) {
                t = Pd(t, this._fakeSelectionContainer);
                return Ed(t, e, zd.bind(null, this.domConverter))
            }

            _findReplaceActions(t, e, n) {
                if (t.indexOf("insert") === -1 || t.indexOf("delete") === -1) {
                    return t
                }
                let i = [];
                let o = [];
                let r = [];
                const s = {equal: 0, insert: 0, delete: 0};
                for (const a of t) {
                    if (a === "insert") {
                        r.push(n[s.equal + s.insert])
                    } else if (a === "delete") {
                        o.push(e[s.equal + s.delete])
                    } else {
                        i = i.concat(Ed(o, r, Ld).map((t => t === "equal" ? "replace" : t)));
                        i.push("equal");
                        o = [];
                        r = []
                    }
                    s[a]++
                }
                return i.concat(Ed(o, r, Ld).map((t => t === "equal" ? "replace" : t)))
            }

            _markDescendantTextToSync(t) {
                if (!t) {
                    return
                }
                if (t.is("$text")) {
                    this.markedTexts.add(t)
                } else if (t.is("element")) {
                    for (const e of t.getChildren()) {
                        this._markDescendantTextToSync(e)
                    }
                }
            }

            _updateSelection() {
                if (this.selection.rangeCount === 0) {
                    this._removeDomSelection();
                    this._removeFakeSelection();
                    return
                }
                const t = this.domConverter.mapViewToDom(this.selection.editableElement);
                if (!this.isFocused || !t) {
                    return
                }
                if (this.selection.isFake) {
                    this._updateFakeSelection(t)
                } else {
                    this._removeFakeSelection();
                    this._updateDomSelection(t)
                }
            }

            _updateFakeSelection(t) {
                const e = t.ownerDocument;
                if (!this._fakeSelectionContainer) {
                    this._fakeSelectionContainer = Od(e)
                }
                const n = this._fakeSelectionContainer;
                this.domConverter.bindFakeSelection(n, this.selection);
                if (!this._fakeSelectionNeedsUpdate(t)) {
                    return
                }
                if (!n.parentElement || n.parentElement != t) {
                    t.appendChild(n)
                }
                n.textContent = this.selection.fakeSelectionLabel || " ";
                const i = e.getSelection();
                const o = e.createRange();
                i.removeAllRanges();
                o.selectNodeContents(n);
                i.addRange(o)
            }

            _updateDomSelection(t) {
                const e = t.ownerDocument.defaultView.getSelection();
                if (!this._domSelectionNeedsUpdate(e)) {
                    return
                }
                const n = this.domConverter.viewPositionToDom(this.selection.anchor);
                const i = this.domConverter.viewPositionToDom(this.selection.focus);
                t.focus();
                e.collapse(n.parent, n.offset);
                e.extend(i.parent, i.offset);
                if (El.isGecko) {
                    Nd(i, e)
                }
            }

            _domSelectionNeedsUpdate(t) {
                if (!this.domConverter.isDomSelectionCorrect(t)) {
                    return true
                }
                const e = t && this.domConverter.domSelectionToView(t);
                if (e && this.selection.isEqual(e)) {
                    return false
                }
                if (!this.selection.isCollapsed && this.selection.isSimilar(e)) {
                    return false
                }
                return true
            }

            _fakeSelectionNeedsUpdate(t) {
                const e = this._fakeSelectionContainer;
                const n = t.ownerDocument.getSelection();
                if (!e || e.parentElement !== t) {
                    return true
                }
                if (n.anchorNode !== e && !e.contains(n.anchorNode)) {
                    return true
                }
                return e.textContent !== this.selection.fakeSelectionLabel
            }

            _removeDomSelection() {
                for (const t of this.domDocuments) {
                    const e = t.getSelection();
                    if (e.rangeCount) {
                        const e = t.activeElement;
                        const n = this.domConverter.mapDomToView(e);
                        if (e && n) {
                            t.getSelection().removeAllRanges()
                        }
                    }
                }
            }

            _removeFakeSelection() {
                const t = this._fakeSelectionContainer;
                if (t) {
                    t.remove()
                }
            }

            _updateFocus() {
                if (this.isFocused) {
                    const t = this.selection.editableElement;
                    if (t) {
                        this.domConverter.focus(t)
                    }
                }
            }
        }

        Cs(Sd, Qc);

        function Id(t) {
            if (t.getAttribute("contenteditable") == "false") {
                return false
            }
            const e = t.findAncestor((t => t.hasAttribute("contenteditable")));
            return !e || e.getAttribute("contenteditable") == "true"
        }

        function Bd(t, e, n) {
            const i = e instanceof Array ? e : e.childNodes;
            const o = i[n];
            if (dd(o)) {
                o.data = gd + o.data;
                return o
            } else {
                const o = t.createTextNode(gd);
                if (Array.isArray(e)) {
                    i.splice(n, 0, o)
                } else {
                    Dd(e, n, o)
                }
                return o
            }
        }

        function Ld(t, e) {
            return Md(t) && Md(e) && !dd(t) && !dd(e) && t.nodeType !== Node.COMMENT_NODE && e.nodeType !== Node.COMMENT_NODE && t.tagName.toLowerCase() === e.tagName.toLowerCase()
        }

        function zd(t, e, n) {
            if (e === n) {
                return true
            } else if (dd(e) && dd(n)) {
                return e.data === n.data
            } else if (t.isBlockFiller(e) && t.isBlockFiller(n)) {
                return true
            }
            return false
        }

        function Nd(t, e) {
            const n = t.parent;
            if (n.nodeType != Node.ELEMENT_NODE || t.offset != n.childNodes.length - 1) {
                return
            }
            const i = n.childNodes[t.offset];
            if (i && i.tagName == "BR") {
                e.addRange(e.getRangeAt(0))
            }
        }

        function Pd(t, e) {
            const n = Array.from(t);
            if (n.length == 0 || !e) {
                return n
            }
            const i = n[n.length - 1];
            if (i == e) {
                n.pop()
            }
            return n
        }

        function Od(t) {
            const e = t.createElement("div");
            Object.assign(e.style, {position: "fixed", top: 0, left: "-9999px", width: "42px"});
            e.textContent = " ";
            return e
        }

        var jd = {window: window, document: document};

        function Rd(t) {
            let e = 0;
            while (t.previousSibling) {
                t = t.previousSibling;
                e++
            }
            return e
        }

        function Fd(t) {
            const e = [];
            while (t && t.nodeType != Node.DOCUMENT_NODE) {
                e.unshift(t);
                t = t.parentNode
            }
            return e
        }

        function Vd(t, e) {
            const n = Fd(t);
            const i = Fd(e);
            let o = 0;
            while (n[o] == i[o] && n[o]) {
                o++
            }
            return o === 0 ? null : n[o - 1]
        }

        const Hd = hd(document);

        class Ud {
            constructor(t, e = {}) {
                this.document = t;
                this.blockFillerMode = e.blockFillerMode || "br";
                this.preElements = ["pre"];
                this.blockElements = ["p", "div", "h1", "h2", "h3", "h4", "h5", "h6", "li", "dd", "dt", "figcaption", "td", "th"];
                this._blockFiller = this.blockFillerMode == "br" ? hd : ud;
                this._domToViewMapping = new WeakMap;
                this._viewToDomMapping = new WeakMap;
                this._fakeSelectionMapping = new WeakMap
            }

            bindFakeSelection(t, e) {
                this._fakeSelectionMapping.set(t, new fl(e))
            }

            fakeSelectionToView(t) {
                return this._fakeSelectionMapping.get(t)
            }

            bindElements(t, e) {
                this._domToViewMapping.set(t, e);
                this._viewToDomMapping.set(e, t)
            }

            unbindDomElement(t) {
                const e = this._domToViewMapping.get(t);
                if (e) {
                    this._domToViewMapping.delete(t);
                    this._viewToDomMapping.delete(e);
                    for (const e of t.childNodes) {
                        this.unbindDomElement(e)
                    }
                }
            }

            bindDocumentFragments(t, e) {
                this._domToViewMapping.set(t, e);
                this._viewToDomMapping.set(e, t)
            }

            viewToDom(t, e, n = {}) {
                if (t.is("$text")) {
                    const n = this._processDataFromViewText(t);
                    return e.createTextNode(n)
                } else {
                    if (this.mapViewToDom(t)) {
                        return this.mapViewToDom(t)
                    }
                    let i;
                    if (t.is("documentFragment")) {
                        i = e.createDocumentFragment();
                        if (n.bind) {
                            this.bindDocumentFragments(i, t)
                        }
                    } else if (t.is("uiElement")) {
                        i = t.render(e);
                        if (n.bind) {
                            this.bindElements(i, t)
                        }
                        return i
                    } else {
                        if (t.hasAttribute("xmlns")) {
                            i = e.createElementNS(t.getAttribute("xmlns"), t.name)
                        } else {
                            i = e.createElement(t.name)
                        }
                        if (t.is("rawElement")) {
                            t.render(i)
                        }
                        if (n.bind) {
                            this.bindElements(i, t)
                        }
                        for (const e of t.getAttributeKeys()) {
                            i.setAttribute(e, t.getAttribute(e))
                        }
                    }
                    if (n.withChildren || n.withChildren === undefined) {
                        for (const o of this.viewChildrenToDom(t, e, n)) {
                            i.appendChild(o)
                        }
                    }
                    return i
                }
            }

            * viewChildrenToDom(t, e, n = {}) {
                const i = t.getFillerOffset && t.getFillerOffset();
                let o = 0;
                for (const r of t.getChildren()) {
                    if (i === o) {
                        yield this._blockFiller(e)
                    }
                    yield this.viewToDom(r, e, n);
                    o++
                }
                if (i === o) {
                    yield this._blockFiller(e)
                }
            }

            viewRangeToDom(t) {
                const e = this.viewPositionToDom(t.start);
                const n = this.viewPositionToDom(t.end);
                const i = document.createRange();
                i.setStart(e.parent, e.offset);
                i.setEnd(n.parent, n.offset);
                return i
            }

            viewPositionToDom(t) {
                const e = t.parent;
                if (e.is("$text")) {
                    const n = this.findCorrespondingDomText(e);
                    if (!n) {
                        return null
                    }
                    let i = t.offset;
                    if (fd(n)) {
                        i += md
                    }
                    return {parent: n, offset: i}
                } else {
                    let n, i, o;
                    if (t.offset === 0) {
                        n = this.mapViewToDom(e);
                        if (!n) {
                            return null
                        }
                        o = n.childNodes[0]
                    } else {
                        const e = t.nodeBefore;
                        i = e.is("$text") ? this.findCorrespondingDomText(e) : this.mapViewToDom(t.nodeBefore);
                        if (!i) {
                            return null
                        }
                        n = i.parentNode;
                        o = i.nextSibling
                    }
                    if (dd(o) && fd(o)) {
                        return {parent: o, offset: md}
                    }
                    const r = i ? Rd(i) + 1 : 0;
                    return {parent: n, offset: r}
                }
            }

            domToView(t, e = {}) {
                if (this.isBlockFiller(t, this.blockFillerMode)) {
                    return null
                }
                const n = this.getHostViewElement(t, this._domToViewMapping);
                if (n) {
                    return n
                }
                if (dd(t)) {
                    if (pd(t)) {
                        return null
                    } else {
                        const e = this._processDataFromDomText(t);
                        return e === "" ? null : new Fs(this.document, e)
                    }
                } else if (this.isComment(t)) {
                    return null
                } else {
                    if (this.mapDomToView(t)) {
                        return this.mapDomToView(t)
                    }
                    let n;
                    if (this.isDocumentFragment(t)) {
                        n = new Ql(this.document);
                        if (e.bind) {
                            this.bindDocumentFragments(t, n)
                        }
                    } else {
                        const i = e.keepOriginalCase ? t.tagName : t.tagName.toLowerCase();
                        n = new jc(this.document, i);
                        if (e.bind) {
                            this.bindElements(t, n)
                        }
                        const o = t.attributes;
                        for (let t = o.length - 1; t >= 0; t--) {
                            n._setAttribute(o[t].name, o[t].value)
                        }
                    }
                    if (e.withChildren || e.withChildren === undefined) {
                        for (const i of this.domChildrenToView(t, e)) {
                            n._appendChild(i)
                        }
                    }
                    return n
                }
            }

            * domChildrenToView(t, e = {}) {
                for (let n = 0; n < t.childNodes.length; n++) {
                    const i = t.childNodes[n];
                    const o = this.domToView(i, e);
                    if (o !== null) {
                        yield o
                    }
                }
            }

            domSelectionToView(t) {
                if (t.rangeCount === 1) {
                    let e = t.getRangeAt(0).startContainer;
                    if (dd(e)) {
                        e = e.parentNode
                    }
                    const n = this.fakeSelectionToView(e);
                    if (n) {
                        return n
                    }
                }
                const e = this.isDomSelectionBackward(t);
                const n = [];
                for (let e = 0; e < t.rangeCount; e++) {
                    const i = t.getRangeAt(e);
                    const o = this.domRangeToView(i);
                    if (o) {
                        n.push(o)
                    }
                }
                return new fl(n, {backward: e})
            }

            domRangeToView(t) {
                const e = this.domPositionToView(t.startContainer, t.startOffset);
                const n = this.domPositionToView(t.endContainer, t.endOffset);
                if (e && n) {
                    return new hl(e, n)
                }
                return null
            }

            domPositionToView(t, e) {
                if (this.isBlockFiller(t, this.blockFillerMode)) {
                    return this.domPositionToView(t.parentNode, Rd(t))
                }
                const n = this.mapDomToView(t);
                if (n && (n.is("uiElement") || n.is("rawElement"))) {
                    return ul._createBefore(n)
                }
                if (dd(t)) {
                    if (pd(t)) {
                        return this.domPositionToView(t.parentNode, Rd(t))
                    }
                    const n = this.findCorrespondingViewText(t);
                    let i = e;
                    if (!n) {
                        return null
                    }
                    if (fd(t)) {
                        i -= md;
                        i = i < 0 ? 0 : i
                    }
                    return new ul(n, i)
                } else {
                    if (e === 0) {
                        const e = this.mapDomToView(t);
                        if (e) {
                            return new ul(e, 0)
                        }
                    } else {
                        const n = t.childNodes[e - 1];
                        const i = dd(n) ? this.findCorrespondingViewText(n) : this.mapDomToView(n);
                        if (i && i.parent) {
                            return new ul(i.parent, i.index + 1)
                        }
                    }
                    return null
                }
            }

            mapDomToView(t) {
                const e = this.getHostViewElement(t);
                return e || this._domToViewMapping.get(t)
            }

            findCorrespondingViewText(t) {
                if (pd(t)) {
                    return null
                }
                const e = this.getHostViewElement(t);
                if (e) {
                    return e
                }
                const n = t.previousSibling;
                if (n) {
                    if (!this.isElement(n)) {
                        return null
                    }
                    const t = this.mapDomToView(n);
                    if (t) {
                        const e = t.nextSibling;
                        if (e instanceof Fs) {
                            return t.nextSibling
                        } else {
                            return null
                        }
                    }
                } else {
                    const e = this.mapDomToView(t.parentNode);
                    if (e) {
                        const t = e.getChild(0);
                        if (t instanceof Fs) {
                            return t
                        } else {
                            return null
                        }
                    }
                }
                return null
            }

            mapViewToDom(t) {
                return this._viewToDomMapping.get(t)
            }

            findCorrespondingDomText(t) {
                const e = t.previousSibling;
                if (e && this.mapViewToDom(e)) {
                    return this.mapViewToDom(e).nextSibling
                }
                if (!e && t.parent && this.mapViewToDom(t.parent)) {
                    return this.mapViewToDom(t.parent).childNodes[0]
                }
                return null
            }

            focus(t) {
                const e = this.mapViewToDom(t);
                if (e && e.ownerDocument.activeElement !== e) {
                    const {scrollX: t, scrollY: n} = jd.window;
                    const i = [];
                    qd(e, (t => {
                        const {scrollLeft: e, scrollTop: n} = t;
                        i.push([e, n])
                    }));
                    e.focus();
                    qd(e, (t => {
                        const [e, n] = i.shift();
                        t.scrollLeft = e;
                        t.scrollTop = n
                    }));
                    jd.window.scrollTo(t, n)
                }
            }

            isElement(t) {
                return t && t.nodeType == Node.ELEMENT_NODE
            }

            isDocumentFragment(t) {
                return t && t.nodeType == Node.DOCUMENT_FRAGMENT_NODE
            }

            isComment(t) {
                return t && t.nodeType == Node.COMMENT_NODE
            }

            isBlockFiller(t) {
                if (this.blockFillerMode == "br") {
                    return t.isEqualNode(Hd)
                }
                if (t.tagName === "BR" && Gd(t, this.blockElements) && t.parentNode.childNodes.length === 1) {
                    return true
                }
                return Kd(t, this.blockElements)
            }

            isDomSelectionBackward(t) {
                if (t.isCollapsed) {
                    return false
                }
                const e = document.createRange();
                e.setStart(t.anchorNode, t.anchorOffset);
                e.setEnd(t.focusNode, t.focusOffset);
                const n = e.collapsed;
                e.detach();
                return n
            }

            getHostViewElement(t) {
                const e = Fd(t);
                e.pop();
                while (e.length) {
                    const t = e.pop();
                    const n = this._domToViewMapping.get(t);
                    if (n && (n.is("uiElement") || n.is("rawElement"))) {
                        return n
                    }
                }
                return null
            }

            isDomSelectionCorrect(t) {
                return this._isDomSelectionPositionCorrect(t.anchorNode, t.anchorOffset) && this._isDomSelectionPositionCorrect(t.focusNode, t.focusOffset)
            }

            _isDomSelectionPositionCorrect(t, e) {
                if (dd(t) && fd(t) && e < md) {
                    return false
                }
                if (this.isElement(t) && fd(t.childNodes[e])) {
                    return false
                }
                const n = this.mapDomToView(t);
                if (n && (n.is("uiElement") || n.is("rawElement"))) {
                    return false
                }
                return true
            }

            _processDataFromViewText(t) {
                let e = t.data;
                if (t.getAncestors().some((t => this.preElements.includes(t.name)))) {
                    return e
                }
                if (e.charAt(0) == " ") {
                    const n = this._getTouchingViewTextNode(t, false);
                    const i = n && this._nodeEndsWithSpace(n);
                    if (i || !n) {
                        e = " " + e.substr(1)
                    }
                }
                if (e.charAt(e.length - 1) == " ") {
                    const n = this._getTouchingViewTextNode(t, true);
                    if (e.charAt(e.length - 2) == " " || !n || n.data.charAt(0) == " ") {
                        e = e.substr(0, e.length - 1) + " "
                    }
                }
                return e.replace(/ {2}/g, "  ")
            }

            _nodeEndsWithSpace(t) {
                if (t.getAncestors().some((t => this.preElements.includes(t.name)))) {
                    return false
                }
                const e = this._processDataFromViewText(t);
                return e.charAt(e.length - 1) == " "
            }

            _processDataFromDomText(t) {
                let e = t.data;
                if (Wd(t, this.preElements)) {
                    return bd(t)
                }
                e = e.replace(/[ \n\t\r]{1,}/g, " ");
                const n = this._getTouchingInlineDomNode(t, false);
                const i = this._getTouchingInlineDomNode(t, true);
                const o = this._checkShouldLeftTrimDomText(n);
                const r = this._checkShouldRightTrimDomText(t, i);
                if (o) {
                    e = e.replace(/^ /, "")
                }
                if (r) {
                    e = e.replace(/ $/, "")
                }
                e = bd(new Text(e));
                e = e.replace(/ \u00A0/g, "  ");
                if (/( |\u00A0)\u00A0$/.test(e) || !i || i.data && i.data.charAt(0) == " ") {
                    e = e.replace(/\u00A0$/, " ")
                }
                if (o) {
                    e = e.replace(/^\u00A0/, " ")
                }
                return e
            }

            _checkShouldLeftTrimDomText(t) {
                if (!t) {
                    return true
                }
                if ($r(t)) {
                    return true
                }
                return /[^\S\u00A0]/.test(t.data.charAt(t.data.length - 1))
            }

            _checkShouldRightTrimDomText(t, e) {
                if (e) {
                    return false
                }
                return !fd(t)
            }

            _getTouchingViewTextNode(t, e) {
                const n = new dl({
                    startPosition: e ? ul._createAfter(t) : ul._createBefore(t),
                    direction: e ? "forward" : "backward"
                });
                for (const t of n) {
                    if (t.item.is("containerElement")) {
                        return null
                    } else if (t.item.is("element", "br")) {
                        return null
                    } else if (t.item.is("$textProxy")) {
                        return t.item
                    }
                }
                return null
            }

            _getTouchingInlineDomNode(t, e) {
                if (!t.parentNode) {
                    return null
                }
                const n = e ? "nextNode" : "previousNode";
                const i = t.ownerDocument;
                const o = Fd(t)[0];
                const r = i.createTreeWalker(o, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT, {
                    acceptNode(t) {
                        if (dd(t)) {
                            return NodeFilter.FILTER_ACCEPT
                        }
                        if (t.tagName == "BR") {
                            return NodeFilter.FILTER_ACCEPT
                        }
                        return NodeFilter.FILTER_SKIP
                    }
                });
                r.currentNode = t;
                const s = r[n]();
                if (s !== null) {
                    const e = Vd(t, s);
                    if (e && !Wd(t, this.blockElements, e) && !Wd(s, this.blockElements, e)) {
                        return s
                    }
                }
                return null
            }
        }

        function Wd(t, e, n) {
            let i = Fd(t);
            if (n) {
                i = i.slice(i.indexOf(n) + 1)
            }
            return i.some((t => t.tagName && e.includes(t.tagName.toLowerCase())))
        }

        function qd(t, e) {
            while (t && t != jd.document) {
                e(t);
                t = t.parentNode
            }
        }

        function Kd(t, e) {
            const n = dd(t) && t.data == " ";
            return n && Gd(t, e) && t.parentNode.childNodes.length === 1
        }

        function Gd(t, e) {
            const n = t.parentNode;
            return n && n.tagName && e.includes(n.tagName.toLowerCase())
        }

        function $d(t) {
            const e = Object.prototype.toString.apply(t);
            if (e == "[object Window]") {
                return true
            }
            if (e == "[object global]") {
                return true
            }
            return false
        }

        const Yd = qc({}, ds, {
            listenTo(t, ...e) {
                if (Md(t) || $d(t)) {
                    const n = this._getProxyEmitter(t) || new Jd(t);
                    n.attach(...e);
                    t = n
                }
                ds.listenTo.call(this, t, ...e)
            }, stopListening(t, e, n) {
                if (Md(t) || $d(t)) {
                    const e = this._getProxyEmitter(t);
                    if (!e) {
                        return
                    }
                    t = e
                }
                ds.stopListening.call(this, t, e, n);
                if (t instanceof Jd) {
                    t.detach(e)
                }
            }, _getProxyEmitter(t) {
                return us(this, Xd(t))
            }
        });
        var Qd = Yd;

        class Jd {
            constructor(t) {
                hs(this, Xd(t));
                this._domNode = t
            }
        }

        qc(Jd.prototype, ds, {
            attach(t, e, n = {}) {
                if (this._domListeners && this._domListeners[t]) {
                    return
                }
                const i = {capture: !!n.useCapture, passive: !!n.usePassive};
                const o = this._createDomListener(t, i);
                this._domNode.addEventListener(t, o, i);
                if (!this._domListeners) {
                    this._domListeners = {}
                }
                this._domListeners[t] = o
            }, detach(t) {
                let e;
                if (this._domListeners[t] && (!(e = this._events[t]) || !e.callbacks.length)) {
                    this._domListeners[t].removeListener()
                }
            }, _createDomListener(t, e) {
                const n = e => {
                    this.fire(t, e)
                };
                n.removeListener = () => {
                    this._domNode.removeEventListener(t, n, e);
                    delete this._domListeners[t]
                };
                return n
            }
        });

        function Xd(t) {
            return t["data-ck-expando"] || (t["data-ck-expando"] = ns())
        }

        class Zd {
            constructor(t) {
                this.view = t;
                this.document = t.document;
                this.isEnabled = false
            }

            enable() {
                this.isEnabled = true
            }

            disable() {
                this.isEnabled = false
            }

            destroy() {
                this.disable();
                this.stopListening()
            }

            checkShouldIgnoreEventFromTarget(t) {
                if (t && t.nodeType === 3) {
                    t = t.parentNode
                }
                if (!t || t.nodeType !== 1) {
                    return false
                }
                return t.matches("[data-cke-ignore-events], [data-cke-ignore-events] *")
            }
        }

        Cs(Zd, Qd);
        var tu = "__lodash_hash_undefined__";

        function eu(t) {
            this.__data__.set(t, tu);
            return this
        }

        var nu = eu;

        function iu(t) {
            return this.__data__.has(t)
        }

        var ou = iu;

        function ru(t) {
            var e = -1, n = t == null ? 0 : t.length;
            this.__data__ = new Ae;
            while (++e < n) {
                this.add(t[e])
            }
        }

        ru.prototype.add = ru.prototype.push = nu;
        ru.prototype.has = ou;
        var su = ru;

        function au(t, e) {
            var n = -1, i = t == null ? 0 : t.length;
            while (++n < i) {
                if (e(t[n], n, t)) {
                    return true
                }
            }
            return false
        }

        var cu = au;

        function lu(t, e) {
            return t.has(e)
        }

        var du = lu;
        var uu = 1, hu = 2;

        function mu(t, e, n, i, o, r) {
            var s = n & uu, a = t.length, c = e.length;
            if (a != c && !(s && c > a)) {
                return false
            }
            var l = r.get(t);
            if (l && r.get(e)) {
                return l == e
            }
            var d = -1, u = true, h = n & hu ? new su : undefined;
            r.set(t, e);
            r.set(e, t);
            while (++d < a) {
                var m = t[d], g = e[d];
                if (i) {
                    var f = s ? i(g, m, d, e, t, r) : i(m, g, d, t, e, r)
                }
                if (f !== undefined) {
                    if (f) {
                        continue
                    }
                    u = false;
                    break
                }
                if (h) {
                    if (!cu(e, (function (t, e) {
                        if (!du(h, e) && (m === t || o(m, t, n, i, r))) {
                            return h.push(e)
                        }
                    }))) {
                        u = false;
                        break
                    }
                } else if (!(m === g || o(m, g, n, i, r))) {
                    u = false;
                    break
                }
            }
            r["delete"](t);
            r["delete"](e);
            return u
        }

        var gu = mu;

        function fu(t) {
            var e = -1, n = Array(t.size);
            t.forEach((function (t, i) {
                n[++e] = [i, t]
            }));
            return n
        }

        var pu = fu;

        function bu(t) {
            var e = -1, n = Array(t.size);
            t.forEach((function (t) {
                n[++e] = t
            }));
            return n
        }

        var ku = bu;
        var wu = 1, Au = 2;
        var _u = "[object Boolean]", Cu = "[object Date]", vu = "[object Error]", yu = "[object Map]",
            xu = "[object Number]", Eu = "[object RegExp]", Du = "[object Set]", Tu = "[object String]",
            Mu = "[object Symbol]";
        var Su = "[object ArrayBuffer]", Iu = "[object DataView]";
        var Bu = r ? r.prototype : undefined, Lu = Bu ? Bu.valueOf : undefined;

        function zu(t, e, n, i, o, r, s) {
            switch (n) {
                case Iu:
                    if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset) {
                        return false
                    }
                    t = t.buffer;
                    e = e.buffer;
                case Su:
                    if (t.byteLength != e.byteLength || !r(new mo(t), new mo(e))) {
                        return false
                    }
                    return true;
                case _u:
                case Cu:
                case xu:
                    return j(+t, +e);
                case vu:
                    return t.name == e.name && t.message == e.message;
                case Eu:
                case Tu:
                    return t == e + "";
                case yu:
                    var a = pu;
                case Du:
                    var c = i & wu;
                    a || (a = ku);
                    if (t.size != e.size && !c) {
                        return false
                    }
                    var l = s.get(t);
                    if (l) {
                        return l == e
                    }
                    i |= Au;
                    s.set(t, e);
                    var d = gu(a(t), a(e), i, o, r, s);
                    s["delete"](t);
                    return d;
                case Mu:
                    if (Lu) {
                        return Lu.call(t) == Lu.call(e)
                    }
            }
            return false
        }

        var Nu = zu;
        var Pu = 1;
        var Ou = Object.prototype;
        var ju = Ou.hasOwnProperty;

        function Ru(t, e, n, i, o, r) {
            var s = n & Pu, a = Oi(t), c = a.length, l = Oi(e), d = l.length;
            if (c != d && !s) {
                return false
            }
            var u = c;
            while (u--) {
                var h = a[u];
                if (!(s ? h in e : ju.call(e, h))) {
                    return false
                }
            }
            var m = r.get(t);
            if (m && r.get(e)) {
                return m == e
            }
            var g = true;
            r.set(t, e);
            r.set(e, t);
            var f = s;
            while (++u < c) {
                h = a[u];
                var p = t[h], b = e[h];
                if (i) {
                    var k = s ? i(b, p, h, e, t, r) : i(p, b, h, t, e, r)
                }
                if (!(k === undefined ? p === b || o(p, b, n, i, r) : k)) {
                    g = false;
                    break
                }
                f || (f = h == "constructor")
            }
            if (g && !f) {
                var w = t.constructor, A = e.constructor;
                if (w != A && ("constructor" in t && "constructor" in e) && !(typeof w == "function" && w instanceof w && typeof A == "function" && A instanceof A)) {
                    g = false
                }
            }
            r["delete"](t);
            r["delete"](e);
            return g
        }

        var Fu = Ru;
        var Vu = 1;
        var Hu = "[object Arguments]", Uu = "[object Array]", Wu = "[object Object]";
        var qu = Object.prototype;
        var Ku = qu.hasOwnProperty;

        function Gu(t, e, n, i, o, r) {
            var s = Ye(t), a = Ye(e), c = s ? Uu : so(t), l = a ? Uu : so(e);
            c = c == Hu ? Wu : c;
            l = l == Hu ? Wu : l;
            var d = c == Wu, u = l == Wu, h = c == l;
            if (h && Object(Qe["a"])(t)) {
                if (!Object(Qe["a"])(e)) {
                    return false
                }
                s = true;
                d = false
            }
            if (h && !d) {
                r || (r = new xe);
                return s || On(t) ? gu(t, e, n, i, o, r) : Nu(t, e, c, n, i, o, r)
            }
            if (!(n & Vu)) {
                var m = d && Ku.call(t, "__wrapped__"), g = u && Ku.call(e, "__wrapped__");
                if (m || g) {
                    var f = m ? t.value() : t, p = g ? e.value() : e;
                    r || (r = new xe);
                    return o(f, p, n, i, r)
                }
            }
            if (!h) {
                return false
            }
            r || (r = new xe);
            return Fu(t, e, n, i, o, r)
        }

        var $u = Gu;

        function Yu(t, e, n, i, o) {
            if (t === e) {
                return true
            }
            if (t == null || e == null || !E(t) && !E(e)) {
                return t !== t && e !== e
            }
            return $u(t, e, n, i, Yu, o)
        }

        var Qu = Yu;

        function Ju(t, e, n) {
            n = typeof n == "function" ? n : undefined;
            var i = n ? n(t, e) : undefined;
            return i === undefined ? Qu(t, e, undefined, n) : !!i
        }

        var Xu = Ju;

        class Zu extends Zd {
            constructor(t) {
                super(t);
                this._config = {childList: true, characterData: true, characterDataOldValue: true, subtree: true};
                this.domConverter = t.domConverter;
                this.renderer = t._renderer;
                this._domElements = [];
                this._mutationObserver = new window.MutationObserver(this._onMutations.bind(this))
            }

            flush() {
                this._onMutations(this._mutationObserver.takeRecords())
            }

            observe(t) {
                this._domElements.push(t);
                if (this.isEnabled) {
                    this._mutationObserver.observe(t, this._config)
                }
            }

            enable() {
                super.enable();
                for (const t of this._domElements) {
                    this._mutationObserver.observe(t, this._config)
                }
            }

            disable() {
                super.disable();
                this._mutationObserver.disconnect()
            }

            destroy() {
                super.destroy();
                this._mutationObserver.disconnect()
            }

            _onMutations(t) {
                if (t.length === 0) {
                    return
                }
                const e = this.domConverter;
                const n = new Map;
                const i = new Set;
                for (const n of t) {
                    if (n.type === "childList") {
                        const t = e.mapDomToView(n.target);
                        if (t && (t.is("uiElement") || t.is("rawElement"))) {
                            continue
                        }
                        if (t && !this._isBogusBrMutation(n)) {
                            i.add(t)
                        }
                    }
                }
                for (const o of t) {
                    const t = e.mapDomToView(o.target);
                    if (t && (t.is("uiElement") || t.is("rawElement"))) {
                        continue
                    }
                    if (o.type === "characterData") {
                        const t = e.findCorrespondingViewText(o.target);
                        if (t && !i.has(t.parent)) {
                            n.set(t, {type: "text", oldText: t.data, newText: bd(o.target), node: t})
                        } else if (!t && fd(o.target)) {
                            i.add(e.mapDomToView(o.target.parentNode))
                        }
                    }
                }
                const o = [];
                for (const t of n.values()) {
                    this.renderer.markToSync("text", t.node);
                    o.push(t)
                }
                for (const t of i) {
                    const n = e.mapViewToDom(t);
                    const i = Array.from(t.getChildren());
                    const r = Array.from(e.domChildrenToView(n, {withChildren: false}));
                    if (!Xu(i, r, a)) {
                        this.renderer.markToSync("children", t);
                        o.push({type: "children", oldChildren: i, newChildren: r, node: t})
                    }
                }
                const r = t[0].target.ownerDocument.getSelection();
                let s = null;
                if (r && r.anchorNode) {
                    const t = e.domPositionToView(r.anchorNode, r.anchorOffset);
                    const n = e.domPositionToView(r.focusNode, r.focusOffset);
                    if (t && n) {
                        s = new fl(t);
                        s.setFocus(n)
                    }
                }
                if (o.length) {
                    this.document.fire("mutations", o, s);
                    this.view.forceRender()
                }

                function a(t, e) {
                    if (Array.isArray(t)) {
                        return
                    }
                    if (t === e) {
                        return true
                    } else if (t.is("$text") && e.is("$text")) {
                        return t.data === e.data
                    }
                    return false
                }
            }

            _isBogusBrMutation(t) {
                let e = null;
                if (t.nextSibling === null && t.removedNodes.length === 0 && t.addedNodes.length == 1) {
                    e = this.domConverter.domToView(t.addedNodes[0], {withChildren: false})
                }
                return e && e.is("element", "br")
            }
        }

        class th {
            constructor(t, e, n) {
                this.view = t;
                this.document = t.document;
                this.domEvent = e;
                this.domTarget = e.target;
                qc(this, n)
            }

            get target() {
                return this.view.domConverter.mapDomToView(this.domTarget)
            }

            preventDefault() {
                this.domEvent.preventDefault()
            }

            stopPropagation() {
                this.domEvent.stopPropagation()
            }
        }

        class eh extends Zd {
            constructor(t) {
                super(t);
                this.useCapture = false
            }

            observe(t) {
                const e = typeof this.domEventType == "string" ? [this.domEventType] : this.domEventType;
                e.forEach((e => {
                    this.listenTo(t, e, ((t, e) => {
                        if (this.isEnabled && !this.checkShouldIgnoreEventFromTarget(e.target)) {
                            this.onDomEvent(e)
                        }
                    }), {useCapture: this.useCapture})
                }))
            }

            fire(t, e, n) {
                if (this.isEnabled) {
                    this.document.fire(t, new th(this.view, e, n))
                }
            }
        }

        class nh extends eh {
            constructor(t) {
                super(t);
                this.domEventType = ["keydown", "keyup"]
            }

            onDomEvent(t) {
                this.fire(t.type, t, {
                    keyCode: t.keyCode,
                    altKey: t.altKey,
                    ctrlKey: t.ctrlKey || t.metaKey,
                    shiftKey: t.shiftKey,
                    get keystroke() {
                        return Pl(this)
                    }
                })
            }
        }

        var ih = function () {
            return i["a"].Date.now()
        };
        var oh = ih;
        var rh = 0 / 0;
        var sh = /^\s+|\s+$/g;
        var ah = /^[-+]0x[0-9a-f]+$/i;
        var ch = /^0b[01]+$/i;
        var lh = /^0o[0-7]+$/i;
        var dh = parseInt;

        function uh(t) {
            if (typeof t == "number") {
                return t
            }
            if (Xs(t)) {
                return rh
            }
            if (ct(t)) {
                var e = typeof t.valueOf == "function" ? t.valueOf() : t;
                t = ct(e) ? e + "" : e
            }
            if (typeof t != "string") {
                return t === 0 ? t : +t
            }
            t = t.replace(sh, "");
            var n = ch.test(t);
            return n || lh.test(t) ? dh(t.slice(2), n ? 2 : 8) : ah.test(t) ? rh : +t
        }

        var hh = uh;
        var mh = "Expected a function";
        var gh = Math.max, fh = Math.min;

        function ph(t, e, n) {
            var i, o, r, s, a, c, l = 0, d = false, u = false, h = true;
            if (typeof t != "function") {
                throw new TypeError(mh)
            }
            e = hh(e) || 0;
            if (ct(n)) {
                d = !!n.leading;
                u = "maxWait" in n;
                r = u ? gh(hh(n.maxWait) || 0, e) : r;
                h = "trailing" in n ? !!n.trailing : h
            }

            function m(e) {
                var n = i, r = o;
                i = o = undefined;
                l = e;
                s = t.apply(r, n);
                return s
            }

            function g(t) {
                l = t;
                a = setTimeout(b, e);
                return d ? m(t) : s
            }

            function f(t) {
                var n = t - c, i = t - l, o = e - n;
                return u ? fh(o, r - i) : o
            }

            function p(t) {
                var n = t - c, i = t - l;
                return c === undefined || n >= e || n < 0 || u && i >= r
            }

            function b() {
                var t = oh();
                if (p(t)) {
                    return k(t)
                }
                a = setTimeout(b, f(t))
            }

            function k(t) {
                a = undefined;
                if (h && i) {
                    return m(t)
                }
                i = o = undefined;
                return s
            }

            function w() {
                if (a !== undefined) {
                    clearTimeout(a)
                }
                l = 0;
                i = c = o = a = undefined
            }

            function A() {
                return a === undefined ? s : k(oh())
            }

            function _() {
                var t = oh(), n = p(t);
                i = arguments;
                o = this;
                c = t;
                if (n) {
                    if (a === undefined) {
                        return g(c)
                    }
                    if (u) {
                        clearTimeout(a);
                        a = setTimeout(b, e);
                        return m(c)
                    }
                }
                if (a === undefined) {
                    a = setTimeout(b, e)
                }
                return s
            }

            _.cancel = w;
            _.flush = A;
            return _
        }

        var bh = ph;

        class kh extends Zd {
            constructor(t) {
                super(t);
                this._fireSelectionChangeDoneDebounced = bh((t => this.document.fire("selectionChangeDone", t)), 200)
            }

            observe() {
                const t = this.document;
                t.on("keydown", ((e, n) => {
                    const i = t.selection;
                    if (i.isFake && Rl(n.keyCode) && this.isEnabled) {
                        n.preventDefault();
                        this._handleSelectionMove(n.keyCode)
                    }
                }), {priority: "lowest"})
            }

            destroy() {
                super.destroy();
                this._fireSelectionChangeDoneDebounced.cancel()
            }

            _handleSelectionMove(t) {
                const e = this.document.selection;
                const n = new fl(e.getRanges(), {backward: e.isBackward, fake: false});
                if (t == Nl.arrowleft || t == Nl.arrowup) {
                    n.setTo(n.getFirstPosition())
                }
                if (t == Nl.arrowright || t == Nl.arrowdown) {
                    n.setTo(n.getLastPosition())
                }
                const i = {oldSelection: e, newSelection: n, domSelection: null};
                this.document.fire("selectionChange", i);
                this._fireSelectionChangeDoneDebounced(i)
            }
        }

        class wh extends Zd {
            constructor(t) {
                super(t);
                this.mutationObserver = t.getObserver(Zu);
                this.selection = this.document.selection;
                this.domConverter = t.domConverter;
                this._documents = new WeakSet;
                this._fireSelectionChangeDoneDebounced = bh((t => this.document.fire("selectionChangeDone", t)), 200);
                this._clearInfiniteLoopInterval = setInterval((() => this._clearInfiniteLoop()), 1e3);
                this._loopbackCounter = 0
            }

            observe(t) {
                const e = t.ownerDocument;
                if (this._documents.has(e)) {
                    return
                }
                this.listenTo(e, "selectionchange", ((t, n) => {
                    this._handleSelectionChange(n, e)
                }));
                this._documents.add(e)
            }

            destroy() {
                super.destroy();
                clearInterval(this._clearInfiniteLoopInterval);
                this._fireSelectionChangeDoneDebounced.cancel()
            }

            _handleSelectionChange(t, e) {
                if (!this.isEnabled) {
                    return
                }
                const n = e.defaultView.getSelection();
                if (this.checkShouldIgnoreEventFromTarget(n.anchorNode)) {
                    return
                }
                this.mutationObserver.flush();
                const i = this.domConverter.domSelectionToView(n);
                if (i.rangeCount == 0) {
                    this.view.hasDomSelection = false;
                    return
                }
                this.view.hasDomSelection = true;
                if (this.selection.isEqual(i) && this.domConverter.isDomSelectionCorrect(n)) {
                    return
                }
                if (++this._loopbackCounter > 60) {
                    return
                }
                if (this.selection.isSimilar(i)) {
                    this.view.forceRender()
                } else {
                    const t = {oldSelection: this.selection, newSelection: i, domSelection: n};
                    this.document.fire("selectionChange", t);
                    this._fireSelectionChangeDoneDebounced(t)
                }
            }

            _clearInfiniteLoop() {
                this._loopbackCounter = 0
            }
        }

        class Ah extends eh {
            constructor(t) {
                super(t);
                this.domEventType = ["focus", "blur"];
                this.useCapture = true;
                const e = this.document;
                e.on("focus", (() => {
                    e.isFocused = true;
                    this._renderTimeoutId = setTimeout((() => t.forceRender()), 50)
                }));
                e.on("blur", ((n, i) => {
                    const o = e.selection.editableElement;
                    if (o === null || o === i.target) {
                        e.isFocused = false;
                        t.forceRender()
                    }
                }))
            }

            onDomEvent(t) {
                this.fire(t.type, t)
            }

            destroy() {
                if (this._renderTimeoutId) {
                    clearTimeout(this._renderTimeoutId)
                }
                super.destroy()
            }
        }

        class _h extends eh {
            constructor(t) {
                super(t);
                this.domEventType = ["compositionstart", "compositionupdate", "compositionend"];
                const e = this.document;
                e.on("compositionstart", (() => {
                    e.isComposing = true
                }));
                e.on("compositionend", (() => {
                    e.isComposing = false
                }))
            }

            onDomEvent(t) {
                this.fire(t.type, t)
            }
        }

        class Ch extends eh {
            constructor(t) {
                super(t);
                this.domEventType = ["beforeinput"]
            }

            onDomEvent(t) {
                this.fire(t.type, t)
            }
        }

        function vh(t) {
            return Object.prototype.toString.apply(t) == "[object Range]"
        }

        function yh(t) {
            const e = t.ownerDocument.defaultView.getComputedStyle(t);
            return {
                top: parseInt(e.borderTopWidth, 10),
                right: parseInt(e.borderRightWidth, 10),
                bottom: parseInt(e.borderBottomWidth, 10),
                left: parseInt(e.borderLeftWidth, 10)
            }
        }

        const xh = ["top", "right", "bottom", "left", "width", "height"];

        class Eh {
            constructor(t) {
                const e = vh(t);
                Object.defineProperty(this, "_source", {value: t._source || t, writable: true, enumerable: false});
                if ($r(t) || e) {
                    if (e) {
                        const e = Eh.getDomRangeRects(t);
                        Dh(this, Eh.getBoundingRect(e))
                    } else {
                        Dh(this, t.getBoundingClientRect())
                    }
                } else if ($d(t)) {
                    const {innerWidth: e, innerHeight: n} = t;
                    Dh(this, {top: 0, right: e, bottom: n, left: 0, width: e, height: n})
                } else {
                    Dh(this, t)
                }
            }

            clone() {
                return new Eh(this)
            }

            moveTo(t, e) {
                this.top = e;
                this.right = t + this.width;
                this.bottom = e + this.height;
                this.left = t;
                return this
            }

            moveBy(t, e) {
                this.top += e;
                this.right += t;
                this.left += t;
                this.bottom += e;
                return this
            }

            getIntersection(t) {
                const e = {
                    top: Math.max(this.top, t.top),
                    right: Math.min(this.right, t.right),
                    bottom: Math.min(this.bottom, t.bottom),
                    left: Math.max(this.left, t.left)
                };
                e.width = e.right - e.left;
                e.height = e.bottom - e.top;
                if (e.width < 0 || e.height < 0) {
                    return null
                } else {
                    return new Eh(e)
                }
            }

            getIntersectionArea(t) {
                const e = this.getIntersection(t);
                if (e) {
                    return e.getArea()
                } else {
                    return 0
                }
            }

            getArea() {
                return this.width * this.height
            }

            getVisible() {
                const t = this._source;
                let e = this.clone();
                if (!Th(t)) {
                    let n = t.parentNode || t.commonAncestorContainer;
                    while (n && !Th(n)) {
                        const t = new Eh(n);
                        const i = e.getIntersection(t);
                        if (i) {
                            if (i.getArea() < e.getArea()) {
                                e = i
                            }
                        } else {
                            return null
                        }
                        n = n.parentNode
                    }
                }
                return e
            }

            isEqual(t) {
                for (const e of xh) {
                    if (this[e] !== t[e]) {
                        return false
                    }
                }
                return true
            }

            contains(t) {
                const e = this.getIntersection(t);
                return !!(e && e.isEqual(t))
            }

            excludeScrollbarsAndBorders() {
                const t = this._source;
                let e, n, i;
                if ($d(t)) {
                    e = t.innerWidth - t.document.documentElement.clientWidth;
                    n = t.innerHeight - t.document.documentElement.clientHeight;
                    i = t.getComputedStyle(t.document.documentElement).direction
                } else {
                    const o = yh(this._source);
                    e = t.offsetWidth - t.clientWidth - o.left - o.right;
                    n = t.offsetHeight - t.clientHeight - o.top - o.bottom;
                    i = t.ownerDocument.defaultView.getComputedStyle(t).direction;
                    this.left += o.left;
                    this.top += o.top;
                    this.right -= o.right;
                    this.bottom -= o.bottom;
                    this.width = this.right - this.left;
                    this.height = this.bottom - this.top
                }
                this.width -= e;
                if (i === "ltr") {
                    this.right -= e
                } else {
                    this.left += e
                }
                this.height -= n;
                this.bottom -= n;
                return this
            }

            static getDomRangeRects(t) {
                const e = [];
                const n = Array.from(t.getClientRects());
                if (n.length) {
                    for (const t of n) {
                        e.push(new Eh(t))
                    }
                } else {
                    let n = t.startContainer;
                    if (dd(n)) {
                        n = n.parentNode
                    }
                    const i = new Eh(n.getBoundingClientRect());
                    i.right = i.left;
                    i.width = 0;
                    e.push(i)
                }
                return e
            }

            static getBoundingRect(t) {
                const e = {
                    left: Number.POSITIVE_INFINITY,
                    top: Number.POSITIVE_INFINITY,
                    right: Number.NEGATIVE_INFINITY,
                    bottom: Number.NEGATIVE_INFINITY
                };
                let n = 0;
                for (const i of t) {
                    n++;
                    e.left = Math.min(e.left, i.left);
                    e.top = Math.min(e.top, i.top);
                    e.right = Math.max(e.right, i.right);
                    e.bottom = Math.max(e.bottom, i.bottom)
                }
                if (n == 0) {
                    return null
                }
                e.width = e.right - e.left;
                e.height = e.bottom - e.top;
                return new Eh(e)
            }
        }

        function Dh(t, e) {
            for (const n of xh) {
                t[n] = e[n]
            }
        }

        function Th(t) {
            if (!$r(t)) {
                return false
            }
            return t === t.ownerDocument.body
        }

        const Mh = {};

        function Sh({target: t, viewportOffset: e = 0}) {
            const n = jh(t);
            let i = n;
            let o = null;
            while (i) {
                let r;
                if (i == n) {
                    r = Rh(t)
                } else {
                    r = Rh(o)
                }
                Lh(r, (() => Fh(t, i)));
                const s = Fh(t, i);
                Bh(i, s, e);
                if (i.parent != i) {
                    o = i.frameElement;
                    i = i.parent;
                    if (!o) {
                        return
                    }
                } else {
                    i = null
                }
            }
        }

        function Ih(t) {
            const e = Rh(t);
            Lh(e, (() => new Eh(t)))
        }

        Object.assign(Mh, {scrollViewportToShowTarget: Sh, scrollAncestorsToShowTarget: Ih});

        function Bh(t, e, n) {
            const i = e.clone().moveBy(0, n);
            const o = e.clone().moveBy(0, -n);
            const r = new Eh(t).excludeScrollbarsAndBorders();
            const s = [o, i];
            if (!s.every((t => r.contains(t)))) {
                let {scrollX: s, scrollY: a} = t;
                if (Nh(o, r)) {
                    a -= r.top - e.top + n
                } else if (zh(i, r)) {
                    a += e.bottom - r.bottom + n
                }
                if (Ph(e, r)) {
                    s -= r.left - e.left + n
                } else if (Oh(e, r)) {
                    s += e.right - r.right + n
                }
                t.scrollTo(s, a)
            }
        }

        function Lh(t, e) {
            const n = jh(t);
            let i, o;
            while (t != n.document.body) {
                o = e();
                i = new Eh(t).excludeScrollbarsAndBorders();
                if (!i.contains(o)) {
                    if (Nh(o, i)) {
                        t.scrollTop -= i.top - o.top
                    } else if (zh(o, i)) {
                        t.scrollTop += o.bottom - i.bottom
                    }
                    if (Ph(o, i)) {
                        t.scrollLeft -= i.left - o.left
                    } else if (Oh(o, i)) {
                        t.scrollLeft += o.right - i.right
                    }
                }
                t = t.parentNode
            }
        }

        function zh(t, e) {
            return t.bottom > e.bottom
        }

        function Nh(t, e) {
            return t.top < e.top
        }

        function Ph(t, e) {
            return t.left < e.left
        }

        function Oh(t, e) {
            return t.right > e.right
        }

        function jh(t) {
            if (vh(t)) {
                return t.startContainer.ownerDocument.defaultView
            } else {
                return t.ownerDocument.defaultView
            }
        }

        function Rh(t) {
            if (vh(t)) {
                let e = t.commonAncestorContainer;
                if (dd(e)) {
                    e = e.parentNode
                }
                return e
            } else {
                return t.parentNode
            }
        }

        function Fh(t, e) {
            const n = jh(t);
            const i = new Eh(t);
            if (n === e) {
                return i
            } else {
                let t = n;
                while (t != e) {
                    const e = t.frameElement;
                    const n = new Eh(e).excludeScrollbarsAndBorders();
                    i.moveBy(n.left, n.top);
                    t = t.parent
                }
            }
            return i
        }

        class Vh {
            constructor(t) {
                this.document = new bl(t);
                this.domConverter = new Ud(this.document);
                this.domRoots = new Map;
                this.set("isRenderingInProgress", false);
                this.set("hasDomSelection", false);
                this._renderer = new Sd(this.domConverter, this.document.selection);
                this._renderer.bind("isFocused").to(this.document);
                this._initialDomRootAttributes = new WeakMap;
                this._observers = new Map;
                this._ongoingChange = false;
                this._postFixersInProgress = false;
                this._renderingDisabled = false;
                this._hasChangedSinceTheLastRendering = false;
                this._writer = new Xl(this.document);
                this.addObserver(Zu);
                this.addObserver(wh);
                this.addObserver(Ah);
                this.addObserver(nh);
                this.addObserver(kh);
                this.addObserver(_h);
                if (El.isAndroid) {
                    this.addObserver(Ch)
                }
                kd(this);
                ql(this);
                this.on("render", (() => {
                    this._render();
                    this.document.fire("layoutChanged");
                    this._hasChangedSinceTheLastRendering = false
                }));
                this.listenTo(this.document.selection, "change", (() => {
                    this._hasChangedSinceTheLastRendering = true
                }))
            }

            attachDomRoot(t, e = "main") {
                const n = this.document.getRoot(e);
                n._name = t.tagName.toLowerCase();
                const i = {};
                for (const {name: e, value: o} of Array.from(t.attributes)) {
                    i[e] = o;
                    if (e === "class") {
                        this._writer.addClass(o.split(" "), n)
                    } else {
                        this._writer.setAttribute(e, o, n)
                    }
                }
                this._initialDomRootAttributes.set(t, i);
                const o = () => {
                    this._writer.setAttribute("contenteditable", !n.isReadOnly, n);
                    if (n.isReadOnly) {
                        this._writer.addClass("ck-read-only", n)
                    } else {
                        this._writer.removeClass("ck-read-only", n)
                    }
                };
                o();
                this.domRoots.set(e, t);
                this.domConverter.bindElements(t, n);
                this._renderer.markToSync("children", n);
                this._renderer.markToSync("attributes", n);
                this._renderer.domDocuments.add(t.ownerDocument);
                n.on("change:children", ((t, e) => this._renderer.markToSync("children", e)));
                n.on("change:attributes", ((t, e) => this._renderer.markToSync("attributes", e)));
                n.on("change:text", ((t, e) => this._renderer.markToSync("text", e)));
                n.on("change:isReadOnly", (() => this.change(o)));
                n.on("change", (() => {
                    this._hasChangedSinceTheLastRendering = true
                }));
                for (const n of this._observers.values()) {
                    n.observe(t, e)
                }
            }

            detachDomRoot(t) {
                const e = this.domRoots.get(t);
                Array.from(e.attributes).forEach((({name: t}) => e.removeAttribute(t)));
                const n = this._initialDomRootAttributes.get(e);
                for (const t in n) {
                    e.setAttribute(t, n[t])
                }
                this.domRoots.delete(t);
                this.domConverter.unbindDomElement(e)
            }

            getDomRoot(t = "main") {
                return this.domRoots.get(t)
            }

            addObserver(t) {
                let e = this._observers.get(t);
                if (e) {
                    return e
                }
                e = new t(this);
                this._observers.set(t, e);
                for (const [t, n] of this.domRoots) {
                    e.observe(n, t)
                }
                e.enable();
                return e
            }

            getObserver(t) {
                return this._observers.get(t)
            }

            disableObservers() {
                for (const t of this._observers.values()) {
                    t.disable()
                }
            }

            enableObservers() {
                for (const t of this._observers.values()) {
                    t.enable()
                }
            }

            scrollToTheSelection() {
                const t = this.document.selection.getFirstRange();
                if (t) {
                    Sh({target: this.domConverter.viewRangeToDom(t), viewportOffset: 20})
                }
            }

            focus() {
                if (!this.document.isFocused) {
                    const t = this.document.selection.editableElement;
                    if (t) {
                        this.domConverter.focus(t);
                        this.forceRender()
                    } else {
                    }
                }
            }

            change(t) {
                if (this.isRenderingInProgress || this._postFixersInProgress) {
                    throw new ss["a"]("cannot-change-view-tree", this)
                }
                try {
                    if (this._ongoingChange) {
                        return t(this._writer)
                    }
                    this._ongoingChange = true;
                    const e = t(this._writer);
                    this._ongoingChange = false;
                    if (!this._renderingDisabled && this._hasChangedSinceTheLastRendering) {
                        this._postFixersInProgress = true;
                        this.document._callPostFixers(this._writer);
                        this._postFixersInProgress = false;
                        this.fire("render")
                    }
                    return e
                } catch (t) {
                    ss["a"].rethrowUnexpectedError(t, this)
                }
            }

            forceRender() {
                this._hasChangedSinceTheLastRendering = true;
                this.change((() => {
                }))
            }

            destroy() {
                for (const t of this._observers.values()) {
                    t.destroy()
                }
                this.document.destroy();
                this.stopListening()
            }

            createPositionAt(t, e) {
                return ul._createAt(t, e)
            }

            createPositionAfter(t) {
                return ul._createAfter(t)
            }

            createPositionBefore(t) {
                return ul._createBefore(t)
            }

            createRange(t, e) {
                return new hl(t, e)
            }

            createRangeOn(t) {
                return hl._createOn(t)
            }

            createRangeIn(t) {
                return hl._createIn(t)
            }

            createSelection(t, e, n) {
                return new fl(t, e, n)
            }

            _disableRendering(t) {
                this._renderingDisabled = t;
                if (t == false) {
                    this.change((() => {
                    }))
                }
            }

            _render() {
                this.isRenderingInProgress = true;
                this.disableObservers();
                this._renderer.render();
                this.enableObservers();
                this.isRenderingInProgress = false
            }
        }

        Cs(Vh, Qc);

        class Hh {
            constructor(t) {
                this.parent = null;
                this._attrs = Us(t)
            }

            get index() {
                let t;
                if (!this.parent) {
                    return null
                }
                if ((t = this.parent.getChildIndex(this)) === null) {
                    throw new ss["a"]("model-node-not-found-in-parent", this)
                }
                return t
            }

            get startOffset() {
                let t;
                if (!this.parent) {
                    return null
                }
                if ((t = this.parent.getChildStartOffset(this)) === null) {
                    throw new ss["a"]("model-node-not-found-in-parent", this)
                }
                return t
            }

            get offsetSize() {
                return 1
            }

            get endOffset() {
                if (!this.parent) {
                    return null
                }
                return this.startOffset + this.offsetSize
            }

            get nextSibling() {
                const t = this.index;
                return t !== null && this.parent.getChild(t + 1) || null
            }

            get previousSibling() {
                const t = this.index;
                return t !== null && this.parent.getChild(t - 1) || null
            }

            get root() {
                let t = this;
                while (t.parent) {
                    t = t.parent
                }
                return t
            }

            isAttached() {
                return this.root.is("rootElement")
            }

            getPath() {
                const t = [];
                let e = this;
                while (e.parent) {
                    t.unshift(e.startOffset);
                    e = e.parent
                }
                return t
            }

            getAncestors(t = {includeSelf: false, parentFirst: false}) {
                const e = [];
                let n = t.includeSelf ? this : this.parent;
                while (n) {
                    e[t.parentFirst ? "push" : "unshift"](n);
                    n = n.parent
                }
                return e
            }

            getCommonAncestor(t, e = {}) {
                const n = this.getAncestors(e);
                const i = t.getAncestors(e);
                let o = 0;
                while (n[o] == i[o] && n[o]) {
                    o++
                }
                return o === 0 ? null : n[o - 1]
            }

            isBefore(t) {
                if (this == t) {
                    return false
                }
                if (this.root !== t.root) {
                    return false
                }
                const e = this.getPath();
                const n = t.getPath();
                const i = Ns(e, n);
                switch (i) {
                    case"prefix":
                        return true;
                    case"extension":
                        return false;
                    default:
                        return e[i] < n[i]
                }
            }

            isAfter(t) {
                if (this == t) {
                    return false
                }
                if (this.root !== t.root) {
                    return false
                }
                return !this.isBefore(t)
            }

            hasAttribute(t) {
                return this._attrs.has(t)
            }

            getAttribute(t) {
                return this._attrs.get(t)
            }

            getAttributes() {
                return this._attrs.entries()
            }

            getAttributeKeys() {
                return this._attrs.keys()
            }

            toJSON() {
                const t = {};
                if (this._attrs.size) {
                    t.attributes = Array.from(this._attrs).reduce(((t, e) => {
                        t[e[0]] = e[1];
                        return t
                    }), {})
                }
                return t
            }

            is(t) {
                return t === "node" || t === "model:node"
            }

            _clone() {
                return new Hh(this._attrs)
            }

            _remove() {
                this.parent._removeChildren(this.index)
            }

            _setAttribute(t, e) {
                this._attrs.set(t, e)
            }

            _setAttributesTo(t) {
                this._attrs = Us(t)
            }

            _removeAttribute(t) {
                return this._attrs.delete(t)
            }

            _clearAttributes() {
                this._attrs.clear()
            }
        }

        class Uh extends Hh {
            constructor(t, e) {
                super(e);
                this._data = t || ""
            }

            get offsetSize() {
                return this.data.length
            }

            get data() {
                return this._data
            }

            is(t) {
                return t === "$text" || t === "model:$text" || t === "text" || t === "model:text" || t === "node" || t === "model:node"
            }

            toJSON() {
                const t = super.toJSON();
                t.data = this.data;
                return t
            }

            _clone() {
                return new Uh(this.data, this.getAttributes())
            }

            static fromJSON(t) {
                return new Uh(t.data, t.attributes)
            }
        }

        class Wh {
            constructor(t, e, n) {
                this.textNode = t;
                if (e < 0 || e > t.offsetSize) {
                    throw new ss["a"]("model-textproxy-wrong-offsetintext", this)
                }
                if (n < 0 || e + n > t.offsetSize) {
                    throw new ss["a"]("model-textproxy-wrong-length", this)
                }
                this.data = t.data.substring(e, e + n);
                this.offsetInText = e
            }

            get startOffset() {
                return this.textNode.startOffset !== null ? this.textNode.startOffset + this.offsetInText : null
            }

            get offsetSize() {
                return this.data.length
            }

            get endOffset() {
                return this.startOffset !== null ? this.startOffset + this.offsetSize : null
            }

            get isPartial() {
                return this.offsetSize !== this.textNode.offsetSize
            }

            get parent() {
                return this.textNode.parent
            }

            get root() {
                return this.textNode.root
            }

            is(t) {
                return t === "$textProxy" || t === "model:$textProxy" || t === "textProxy" || t === "model:textProxy"
            }

            getPath() {
                const t = this.textNode.getPath();
                if (t.length > 0) {
                    t[t.length - 1] += this.offsetInText
                }
                return t
            }

            getAncestors(t = {includeSelf: false, parentFirst: false}) {
                const e = [];
                let n = t.includeSelf ? this : this.parent;
                while (n) {
                    e[t.parentFirst ? "push" : "unshift"](n);
                    n = n.parent
                }
                return e
            }

            hasAttribute(t) {
                return this.textNode.hasAttribute(t)
            }

            getAttribute(t) {
                return this.textNode.getAttribute(t)
            }

            getAttributes() {
                return this.textNode.getAttributes()
            }

            getAttributeKeys() {
                return this.textNode.getAttributeKeys()
            }
        }

        class qh {
            constructor(t) {
                this._nodes = [];
                if (t) {
                    this._insertNodes(0, t)
                }
            }

            [Symbol.iterator]() {
                return this._nodes[Symbol.iterator]()
            }

            get length() {
                return this._nodes.length
            }

            get maxOffset() {
                return this._nodes.reduce(((t, e) => t + e.offsetSize), 0)
            }

            getNode(t) {
                return this._nodes[t] || null
            }

            getNodeIndex(t) {
                const e = this._nodes.indexOf(t);
                return e == -1 ? null : e
            }

            getNodeStartOffset(t) {
                const e = this.getNodeIndex(t);
                return e === null ? null : this._nodes.slice(0, e).reduce(((t, e) => t + e.offsetSize), 0)
            }

            indexToOffset(t) {
                if (t == this._nodes.length) {
                    return this.maxOffset
                }
                const e = this._nodes[t];
                if (!e) {
                    throw new ss["a"]("model-nodelist-index-out-of-bounds", this)
                }
                return this.getNodeStartOffset(e)
            }

            offsetToIndex(t) {
                let e = 0;
                for (const n of this._nodes) {
                    if (t >= e && t < e + n.offsetSize) {
                        return this.getNodeIndex(n)
                    }
                    e += n.offsetSize
                }
                if (e != t) {
                    throw new ss["a"]("model-nodelist-offset-out-of-bounds", this, {offset: t, nodeList: this})
                }
                return this.length
            }

            _insertNodes(t, e) {
                for (const t of e) {
                    if (!(t instanceof Hh)) {
                        throw new ss["a"]("model-nodelist-insertnodes-not-node", this)
                    }
                }
                this._nodes.splice(t, 0, ...e)
            }

            _removeNodes(t, e = 1) {
                return this._nodes.splice(t, e)
            }

            toJSON() {
                return this._nodes.map((t => t.toJSON()))
            }
        }

        class Kh extends Hh {
            constructor(t, e, n) {
                super(e);
                this.name = t;
                this._children = new qh;
                if (n) {
                    this._insertChild(0, n)
                }
            }

            get childCount() {
                return this._children.length
            }

            get maxOffset() {
                return this._children.maxOffset
            }

            get isEmpty() {
                return this.childCount === 0
            }

            is(t, e = null) {
                if (!e) {
                    return t === "element" || t === "model:element" || t === "node" || t === "model:node"
                }
                return e === this.name && (t === "element" || t === "model:element")
            }

            getChild(t) {
                return this._children.getNode(t)
            }

            getChildren() {
                return this._children[Symbol.iterator]()
            }

            getChildIndex(t) {
                return this._children.getNodeIndex(t)
            }

            getChildStartOffset(t) {
                return this._children.getNodeStartOffset(t)
            }

            offsetToIndex(t) {
                return this._children.offsetToIndex(t)
            }

            getNodeByPath(t) {
                let e = this;
                for (const n of t) {
                    e = e.getChild(e.offsetToIndex(n))
                }
                return e
            }

            findAncestor(t, e = {includeSelf: false}) {
                let n = e.includeSelf ? this : this.parent;
                while (n) {
                    if (n.name === t) {
                        return n
                    }
                    n = n.parent
                }
                return null
            }

            toJSON() {
                const t = super.toJSON();
                t.name = this.name;
                if (this._children.length > 0) {
                    t.children = [];
                    for (const e of this._children) {
                        t.children.push(e.toJSON())
                    }
                }
                return t
            }

            _clone(t = false) {
                const e = t ? Array.from(this._children).map((t => t._clone(true))) : null;
                return new Kh(this.name, this.getAttributes(), e)
            }

            _appendChild(t) {
                this._insertChild(this.childCount, t)
            }

            _insertChild(t, e) {
                const n = Gh(e);
                for (const t of n) {
                    if (t.parent !== null) {
                        t._remove()
                    }
                    t.parent = this
                }
                this._children._insertNodes(t, n)
            }

            _removeChildren(t, e = 1) {
                const n = this._children._removeNodes(t, e);
                for (const t of n) {
                    t.parent = null
                }
                return n
            }

            static fromJSON(t) {
                let e = null;
                if (t.children) {
                    e = [];
                    for (const n of t.children) {
                        if (n.name) {
                            e.push(Kh.fromJSON(n))
                        } else {
                            e.push(Uh.fromJSON(n))
                        }
                    }
                }
                return new Kh(t.name, t.attributes, e)
            }
        }

        function Gh(t) {
            if (typeof t == "string") {
                return [new Uh(t)]
            }
            if (!_s(t)) {
                t = [t]
            }
            return Array.from(t).map((t => {
                if (typeof t == "string") {
                    return new Uh(t)
                }
                if (t instanceof Wh) {
                    return new Uh(t.data, t.getAttributes())
                }
                return t
            }))
        }

        class $h {
            constructor(t = {}) {
                if (!t.boundaries && !t.startPosition) {
                    throw new ss["a"]("model-tree-walker-no-start-position", null)
                }
                const e = t.direction || "forward";
                if (e != "forward" && e != "backward") {
                    throw new ss["a"]("model-tree-walker-unknown-direction", t, {direction: e})
                }
                this.direction = e;
                this.boundaries = t.boundaries || null;
                if (t.startPosition) {
                    this.position = t.startPosition.clone()
                } else {
                    this.position = Qh._createAt(this.boundaries[this.direction == "backward" ? "end" : "start"])
                }
                this.position.stickiness = "toNone";
                this.singleCharacters = !!t.singleCharacters;
                this.shallow = !!t.shallow;
                this.ignoreElementEnd = !!t.ignoreElementEnd;
                this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;
                this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;
                this._visitedParent = this.position.parent
            }

            [Symbol.iterator]() {
                return this
            }

            skip(t) {
                let e, n, i, o;
                do {
                    i = this.position;
                    o = this._visitedParent;
                    ({done: e, value: n} = this.next())
                } while (!e && t(n));
                if (!e) {
                    this.position = i;
                    this._visitedParent = o
                }
            }

            next() {
                if (this.direction == "forward") {
                    return this._next()
                } else {
                    return this._previous()
                }
            }

            _next() {
                const t = this.position;
                const e = this.position.clone();
                const n = this._visitedParent;
                if (n.parent === null && e.offset === n.maxOffset) {
                    return {done: true}
                }
                if (n === this._boundaryEndParent && e.offset == this.boundaries.end.offset) {
                    return {done: true}
                }
                const i = e.parent;
                const o = Jh(e, i);
                const r = o ? o : Xh(e, i, o);
                if (r instanceof Kh) {
                    if (!this.shallow) {
                        e.path.push(0);
                        this._visitedParent = r
                    } else {
                        e.offset++
                    }
                    this.position = e;
                    return Yh("elementStart", r, t, e, 1)
                } else if (r instanceof Uh) {
                    let i;
                    if (this.singleCharacters) {
                        i = 1
                    } else {
                        let t = r.endOffset;
                        if (this._boundaryEndParent == n && this.boundaries.end.offset < t) {
                            t = this.boundaries.end.offset
                        }
                        i = t - e.offset
                    }
                    const o = e.offset - r.startOffset;
                    const s = new Wh(r, o, i);
                    e.offset += i;
                    this.position = e;
                    return Yh("text", s, t, e, i)
                } else {
                    e.path.pop();
                    e.offset++;
                    this.position = e;
                    this._visitedParent = n.parent;
                    if (this.ignoreElementEnd) {
                        return this._next()
                    } else {
                        return Yh("elementEnd", n, t, e)
                    }
                }
            }

            _previous() {
                const t = this.position;
                const e = this.position.clone();
                const n = this._visitedParent;
                if (n.parent === null && e.offset === 0) {
                    return {done: true}
                }
                if (n == this._boundaryStartParent && e.offset == this.boundaries.start.offset) {
                    return {done: true}
                }
                const i = e.parent;
                const o = Jh(e, i);
                const r = o ? o : Zh(e, i, o);
                if (r instanceof Kh) {
                    e.offset--;
                    if (!this.shallow) {
                        e.path.push(r.maxOffset);
                        this.position = e;
                        this._visitedParent = r;
                        if (this.ignoreElementEnd) {
                            return this._previous()
                        } else {
                            return Yh("elementEnd", r, t, e)
                        }
                    } else {
                        this.position = e;
                        return Yh("elementStart", r, t, e, 1)
                    }
                } else if (r instanceof Uh) {
                    let i;
                    if (this.singleCharacters) {
                        i = 1
                    } else {
                        let t = r.startOffset;
                        if (this._boundaryStartParent == n && this.boundaries.start.offset > t) {
                            t = this.boundaries.start.offset
                        }
                        i = e.offset - t
                    }
                    const o = e.offset - r.startOffset;
                    const s = new Wh(r, o - i, i);
                    e.offset -= i;
                    this.position = e;
                    return Yh("text", s, t, e, i)
                } else {
                    e.path.pop();
                    this.position = e;
                    this._visitedParent = n.parent;
                    return Yh("elementStart", n, t, e, 1)
                }
            }
        }

        function Yh(t, e, n, i, o) {
            return {done: false, value: {type: t, item: e, previousPosition: n, nextPosition: i, length: o}}
        }

        class Qh {
            constructor(t, e, n = "toNone") {
                if (!t.is("element") && !t.is("documentFragment")) {
                    throw new ss["a"]("model-position-root-invalid", t)
                }
                if (!(e instanceof Array) || e.length === 0) {
                    throw new ss["a"]("model-position-path-incorrect-format", t, {path: e})
                }
                if (t.is("rootElement")) {
                    e = e.slice()
                } else {
                    e = [...t.getPath(), ...e];
                    t = t.root
                }
                this.root = t;
                this.path = e;
                this.stickiness = n
            }

            get offset() {
                return this.path[this.path.length - 1]
            }

            set offset(t) {
                this.path[this.path.length - 1] = t
            }

            get parent() {
                let t = this.root;
                for (let e = 0; e < this.path.length - 1; e++) {
                    t = t.getChild(t.offsetToIndex(this.path[e]));
                    if (!t) {
                        throw new ss["a"]("model-position-path-incorrect", this, {position: this})
                    }
                }
                if (t.is("$text")) {
                    throw new ss["a"]("model-position-path-incorrect", this, {position: this})
                }
                return t
            }

            get index() {
                return this.parent.offsetToIndex(this.offset)
            }

            get textNode() {
                return Jh(this, this.parent)
            }

            get nodeAfter() {
                const t = this.parent;
                return Xh(this, t, Jh(this, t))
            }

            get nodeBefore() {
                const t = this.parent;
                return Zh(this, t, Jh(this, t))
            }

            get isAtStart() {
                return this.offset === 0
            }

            get isAtEnd() {
                return this.offset == this.parent.maxOffset
            }

            compareWith(t) {
                if (this.root != t.root) {
                    return "different"
                }
                const e = Ns(this.path, t.path);
                switch (e) {
                    case"same":
                        return "same";
                    case"prefix":
                        return "before";
                    case"extension":
                        return "after";
                    default:
                        return this.path[e] < t.path[e] ? "before" : "after"
                }
            }

            getLastMatchingPosition(t, e = {}) {
                e.startPosition = this;
                const n = new $h(e);
                n.skip(t);
                return n.position
            }

            getParentPath() {
                return this.path.slice(0, -1)
            }

            getAncestors() {
                const t = this.parent;
                if (t.is("documentFragment")) {
                    return [t]
                } else {
                    return t.getAncestors({includeSelf: true})
                }
            }

            findAncestor(t) {
                const e = this.parent;
                if (e.is("element")) {
                    return e.findAncestor(t, {includeSelf: true})
                }
                return null
            }

            getCommonPath(t) {
                if (this.root != t.root) {
                    return []
                }
                const e = Ns(this.path, t.path);
                const n = typeof e == "string" ? Math.min(this.path.length, t.path.length) : e;
                return this.path.slice(0, n)
            }

            getCommonAncestor(t) {
                const e = this.getAncestors();
                const n = t.getAncestors();
                let i = 0;
                while (e[i] == n[i] && e[i]) {
                    i++
                }
                return i === 0 ? null : e[i - 1]
            }

            getShiftedBy(t) {
                const e = this.clone();
                const n = e.offset + t;
                e.offset = n < 0 ? 0 : n;
                return e
            }

            isAfter(t) {
                return this.compareWith(t) == "after"
            }

            isBefore(t) {
                return this.compareWith(t) == "before"
            }

            isEqual(t) {
                return this.compareWith(t) == "same"
            }

            isTouching(t) {
                let e = null;
                let n = null;
                const i = this.compareWith(t);
                switch (i) {
                    case"same":
                        return true;
                    case"before":
                        e = Qh._createAt(this);
                        n = Qh._createAt(t);
                        break;
                    case"after":
                        e = Qh._createAt(t);
                        n = Qh._createAt(this);
                        break;
                    default:
                        return false
                }
                let o = e.parent;
                while (e.path.length + n.path.length) {
                    if (e.isEqual(n)) {
                        return true
                    }
                    if (e.path.length > n.path.length) {
                        if (e.offset !== o.maxOffset) {
                            return false
                        }
                        e.path = e.path.slice(0, -1);
                        o = o.parent;
                        e.offset++
                    } else {
                        if (n.offset !== 0) {
                            return false
                        }
                        n.path = n.path.slice(0, -1)
                    }
                }
            }

            is(t) {
                return t === "position" || t === "model:position"
            }

            hasSameParentAs(t) {
                if (this.root !== t.root) {
                    return false
                }
                const e = this.getParentPath();
                const n = t.getParentPath();
                return Ns(e, n) == "same"
            }

            getTransformedByOperation(t) {
                let e;
                switch (t.type) {
                    case"insert":
                        e = this._getTransformedByInsertOperation(t);
                        break;
                    case"move":
                    case"remove":
                    case"reinsert":
                        e = this._getTransformedByMoveOperation(t);
                        break;
                    case"split":
                        e = this._getTransformedBySplitOperation(t);
                        break;
                    case"merge":
                        e = this._getTransformedByMergeOperation(t);
                        break;
                    default:
                        e = Qh._createAt(this);
                        break
                }
                return e
            }

            _getTransformedByInsertOperation(t) {
                return this._getTransformedByInsertion(t.position, t.howMany)
            }

            _getTransformedByMoveOperation(t) {
                return this._getTransformedByMove(t.sourcePosition, t.targetPosition, t.howMany)
            }

            _getTransformedBySplitOperation(t) {
                const e = t.movedRange;
                const n = e.containsPosition(this) || e.start.isEqual(this) && this.stickiness == "toNext";
                if (n) {
                    return this._getCombined(t.splitPosition, t.moveTargetPosition)
                } else {
                    if (t.graveyardPosition) {
                        return this._getTransformedByMove(t.graveyardPosition, t.insertionPosition, 1)
                    } else {
                        return this._getTransformedByInsertion(t.insertionPosition, 1)
                    }
                }
            }

            _getTransformedByMergeOperation(t) {
                const e = t.movedRange;
                const n = e.containsPosition(this) || e.start.isEqual(this);
                let i;
                if (n) {
                    i = this._getCombined(t.sourcePosition, t.targetPosition);
                    if (t.sourcePosition.isBefore(t.targetPosition)) {
                        i = i._getTransformedByDeletion(t.deletionPosition, 1)
                    }
                } else if (this.isEqual(t.deletionPosition)) {
                    i = Qh._createAt(t.deletionPosition)
                } else {
                    i = this._getTransformedByMove(t.deletionPosition, t.graveyardPosition, 1)
                }
                return i
            }

            _getTransformedByDeletion(t, e) {
                const n = Qh._createAt(this);
                if (this.root != t.root) {
                    return n
                }
                if (Ns(t.getParentPath(), this.getParentPath()) == "same") {
                    if (t.offset < this.offset) {
                        if (t.offset + e > this.offset) {
                            return null
                        } else {
                            n.offset -= e
                        }
                    }
                } else if (Ns(t.getParentPath(), this.getParentPath()) == "prefix") {
                    const i = t.path.length - 1;
                    if (t.offset <= this.path[i]) {
                        if (t.offset + e > this.path[i]) {
                            return null
                        } else {
                            n.path[i] -= e
                        }
                    }
                }
                return n
            }

            _getTransformedByInsertion(t, e) {
                const n = Qh._createAt(this);
                if (this.root != t.root) {
                    return n
                }
                if (Ns(t.getParentPath(), this.getParentPath()) == "same") {
                    if (t.offset < this.offset || t.offset == this.offset && this.stickiness != "toPrevious") {
                        n.offset += e
                    }
                } else if (Ns(t.getParentPath(), this.getParentPath()) == "prefix") {
                    const i = t.path.length - 1;
                    if (t.offset <= this.path[i]) {
                        n.path[i] += e
                    }
                }
                return n
            }

            _getTransformedByMove(t, e, n) {
                e = e._getTransformedByDeletion(t, n);
                if (t.isEqual(e)) {
                    return Qh._createAt(this)
                }
                const i = this._getTransformedByDeletion(t, n);
                const o = i === null || t.isEqual(this) && this.stickiness == "toNext" || t.getShiftedBy(n).isEqual(this) && this.stickiness == "toPrevious";
                if (o) {
                    return this._getCombined(t, e)
                } else {
                    return i._getTransformedByInsertion(e, n)
                }
            }

            _getCombined(t, e) {
                const n = t.path.length - 1;
                const i = Qh._createAt(e);
                i.stickiness = this.stickiness;
                i.offset = i.offset + this.path[n] - t.offset;
                i.path = [...i.path, ...this.path.slice(n + 1)];
                return i
            }

            toJSON() {
                return {root: this.root.toJSON(), path: Array.from(this.path), stickiness: this.stickiness}
            }

            clone() {
                return new this.constructor(this.root, this.path, this.stickiness)
            }

            static _createAt(t, e, n = "toNone") {
                if (t instanceof Qh) {
                    return new Qh(t.root, t.path, t.stickiness)
                } else {
                    const i = t;
                    if (e == "end") {
                        e = i.maxOffset
                    } else if (e == "before") {
                        return this._createBefore(i, n)
                    } else if (e == "after") {
                        return this._createAfter(i, n)
                    } else if (e !== 0 && !e) {
                        throw new ss["a"]("model-createpositionat-offset-required", [this, t])
                    }
                    if (!i.is("element") && !i.is("documentFragment")) {
                        throw new ss["a"]("model-position-parent-incorrect", [this, t])
                    }
                    const o = i.getPath();
                    o.push(e);
                    return new this(i.root, o, n)
                }
            }

            static _createAfter(t, e) {
                if (!t.parent) {
                    throw new ss["a"]("model-position-after-root", [this, t], {root: t})
                }
                return this._createAt(t.parent, t.endOffset, e)
            }

            static _createBefore(t, e) {
                if (!t.parent) {
                    throw new ss["a"]("model-position-before-root", t, {root: t})
                }
                return this._createAt(t.parent, t.startOffset, e)
            }

            static fromJSON(t, e) {
                if (t.root === "$graveyard") {
                    const n = new Qh(e.graveyard, t.path);
                    n.stickiness = t.stickiness;
                    return n
                }
                if (!e.getRoot(t.root)) {
                    throw new ss["a"]("model-position-fromjson-no-root", e, {rootName: t.root})
                }
                return new Qh(e.getRoot(t.root), t.path, t.stickiness)
            }
        }

        function Jh(t, e) {
            const n = e.getChild(e.offsetToIndex(t.offset));
            if (n && n.is("$text") && n.startOffset < t.offset) {
                return n
            }
            return null
        }

        function Xh(t, e, n) {
            if (n !== null) {
                return null
            }
            return e.getChild(e.offsetToIndex(t.offset))
        }

        function Zh(t, e, n) {
            if (n !== null) {
                return null
            }
            return e.getChild(e.offsetToIndex(t.offset) - 1)
        }

        class tm {
            constructor(t, e = null) {
                this.start = Qh._createAt(t);
                this.end = e ? Qh._createAt(e) : Qh._createAt(t);
                this.start.stickiness = this.isCollapsed ? "toNone" : "toNext";
                this.end.stickiness = this.isCollapsed ? "toNone" : "toPrevious"
            }

            * [Symbol.iterator]() {
                yield* new $h({boundaries: this, ignoreElementEnd: true})
            }

            get isCollapsed() {
                return this.start.isEqual(this.end)
            }

            get isFlat() {
                const t = this.start.getParentPath();
                const e = this.end.getParentPath();
                return Ns(t, e) == "same"
            }

            get root() {
                return this.start.root
            }

            containsPosition(t) {
                return t.isAfter(this.start) && t.isBefore(this.end)
            }

            containsRange(t, e = false) {
                if (t.isCollapsed) {
                    e = false
                }
                const n = this.containsPosition(t.start) || e && this.start.isEqual(t.start);
                const i = this.containsPosition(t.end) || e && this.end.isEqual(t.end);
                return n && i
            }

            containsItem(t) {
                const e = Qh._createBefore(t);
                return this.containsPosition(e) || this.start.isEqual(e)
            }

            is(t) {
                return t === "range" || t === "model:range"
            }

            isEqual(t) {
                return this.start.isEqual(t.start) && this.end.isEqual(t.end)
            }

            isIntersecting(t) {
                return this.start.isBefore(t.end) && this.end.isAfter(t.start)
            }

            getDifference(t) {
                const e = [];
                if (this.isIntersecting(t)) {
                    if (this.containsPosition(t.start)) {
                        e.push(new tm(this.start, t.start))
                    }
                    if (this.containsPosition(t.end)) {
                        e.push(new tm(t.end, this.end))
                    }
                } else {
                    e.push(new tm(this.start, this.end))
                }
                return e
            }

            getIntersection(t) {
                if (this.isIntersecting(t)) {
                    let e = this.start;
                    let n = this.end;
                    if (this.containsPosition(t.start)) {
                        e = t.start
                    }
                    if (this.containsPosition(t.end)) {
                        n = t.end
                    }
                    return new tm(e, n)
                }
                return null
            }

            getJoined(t, e = false) {
                let n = this.isIntersecting(t);
                if (!n) {
                    if (this.start.isBefore(t.start)) {
                        n = e ? this.end.isTouching(t.start) : this.end.isEqual(t.start)
                    } else {
                        n = e ? t.end.isTouching(this.start) : t.end.isEqual(this.start)
                    }
                }
                if (!n) {
                    return null
                }
                let i = this.start;
                let o = this.end;
                if (t.start.isBefore(i)) {
                    i = t.start
                }
                if (t.end.isAfter(o)) {
                    o = t.end
                }
                return new tm(i, o)
            }

            getMinimalFlatRanges() {
                const t = [];
                const e = this.start.getCommonPath(this.end).length;
                const n = Qh._createAt(this.start);
                let i = n.parent;
                while (n.path.length > e + 1) {
                    const e = i.maxOffset - n.offset;
                    if (e !== 0) {
                        t.push(new tm(n, n.getShiftedBy(e)))
                    }
                    n.path = n.path.slice(0, -1);
                    n.offset++;
                    i = i.parent
                }
                while (n.path.length <= this.end.path.length) {
                    const e = this.end.path[n.path.length - 1];
                    const i = e - n.offset;
                    if (i !== 0) {
                        t.push(new tm(n, n.getShiftedBy(i)))
                    }
                    n.offset = e;
                    n.path.push(0)
                }
                return t
            }

            getWalker(t = {}) {
                t.boundaries = this;
                return new $h(t)
            }

            * getItems(t = {}) {
                t.boundaries = this;
                t.ignoreElementEnd = true;
                const e = new $h(t);
                for (const t of e) {
                    yield t.item
                }
            }

            * getPositions(t = {}) {
                t.boundaries = this;
                const e = new $h(t);
                yield e.position;
                for (const t of e) {
                    yield t.nextPosition
                }
            }

            getTransformedByOperation(t) {
                switch (t.type) {
                    case"insert":
                        return this._getTransformedByInsertOperation(t);
                    case"move":
                    case"remove":
                    case"reinsert":
                        return this._getTransformedByMoveOperation(t);
                    case"split":
                        return [this._getTransformedBySplitOperation(t)];
                    case"merge":
                        return [this._getTransformedByMergeOperation(t)]
                }
                return [new tm(this.start, this.end)]
            }

            getTransformedByOperations(t) {
                const e = [new tm(this.start, this.end)];
                for (const n of t) {
                    for (let t = 0; t < e.length; t++) {
                        const i = e[t].getTransformedByOperation(n);
                        e.splice(t, 1, ...i);
                        t += i.length - 1
                    }
                }
                for (let t = 0; t < e.length; t++) {
                    const n = e[t];
                    for (let i = t + 1; i < e.length; i++) {
                        const t = e[i];
                        if (n.containsRange(t) || t.containsRange(n) || n.isEqual(t)) {
                            e.splice(i, 1)
                        }
                    }
                }
                return e
            }

            getCommonAncestor() {
                return this.start.getCommonAncestor(this.end)
            }

            getContainedElement() {
                if (this.isCollapsed) {
                    return null
                }
                const t = this.start.nodeAfter;
                const e = this.end.nodeBefore;
                if (t && t.is("element") && t === e) {
                    return t
                }
                return null
            }

            toJSON() {
                return {start: this.start.toJSON(), end: this.end.toJSON()}
            }

            clone() {
                return new this.constructor(this.start, this.end)
            }

            _getTransformedByInsertOperation(t, e = false) {
                return this._getTransformedByInsertion(t.position, t.howMany, e)
            }

            _getTransformedByMoveOperation(t, e = false) {
                const n = t.sourcePosition;
                const i = t.howMany;
                const o = t.targetPosition;
                return this._getTransformedByMove(n, o, i, e)
            }

            _getTransformedBySplitOperation(t) {
                const e = this.start._getTransformedBySplitOperation(t);
                let n = this.end._getTransformedBySplitOperation(t);
                if (this.end.isEqual(t.insertionPosition)) {
                    n = this.end.getShiftedBy(1)
                }
                if (e.root != n.root) {
                    n = this.end.getShiftedBy(-1)
                }
                return new tm(e, n)
            }

            _getTransformedByMergeOperation(t) {
                if (this.start.isEqual(t.targetPosition) && this.end.isEqual(t.deletionPosition)) {
                    return new tm(this.start)
                }
                let e = this.start._getTransformedByMergeOperation(t);
                let n = this.end._getTransformedByMergeOperation(t);
                if (e.root != n.root) {
                    n = this.end.getShiftedBy(-1)
                }
                if (e.isAfter(n)) {
                    if (t.sourcePosition.isBefore(t.targetPosition)) {
                        e = Qh._createAt(n);
                        e.offset = 0
                    } else {
                        if (!t.deletionPosition.isEqual(e)) {
                            n = t.deletionPosition
                        }
                        e = t.targetPosition
                    }
                    return new tm(e, n)
                }
                return new tm(e, n)
            }

            _getTransformedByInsertion(t, e, n = false) {
                if (n && this.containsPosition(t)) {
                    return [new tm(this.start, t), new tm(t.getShiftedBy(e), this.end._getTransformedByInsertion(t, e))]
                } else {
                    const n = new tm(this.start, this.end);
                    n.start = n.start._getTransformedByInsertion(t, e);
                    n.end = n.end._getTransformedByInsertion(t, e);
                    return [n]
                }
            }

            _getTransformedByMove(t, e, n, i = false) {
                if (this.isCollapsed) {
                    const i = this.start._getTransformedByMove(t, e, n);
                    return [new tm(i)]
                }
                const o = tm._createFromPositionAndShift(t, n);
                const r = e._getTransformedByDeletion(t, n);
                if (this.containsPosition(e) && !i) {
                    if (o.containsPosition(this.start) || o.containsPosition(this.end)) {
                        const i = this.start._getTransformedByMove(t, e, n);
                        const o = this.end._getTransformedByMove(t, e, n);
                        return [new tm(i, o)]
                    }
                }
                let s;
                const a = this.getDifference(o);
                let c = null;
                const l = this.getIntersection(o);
                if (a.length == 1) {
                    c = new tm(a[0].start._getTransformedByDeletion(t, n), a[0].end._getTransformedByDeletion(t, n))
                } else if (a.length == 2) {
                    c = new tm(this.start, this.end._getTransformedByDeletion(t, n))
                }
                if (c) {
                    s = c._getTransformedByInsertion(r, n, l !== null || i)
                } else {
                    s = []
                }
                if (l) {
                    const t = new tm(l.start._getCombined(o.start, r), l.end._getCombined(o.start, r));
                    if (s.length == 2) {
                        s.splice(1, 0, t)
                    } else {
                        s.push(t)
                    }
                }
                return s
            }

            _getTransformedByDeletion(t, e) {
                let n = this.start._getTransformedByDeletion(t, e);
                let i = this.end._getTransformedByDeletion(t, e);
                if (n == null && i == null) {
                    return null
                }
                if (n == null) {
                    n = t
                }
                if (i == null) {
                    i = t
                }
                return new tm(n, i)
            }

            static _createFromPositionAndShift(t, e) {
                const n = t;
                const i = t.getShiftedBy(e);
                return e > 0 ? new this(n, i) : new this(i, n)
            }

            static _createIn(t) {
                return new this(Qh._createAt(t, 0), Qh._createAt(t, t.maxOffset))
            }

            static _createOn(t) {
                return this._createFromPositionAndShift(Qh._createBefore(t), t.offsetSize)
            }

            static _createFromRanges(t) {
                if (t.length === 0) {
                    throw new ss["a"]("range-create-from-ranges-empty-array", null)
                } else if (t.length == 1) {
                    return t[0].clone()
                }
                const e = t[0];
                t.sort(((t, e) => t.start.isAfter(e.start) ? 1 : -1));
                const n = t.indexOf(e);
                const i = new this(e.start, e.end);
                if (n > 0) {
                    for (let e = n - 1; true; e++) {
                        if (t[e].end.isEqual(i.start)) {
                            i.start = Qh._createAt(t[e].start)
                        } else {
                            break
                        }
                    }
                }
                for (let e = n + 1; e < t.length; e++) {
                    if (t[e].start.isEqual(i.end)) {
                        i.end = Qh._createAt(t[e].end)
                    } else {
                        break
                    }
                }
                return i
            }

            static fromJSON(t, e) {
                return new this(Qh.fromJSON(t.start, e), Qh.fromJSON(t.end, e))
            }
        }

        class em {
            constructor() {
                this._modelToViewMapping = new WeakMap;
                this._viewToModelMapping = new WeakMap;
                this._viewToModelLengthCallbacks = new Map;
                this._markerNameToElements = new Map;
                this._elementToMarkerNames = new Map;
                this._unboundMarkerNames = new Set;
                this.on("modelToViewPosition", ((t, e) => {
                    if (e.viewPosition) {
                        return
                    }
                    const n = this._modelToViewMapping.get(e.modelPosition.parent);
                    e.viewPosition = this.findPositionIn(n, e.modelPosition.offset)
                }), {priority: "low"});
                this.on("viewToModelPosition", ((t, e) => {
                    if (e.modelPosition) {
                        return
                    }
                    const n = this.findMappedViewAncestor(e.viewPosition);
                    const i = this._viewToModelMapping.get(n);
                    const o = this._toModelOffset(e.viewPosition.parent, e.viewPosition.offset, n);
                    e.modelPosition = Qh._createAt(i, o)
                }), {priority: "low"})
            }

            bindElements(t, e) {
                this._modelToViewMapping.set(t, e);
                this._viewToModelMapping.set(e, t)
            }

            unbindViewElement(t) {
                const e = this.toModelElement(t);
                this._viewToModelMapping.delete(t);
                if (this._elementToMarkerNames.has(t)) {
                    for (const e of this._elementToMarkerNames.get(t)) {
                        this._unboundMarkerNames.add(e)
                    }
                }
                if (this._modelToViewMapping.get(e) == t) {
                    this._modelToViewMapping.delete(e)
                }
            }

            unbindModelElement(t) {
                const e = this.toViewElement(t);
                this._modelToViewMapping.delete(t);
                if (this._viewToModelMapping.get(e) == t) {
                    this._viewToModelMapping.delete(e)
                }
            }

            bindElementToMarker(t, e) {
                const n = this._markerNameToElements.get(e) || new Set;
                n.add(t);
                const i = this._elementToMarkerNames.get(t) || new Set;
                i.add(e);
                this._markerNameToElements.set(e, n);
                this._elementToMarkerNames.set(t, i)
            }

            unbindElementFromMarkerName(t, e) {
                const n = this._markerNameToElements.get(e);
                if (n) {
                    n.delete(t);
                    if (n.size == 0) {
                        this._markerNameToElements.delete(e)
                    }
                }
                const i = this._elementToMarkerNames.get(t);
                if (i) {
                    i.delete(e);
                    if (i.size == 0) {
                        this._elementToMarkerNames.delete(t)
                    }
                }
            }

            flushUnboundMarkerNames() {
                const t = Array.from(this._unboundMarkerNames);
                this._unboundMarkerNames.clear();
                return t
            }

            clearBindings() {
                this._modelToViewMapping = new WeakMap;
                this._viewToModelMapping = new WeakMap;
                this._markerNameToElements = new Map;
                this._elementToMarkerNames = new Map;
                this._unboundMarkerNames = new Set
            }

            toModelElement(t) {
                return this._viewToModelMapping.get(t)
            }

            toViewElement(t) {
                return this._modelToViewMapping.get(t)
            }

            toModelRange(t) {
                return new tm(this.toModelPosition(t.start), this.toModelPosition(t.end))
            }

            toViewRange(t) {
                return new hl(this.toViewPosition(t.start), this.toViewPosition(t.end))
            }

            toModelPosition(t) {
                const e = {viewPosition: t, mapper: this};
                this.fire("viewToModelPosition", e);
                return e.modelPosition
            }

            toViewPosition(t, e = {isPhantom: false}) {
                const n = {modelPosition: t, mapper: this, isPhantom: e.isPhantom};
                this.fire("modelToViewPosition", n);
                return n.viewPosition
            }

            markerNameToElements(t) {
                const e = this._markerNameToElements.get(t);
                if (!e) {
                    return null
                }
                const n = new Set;
                for (const t of e) {
                    if (t.is("attributeElement")) {
                        for (const e of t.getElementsWithSameId()) {
                            n.add(e)
                        }
                    } else {
                        n.add(t)
                    }
                }
                return n
            }

            registerViewToModelLength(t, e) {
                this._viewToModelLengthCallbacks.set(t, e)
            }

            findMappedViewAncestor(t) {
                let e = t.parent;
                while (!this._viewToModelMapping.has(e)) {
                    e = e.parent
                }
                return e
            }

            _toModelOffset(t, e, n) {
                if (n != t) {
                    const i = this._toModelOffset(t.parent, t.index, n);
                    const o = this._toModelOffset(t, e, t);
                    return i + o
                }
                if (t.is("$text")) {
                    return e
                }
                let i = 0;
                for (let n = 0; n < e; n++) {
                    i += this.getModelLength(t.getChild(n))
                }
                return i
            }

            getModelLength(t) {
                if (this._viewToModelLengthCallbacks.get(t.name)) {
                    const e = this._viewToModelLengthCallbacks.get(t.name);
                    return e(t)
                } else if (this._viewToModelMapping.has(t)) {
                    return 1
                } else if (t.is("$text")) {
                    return t.data.length
                } else if (t.is("uiElement")) {
                    return 0
                } else {
                    let e = 0;
                    for (const n of t.getChildren()) {
                        e += this.getModelLength(n)
                    }
                    return e
                }
            }

            findPositionIn(t, e) {
                let n;
                let i = 0;
                let o = 0;
                let r = 0;
                if (t.is("$text")) {
                    return new ul(t, e)
                }
                while (o < e) {
                    n = t.getChild(r);
                    i = this.getModelLength(n);
                    o += i;
                    r++
                }
                if (o == e) {
                    return this._moveViewPositionToTextNode(new ul(t, r))
                } else {
                    return this.findPositionIn(n, e - (o - i))
                }
            }

            _moveViewPositionToTextNode(t) {
                const e = t.nodeBefore;
                const n = t.nodeAfter;
                if (e instanceof Fs) {
                    return new ul(e, e.data.length)
                } else if (n instanceof Fs) {
                    return new ul(n, 0)
                }
                return t
            }
        }

        Cs(em, ds);

        class nm {
            constructor() {
                this._consumable = new Map;
                this._textProxyRegistry = new Map
            }

            add(t, e) {
                e = im(e);
                if (t instanceof Wh) {
                    t = this._getSymbolForTextProxy(t)
                }
                if (!this._consumable.has(t)) {
                    this._consumable.set(t, new Map)
                }
                this._consumable.get(t).set(e, true)
            }

            consume(t, e) {
                e = im(e);
                if (t instanceof Wh) {
                    t = this._getSymbolForTextProxy(t)
                }
                if (this.test(t, e)) {
                    this._consumable.get(t).set(e, false);
                    return true
                } else {
                    return false
                }
            }

            test(t, e) {
                e = im(e);
                if (t instanceof Wh) {
                    t = this._getSymbolForTextProxy(t)
                }
                const n = this._consumable.get(t);
                if (n === undefined) {
                    return null
                }
                const i = n.get(e);
                if (i === undefined) {
                    return null
                }
                return i
            }

            revert(t, e) {
                e = im(e);
                if (t instanceof Wh) {
                    t = this._getSymbolForTextProxy(t)
                }
                const n = this.test(t, e);
                if (n === false) {
                    this._consumable.get(t).set(e, true);
                    return true
                } else if (n === true) {
                    return false
                }
                return null
            }

            _getSymbolForTextProxy(t) {
                let e = null;
                const n = this._textProxyRegistry.get(t.startOffset);
                if (n) {
                    const i = n.get(t.endOffset);
                    if (i) {
                        e = i.get(t.parent)
                    }
                }
                if (!e) {
                    e = this._addSymbolForTextProxy(t.startOffset, t.endOffset, t.parent)
                }
                return e
            }

            _addSymbolForTextProxy(t, e, n) {
                const i = Symbol("textProxySymbol");
                let o, r;
                o = this._textProxyRegistry.get(t);
                if (!o) {
                    o = new Map;
                    this._textProxyRegistry.set(t, o)
                }
                r = o.get(e);
                if (!r) {
                    r = new Map;
                    o.set(e, r)
                }
                r.set(n, i);
                return i
            }
        }

        function im(t) {
            const e = t.split(":");
            return e.length > 1 ? e[0] + ":" + e[1] : e[0]
        }

        class om {
            constructor(t) {
                this.conversionApi = Object.assign({dispatcher: this}, t);
                this._reconversionEventsMapping = new Map
            }

            convertChanges(t, e, n) {
                for (const e of t.getMarkersToRemove()) {
                    this.convertMarkerRemove(e.name, e.range, n)
                }
                const i = this._mapChangesWithAutomaticReconversion(t);
                for (const t of i) {
                    if (t.type === "insert") {
                        this.convertInsert(tm._createFromPositionAndShift(t.position, t.length), n)
                    } else if (t.type === "remove") {
                        this.convertRemove(t.position, t.length, t.name, n)
                    } else if (t.type === "reconvert") {
                        this.reconvertElement(t.element, n)
                    } else {
                        this.convertAttribute(t.range, t.attributeKey, t.attributeOldValue, t.attributeNewValue, n)
                    }
                }
                for (const t of this.conversionApi.mapper.flushUnboundMarkerNames()) {
                    const i = e.get(t).getRange();
                    this.convertMarkerRemove(t, i, n);
                    this.convertMarkerAdd(t, i, n)
                }
                for (const e of t.getMarkersToAdd()) {
                    this.convertMarkerAdd(e.name, e.range, n)
                }
            }

            convertInsert(t, e) {
                this.conversionApi.writer = e;
                this.conversionApi.consumable = this._createInsertConsumable(t);
                for (const e of Array.from(t).map(am)) {
                    this._convertInsertWithAttributes(e)
                }
                this._clearConversionApi()
            }

            convertRemove(t, e, n, i) {
                this.conversionApi.writer = i;
                this.fire("remove:" + n, {position: t, length: e}, this.conversionApi);
                this._clearConversionApi()
            }

            convertAttribute(t, e, n, i, o) {
                this.conversionApi.writer = o;
                this.conversionApi.consumable = this._createConsumableForRange(t, `attribute:${e}`);
                for (const o of t) {
                    const t = o.item;
                    const r = tm._createFromPositionAndShift(o.previousPosition, o.length);
                    const s = {item: t, range: r, attributeKey: e, attributeOldValue: n, attributeNewValue: i};
                    this._testAndFire(`attribute:${e}`, s)
                }
                this._clearConversionApi()
            }

            reconvertElement(t, e) {
                const n = tm._createOn(t);
                this.conversionApi.writer = e;
                this.conversionApi.consumable = this._createInsertConsumable(n);
                const i = this.conversionApi.mapper;
                const o = i.toViewElement(t);
                e.remove(o);
                this._convertInsertWithAttributes({item: t, range: n});
                const r = i.toViewElement(t);
                for (const n of tm._createIn(t)) {
                    const {item: t} = n;
                    const o = cm(t, i);
                    if (o) {
                        if (o.root !== r.root) {
                            e.move(e.createRangeOn(o), i.toViewPosition(Qh._createBefore(t)))
                        }
                    } else {
                        this._convertInsertWithAttributes(am(n))
                    }
                }
                i.unbindViewElement(o);
                this._clearConversionApi()
            }

            convertSelection(t, e, n) {
                const i = Array.from(e.getMarkersAtPosition(t.getFirstPosition()));
                this.conversionApi.writer = n;
                this.conversionApi.consumable = this._createSelectionConsumable(t, i);
                this.fire("selection", {selection: t}, this.conversionApi);
                if (!t.isCollapsed) {
                    return
                }
                for (const e of i) {
                    const n = e.getRange();
                    if (!rm(t.getFirstPosition(), e, this.conversionApi.mapper)) {
                        continue
                    }
                    const i = {item: t, markerName: e.name, markerRange: n};
                    if (this.conversionApi.consumable.test(t, "addMarker:" + e.name)) {
                        this.fire("addMarker:" + e.name, i, this.conversionApi)
                    }
                }
                for (const e of t.getAttributeKeys()) {
                    const n = {
                        item: t,
                        range: t.getFirstRange(),
                        attributeKey: e,
                        attributeOldValue: null,
                        attributeNewValue: t.getAttribute(e)
                    };
                    if (this.conversionApi.consumable.test(t, "attribute:" + n.attributeKey)) {
                        this.fire("attribute:" + n.attributeKey + ":$text", n, this.conversionApi)
                    }
                }
                this._clearConversionApi()
            }

            convertMarkerAdd(t, e, n) {
                if (!e.root.document || e.root.rootName == "$graveyard") {
                    return
                }
                this.conversionApi.writer = n;
                const i = "addMarker:" + t;
                const o = new nm;
                o.add(e, i);
                this.conversionApi.consumable = o;
                this.fire(i, {markerName: t, markerRange: e}, this.conversionApi);
                if (!o.test(e, i)) {
                    return
                }
                this.conversionApi.consumable = this._createConsumableForRange(e, i);
                for (const n of e.getItems()) {
                    if (!this.conversionApi.consumable.test(n, i)) {
                        continue
                    }
                    const o = {item: n, range: tm._createOn(n), markerName: t, markerRange: e};
                    this.fire(i, o, this.conversionApi)
                }
                this._clearConversionApi()
            }

            convertMarkerRemove(t, e, n) {
                if (!e.root.document || e.root.rootName == "$graveyard") {
                    return
                }
                this.conversionApi.writer = n;
                this.fire("removeMarker:" + t, {markerName: t, markerRange: e}, this.conversionApi);
                this._clearConversionApi()
            }

            _mapReconversionTriggerEvent(t, e) {
                this._reconversionEventsMapping.set(e, t)
            }

            _createInsertConsumable(t) {
                const e = new nm;
                for (const n of t) {
                    const t = n.item;
                    e.add(t, "insert");
                    for (const n of t.getAttributeKeys()) {
                        e.add(t, "attribute:" + n)
                    }
                }
                return e
            }

            _createConsumableForRange(t, e) {
                const n = new nm;
                for (const i of t.getItems()) {
                    n.add(i, e)
                }
                return n
            }

            _createSelectionConsumable(t, e) {
                const n = new nm;
                n.add(t, "selection");
                for (const i of e) {
                    n.add(t, "addMarker:" + i.name)
                }
                for (const e of t.getAttributeKeys()) {
                    n.add(t, "attribute:" + e)
                }
                return n
            }

            _testAndFire(t, e) {
                if (!this.conversionApi.consumable.test(e.item, t)) {
                    return
                }
                this.fire(sm(t, e), e, this.conversionApi)
            }

            _clearConversionApi() {
                delete this.conversionApi.writer;
                delete this.conversionApi.consumable
            }

            _convertInsertWithAttributes(t) {
                this._testAndFire("insert", t);
                for (const e of t.item.getAttributeKeys()) {
                    t.attributeKey = e;
                    t.attributeOldValue = null;
                    t.attributeNewValue = t.item.getAttribute(e);
                    this._testAndFire(`attribute:${e}`, t)
                }
            }

            _mapChangesWithAutomaticReconversion(t) {
                const e = new Set;
                const n = [];
                for (const i of t.getChanges()) {
                    const t = i.position || i.range.start;
                    const o = t.parent;
                    const r = Jh(t, o);
                    if (r) {
                        n.push(i);
                        continue
                    }
                    const s = i.type === "attribute" ? Xh(t, o, null) : o;
                    if (s.is("$text")) {
                        n.push(i);
                        continue
                    }
                    let a;
                    if (i.type === "attribute") {
                        a = `attribute:${i.attributeKey}:${s.name}`
                    } else {
                        a = `${i.type}:${i.name}`
                    }
                    if (this._isReconvertTriggerEvent(a, s.name)) {
                        if (e.has(s)) {
                            continue
                        }
                        e.add(s);
                        n.push({type: "reconvert", element: s})
                    } else {
                        n.push(i)
                    }
                }
                return n
            }

            _isReconvertTriggerEvent(t, e) {
                return this._reconversionEventsMapping.get(t) === e
            }
        }

        Cs(om, ds);

        function rm(t, e, n) {
            const i = e.getRange();
            const o = Array.from(t.getAncestors());
            o.shift();
            o.reverse();
            const r = o.some((t => {
                if (i.containsItem(t)) {
                    const e = n.toViewElement(t);
                    return !!e.getCustomProperty("addHighlight")
                }
            }));
            return !r
        }

        function sm(t, e) {
            const n = e.item.name || "$text";
            return `${t}:${n}`
        }

        function am(t) {
            const e = t.item;
            const n = tm._createFromPositionAndShift(t.previousPosition, t.length);
            return {item: e, range: n}
        }

        function cm(t, e) {
            if (t.is("textProxy")) {
                const n = e.toViewPosition(Qh._createBefore(t));
                const i = n.parent;
                return i.is("$text") ? i : null
            }
            return e.toViewElement(t)
        }

        class lm {
            constructor(t, e, n) {
                this._lastRangeBackward = false;
                this._ranges = [];
                this._attrs = new Map;
                if (t) {
                    this.setTo(t, e, n)
                }
            }

            get anchor() {
                if (this._ranges.length > 0) {
                    const t = this._ranges[this._ranges.length - 1];
                    return this._lastRangeBackward ? t.end : t.start
                }
                return null
            }

            get focus() {
                if (this._ranges.length > 0) {
                    const t = this._ranges[this._ranges.length - 1];
                    return this._lastRangeBackward ? t.start : t.end
                }
                return null
            }

            get isCollapsed() {
                const t = this._ranges.length;
                if (t === 1) {
                    return this._ranges[0].isCollapsed
                } else {
                    return false
                }
            }

            get rangeCount() {
                return this._ranges.length
            }

            get isBackward() {
                return !this.isCollapsed && this._lastRangeBackward
            }

            isEqual(t) {
                if (this.rangeCount != t.rangeCount) {
                    return false
                } else if (this.rangeCount === 0) {
                    return true
                }
                if (!this.anchor.isEqual(t.anchor) || !this.focus.isEqual(t.focus)) {
                    return false
                }
                for (const e of this._ranges) {
                    let n = false;
                    for (const i of t._ranges) {
                        if (e.isEqual(i)) {
                            n = true;
                            break
                        }
                    }
                    if (!n) {
                        return false
                    }
                }
                return true
            }

            * getRanges() {
                for (const t of this._ranges) {
                    yield new tm(t.start, t.end)
                }
            }

            getFirstRange() {
                let t = null;
                for (const e of this._ranges) {
                    if (!t || e.start.isBefore(t.start)) {
                        t = e
                    }
                }
                return t ? new tm(t.start, t.end) : null
            }

            getLastRange() {
                let t = null;
                for (const e of this._ranges) {
                    if (!t || e.end.isAfter(t.end)) {
                        t = e
                    }
                }
                return t ? new tm(t.start, t.end) : null
            }

            getFirstPosition() {
                const t = this.getFirstRange();
                return t ? t.start.clone() : null
            }

            getLastPosition() {
                const t = this.getLastRange();
                return t ? t.end.clone() : null
            }

            setTo(t, e, n) {
                if (t === null) {
                    this._setRanges([])
                } else if (t instanceof lm) {
                    this._setRanges(t.getRanges(), t.isBackward)
                } else if (t && typeof t.getRanges == "function") {
                    this._setRanges(t.getRanges(), t.isBackward)
                } else if (t instanceof tm) {
                    this._setRanges([t], !!e && !!e.backward)
                } else if (t instanceof Qh) {
                    this._setRanges([new tm(t)])
                } else if (t instanceof Hh) {
                    const i = !!n && !!n.backward;
                    let o;
                    if (e == "in") {
                        o = tm._createIn(t)
                    } else if (e == "on") {
                        o = tm._createOn(t)
                    } else if (e !== undefined) {
                        o = new tm(Qh._createAt(t, e))
                    } else {
                        throw new ss["a"]("model-selection-setto-required-second-parameter", [this, t])
                    }
                    this._setRanges([o], i)
                } else if (_s(t)) {
                    this._setRanges(t, e && !!e.backward)
                } else {
                    throw new ss["a"]("model-selection-setto-not-selectable", [this, t])
                }
            }

            _setRanges(t, e = false) {
                t = Array.from(t);
                const n = t.some((e => {
                    if (!(e instanceof tm)) {
                        throw new ss["a"]("model-selection-set-ranges-not-range", [this, t])
                    }
                    return this._ranges.every((t => !t.isEqual(e)))
                }));
                if (t.length === this._ranges.length && !n) {
                    return
                }
                this._removeAllRanges();
                for (const e of t) {
                    this._pushRange(e)
                }
                this._lastRangeBackward = !!e;
                this.fire("change:range", {directChange: true})
            }

            setFocus(t, e) {
                if (this.anchor === null) {
                    throw new ss["a"]("model-selection-setfocus-no-ranges", [this, t])
                }
                const n = Qh._createAt(t, e);
                if (n.compareWith(this.focus) == "same") {
                    return
                }
                const i = this.anchor;
                if (this._ranges.length) {
                    this._popRange()
                }
                if (n.compareWith(i) == "before") {
                    this._pushRange(new tm(n, i));
                    this._lastRangeBackward = true
                } else {
                    this._pushRange(new tm(i, n));
                    this._lastRangeBackward = false
                }
                this.fire("change:range", {directChange: true})
            }

            getAttribute(t) {
                return this._attrs.get(t)
            }

            getAttributes() {
                return this._attrs.entries()
            }

            getAttributeKeys() {
                return this._attrs.keys()
            }

            hasAttribute(t) {
                return this._attrs.has(t)
            }

            removeAttribute(t) {
                if (this.hasAttribute(t)) {
                    this._attrs.delete(t);
                    this.fire("change:attribute", {attributeKeys: [t], directChange: true})
                }
            }

            setAttribute(t, e) {
                if (this.getAttribute(t) !== e) {
                    this._attrs.set(t, e);
                    this.fire("change:attribute", {attributeKeys: [t], directChange: true})
                }
            }

            getSelectedElement() {
                if (this.rangeCount !== 1) {
                    return null
                }
                return this.getFirstRange().getContainedElement()
            }

            is(t) {
                return t === "selection" || t === "model:selection"
            }

            * getSelectedBlocks() {
                const t = new WeakSet;
                for (const e of this.getRanges()) {
                    const n = hm(e.start, t);
                    if (n && mm(n, e)) {
                        yield n
                    }
                    for (const n of e.getWalker()) {
                        const i = n.item;
                        if (n.type == "elementEnd" && um(i, t, e)) {
                            yield i
                        }
                    }
                    const i = hm(e.end, t);
                    if (i && !e.end.isTouching(Qh._createAt(i, 0)) && mm(i, e)) {
                        yield i
                    }
                }
            }

            containsEntireContent(t = this.anchor.root) {
                const e = Qh._createAt(t, 0);
                const n = Qh._createAt(t, "end");
                return e.isTouching(this.getFirstPosition()) && n.isTouching(this.getLastPosition())
            }

            _pushRange(t) {
                this._checkRange(t);
                this._ranges.push(new tm(t.start, t.end))
            }

            _checkRange(t) {
                for (let e = 0; e < this._ranges.length; e++) {
                    if (t.isIntersecting(this._ranges[e])) {
                        throw new ss["a"]("model-selection-range-intersects", [this, t], {
                            addedRange: t,
                            intersectingRange: this._ranges[e]
                        })
                    }
                }
            }

            _removeAllRanges() {
                while (this._ranges.length > 0) {
                    this._popRange()
                }
            }

            _popRange() {
                this._ranges.pop()
            }
        }

        Cs(lm, ds);

        function dm(t, e) {
            if (e.has(t)) {
                return false
            }
            e.add(t);
            return t.root.document.model.schema.isBlock(t) && t.parent
        }

        function um(t, e, n) {
            return dm(t, e) && mm(t, n)
        }

        function hm(t, e) {
            const n = t.parent;
            const i = n.root.document.model.schema;
            const o = t.parent.getAncestors({parentFirst: true, includeSelf: true});
            let r = false;
            const s = o.find((t => {
                if (r) {
                    return false
                }
                r = i.isLimit(t);
                return !r && dm(t, e)
            }));
            o.forEach((t => e.add(t)));
            return s
        }

        function mm(t, e) {
            const n = gm(t);
            if (!n) {
                return true
            }
            const i = e.containsRange(tm._createOn(n), true);
            return !i
        }

        function gm(t) {
            const e = t.root.document.model.schema;
            let n = t.parent;
            while (n) {
                if (e.isBlock(n)) {
                    return n
                }
                n = n.parent
            }
        }

        class fm extends tm {
            constructor(t, e) {
                super(t, e);
                pm.call(this)
            }

            detach() {
                this.stopListening()
            }

            is(t) {
                return t === "liveRange" || t === "model:liveRange" || t == "range" || t === "model:range"
            }

            toRange() {
                return new tm(this.start, this.end)
            }

            static fromRange(t) {
                return new fm(t.start, t.end)
            }
        }

        function pm() {
            this.listenTo(this.root.document.model, "applyOperation", ((t, e) => {
                const n = e[0];
                if (!n.isDocumentOperation) {
                    return
                }
                bm.call(this, n)
            }), {priority: "low"})
        }

        function bm(t) {
            const e = this.getTransformedByOperation(t);
            const n = tm._createFromRanges(e);
            const i = !n.isEqual(this);
            const o = km(this, t);
            let r = null;
            if (i) {
                if (n.root.rootName == "$graveyard") {
                    if (t.type == "remove") {
                        r = t.sourcePosition
                    } else {
                        r = t.deletionPosition
                    }
                }
                const e = this.toRange();
                this.start = n.start;
                this.end = n.end;
                this.fire("change:range", e, {deletionPosition: r})
            } else if (o) {
                this.fire("change:content", this.toRange(), {deletionPosition: r})
            }
        }

        function km(t, e) {
            switch (e.type) {
                case"insert":
                    return t.containsPosition(e.position);
                case"move":
                case"remove":
                case"reinsert":
                case"merge":
                    return t.containsPosition(e.sourcePosition) || t.start.isEqual(e.sourcePosition) || t.containsPosition(e.targetPosition);
                case"split":
                    return t.containsPosition(e.splitPosition) || t.containsPosition(e.insertionPosition)
            }
            return false
        }

        Cs(fm, ds);
        const wm = "selection:";

        class Am {
            constructor(t) {
                this._selection = new _m(t);
                this._selection.delegate("change:range").to(this);
                this._selection.delegate("change:attribute").to(this);
                this._selection.delegate("change:marker").to(this)
            }

            get isCollapsed() {
                return this._selection.isCollapsed
            }

            get anchor() {
                return this._selection.anchor
            }

            get focus() {
                return this._selection.focus
            }

            get rangeCount() {
                return this._selection.rangeCount
            }

            get hasOwnRange() {
                return this._selection.hasOwnRange
            }

            get isBackward() {
                return this._selection.isBackward
            }

            get isGravityOverridden() {
                return this._selection.isGravityOverridden
            }

            get markers() {
                return this._selection.markers
            }

            get _ranges() {
                return this._selection._ranges
            }

            getRanges() {
                return this._selection.getRanges()
            }

            getFirstPosition() {
                return this._selection.getFirstPosition()
            }

            getLastPosition() {
                return this._selection.getLastPosition()
            }

            getFirstRange() {
                return this._selection.getFirstRange()
            }

            getLastRange() {
                return this._selection.getLastRange()
            }

            getSelectedBlocks() {
                return this._selection.getSelectedBlocks()
            }

            getSelectedElement() {
                return this._selection.getSelectedElement()
            }

            containsEntireContent(t) {
                return this._selection.containsEntireContent(t)
            }

            destroy() {
                this._selection.destroy()
            }

            getAttributeKeys() {
                return this._selection.getAttributeKeys()
            }

            getAttributes() {
                return this._selection.getAttributes()
            }

            getAttribute(t) {
                return this._selection.getAttribute(t)
            }

            hasAttribute(t) {
                return this._selection.hasAttribute(t)
            }

            refresh() {
                this._selection._updateMarkers();
                this._selection._updateAttributes(false)
            }

            is(t) {
                return t === "selection" || t == "model:selection" || t == "documentSelection" || t == "model:documentSelection"
            }

            _setFocus(t, e) {
                this._selection.setFocus(t, e)
            }

            _setTo(t, e, n) {
                this._selection.setTo(t, e, n)
            }

            _setAttribute(t, e) {
                this._selection.setAttribute(t, e)
            }

            _removeAttribute(t) {
                this._selection.removeAttribute(t)
            }

            _getStoredAttributes() {
                return this._selection._getStoredAttributes()
            }

            _overrideGravity() {
                return this._selection.overrideGravity()
            }

            _restoreGravity(t) {
                this._selection.restoreGravity(t)
            }

            static _getStoreAttributeKey(t) {
                return wm + t
            }

            static _isStoreAttributeKey(t) {
                return t.startsWith(wm)
            }
        }

        Cs(Am, ds);

        class _m extends lm {
            constructor(t) {
                super();
                this.markers = new vs({idProperty: "name"});
                this._model = t.model;
                this._document = t;
                this._attributePriority = new Map;
                this._selectionRestorePosition = null;
                this._hasChangedRange = false;
                this._overriddenGravityRegister = new Set;
                this.listenTo(this._model, "applyOperation", ((t, e) => {
                    const n = e[0];
                    if (!n.isDocumentOperation || n.type == "marker" || n.type == "rename" || n.type == "noop") {
                        return
                    }
                    if (this._ranges.length == 0 && this._selectionRestorePosition) {
                        this._fixGraveyardSelection(this._selectionRestorePosition)
                    }
                    this._selectionRestorePosition = null;
                    if (this._hasChangedRange) {
                        this._hasChangedRange = false;
                        this.fire("change:range", {directChange: false})
                    }
                }), {priority: "lowest"});
                this.on("change:range", (() => {
                    for (const t of this.getRanges()) {
                        if (!this._document._validateSelectionRange(t)) {
                            throw new ss["a"]("document-selection-wrong-position", this, {range: t})
                        }
                    }
                }));
                this.listenTo(this._model.markers, "update", (() => this._updateMarkers()));
                this.listenTo(this._document, "change", ((t, e) => {
                    vm(this._model, e)
                }))
            }

            get isCollapsed() {
                const t = this._ranges.length;
                return t === 0 ? this._document._getDefaultRange().isCollapsed : super.isCollapsed
            }

            get anchor() {
                return super.anchor || this._document._getDefaultRange().start
            }

            get focus() {
                return super.focus || this._document._getDefaultRange().end
            }

            get rangeCount() {
                return this._ranges.length ? this._ranges.length : 1
            }

            get hasOwnRange() {
                return this._ranges.length > 0
            }

            get isGravityOverridden() {
                return !!this._overriddenGravityRegister.size
            }

            destroy() {
                for (let t = 0; t < this._ranges.length; t++) {
                    this._ranges[t].detach()
                }
                this.stopListening()
            }

            * getRanges() {
                if (this._ranges.length) {
                    yield* super.getRanges()
                } else {
                    yield this._document._getDefaultRange()
                }
            }

            getFirstRange() {
                return super.getFirstRange() || this._document._getDefaultRange()
            }

            getLastRange() {
                return super.getLastRange() || this._document._getDefaultRange()
            }

            setTo(t, e, n) {
                super.setTo(t, e, n);
                this._updateAttributes(true);
                this._updateMarkers()
            }

            setFocus(t, e) {
                super.setFocus(t, e);
                this._updateAttributes(true);
                this._updateMarkers()
            }

            setAttribute(t, e) {
                if (this._setAttribute(t, e)) {
                    const e = [t];
                    this.fire("change:attribute", {attributeKeys: e, directChange: true})
                }
            }

            removeAttribute(t) {
                if (this._removeAttribute(t)) {
                    const e = [t];
                    this.fire("change:attribute", {attributeKeys: e, directChange: true})
                }
            }

            overrideGravity() {
                const t = ns();
                this._overriddenGravityRegister.add(t);
                if (this._overriddenGravityRegister.size === 1) {
                    this._updateAttributes(true)
                }
                return t
            }

            restoreGravity(t) {
                if (!this._overriddenGravityRegister.has(t)) {
                    throw new ss["a"]("document-selection-gravity-wrong-restore", this, {uid: t})
                }
                this._overriddenGravityRegister.delete(t);
                if (!this.isGravityOverridden) {
                    this._updateAttributes(true)
                }
            }

            _popRange() {
                this._ranges.pop().detach()
            }

            _pushRange(t) {
                const e = this._prepareRange(t);
                if (e) {
                    this._ranges.push(e)
                }
            }

            _prepareRange(t) {
                this._checkRange(t);
                if (t.root == this._document.graveyard) {
                    return
                }
                const e = fm.fromRange(t);
                e.on("change:range", ((t, n, i) => {
                    this._hasChangedRange = true;
                    if (e.root == this._document.graveyard) {
                        this._selectionRestorePosition = i.deletionPosition;
                        const t = this._ranges.indexOf(e);
                        this._ranges.splice(t, 1);
                        e.detach()
                    }
                }));
                return e
            }

            _updateMarkers() {
                const t = [];
                let e = false;
                for (const e of this._model.markers) {
                    const n = e.getRange();
                    for (const i of this.getRanges()) {
                        if (n.containsRange(i, !i.isCollapsed)) {
                            t.push(e)
                        }
                    }
                }
                const n = Array.from(this.markers);
                for (const n of t) {
                    if (!this.markers.has(n)) {
                        this.markers.add(n);
                        e = true
                    }
                }
                for (const n of Array.from(this.markers)) {
                    if (!t.includes(n)) {
                        this.markers.remove(n);
                        e = true
                    }
                }
                if (e) {
                    this.fire("change:marker", {oldMarkers: n, directChange: false})
                }
            }

            _updateAttributes(t) {
                const e = Us(this._getSurroundingAttributes());
                const n = Us(this.getAttributes());
                if (t) {
                    this._attributePriority = new Map;
                    this._attrs = new Map
                } else {
                    for (const [t, e] of this._attributePriority) {
                        if (e == "low") {
                            this._attrs.delete(t);
                            this._attributePriority.delete(t)
                        }
                    }
                }
                this._setAttributesTo(e);
                const i = [];
                for (const [t, e] of this.getAttributes()) {
                    if (!n.has(t) || n.get(t) !== e) {
                        i.push(t)
                    }
                }
                for (const [t] of n) {
                    if (!this.hasAttribute(t)) {
                        i.push(t)
                    }
                }
                if (i.length > 0) {
                    this.fire("change:attribute", {attributeKeys: i, directChange: false})
                }
            }

            _setAttribute(t, e, n = true) {
                const i = n ? "normal" : "low";
                if (i == "low" && this._attributePriority.get(t) == "normal") {
                    return false
                }
                const o = super.getAttribute(t);
                if (o === e) {
                    return false
                }
                this._attrs.set(t, e);
                this._attributePriority.set(t, i);
                return true
            }

            _removeAttribute(t, e = true) {
                const n = e ? "normal" : "low";
                if (n == "low" && this._attributePriority.get(t) == "normal") {
                    return false
                }
                this._attributePriority.set(t, n);
                if (!super.hasAttribute(t)) {
                    return false
                }
                this._attrs.delete(t);
                return true
            }

            _setAttributesTo(t) {
                const e = new Set;
                for (const [e, n] of this.getAttributes()) {
                    if (t.get(e) === n) {
                        continue
                    }
                    this._removeAttribute(e, false)
                }
                for (const [n, i] of t) {
                    const t = this._setAttribute(n, i, false);
                    if (t) {
                        e.add(n)
                    }
                }
                return e
            }

            * _getStoredAttributes() {
                const t = this.getFirstPosition().parent;
                if (this.isCollapsed && t.isEmpty) {
                    for (const e of t.getAttributeKeys()) {
                        if (e.startsWith(wm)) {
                            const n = e.substr(wm.length);
                            yield[n, t.getAttribute(e)]
                        }
                    }
                }
            }

            _getSurroundingAttributes() {
                const t = this.getFirstPosition();
                const e = this._model.schema;
                let n = null;
                if (!this.isCollapsed) {
                    const t = this.getFirstRange();
                    for (const i of t) {
                        if (i.item.is("element") && e.isObject(i.item)) {
                            break
                        }
                        if (i.type == "text") {
                            n = i.item.getAttributes();
                            break
                        }
                    }
                } else {
                    const i = t.textNode ? t.textNode : t.nodeBefore;
                    const o = t.textNode ? t.textNode : t.nodeAfter;
                    if (!this.isGravityOverridden) {
                        n = Cm(i)
                    }
                    if (!n) {
                        n = Cm(o)
                    }
                    if (!this.isGravityOverridden && !n) {
                        let t = i;
                        while (t && !e.isInline(t) && !n) {
                            t = t.previousSibling;
                            n = Cm(t)
                        }
                    }
                    if (!n) {
                        let t = o;
                        while (t && !e.isInline(t) && !n) {
                            t = t.nextSibling;
                            n = Cm(t)
                        }
                    }
                    if (!n) {
                        n = this._getStoredAttributes()
                    }
                }
                return n
            }

            _fixGraveyardSelection(t) {
                const e = this._model.schema.getNearestSelectionRange(t);
                if (e) {
                    this._pushRange(e)
                }
            }
        }

        function Cm(t) {
            if (t instanceof Wh || t instanceof Uh) {
                return t.getAttributes()
            }
            return null
        }

        function vm(t, e) {
            const n = t.document.differ;
            for (const i of n.getChanges()) {
                if (i.type != "insert") {
                    continue
                }
                const n = i.position.parent;
                const o = i.length === n.maxOffset;
                if (o) {
                    t.enqueueChange(e, (t => {
                        const e = Array.from(n.getAttributeKeys()).filter((t => t.startsWith(wm)));
                        for (const i of e) {
                            t.removeAttribute(i, n)
                        }
                    }))
                }
            }
        }

        class ym {
            constructor(t) {
                this._dispatchers = t
            }

            add(t) {
                for (const e of this._dispatchers) {
                    t(e)
                }
                return this
            }
        }

        var xm = 1, Em = 4;

        function Dm(t) {
            return Hr(t, xm | Em)
        }

        var Tm = Dm;

        class Mm extends ym {
            elementToElement(t) {
                return this.add(Ym(t))
            }

            attributeToElement(t) {
                return this.add(Qm(t))
            }

            attributeToAttribute(t) {
                return this.add(Jm(t))
            }

            markerToElement(t) {
                return this.add(Xm(t))
            }

            markerToHighlight(t) {
                return this.add(tg(t))
            }

            markerToData(t) {
                return this.add(Zm(t))
            }
        }

        function Sm() {
            return (t, e, n) => {
                if (!n.consumable.consume(e.item, "insert")) {
                    return
                }
                const i = n.writer;
                const o = n.mapper.toViewPosition(e.range.start);
                const r = i.createText(e.item.data);
                i.insert(o, r)
            }
        }

        function Im() {
            return (t, e, n) => {
                const i = n.mapper.toViewPosition(e.position);
                const o = e.position.getShiftedBy(e.length);
                const r = n.mapper.toViewPosition(o, {isPhantom: true});
                const s = n.writer.createRange(i, r);
                const a = n.writer.remove(s.getTrimmed());
                for (const t of n.writer.createRangeIn(a).getItems()) {
                    n.mapper.unbindViewElement(t)
                }
            }
        }

        function Bm(t, e) {
            const n = t.createAttributeElement("span", e.attributes);
            if (e.classes) {
                n._addClass(e.classes)
            }
            if (e.priority) {
                n._priority = e.priority
            }
            n._id = e.id;
            return n
        }

        function Lm() {
            return (t, e, n) => {
                const i = e.selection;
                if (i.isCollapsed) {
                    return
                }
                if (!n.consumable.consume(i, "selection")) {
                    return
                }
                const o = [];
                for (const t of i.getRanges()) {
                    const e = n.mapper.toViewRange(t);
                    o.push(e)
                }
                n.writer.setSelection(o, {backward: i.isBackward})
            }
        }

        function zm() {
            return (t, e, n) => {
                const i = e.selection;
                if (!i.isCollapsed) {
                    return
                }
                if (!n.consumable.consume(i, "selection")) {
                    return
                }
                const o = n.writer;
                const r = i.getFirstPosition();
                const s = n.mapper.toViewPosition(r);
                const a = o.breakAttributes(s);
                o.setSelection(a)
            }
        }

        function Nm() {
            return (t, e, n) => {
                const i = n.writer;
                const o = i.document.selection;
                for (const t of o.getRanges()) {
                    if (t.isCollapsed) {
                        if (t.end.parent.isAttached()) {
                            n.writer.mergeAttributes(t.start)
                        }
                    }
                }
                i.setSelection(null)
            }
        }

        function Pm(t) {
            return (e, n, i) => {
                const o = t(n.attributeOldValue, i);
                const r = t(n.attributeNewValue, i);
                if (!o && !r) {
                    return
                }
                if (!i.consumable.consume(n.item, e.name)) {
                    return
                }
                const s = i.writer;
                const a = s.document.selection;
                if (n.item instanceof lm || n.item instanceof Am) {
                    s.wrap(a.getFirstRange(), r)
                } else {
                    let t = i.mapper.toViewRange(n.range);
                    if (n.attributeOldValue !== null && o) {
                        t = s.unwrap(t, o)
                    }
                    if (n.attributeNewValue !== null && r) {
                        s.wrap(t, r)
                    }
                }
            }
        }

        function Om(t) {
            return (e, n, i) => {
                const o = t(n.item, i);
                if (!o) {
                    return
                }
                if (!i.consumable.consume(n.item, "insert")) {
                    return
                }
                const r = i.mapper.toViewPosition(n.range.start);
                i.mapper.bindElements(n.item, o);
                i.writer.insert(r, o)
            }
        }

        function jm(t) {
            return (e, n, i) => {
                n.isOpening = true;
                const o = t(n, i);
                n.isOpening = false;
                const r = t(n, i);
                if (!o || !r) {
                    return
                }
                const s = n.markerRange;
                if (s.isCollapsed && !i.consumable.consume(s, e.name)) {
                    return
                }
                for (const t of s) {
                    if (!i.consumable.consume(t.item, e.name)) {
                        return
                    }
                }
                const a = i.mapper;
                const c = i.writer;
                c.insert(a.toViewPosition(s.start), o);
                i.mapper.bindElementToMarker(o, n.markerName);
                if (!s.isCollapsed) {
                    c.insert(a.toViewPosition(s.end), r);
                    i.mapper.bindElementToMarker(r, n.markerName)
                }
                e.stop()
            }
        }

        function Rm() {
            return (t, e, n) => {
                const i = n.mapper.markerNameToElements(e.markerName);
                if (!i) {
                    return
                }
                for (const t of i) {
                    n.mapper.unbindElementFromMarkerName(t, e.markerName);
                    n.writer.clear(n.writer.createRangeOn(t), t)
                }
                n.writer.clearClonedElementsGroup(e.markerName);
                t.stop()
            }
        }

        function Fm(t) {
            return (e, n, i) => {
                const o = t(n.markerName, i);
                if (!o) {
                    return
                }
                const r = n.markerRange;
                if (!i.consumable.consume(r, e.name)) {
                    return
                }
                Vm(r, false, i, n, o);
                Vm(r, true, i, n, o);
                e.stop()
            }
        }

        function Vm(t, e, n, i, o) {
            const r = e ? t.start : t.end;
            const s = n.schema.checkChild(r, "$text");
            if (s) {
                const t = n.mapper.toViewPosition(r);
                Um(t, e, n, i, o)
            } else {
                let t;
                let s;
                if (e && r.nodeAfter || !e && !r.nodeBefore) {
                    t = r.nodeAfter;
                    s = true
                } else {
                    t = r.nodeBefore;
                    s = false
                }
                const a = n.mapper.toViewElement(t);
                Hm(a, e, s, n, i, o)
            }
        }

        function Hm(t, e, n, i, o, r) {
            const s = `data-${r.group}-${e ? "start" : "end"}-${n ? "before" : "after"}`;
            const a = t.hasAttribute(s) ? t.getAttribute(s).split(",") : [];
            a.unshift(r.name);
            i.writer.setAttribute(s, a.join(","), t);
            i.mapper.bindElementToMarker(t, o.markerName)
        }

        function Um(t, e, n, i, o) {
            const r = `${o.group}-${e ? "start" : "end"}`;
            const s = o.name ? {name: o.name} : null;
            const a = n.writer.createUIElement(r, s);
            n.writer.insert(t, a);
            n.mapper.bindElementToMarker(a, i.markerName)
        }

        function Wm(t) {
            return (e, n, i) => {
                const o = t(n.markerName, i);
                if (!o) {
                    return
                }
                const r = i.mapper.markerNameToElements(n.markerName);
                if (!r) {
                    return
                }
                for (const t of r) {
                    i.mapper.unbindElementFromMarkerName(t, n.markerName);
                    if (t.is("containerElement")) {
                        s(`data-${o.group}-start-before`, t);
                        s(`data-${o.group}-start-after`, t);
                        s(`data-${o.group}-end-before`, t);
                        s(`data-${o.group}-end-after`, t)
                    } else {
                        i.writer.clear(i.writer.createRangeOn(t), t)
                    }
                }
                i.writer.clearClonedElementsGroup(n.markerName);
                e.stop();

                function s(t, e) {
                    if (e.hasAttribute(t)) {
                        const n = new Set(e.getAttribute(t).split(","));
                        n.delete(o.name);
                        if (n.size == 0) {
                            i.writer.removeAttribute(t, e)
                        } else {
                            i.writer.setAttribute(t, Array.from(n).join(","), e)
                        }
                    }
                }
            }
        }

        function qm(t) {
            return (e, n, i) => {
                const o = t(n.attributeOldValue, i);
                const r = t(n.attributeNewValue, i);
                if (!o && !r) {
                    return
                }
                if (!i.consumable.consume(n.item, e.name)) {
                    return
                }
                const s = i.mapper.toViewElement(n.item);
                const a = i.writer;
                if (!s) {
                    throw new ss["a"]("conversion-attribute-to-attribute-on-text", [n, i])
                }
                if (n.attributeOldValue !== null && o) {
                    if (o.key == "class") {
                        const t = Array.isArray(o.value) ? o.value : [o.value];
                        for (const e of t) {
                            a.removeClass(e, s)
                        }
                    } else if (o.key == "style") {
                        const t = Object.keys(o.value);
                        for (const e of t) {
                            a.removeStyle(e, s)
                        }
                    } else {
                        a.removeAttribute(o.key, s)
                    }
                }
                if (n.attributeNewValue !== null && r) {
                    if (r.key == "class") {
                        const t = Array.isArray(r.value) ? r.value : [r.value];
                        for (const e of t) {
                            a.addClass(e, s)
                        }
                    } else if (r.key == "style") {
                        const t = Object.keys(r.value);
                        for (const e of t) {
                            a.setStyle(e, r.value[e], s)
                        }
                    } else {
                        a.setAttribute(r.key, r.value, s)
                    }
                }
            }
        }

        function Km(t) {
            return (e, n, i) => {
                if (!n.item) {
                    return
                }
                if (!(n.item instanceof lm || n.item instanceof Am) && !n.item.is("$textProxy")) {
                    return
                }
                const o = rg(t, n, i);
                if (!o) {
                    return
                }
                if (!i.consumable.consume(n.item, e.name)) {
                    return
                }
                const r = i.writer;
                const s = Bm(r, o);
                const a = r.document.selection;
                if (n.item instanceof lm || n.item instanceof Am) {
                    r.wrap(a.getFirstRange(), s, a)
                } else {
                    const t = i.mapper.toViewRange(n.range);
                    const e = r.wrap(t, s);
                    for (const t of e.getItems()) {
                        if (t.is("attributeElement") && t.isSimilar(s)) {
                            i.mapper.bindElementToMarker(t, n.markerName);
                            break
                        }
                    }
                }
            }
        }

        function Gm(t) {
            return (e, n, i) => {
                if (!n.item) {
                    return
                }
                if (!(n.item instanceof Kh)) {
                    return
                }
                const o = rg(t, n, i);
                if (!o) {
                    return
                }
                if (!i.consumable.test(n.item, e.name)) {
                    return
                }
                const r = i.mapper.toViewElement(n.item);
                if (r && r.getCustomProperty("addHighlight")) {
                    i.consumable.consume(n.item, e.name);
                    for (const t of tm._createIn(n.item)) {
                        i.consumable.consume(t.item, e.name)
                    }
                    r.getCustomProperty("addHighlight")(r, o, i.writer);
                    i.mapper.bindElementToMarker(r, n.markerName)
                }
            }
        }

        function $m(t) {
            return (e, n, i) => {
                if (n.markerRange.isCollapsed) {
                    return
                }
                const o = rg(t, n, i);
                if (!o) {
                    return
                }
                const r = Bm(i.writer, o);
                const s = i.mapper.markerNameToElements(n.markerName);
                if (!s) {
                    return
                }
                for (const t of s) {
                    i.mapper.unbindElementFromMarkerName(t, n.markerName);
                    if (t.is("attributeElement")) {
                        i.writer.unwrap(i.writer.createRangeOn(t), r)
                    } else {
                        t.getCustomProperty("removeHighlight")(t, o.id, i.writer)
                    }
                }
                i.writer.clearClonedElementsGroup(n.markerName);
                e.stop()
            }
        }

        function Ym(t) {
            t = Tm(t);
            t.view = eg(t.view, "container");
            return e => {
                e.on("insert:" + t.model, Om(t.view), {priority: t.converterPriority || "normal"});
                if (t.triggerBy) {
                    if (t.triggerBy.attributes) {
                        for (const n of t.triggerBy.attributes) {
                            e._mapReconversionTriggerEvent(t.model, `attribute:${n}:${t.model}`)
                        }
                    }
                    if (t.triggerBy.children) {
                        for (const n of t.triggerBy.children) {
                            e._mapReconversionTriggerEvent(t.model, `insert:${n}`);
                            e._mapReconversionTriggerEvent(t.model, `remove:${n}`)
                        }
                    }
                }
            }
        }

        function Qm(t) {
            t = Tm(t);
            const e = t.model.key ? t.model.key : t.model;
            let n = "attribute:" + e;
            if (t.model.name) {
                n += ":" + t.model.name
            }
            if (t.model.values) {
                for (const e of t.model.values) {
                    t.view[e] = eg(t.view[e], "attribute")
                }
            } else {
                t.view = eg(t.view, "attribute")
            }
            const i = ig(t);
            return e => {
                e.on(n, Pm(i), {priority: t.converterPriority || "normal"})
            }
        }

        function Jm(t) {
            t = Tm(t);
            const e = t.model.key ? t.model.key : t.model;
            let n = "attribute:" + e;
            if (t.model.name) {
                n += ":" + t.model.name
            }
            if (t.model.values) {
                for (const e of t.model.values) {
                    t.view[e] = og(t.view[e])
                }
            } else {
                t.view = og(t.view)
            }
            const i = ig(t);
            return e => {
                e.on(n, qm(i), {priority: t.converterPriority || "normal"})
            }
        }

        function Xm(t) {
            t = Tm(t);
            t.view = eg(t.view, "ui");
            return e => {
                e.on("addMarker:" + t.model, jm(t.view), {priority: t.converterPriority || "normal"});
                e.on("removeMarker:" + t.model, Rm(t.view), {priority: t.converterPriority || "normal"})
            }
        }

        function Zm(t) {
            t = Tm(t);
            const e = t.model;
            if (!t.view) {
                t.view = n => ({group: e, name: n.substr(t.model.length + 1)})
            }
            return n => {
                n.on("addMarker:" + e, Fm(t.view), {priority: t.converterPriority || "normal"});
                n.on("removeMarker:" + e, Wm(t.view), {priority: t.converterPriority || "normal"})
            }
        }

        function tg(t) {
            return e => {
                e.on("addMarker:" + t.model, Km(t.view), {priority: t.converterPriority || "normal"});
                e.on("addMarker:" + t.model, Gm(t.view), {priority: t.converterPriority || "normal"});
                e.on("removeMarker:" + t.model, $m(t.view), {priority: t.converterPriority || "normal"})
            }
        }

        function eg(t, e) {
            if (typeof t == "function") {
                return t
            }
            return (n, i) => ng(t, i, e)
        }

        function ng(t, e, n) {
            if (typeof t == "string") {
                t = {name: t}
            }
            let i;
            const o = e.writer;
            const r = Object.assign({}, t.attributes);
            if (n == "container") {
                i = o.createContainerElement(t.name, r)
            } else if (n == "attribute") {
                const e = {priority: t.priority || wl.DEFAULT_PRIORITY};
                i = o.createAttributeElement(t.name, r, e)
            } else {
                i = o.createUIElement(t.name, r)
            }
            if (t.styles) {
                const e = Object.keys(t.styles);
                for (const n of e) {
                    o.setStyle(n, t.styles[n], i)
                }
            }
            if (t.classes) {
                const e = t.classes;
                if (typeof e == "string") {
                    o.addClass(e, i)
                } else {
                    for (const t of e) {
                        o.addClass(t, i)
                    }
                }
            }
            return i
        }

        function ig(t) {
            if (t.model.values) {
                return (e, n) => {
                    const i = t.view[e];
                    if (i) {
                        return i(e, n)
                    }
                    return null
                }
            } else {
                return t.view
            }
        }

        function og(t) {
            if (typeof t == "string") {
                return e => ({key: t, value: e})
            } else if (typeof t == "object") {
                if (t.value) {
                    return () => t
                } else {
                    return e => ({key: t.key, value: e})
                }
            } else {
                return t
            }
        }

        function rg(t, e, n) {
            const i = typeof t == "function" ? t(e, n) : t;
            if (!i) {
                return null
            }
            if (!i.priority) {
                i.priority = 10
            }
            if (!i.id) {
                i.id = e.markerName
            }
            return i
        }

        function sg(t) {
            const {schema: e, document: n} = t.model;
            for (const i of n.getRootNames()) {
                const o = n.getRoot(i);
                if (o.isEmpty && !e.checkChild(o, "$text")) {
                    if (e.checkChild(o, "paragraph")) {
                        t.insertElement("paragraph", o);
                        return true
                    }
                }
            }
            return false
        }

        function ag(t, e, n) {
            const i = n.createContext(t);
            if (!n.checkChild(i, "paragraph")) {
                return false
            }
            if (!n.checkChild(i.push("paragraph"), e)) {
                return false
            }
            return true
        }

        function cg(t, e) {
            const n = e.createElement("paragraph");
            e.insert(n, t);
            return e.createPositionAt(n, 0)
        }

        class lg extends ym {
            elementToElement(t) {
                return this.add(mg(t))
            }

            elementToAttribute(t) {
                return this.add(gg(t))
            }

            attributeToAttribute(t) {
                return this.add(fg(t))
            }

            elementToMarker(t) {
                Object(ss["c"])("upcast-helpers-element-to-marker-deprecated");
                return this.add(pg(t))
            }

            dataToMarker(t) {
                return this.add(bg(t))
            }
        }

        function dg() {
            return (t, e, n) => {
                if (!e.modelRange && n.consumable.consume(e.viewItem, {name: true})) {
                    const {modelRange: t, modelCursor: i} = n.convertChildren(e.viewItem, e.modelCursor);
                    e.modelRange = t;
                    e.modelCursor = i
                }
            }
        }

        function ug() {
            return (t, e, {schema: n, consumable: i, writer: o}) => {
                let r = e.modelCursor;
                if (!i.test(e.viewItem)) {
                    return
                }
                if (!n.checkChild(r, "$text")) {
                    if (!ag(r, "$text", n)) {
                        return
                    }
                    r = cg(r, o)
                }
                i.consume(e.viewItem);
                const s = o.createText(e.viewItem.data);
                o.insert(s, r);
                e.modelRange = o.createRange(r, r.getShiftedBy(s.offsetSize));
                e.modelCursor = e.modelRange.end
            }
        }

        function hg(t, e) {
            return (n, i) => {
                const o = i.newSelection;
                const r = [];
                for (const t of o.getRanges()) {
                    r.push(e.toModelRange(t))
                }
                const s = t.createSelection(r, {backward: o.isBackward});
                if (!s.isEqual(t.document.selection)) {
                    t.change((t => {
                        t.setSelection(s)
                    }))
                }
            }
        }

        function mg(t) {
            t = Tm(t);
            const e = Ag(t);
            const n = wg(t.view);
            const i = n ? "element:" + n : "element";
            return n => {
                n.on(i, e, {priority: t.converterPriority || "normal"})
            }
        }

        function gg(t) {
            t = Tm(t);
            vg(t);
            const e = yg(t, false);
            const n = wg(t.view);
            const i = n ? "element:" + n : "element";
            return n => {
                n.on(i, e, {priority: t.converterPriority || "low"})
            }
        }

        function fg(t) {
            t = Tm(t);
            let e = null;
            if (typeof t.view == "string" || t.view.key) {
                e = Cg(t)
            }
            vg(t, e);
            const n = yg(t, true);
            return e => {
                e.on("element", n, {priority: t.converterPriority || "low"})
            }
        }

        function pg(t) {
            t = Tm(t);
            Dg(t);
            return mg(t)
        }

        function bg(t) {
            t = Tm(t);
            if (!t.model) {
                t.model = e => e ? t.view + ":" + e : t.view
            }
            const e = Ag(Tg(t, "start"));
            const n = Ag(Tg(t, "end"));
            return i => {
                i.on("element:" + t.view + "-start", e, {priority: t.converterPriority || "normal"});
                i.on("element:" + t.view + "-end", n, {priority: t.converterPriority || "normal"});
                const o = os.get("low");
                const r = os.get("highest");
                const s = os.get(t.converterPriority) / r;
                i.on("element", kg(t), {priority: o + s})
            }
        }

        function kg(t) {
            return (e, n, i) => {
                const o = `data-${t.view}`;
                if (!n.modelRange) {
                    n = Object.assign(n, i.convertChildren(n.viewItem, n.modelCursor))
                }
                if (i.consumable.consume(n.viewItem, {attributes: o + "-end-after"})) {
                    r(n.modelRange.end, n.viewItem.getAttribute(o + "-end-after").split(","))
                }
                if (i.consumable.consume(n.viewItem, {attributes: o + "-start-after"})) {
                    r(n.modelRange.end, n.viewItem.getAttribute(o + "-start-after").split(","))
                }
                if (i.consumable.consume(n.viewItem, {attributes: o + "-end-before"})) {
                    r(n.modelRange.start, n.viewItem.getAttribute(o + "-end-before").split(","))
                }
                if (i.consumable.consume(n.viewItem, {attributes: o + "-start-before"})) {
                    r(n.modelRange.start, n.viewItem.getAttribute(o + "-start-before").split(","))
                }

                function r(e, o) {
                    for (const r of o) {
                        const o = t.model(r, i);
                        const s = i.writer.createElement("$marker", {"data-name": o});
                        i.writer.insert(s, e);
                        if (n.modelCursor.isEqual(e)) {
                            n.modelCursor = n.modelCursor.getShiftedBy(1)
                        } else {
                            n.modelCursor = n.modelCursor._getTransformedByInsertion(e, 1)
                        }
                        n.modelRange = n.modelRange._getTransformedByInsertion(e, 1)[0]
                    }
                }
            }
        }

        function wg(t) {
            if (typeof t == "string") {
                return t
            }
            if (typeof t == "object" && typeof t.name == "string") {
                return t.name
            }
            return null
        }

        function Ag(t) {
            const e = new Ws(t.view);
            return (n, i, o) => {
                const r = e.match(i.viewItem);
                if (!r) {
                    return
                }
                const s = r.match;
                s.name = true;
                if (!o.consumable.test(i.viewItem, s)) {
                    return
                }
                const a = _g(t.model, i.viewItem, o);
                if (!a) {
                    return
                }
                if (!o.safeInsert(a, i.modelCursor)) {
                    return
                }
                o.consumable.consume(i.viewItem, s);
                o.convertChildren(i.viewItem, a);
                o.updateConversionResult(a, i)
            }
        }

        function _g(t, e, n) {
            if (t instanceof Function) {
                return t(e, n)
            } else {
                return n.writer.createElement(t)
            }
        }

        function Cg(t) {
            if (typeof t.view == "string") {
                t.view = {key: t.view}
            }
            const e = t.view.key;
            let n;
            if (e == "class" || e == "style") {
                const i = e == "class" ? "classes" : "styles";
                n = {[i]: t.view.value}
            } else {
                const i = typeof t.view.value == "undefined" ? /[\s\S]*/ : t.view.value;
                n = {attributes: {[e]: i}}
            }
            if (t.view.name) {
                n.name = t.view.name
            }
            t.view = n;
            return e
        }

        function vg(t, e = null) {
            const n = e === null ? true : t => t.getAttribute(e);
            const i = typeof t.model != "object" ? t.model : t.model.key;
            const o = typeof t.model != "object" || typeof t.model.value == "undefined" ? n : t.model.value;
            t.model = {key: i, value: o}
        }

        function yg(t, e) {
            const n = new Ws(t.view);
            return (i, o, r) => {
                const s = n.match(o.viewItem);
                if (!s) {
                    return
                }
                const a = t.model.key;
                const c = typeof t.model.value == "function" ? t.model.value(o.viewItem, r) : t.model.value;
                if (c === null) {
                    return
                }
                if (xg(t.view, o.viewItem)) {
                    s.match.name = true
                } else {
                    delete s.match.name
                }
                if (!r.consumable.test(o.viewItem, s.match)) {
                    return
                }
                if (!o.modelRange) {
                    o = Object.assign(o, r.convertChildren(o.viewItem, o.modelCursor))
                }
                const l = Eg(o.modelRange, {key: a, value: c}, e, r);
                if (l) {
                    r.consumable.consume(o.viewItem, s.match)
                }
            }
        }

        function xg(t, e) {
            const n = typeof t == "function" ? t(e) : t;
            if (typeof n == "object" && !wg(n)) {
                return false
            }
            return !n.classes && !n.attributes && !n.styles
        }

        function Eg(t, e, n, i) {
            let o = false;
            for (const r of Array.from(t.getItems({shallow: n}))) {
                if (i.schema.checkAttribute(r, e.key)) {
                    i.writer.setAttribute(e.key, e.value, r);
                    o = true
                }
            }
            return o
        }

        function Dg(t) {
            const e = t.model;
            t.model = (t, n) => {
                const i = typeof e == "string" ? e : e(t, n);
                return n.writer.createElement("$marker", {"data-name": i})
            }
        }

        function Tg(t, e) {
            const n = {};
            n.view = t.view + "-" + e;
            n.model = (e, n) => {
                const i = e.getAttribute("name");
                const o = t.model(i, n);
                return n.writer.createElement("$marker", {"data-name": o})
            };
            return n
        }

        class Mg {
            constructor(t, e) {
                this.model = t;
                this.view = new Vh(e);
                this.mapper = new em;
                this.downcastDispatcher = new om({mapper: this.mapper, schema: t.schema});
                const n = this.model.document;
                const i = n.selection;
                const o = this.model.markers;
                this.listenTo(this.model, "_beforeChanges", (() => {
                    this.view._disableRendering(true)
                }), {priority: "highest"});
                this.listenTo(this.model, "_afterChanges", (() => {
                    this.view._disableRendering(false)
                }), {priority: "lowest"});
                this.listenTo(n, "change", (() => {
                    this.view.change((t => {
                        this.downcastDispatcher.convertChanges(n.differ, o, t);
                        this.downcastDispatcher.convertSelection(i, o, t)
                    }))
                }), {priority: "low"});
                this.listenTo(this.view.document, "selectionChange", hg(this.model, this.mapper));
                this.downcastDispatcher.on("insert:$text", Sm(), {priority: "lowest"});
                this.downcastDispatcher.on("remove", Im(), {priority: "low"});
                this.downcastDispatcher.on("selection", Nm(), {priority: "low"});
                this.downcastDispatcher.on("selection", Lm(), {priority: "low"});
                this.downcastDispatcher.on("selection", zm(), {priority: "low"});
                this.view.document.roots.bindTo(this.model.document.roots).using((t => {
                    if (t.rootName == "$graveyard") {
                        return null
                    }
                    const e = new ll(this.view.document, t.name);
                    e.rootName = t.rootName;
                    this.mapper.bindElements(t, e);
                    return e
                }))
            }

            destroy() {
                this.view.destroy();
                this.stopListening()
            }
        }

        Cs(Mg, Qc);

        class Sg {
            constructor() {
                this._commands = new Map
            }

            add(t, e) {
                this._commands.set(t, e)
            }

            get(t) {
                return this._commands.get(t)
            }

            execute(t, ...e) {
                const n = this.get(t);
                if (!n) {
                    throw new ss["a"]("commandcollection-command-not-found", this, {commandName: t})
                }
                return n.execute(...e)
            }

            * names() {
                yield* this._commands.keys()
            }

            * commands() {
                yield* this._commands.values()
            }

            [Symbol.iterator]() {
                return this._commands[Symbol.iterator]()
            }

            destroy() {
                for (const t of this.commands()) {
                    t.destroy()
                }
            }
        }

        class Ig {
            constructor() {
                this._consumables = new Map
            }

            add(t, e) {
                let n;
                if (t.is("$text") || t.is("documentFragment")) {
                    this._consumables.set(t, true);
                    return
                }
                if (!this._consumables.has(t)) {
                    n = new Bg(t);
                    this._consumables.set(t, n)
                } else {
                    n = this._consumables.get(t)
                }
                n.add(e)
            }

            test(t, e) {
                const n = this._consumables.get(t);
                if (n === undefined) {
                    return null
                }
                if (t.is("$text") || t.is("documentFragment")) {
                    return n
                }
                return n.test(e)
            }

            consume(t, e) {
                if (this.test(t, e)) {
                    if (t.is("$text") || t.is("documentFragment")) {
                        this._consumables.set(t, false)
                    } else {
                        this._consumables.get(t).consume(e)
                    }
                    return true
                }
                return false
            }

            revert(t, e) {
                const n = this._consumables.get(t);
                if (n !== undefined) {
                    if (t.is("$text") || t.is("documentFragment")) {
                        this._consumables.set(t, true)
                    } else {
                        n.revert(e)
                    }
                }
            }

            static consumablesFromElement(t) {
                const e = {element: t, name: true, attributes: [], classes: [], styles: []};
                const n = t.getAttributeKeys();
                for (const t of n) {
                    if (t == "style" || t == "class") {
                        continue
                    }
                    e.attributes.push(t)
                }
                const i = t.getClassNames();
                for (const t of i) {
                    e.classes.push(t)
                }
                const o = t.getStyleNames();
                for (const t of o) {
                    e.styles.push(t)
                }
                return e
            }

            static createFrom(t, e) {
                if (!e) {
                    e = new Ig(t)
                }
                if (t.is("$text")) {
                    e.add(t);
                    return e
                }
                if (t.is("element")) {
                    e.add(t, Ig.consumablesFromElement(t))
                }
                if (t.is("documentFragment")) {
                    e.add(t)
                }
                for (const n of t.getChildren()) {
                    e = Ig.createFrom(n, e)
                }
                return e
            }
        }

        class Bg {
            constructor(t) {
                this.element = t;
                this._canConsumeName = null;
                this._consumables = {attributes: new Map, styles: new Map, classes: new Map}
            }

            add(t) {
                if (t.name) {
                    this._canConsumeName = true
                }
                for (const e in this._consumables) {
                    if (e in t) {
                        this._add(e, t[e])
                    }
                }
            }

            test(t) {
                if (t.name && !this._canConsumeName) {
                    return this._canConsumeName
                }
                for (const e in this._consumables) {
                    if (e in t) {
                        const n = this._test(e, t[e]);
                        if (n !== true) {
                            return n
                        }
                    }
                }
                return true
            }

            consume(t) {
                if (t.name) {
                    this._canConsumeName = false
                }
                for (const e in this._consumables) {
                    if (e in t) {
                        this._consume(e, t[e])
                    }
                }
            }

            revert(t) {
                if (t.name) {
                    this._canConsumeName = true
                }
                for (const e in this._consumables) {
                    if (e in t) {
                        this._revert(e, t[e])
                    }
                }
            }

            _add(t, e) {
                const n = Ye(e) ? e : [e];
                const i = this._consumables[t];
                for (const e of n) {
                    if (t === "attributes" && (e === "class" || e === "style")) {
                        throw new ss["a"]("viewconsumable-invalid-attribute", this)
                    }
                    i.set(e, true);
                    if (t === "styles") {
                        for (const t of this.element.document.stylesProcessor.getRelatedStyles(e)) {
                            i.set(t, true)
                        }
                    }
                }
            }

            _test(t, e) {
                const n = Ye(e) ? e : [e];
                const i = this._consumables[t];
                for (const e of n) {
                    if (t === "attributes" && (e === "class" || e === "style")) {
                        const t = e == "class" ? "classes" : "styles";
                        const n = this._test(t, [...this._consumables[t].keys()]);
                        if (n !== true) {
                            return n
                        }
                    } else {
                        const t = i.get(e);
                        if (t === undefined) {
                            return null
                        }
                        if (!t) {
                            return false
                        }
                    }
                }
                return true
            }

            _consume(t, e) {
                const n = Ye(e) ? e : [e];
                const i = this._consumables[t];
                for (const e of n) {
                    if (t === "attributes" && (e === "class" || e === "style")) {
                        const t = e == "class" ? "classes" : "styles";
                        this._consume(t, [...this._consumables[t].keys()])
                    } else {
                        i.set(e, false);
                        if (t == "styles") {
                            for (const t of this.element.document.stylesProcessor.getRelatedStyles(e)) {
                                i.set(t, false)
                            }
                        }
                    }
                }
            }

            _revert(t, e) {
                const n = Ye(e) ? e : [e];
                const i = this._consumables[t];
                for (const e of n) {
                    if (t === "attributes" && (e === "class" || e === "style")) {
                        const t = e == "class" ? "classes" : "styles";
                        this._revert(t, [...this._consumables[t].keys()])
                    } else {
                        const t = i.get(e);
                        if (t === false) {
                            i.set(e, true)
                        }
                    }
                }
            }
        }

        class Lg {
            constructor() {
                this._sourceDefinitions = {};
                this._attributeProperties = {};
                this.decorate("checkChild");
                this.decorate("checkAttribute");
                this.on("checkAttribute", ((t, e) => {
                    e[0] = new zg(e[0])
                }), {priority: "highest"});
                this.on("checkChild", ((t, e) => {
                    e[0] = new zg(e[0]);
                    e[1] = this.getDefinition(e[1])
                }), {priority: "highest"})
            }

            register(t, e) {
                if (this._sourceDefinitions[t]) {
                    throw new ss["a"]("schema-cannot-register-item-twice", this, {itemName: t})
                }
                this._sourceDefinitions[t] = [Object.assign({}, e)];
                this._clearCache()
            }

            extend(t, e) {
                if (!this._sourceDefinitions[t]) {
                    throw new ss["a"]("schema-cannot-extend-missing-item", this, {itemName: t})
                }
                this._sourceDefinitions[t].push(Object.assign({}, e));
                this._clearCache()
            }

            getDefinitions() {
                if (!this._compiledDefinitions) {
                    this._compile()
                }
                return this._compiledDefinitions
            }

            getDefinition(t) {
                let e;
                if (typeof t == "string") {
                    e = t
                } else if (t.is && (t.is("$text") || t.is("$textProxy"))) {
                    e = "$text"
                } else {
                    e = t.name
                }
                return this.getDefinitions()[e]
            }

            isRegistered(t) {
                return !!this.getDefinition(t)
            }

            isBlock(t) {
                const e = this.getDefinition(t);
                return !!(e && e.isBlock)
            }

            isLimit(t) {
                const e = this.getDefinition(t);
                if (!e) {
                    return false
                }
                return !!(e.isLimit || e.isObject)
            }

            isObject(t) {
                const e = this.getDefinition(t);
                if (!e) {
                    return false
                }
                return !!(e.isObject || e.isLimit && e.isSelectable && e.isContent)
            }

            isInline(t) {
                const e = this.getDefinition(t);
                return !!(e && e.isInline)
            }

            isSelectable(t) {
                const e = this.getDefinition(t);
                if (!e) {
                    return false
                }
                return !!(e.isSelectable || e.isObject)
            }

            isContent(t) {
                const e = this.getDefinition(t);
                if (!e) {
                    return false
                }
                return !!(e.isContent || e.isObject)
            }

            checkChild(t, e) {
                if (!e) {
                    return false
                }
                return this._checkContextMatch(e, t)
            }

            checkAttribute(t, e) {
                const n = this.getDefinition(t.last);
                if (!n) {
                    return false
                }
                return n.allowAttributes.includes(e)
            }

            checkMerge(t, e = null) {
                if (t instanceof Qh) {
                    const e = t.nodeBefore;
                    const n = t.nodeAfter;
                    if (!(e instanceof Kh)) {
                        throw new ss["a"]("schema-check-merge-no-element-before", this)
                    }
                    if (!(n instanceof Kh)) {
                        throw new ss["a"]("schema-check-merge-no-element-after", this)
                    }
                    return this.checkMerge(e, n)
                }
                for (const n of e.getChildren()) {
                    if (!this.checkChild(t, n)) {
                        return false
                    }
                }
                return true
            }

            addChildCheck(t) {
                this.on("checkChild", ((e, [n, i]) => {
                    if (!i) {
                        return
                    }
                    const o = t(n, i);
                    if (typeof o == "boolean") {
                        e.stop();
                        e.return = o
                    }
                }), {priority: "high"})
            }

            addAttributeCheck(t) {
                this.on("checkAttribute", ((e, [n, i]) => {
                    const o = t(n, i);
                    if (typeof o == "boolean") {
                        e.stop();
                        e.return = o
                    }
                }), {priority: "high"})
            }

            setAttributeProperties(t, e) {
                this._attributeProperties[t] = Object.assign(this.getAttributeProperties(t), e)
            }

            getAttributeProperties(t) {
                return this._attributeProperties[t] || {}
            }

            getLimitElement(t) {
                let e;
                if (t instanceof Qh) {
                    e = t.parent
                } else {
                    const n = t instanceof tm ? [t] : Array.from(t.getRanges());
                    e = n.reduce(((t, e) => {
                        const n = e.getCommonAncestor();
                        if (!t) {
                            return n
                        }
                        return t.getCommonAncestor(n, {includeSelf: true})
                    }), null)
                }
                while (!this.isLimit(e)) {
                    if (e.parent) {
                        e = e.parent
                    } else {
                        break
                    }
                }
                return e
            }

            checkAttributeInSelection(t, e) {
                if (t.isCollapsed) {
                    const n = t.getFirstPosition();
                    const i = [...n.getAncestors(), new Uh("", t.getAttributes())];
                    return this.checkAttribute(i, e)
                } else {
                    const n = t.getRanges();
                    for (const t of n) {
                        for (const n of t) {
                            if (this.checkAttribute(n.item, e)) {
                                return true
                            }
                        }
                    }
                }
                return false
            }

            * getValidRanges(t, e) {
                t = Yg(t);
                for (const n of t) {
                    yield* this._getValidRangesForRange(n, e)
                }
            }

            getNearestSelectionRange(t, e = "both") {
                if (this.checkChild(t, "$text")) {
                    return new tm(t)
                }
                let n, i;
                const o = t.getAncestors().reverse().find((t => this.isLimit(t))) || t.root;
                if (e == "both" || e == "backward") {
                    n = new $h({boundaries: tm._createIn(o), startPosition: t, direction: "backward"})
                }
                if (e == "both" || e == "forward") {
                    i = new $h({boundaries: tm._createIn(o), startPosition: t})
                }
                for (const t of $g(n, i)) {
                    const e = t.walker == n ? "elementEnd" : "elementStart";
                    const i = t.value;
                    if (i.type == e && this.isObject(i.item)) {
                        return tm._createOn(i.item)
                    }
                    if (this.checkChild(i.nextPosition, "$text")) {
                        return new tm(i.nextPosition)
                    }
                }
                return null
            }

            findAllowedParent(t, e) {
                let n = t.parent;
                while (n) {
                    if (this.checkChild(n, e)) {
                        return n
                    }
                    if (this.isLimit(n)) {
                        return null
                    }
                    n = n.parent
                }
                return null
            }

            removeDisallowedAttributes(t, e) {
                for (const n of t) {
                    if (n.is("$text")) {
                        Qg(this, n, e)
                    } else {
                        const t = tm._createIn(n);
                        const i = t.getPositions();
                        for (const t of i) {
                            const n = t.nodeBefore || t.parent;
                            Qg(this, n, e)
                        }
                    }
                }
            }

            createContext(t) {
                return new zg(t)
            }

            _clearCache() {
                this._compiledDefinitions = null
            }

            _compile() {
                const t = {};
                const e = this._sourceDefinitions;
                const n = Object.keys(e);
                for (const i of n) {
                    t[i] = Ng(e[i], i)
                }
                for (const e of n) {
                    Pg(t, e)
                }
                for (const e of n) {
                    Og(t, e)
                }
                for (const e of n) {
                    jg(t, e);
                    Rg(t, e)
                }
                for (const e of n) {
                    Fg(t, e);
                    Vg(t, e)
                }
                this._compiledDefinitions = t
            }

            _checkContextMatch(t, e, n = e.length - 1) {
                const i = e.getItem(n);
                if (t.allowIn.includes(i.name)) {
                    if (n == 0) {
                        return true
                    } else {
                        const t = this.getDefinition(i);
                        return this._checkContextMatch(t, e, n - 1)
                    }
                } else {
                    return false
                }
            }

            * _getValidRangesForRange(t, e) {
                let n = t.start;
                let i = t.start;
                for (const o of t.getItems({shallow: true})) {
                    if (o.is("element")) {
                        yield* this._getValidRangesForRange(tm._createIn(o), e)
                    }
                    if (!this.checkAttribute(o, e)) {
                        if (!n.isEqual(i)) {
                            yield new tm(n, i)
                        }
                        n = Qh._createAfter(o)
                    }
                    i = Qh._createAfter(o)
                }
                if (!n.isEqual(i)) {
                    yield new tm(n, i)
                }
            }
        }

        Cs(Lg, Qc);

        class zg {
            constructor(t) {
                if (t instanceof zg) {
                    return t
                }
                if (typeof t == "string") {
                    t = [t]
                } else if (!Array.isArray(t)) {
                    t = t.getAncestors({includeSelf: true})
                }
                if (t[0] && typeof t[0] != "string" && t[0].is("documentFragment")) {
                    t.shift()
                }
                this._items = t.map(Gg)
            }

            get length() {
                return this._items.length
            }

            get last() {
                return this._items[this._items.length - 1]
            }

            [Symbol.iterator]() {
                return this._items[Symbol.iterator]()
            }

            push(t) {
                const e = new zg([t]);
                e._items = [...this._items, ...e._items];
                return e
            }

            getItem(t) {
                return this._items[t]
            }

            * getNames() {
                yield* this._items.map((t => t.name))
            }

            endsWith(t) {
                return Array.from(this.getNames()).join(" ").endsWith(t)
            }

            startsWith(t) {
                return Array.from(this.getNames()).join(" ").startsWith(t)
            }
        }

        function Ng(t, e) {
            const n = {
                name: e,
                allowIn: [],
                allowContentOf: [],
                allowWhere: [],
                allowAttributes: [],
                allowAttributesOf: [],
                inheritTypesFrom: []
            };
            Hg(t, n);
            Ug(t, n, "allowIn");
            Ug(t, n, "allowContentOf");
            Ug(t, n, "allowWhere");
            Ug(t, n, "allowAttributes");
            Ug(t, n, "allowAttributesOf");
            Ug(t, n, "inheritTypesFrom");
            Wg(t, n);
            return n
        }

        function Pg(t, e) {
            for (const n of t[e].allowContentOf) {
                if (t[n]) {
                    const i = qg(t, n);
                    i.forEach((t => {
                        t.allowIn.push(e)
                    }))
                }
            }
            delete t[e].allowContentOf
        }

        function Og(t, e) {
            for (const n of t[e].allowWhere) {
                const i = t[n];
                if (i) {
                    const n = i.allowIn;
                    t[e].allowIn.push(...n)
                }
            }
            delete t[e].allowWhere
        }

        function jg(t, e) {
            for (const n of t[e].allowAttributesOf) {
                const i = t[n];
                if (i) {
                    const n = i.allowAttributes;
                    t[e].allowAttributes.push(...n)
                }
            }
            delete t[e].allowAttributesOf
        }

        function Rg(t, e) {
            const n = t[e];
            for (const e of n.inheritTypesFrom) {
                const i = t[e];
                if (i) {
                    const t = Object.keys(i).filter((t => t.startsWith("is")));
                    for (const e of t) {
                        if (!(e in n)) {
                            n[e] = i[e]
                        }
                    }
                }
            }
            delete n.inheritTypesFrom
        }

        function Fg(t, e) {
            const n = t[e];
            const i = n.allowIn.filter((e => t[e]));
            n.allowIn = Array.from(new Set(i))
        }

        function Vg(t, e) {
            const n = t[e];
            n.allowAttributes = Array.from(new Set(n.allowAttributes))
        }

        function Hg(t, e) {
            for (const n of t) {
                const t = Object.keys(n).filter((t => t.startsWith("is")));
                for (const i of t) {
                    e[i] = n[i]
                }
            }
        }

        function Ug(t, e, n) {
            for (const i of t) {
                if (typeof i[n] == "string") {
                    e[n].push(i[n])
                } else if (Array.isArray(i[n])) {
                    e[n].push(...i[n])
                }
            }
        }

        function Wg(t, e) {
            for (const n of t) {
                const t = n.inheritAllFrom;
                if (t) {
                    e.allowContentOf.push(t);
                    e.allowWhere.push(t);
                    e.allowAttributesOf.push(t);
                    e.inheritTypesFrom.push(t)
                }
            }
        }

        function qg(t, e) {
            const n = t[e];
            return Kg(t).filter((t => t.allowIn.includes(n.name)))
        }

        function Kg(t) {
            return Object.keys(t).map((e => t[e]))
        }

        function Gg(t) {
            if (typeof t == "string") {
                return {
                    name: t, * getAttributeKeys() {
                    }, getAttribute() {
                    }
                }
            } else {
                return {
                    name: t.is("element") ? t.name : "$text", * getAttributeKeys() {
                        yield* t.getAttributeKeys()
                    }, getAttribute(e) {
                        return t.getAttribute(e)
                    }
                }
            }
        }

        function* $g(t, e) {
            let n = false;
            while (!n) {
                n = true;
                if (t) {
                    const e = t.next();
                    if (!e.done) {
                        n = false;
                        yield{walker: t, value: e.value}
                    }
                }
                if (e) {
                    const t = e.next();
                    if (!t.done) {
                        n = false;
                        yield{walker: e, value: t.value}
                    }
                }
            }
        }

        function* Yg(t) {
            for (const e of t) {
                yield* e.getMinimalFlatRanges()
            }
        }

        function Qg(t, e, n) {
            for (const i of e.getAttributeKeys()) {
                if (!t.checkAttribute(e, i)) {
                    n.removeAttribute(i, e)
                }
            }
        }

        class Jg {
            constructor(t = {}) {
                this._splitParts = new Map;
                this._cursorParents = new Map;
                this._modelCursor = null;
                this.conversionApi = Object.assign({}, t);
                this.conversionApi.convertItem = this._convertItem.bind(this);
                this.conversionApi.convertChildren = this._convertChildren.bind(this);
                this.conversionApi.safeInsert = this._safeInsert.bind(this);
                this.conversionApi.updateConversionResult = this._updateConversionResult.bind(this);
                this.conversionApi.splitToAllowedParent = this._splitToAllowedParent.bind(this);
                this.conversionApi.getSplitParts = this._getSplitParts.bind(this)
            }

            convert(t, e, n = ["$root"]) {
                this.fire("viewCleanup", t);
                this._modelCursor = Zg(n, e);
                this.conversionApi.writer = e;
                this.conversionApi.consumable = Ig.createFrom(t);
                this.conversionApi.store = {};
                const {modelRange: i} = this._convertItem(t, this._modelCursor);
                const o = e.createDocumentFragment();
                if (i) {
                    this._removeEmptyElements();
                    for (const t of Array.from(this._modelCursor.parent.getChildren())) {
                        e.append(t, o)
                    }
                    o.markers = Xg(o, e)
                }
                this._modelCursor = null;
                this._splitParts.clear();
                this._cursorParents.clear();
                this.conversionApi.writer = null;
                this.conversionApi.store = null;
                return o
            }

            _convertItem(t, e) {
                const n = Object.assign({viewItem: t, modelCursor: e, modelRange: null});
                if (t.is("element")) {
                    this.fire("element:" + t.name, n, this.conversionApi)
                } else if (t.is("$text")) {
                    this.fire("text", n, this.conversionApi)
                } else {
                    this.fire("documentFragment", n, this.conversionApi)
                }
                if (n.modelRange && !(n.modelRange instanceof tm)) {
                    throw new ss["a"]("view-conversion-dispatcher-incorrect-result", this)
                }
                return {modelRange: n.modelRange, modelCursor: n.modelCursor}
            }

            _convertChildren(t, e) {
                let n = e.is("position") ? e : Qh._createAt(e, 0);
                const i = new tm(n);
                for (const e of Array.from(t.getChildren())) {
                    const t = this._convertItem(e, n);
                    if (t.modelRange instanceof tm) {
                        i.end = t.modelRange.end;
                        n = t.modelCursor
                    }
                }
                return {modelRange: i, modelCursor: n}
            }

            _safeInsert(t, e) {
                const n = this._splitToAllowedParent(t, e);
                if (!n) {
                    return false
                }
                this.conversionApi.writer.insert(t, n.position);
                return true
            }

            _updateConversionResult(t, e) {
                const n = this._getSplitParts(t);
                const i = this.conversionApi.writer;
                if (!e.modelRange) {
                    e.modelRange = i.createRange(i.createPositionBefore(t), i.createPositionAfter(n[n.length - 1]))
                }
                const o = this._cursorParents.get(t);
                if (o) {
                    e.modelCursor = i.createPositionAt(o, 0)
                } else {
                    e.modelCursor = e.modelRange.end
                }
            }

            _splitToAllowedParent(t, e) {
                const {schema: n, writer: i} = this.conversionApi;
                let o = n.findAllowedParent(e, t);
                if (o) {
                    if (o === e.parent) {
                        return {position: e}
                    }
                    if (this._modelCursor.parent.getAncestors().includes(o)) {
                        o = null
                    }
                }
                if (!o) {
                    if (!ag(e, t, n)) {
                        return null
                    }
                    return {position: cg(e, i)}
                }
                const r = this.conversionApi.writer.split(e, o);
                const s = [];
                for (const t of r.range.getWalker()) {
                    if (t.type == "elementEnd") {
                        s.push(t.item)
                    } else {
                        const e = s.pop();
                        const n = t.item;
                        this._registerSplitPair(e, n)
                    }
                }
                const a = r.range.end.parent;
                this._cursorParents.set(t, a);
                return {position: r.position, cursorParent: a}
            }

            _registerSplitPair(t, e) {
                if (!this._splitParts.has(t)) {
                    this._splitParts.set(t, [t])
                }
                const n = this._splitParts.get(t);
                this._splitParts.set(e, n);
                n.push(e)
            }

            _getSplitParts(t) {
                let e;
                if (!this._splitParts.has(t)) {
                    e = [t]
                } else {
                    e = this._splitParts.get(t)
                }
                return e
            }

            _removeEmptyElements() {
                let t = false;
                for (const e of this._splitParts.keys()) {
                    if (e.isEmpty) {
                        this.conversionApi.writer.remove(e);
                        this._splitParts.delete(e);
                        t = true
                    }
                }
                if (t) {
                    this._removeEmptyElements()
                }
            }
        }

        Cs(Jg, ds);

        function Xg(t, e) {
            const n = new Set;
            const i = new Map;
            const o = tm._createIn(t).getItems();
            for (const t of o) {
                if (t.name == "$marker") {
                    n.add(t)
                }
            }
            for (const t of n) {
                const n = t.getAttribute("data-name");
                const o = e.createPositionBefore(t);
                if (!i.has(n)) {
                    i.set(n, new tm(o.clone()))
                } else {
                    i.get(n).end = o.clone()
                }
                e.remove(t)
            }
            return i
        }

        function Zg(t, e) {
            let n;
            for (const i of new zg(t)) {
                const t = {};
                for (const e of i.getAttributeKeys()) {
                    t[e] = i.getAttribute(e)
                }
                const o = e.createElement(i.name, t);
                if (n) {
                    e.append(o, n)
                }
                n = Qh._createAt(o, 0)
            }
            return n
        }

        class tf {
            constructor(t, e) {
                this.model = t;
                this.stylesProcessor = e;
                this.processor = undefined;
                this.mapper = new em;
                this.downcastDispatcher = new om({mapper: this.mapper, schema: t.schema});
                this.downcastDispatcher.on("insert:$text", Sm(), {priority: "lowest"});
                this.upcastDispatcher = new Jg({schema: t.schema});
                this.viewDocument = new bl(e);
                this._viewWriter = new Xl(this.viewDocument);
                this.upcastDispatcher.on("text", ug(), {priority: "lowest"});
                this.upcastDispatcher.on("element", dg(), {priority: "lowest"});
                this.upcastDispatcher.on("documentFragment", dg(), {priority: "lowest"});
                this.decorate("init");
                this.decorate("set");
                this.on("init", (() => {
                    this.fire("ready")
                }), {priority: "lowest"});
                this.on("ready", (() => {
                    this.model.enqueueChange("transparent", sg)
                }), {priority: "lowest"})
            }

            get(t = {}) {
                const {rootName: e = "main", trim: n = "empty"} = t;
                if (!this._checkIfRootsExists([e])) {
                    throw new ss["a"]("datacontroller-get-non-existent-root", this)
                }
                const i = this.model.document.getRoot(e);
                if (n === "empty" && !this.model.hasContent(i, {ignoreWhitespaces: true})) {
                    return ""
                }
                return this.stringify(i, t)
            }

            stringify(t, e) {
                const n = this.toView(t, e);
                return this.processor.toData(n)
            }

            toView(t, e) {
                const n = this.viewDocument;
                const i = this._viewWriter;
                this.mapper.clearBindings();
                const o = tm._createIn(t);
                const r = new Ql(n);
                this.mapper.bindElements(t, r);
                this.downcastDispatcher.conversionApi.options = e;
                this.downcastDispatcher.convertInsert(o, i);
                if (!t.is("documentFragment")) {
                    const e = ef(t);
                    for (const [t, n] of e) {
                        this.downcastDispatcher.convertMarkerAdd(t, n, i)
                    }
                }
                delete this.downcastDispatcher.conversionApi.options;
                return r
            }

            init(t) {
                if (this.model.document.version) {
                    throw new ss["a"]("datacontroller-init-document-not-empty", this)
                }
                let e = {};
                if (typeof t === "string") {
                    e.main = t
                } else {
                    e = t
                }
                if (!this._checkIfRootsExists(Object.keys(e))) {
                    throw new ss["a"]("datacontroller-init-non-existent-root", this)
                }
                this.model.enqueueChange("transparent", (t => {
                    for (const n of Object.keys(e)) {
                        const i = this.model.document.getRoot(n);
                        t.insert(this.parse(e[n], i), i, 0)
                    }
                }));
                return Promise.resolve()
            }

            set(t) {
                let e = {};
                if (typeof t === "string") {
                    e.main = t
                } else {
                    e = t
                }
                if (!this._checkIfRootsExists(Object.keys(e))) {
                    throw new ss["a"]("datacontroller-set-non-existent-root", this)
                }
                this.model.enqueueChange("transparent", (t => {
                    t.setSelection(null);
                    t.removeSelectionAttribute(this.model.document.selection.getAttributeKeys());
                    for (const n of Object.keys(e)) {
                        const i = this.model.document.getRoot(n);
                        t.remove(t.createRangeIn(i));
                        t.insert(this.parse(e[n], i), i, 0)
                    }
                }))
            }

            parse(t, e = "$root") {
                const n = this.processor.toView(t);
                return this.toModel(n, e)
            }

            toModel(t, e = "$root") {
                return this.model.change((n => this.upcastDispatcher.convert(t, n, e)))
            }

            addStyleProcessorRules(t) {
                t(this.stylesProcessor)
            }

            destroy() {
                this.stopListening()
            }

            _checkIfRootsExists(t) {
                for (const e of t) {
                    if (!this.model.document.getRootNames().includes(e)) {
                        return false
                    }
                }
                return true
            }
        }

        Cs(tf, Qc);

        function ef(t) {
            const e = [];
            const n = t.root.document;
            if (!n) {
                return []
            }
            const i = tm._createIn(t);
            for (const t of n.model.markers) {
                const n = i.getIntersection(t.getRange());
                if (n) {
                    e.push([t.name, n])
                }
            }
            return e
        }

        class nf {
            constructor(t, e) {
                this._helpers = new Map;
                this._downcast = Array.isArray(t) ? t : [t];
                this._createConversionHelpers({name: "downcast", dispatchers: this._downcast, isDowncast: true});
                this._upcast = Array.isArray(e) ? e : [e];
                this._createConversionHelpers({name: "upcast", dispatchers: this._upcast, isDowncast: false})
            }

            addAlias(t, e) {
                const n = this._downcast.includes(e);
                const i = this._upcast.includes(e);
                if (!i && !n) {
                    throw new ss["a"]("conversion-add-alias-dispatcher-not-registered", this)
                }
                this._createConversionHelpers({name: t, dispatchers: [e], isDowncast: n})
            }

            for(t) {
                if (!this._helpers.has(t)) {
                    throw new ss["a"]("conversion-for-unknown-group", this)
                }
                return this._helpers.get(t)
            }

            elementToElement(t) {
                this.for("downcast").elementToElement(t);
                for (const {model: e, view: n} of of(t)) {
                    this.for("upcast").elementToElement({model: e, view: n, converterPriority: t.converterPriority})
                }
            }

            attributeToElement(t) {
                this.for("downcast").attributeToElement(t);
                for (const {model: e, view: n} of of(t)) {
                    this.for("upcast").elementToAttribute({view: n, model: e, converterPriority: t.converterPriority})
                }
            }

            attributeToAttribute(t) {
                this.for("downcast").attributeToAttribute(t);
                for (const {model: e, view: n} of of(t)) {
                    this.for("upcast").attributeToAttribute({view: n, model: e})
                }
            }

            _createConversionHelpers({name: t, dispatchers: e, isDowncast: n}) {
                if (this._helpers.has(t)) {
                    throw new ss["a"]("conversion-group-exists", this)
                }
                const i = n ? new Mm(e) : new lg(e);
                this._helpers.set(t, i)
            }
        }

        function* of(t) {
            if (t.model.values) {
                for (const e of t.model.values) {
                    const n = {key: t.model.key, value: e};
                    const i = t.view[e];
                    const o = t.upcastAlso ? t.upcastAlso[e] : undefined;
                    yield* rf(n, i, o)
                }
            } else {
                yield* rf(t.model, t.view, t.upcastAlso)
            }
        }

        function* rf(t, e, n) {
            yield{model: t, view: e};
            if (n) {
                n = Array.isArray(n) ? n : [n];
                for (const e of n) {
                    yield{model: t, view: e}
                }
            }
        }

        class sf {
            constructor(t = "default") {
                this.operations = [];
                this.type = t
            }

            get baseVersion() {
                for (const t of this.operations) {
                    if (t.baseVersion !== null) {
                        return t.baseVersion
                    }
                }
                return null
            }

            addOperation(t) {
                t.batch = this;
                this.operations.push(t);
                return t
            }
        }

        class af {
            constructor(t) {
                this.baseVersion = t;
                this.isDocumentOperation = this.baseVersion !== null;
                this.batch = null
            }

            _validate() {
            }

            toJSON() {
                const t = Object.assign({}, this);
                t.__className = this.constructor.className;
                delete t.batch;
                delete t.isDocumentOperation;
                return t
            }

            static get className() {
                return "Operation"
            }

            static fromJSON(t) {
                return new this(t.baseVersion)
            }
        }

        class cf {
            constructor(t) {
                this.markers = new Map;
                this._children = new qh;
                if (t) {
                    this._insertChild(0, t)
                }
            }

            [Symbol.iterator]() {
                return this.getChildren()
            }

            get childCount() {
                return this._children.length
            }

            get maxOffset() {
                return this._children.maxOffset
            }

            get isEmpty() {
                return this.childCount === 0
            }

            get root() {
                return this
            }

            get parent() {
                return null
            }

            is(t) {
                return t === "documentFragment" || t === "model:documentFragment"
            }

            getChild(t) {
                return this._children.getNode(t)
            }

            getChildren() {
                return this._children[Symbol.iterator]()
            }

            getChildIndex(t) {
                return this._children.getNodeIndex(t)
            }

            getChildStartOffset(t) {
                return this._children.getNodeStartOffset(t)
            }

            getPath() {
                return []
            }

            getNodeByPath(t) {
                let e = this;
                for (const n of t) {
                    e = e.getChild(e.offsetToIndex(n))
                }
                return e
            }

            offsetToIndex(t) {
                return this._children.offsetToIndex(t)
            }

            toJSON() {
                const t = [];
                for (const e of this._children) {
                    t.push(e.toJSON())
                }
                return t
            }

            static fromJSON(t) {
                const e = [];
                for (const n of t) {
                    if (n.name) {
                        e.push(Kh.fromJSON(n))
                    } else {
                        e.push(Uh.fromJSON(n))
                    }
                }
                return new cf(e)
            }

            _appendChild(t) {
                this._insertChild(this.childCount, t)
            }

            _insertChild(t, e) {
                const n = lf(e);
                for (const t of n) {
                    if (t.parent !== null) {
                        t._remove()
                    }
                    t.parent = this
                }
                this._children._insertNodes(t, n)
            }

            _removeChildren(t, e = 1) {
                const n = this._children._removeNodes(t, e);
                for (const t of n) {
                    t.parent = null
                }
                return n
            }
        }

        function lf(t) {
            if (typeof t == "string") {
                return [new Uh(t)]
            }
            if (!_s(t)) {
                t = [t]
            }
            return Array.from(t).map((t => {
                if (typeof t == "string") {
                    return new Uh(t)
                }
                if (t instanceof Wh) {
                    return new Uh(t.data, t.getAttributes())
                }
                return t
            }))
        }

        function df(t, e) {
            e = gf(e);
            const n = e.reduce(((t, e) => t + e.offsetSize), 0);
            const i = t.parent;
            pf(t);
            const o = t.index;
            i._insertChild(o, e);
            ff(i, o + e.length);
            ff(i, o);
            return new tm(t, t.getShiftedBy(n))
        }

        function uf(t) {
            if (!t.isFlat) {
                throw new ss["a"]("operation-utils-remove-range-not-flat", this)
            }
            const e = t.start.parent;
            pf(t.start);
            pf(t.end);
            const n = e._removeChildren(t.start.index, t.end.index - t.start.index);
            ff(e, t.start.index);
            return n
        }

        function hf(t, e) {
            if (!t.isFlat) {
                throw new ss["a"]("operation-utils-move-range-not-flat", this)
            }
            const n = uf(t);
            e = e._getTransformedByDeletion(t.start, t.end.offset - t.start.offset);
            return df(e, n)
        }

        function mf(t, e, n) {
            pf(t.start);
            pf(t.end);
            for (const i of t.getItems({shallow: true})) {
                const t = i.is("$textProxy") ? i.textNode : i;
                if (n !== null) {
                    t._setAttribute(e, n)
                } else {
                    t._removeAttribute(e)
                }
                ff(t.parent, t.index)
            }
            ff(t.end.parent, t.end.index)
        }

        function gf(t) {
            const e = [];
            if (!(t instanceof Array)) {
                t = [t]
            }
            for (let n = 0; n < t.length; n++) {
                if (typeof t[n] == "string") {
                    e.push(new Uh(t[n]))
                } else if (t[n] instanceof Wh) {
                    e.push(new Uh(t[n].data, t[n].getAttributes()))
                } else if (t[n] instanceof cf || t[n] instanceof qh) {
                    for (const i of t[n]) {
                        e.push(i)
                    }
                } else if (t[n] instanceof Hh) {
                    e.push(t[n])
                }
            }
            for (let t = 1; t < e.length; t++) {
                const n = e[t];
                const i = e[t - 1];
                if (n instanceof Uh && i instanceof Uh && bf(n, i)) {
                    e.splice(t - 1, 2, new Uh(i.data + n.data, i.getAttributes()));
                    t--
                }
            }
            return e
        }

        function ff(t, e) {
            const n = t.getChild(e - 1);
            const i = t.getChild(e);
            if (n && i && n.is("$text") && i.is("$text") && bf(n, i)) {
                const o = new Uh(n.data + i.data, n.getAttributes());
                t._removeChildren(e - 1, 2);
                t._insertChild(e - 1, o)
            }
        }

        function pf(t) {
            const e = t.textNode;
            const n = t.parent;
            if (e) {
                const i = t.offset - e.startOffset;
                const o = e.index;
                n._removeChildren(o, 1);
                const r = new Uh(e.data.substr(0, i), e.getAttributes());
                const s = new Uh(e.data.substr(i), e.getAttributes());
                n._insertChild(o, [r, s])
            }
        }

        function bf(t, e) {
            const n = t.getAttributes();
            const i = e.getAttributes();
            for (const t of n) {
                if (t[1] !== e.getAttribute(t[0])) {
                    return false
                }
                i.next()
            }
            return i.next().done
        }

        function kf(t, e) {
            return Qu(t, e)
        }

        var wf = kf;

        class Af extends af {
            constructor(t, e, n, i, o) {
                super(o);
                this.range = t.clone();
                this.key = e;
                this.oldValue = n === undefined ? null : n;
                this.newValue = i === undefined ? null : i
            }

            get type() {
                if (this.oldValue === null) {
                    return "addAttribute"
                } else if (this.newValue === null) {
                    return "removeAttribute"
                } else {
                    return "changeAttribute"
                }
            }

            clone() {
                return new Af(this.range, this.key, this.oldValue, this.newValue, this.baseVersion)
            }

            getReversed() {
                return new Af(this.range, this.key, this.newValue, this.oldValue, this.baseVersion + 1)
            }

            toJSON() {
                const t = super.toJSON();
                t.range = this.range.toJSON();
                return t
            }

            _validate() {
                if (!this.range.isFlat) {
                    throw new ss["a"]("attribute-operation-range-not-flat", this)
                }
                for (const t of this.range.getItems({shallow: true})) {
                    if (this.oldValue !== null && !wf(t.getAttribute(this.key), this.oldValue)) {
                        throw new ss["a"]("attribute-operation-wrong-old-value", this, {
                            item: t,
                            key: this.key,
                            value: this.oldValue
                        })
                    }
                    if (this.oldValue === null && this.newValue !== null && t.hasAttribute(this.key)) {
                        throw new ss["a"]("attribute-operation-attribute-exists", this, {node: t, key: this.key})
                    }
                }
            }

            _execute() {
                if (!wf(this.oldValue, this.newValue)) {
                    mf(this.range, this.key, this.newValue)
                }
            }

            static get className() {
                return "AttributeOperation"
            }

            static fromJSON(t, e) {
                return new Af(tm.fromJSON(t.range, e), t.key, t.oldValue, t.newValue, t.baseVersion)
            }
        }

        class _f extends af {
            constructor(t, e) {
                super(null);
                this.sourcePosition = t.clone();
                this.howMany = e
            }

            get type() {
                return "detach"
            }

            toJSON() {
                const t = super.toJSON();
                t.sourcePosition = this.sourcePosition.toJSON();
                return t
            }

            _validate() {
                if (this.sourcePosition.root.document) {
                    throw new ss["a"]("detach-operation-on-document-node", this)
                }
            }

            _execute() {
                uf(tm._createFromPositionAndShift(this.sourcePosition, this.howMany))
            }

            static get className() {
                return "DetachOperation"
            }
        }

        class Cf extends af {
            constructor(t, e, n, i) {
                super(i);
                this.sourcePosition = t.clone();
                this.sourcePosition.stickiness = "toNext";
                this.howMany = e;
                this.targetPosition = n.clone();
                this.targetPosition.stickiness = "toNone"
            }

            get type() {
                if (this.targetPosition.root.rootName == "$graveyard") {
                    return "remove"
                } else if (this.sourcePosition.root.rootName == "$graveyard") {
                    return "reinsert"
                }
                return "move"
            }

            clone() {
                return new this.constructor(this.sourcePosition, this.howMany, this.targetPosition, this.baseVersion)
            }

            getMovedRangeStart() {
                return this.targetPosition._getTransformedByDeletion(this.sourcePosition, this.howMany)
            }

            getReversed() {
                const t = this.sourcePosition._getTransformedByInsertion(this.targetPosition, this.howMany);
                return new this.constructor(this.getMovedRangeStart(), this.howMany, t, this.baseVersion + 1)
            }

            _validate() {
                const t = this.sourcePosition.parent;
                const e = this.targetPosition.parent;
                const n = this.sourcePosition.offset;
                const i = this.targetPosition.offset;
                if (n + this.howMany > t.maxOffset) {
                    throw new ss["a"]("move-operation-nodes-do-not-exist", this)
                } else if (t === e && n < i && i < n + this.howMany) {
                    throw new ss["a"]("move-operation-range-into-itself", this)
                } else if (this.sourcePosition.root == this.targetPosition.root) {
                    if (Ns(this.sourcePosition.getParentPath(), this.targetPosition.getParentPath()) == "prefix") {
                        const t = this.sourcePosition.path.length - 1;
                        if (this.targetPosition.path[t] >= n && this.targetPosition.path[t] < n + this.howMany) {
                            throw new ss["a"]("move-operation-node-into-itself", this)
                        }
                    }
                }
            }

            _execute() {
                hf(tm._createFromPositionAndShift(this.sourcePosition, this.howMany), this.targetPosition)
            }

            toJSON() {
                const t = super.toJSON();
                t.sourcePosition = this.sourcePosition.toJSON();
                t.targetPosition = this.targetPosition.toJSON();
                return t
            }

            static get className() {
                return "MoveOperation"
            }

            static fromJSON(t, e) {
                const n = Qh.fromJSON(t.sourcePosition, e);
                const i = Qh.fromJSON(t.targetPosition, e);
                return new this(n, t.howMany, i, t.baseVersion)
            }
        }

        class vf extends af {
            constructor(t, e, n) {
                super(n);
                this.position = t.clone();
                this.position.stickiness = "toNone";
                this.nodes = new qh(gf(e));
                this.shouldReceiveAttributes = false
            }

            get type() {
                return "insert"
            }

            get howMany() {
                return this.nodes.maxOffset
            }

            clone() {
                const t = new qh([...this.nodes].map((t => t._clone(true))));
                const e = new vf(this.position, t, this.baseVersion);
                e.shouldReceiveAttributes = this.shouldReceiveAttributes;
                return e
            }

            getReversed() {
                const t = this.position.root.document.graveyard;
                const e = new Qh(t, [0]);
                return new Cf(this.position, this.nodes.maxOffset, e, this.baseVersion + 1)
            }

            _validate() {
                const t = this.position.parent;
                if (!t || t.maxOffset < this.position.offset) {
                    throw new ss["a"]("insert-operation-position-invalid", this)
                }
            }

            _execute() {
                const t = this.nodes;
                this.nodes = new qh([...t].map((t => t._clone(true))));
                df(this.position, t)
            }

            toJSON() {
                const t = super.toJSON();
                t.position = this.position.toJSON();
                t.nodes = this.nodes.toJSON();
                return t
            }

            static get className() {
                return "InsertOperation"
            }

            static fromJSON(t, e) {
                const n = [];
                for (const e of t.nodes) {
                    if (e.name) {
                        n.push(Kh.fromJSON(e))
                    } else {
                        n.push(Uh.fromJSON(e))
                    }
                }
                const i = new vf(Qh.fromJSON(t.position, e), n, t.baseVersion);
                i.shouldReceiveAttributes = t.shouldReceiveAttributes;
                return i
            }
        }

        class yf extends af {
            constructor(t, e, n, i, o, r) {
                super(r);
                this.name = t;
                this.oldRange = e ? e.clone() : null;
                this.newRange = n ? n.clone() : null;
                this.affectsData = o;
                this._markers = i
            }

            get type() {
                return "marker"
            }

            clone() {
                return new yf(this.name, this.oldRange, this.newRange, this._markers, this.affectsData, this.baseVersion)
            }

            getReversed() {
                return new yf(this.name, this.newRange, this.oldRange, this._markers, this.affectsData, this.baseVersion + 1)
            }

            _execute() {
                const t = this.newRange ? "_set" : "_remove";
                this._markers[t](this.name, this.newRange, true, this.affectsData)
            }

            toJSON() {
                const t = super.toJSON();
                if (this.oldRange) {
                    t.oldRange = this.oldRange.toJSON()
                }
                if (this.newRange) {
                    t.newRange = this.newRange.toJSON()
                }
                delete t._markers;
                return t
            }

            static get className() {
                return "MarkerOperation"
            }

            static fromJSON(t, e) {
                return new yf(t.name, t.oldRange ? tm.fromJSON(t.oldRange, e) : null, t.newRange ? tm.fromJSON(t.newRange, e) : null, e.model.markers, t.affectsData, t.baseVersion)
            }
        }

        class xf extends af {
            constructor(t, e, n, i) {
                super(i);
                this.position = t;
                this.position.stickiness = "toNext";
                this.oldName = e;
                this.newName = n
            }

            get type() {
                return "rename"
            }

            clone() {
                return new xf(this.position.clone(), this.oldName, this.newName, this.baseVersion)
            }

            getReversed() {
                return new xf(this.position.clone(), this.newName, this.oldName, this.baseVersion + 1)
            }

            _validate() {
                const t = this.position.nodeAfter;
                if (!(t instanceof Kh)) {
                    throw new ss["a"]("rename-operation-wrong-position", this)
                } else if (t.name !== this.oldName) {
                    throw new ss["a"]("rename-operation-wrong-name", this)
                }
            }

            _execute() {
                const t = this.position.nodeAfter;
                t.name = this.newName
            }

            toJSON() {
                const t = super.toJSON();
                t.position = this.position.toJSON();
                return t
            }

            static get className() {
                return "RenameOperation"
            }

            static fromJSON(t, e) {
                return new xf(Qh.fromJSON(t.position, e), t.oldName, t.newName, t.baseVersion)
            }
        }

        class Ef extends af {
            constructor(t, e, n, i, o) {
                super(o);
                this.root = t;
                this.key = e;
                this.oldValue = n;
                this.newValue = i
            }

            get type() {
                if (this.oldValue === null) {
                    return "addRootAttribute"
                } else if (this.newValue === null) {
                    return "removeRootAttribute"
                } else {
                    return "changeRootAttribute"
                }
            }

            clone() {
                return new Ef(this.root, this.key, this.oldValue, this.newValue, this.baseVersion)
            }

            getReversed() {
                return new Ef(this.root, this.key, this.newValue, this.oldValue, this.baseVersion + 1)
            }

            _validate() {
                if (this.root != this.root.root || this.root.is("documentFragment")) {
                    throw new ss["a"]("rootattribute-operation-not-a-root", this, {root: this.root, key: this.key})
                }
                if (this.oldValue !== null && this.root.getAttribute(this.key) !== this.oldValue) {
                    throw new ss["a"]("rootattribute-operation-wrong-old-value", this, {root: this.root, key: this.key})
                }
                if (this.oldValue === null && this.newValue !== null && this.root.hasAttribute(this.key)) {
                    throw new ss["a"]("rootattribute-operation-attribute-exists", this, {
                        root: this.root,
                        key: this.key
                    })
                }
            }

            _execute() {
                if (this.newValue !== null) {
                    this.root._setAttribute(this.key, this.newValue)
                } else {
                    this.root._removeAttribute(this.key)
                }
            }

            toJSON() {
                const t = super.toJSON();
                t.root = this.root.toJSON();
                return t
            }

            static get className() {
                return "RootAttributeOperation"
            }

            static fromJSON(t, e) {
                if (!e.getRoot(t.root)) {
                    throw new ss["a"]("rootattribute-operation-fromjson-no-root", this, {rootName: t.root})
                }
                return new Ef(e.getRoot(t.root), t.key, t.oldValue, t.newValue, t.baseVersion)
            }
        }

        class Df extends af {
            constructor(t, e, n, i, o) {
                super(o);
                this.sourcePosition = t.clone();
                this.sourcePosition.stickiness = "toPrevious";
                this.howMany = e;
                this.targetPosition = n.clone();
                this.targetPosition.stickiness = "toNext";
                this.graveyardPosition = i.clone()
            }

            get type() {
                return "merge"
            }

            get deletionPosition() {
                return new Qh(this.sourcePosition.root, this.sourcePosition.path.slice(0, -1))
            }

            get movedRange() {
                const t = this.sourcePosition.getShiftedBy(Number.POSITIVE_INFINITY);
                return new tm(this.sourcePosition, t)
            }

            clone() {
                return new this.constructor(this.sourcePosition, this.howMany, this.targetPosition, this.graveyardPosition, this.baseVersion)
            }

            getReversed() {
                const t = this.targetPosition._getTransformedByMergeOperation(this);
                const e = this.sourcePosition.path.slice(0, -1);
                const n = new Qh(this.sourcePosition.root, e)._getTransformedByMergeOperation(this);
                const i = new Tf(t, this.howMany, this.graveyardPosition, this.baseVersion + 1);
                i.insertionPosition = n;
                return i
            }

            _validate() {
                const t = this.sourcePosition.parent;
                const e = this.targetPosition.parent;
                if (!t.parent) {
                    throw new ss["a"]("merge-operation-source-position-invalid", this)
                } else if (!e.parent) {
                    throw new ss["a"]("merge-operation-target-position-invalid", this)
                } else if (this.howMany != t.maxOffset) {
                    throw new ss["a"]("merge-operation-how-many-invalid", this)
                }
            }

            _execute() {
                const t = this.sourcePosition.parent;
                const e = tm._createIn(t);
                hf(e, this.targetPosition);
                hf(tm._createOn(t), this.graveyardPosition)
            }

            toJSON() {
                const t = super.toJSON();
                t.sourcePosition = t.sourcePosition.toJSON();
                t.targetPosition = t.targetPosition.toJSON();
                t.graveyardPosition = t.graveyardPosition.toJSON();
                return t
            }

            static get className() {
                return "MergeOperation"
            }

            static fromJSON(t, e) {
                const n = Qh.fromJSON(t.sourcePosition, e);
                const i = Qh.fromJSON(t.targetPosition, e);
                const o = Qh.fromJSON(t.graveyardPosition, e);
                return new this(n, t.howMany, i, o, t.baseVersion)
            }
        }

        class Tf extends af {
            constructor(t, e, n, i) {
                super(i);
                this.splitPosition = t.clone();
                this.splitPosition.stickiness = "toNext";
                this.howMany = e;
                this.insertionPosition = Tf.getInsertionPosition(t);
                this.insertionPosition.stickiness = "toNone";
                this.graveyardPosition = n ? n.clone() : null;
                if (this.graveyardPosition) {
                    this.graveyardPosition.stickiness = "toNext"
                }
            }

            get type() {
                return "split"
            }

            get moveTargetPosition() {
                const t = this.insertionPosition.path.slice();
                t.push(0);
                return new Qh(this.insertionPosition.root, t)
            }

            get movedRange() {
                const t = this.splitPosition.getShiftedBy(Number.POSITIVE_INFINITY);
                return new tm(this.splitPosition, t)
            }

            clone() {
                const t = new this.constructor(this.splitPosition, this.howMany, this.graveyardPosition, this.baseVersion);
                t.insertionPosition = this.insertionPosition;
                return t
            }

            getReversed() {
                const t = this.splitPosition.root.document.graveyard;
                const e = new Qh(t, [0]);
                return new Df(this.moveTargetPosition, this.howMany, this.splitPosition, e, this.baseVersion + 1)
            }

            _validate() {
                const t = this.splitPosition.parent;
                const e = this.splitPosition.offset;
                if (!t || t.maxOffset < e) {
                    throw new ss["a"]("split-operation-position-invalid", this)
                } else if (!t.parent) {
                    throw new ss["a"]("split-operation-split-in-root", this)
                } else if (this.howMany != t.maxOffset - this.splitPosition.offset) {
                    throw new ss["a"]("split-operation-how-many-invalid", this)
                } else if (this.graveyardPosition && !this.graveyardPosition.nodeAfter) {
                    throw new ss["a"]("split-operation-graveyard-position-invalid", this)
                }
            }

            _execute() {
                const t = this.splitPosition.parent;
                if (this.graveyardPosition) {
                    hf(tm._createFromPositionAndShift(this.graveyardPosition, 1), this.insertionPosition)
                } else {
                    const e = t._clone();
                    df(this.insertionPosition, e)
                }
                const e = new tm(Qh._createAt(t, this.splitPosition.offset), Qh._createAt(t, t.maxOffset));
                hf(e, this.moveTargetPosition)
            }

            toJSON() {
                const t = super.toJSON();
                t.splitPosition = this.splitPosition.toJSON();
                t.insertionPosition = this.insertionPosition.toJSON();
                if (this.graveyardPosition) {
                    t.graveyardPosition = this.graveyardPosition.toJSON()
                }
                return t
            }

            static get className() {
                return "SplitOperation"
            }

            static getInsertionPosition(t) {
                const e = t.path.slice(0, -1);
                e[e.length - 1]++;
                return new Qh(t.root, e)
            }

            static fromJSON(t, e) {
                const n = Qh.fromJSON(t.splitPosition, e);
                const i = Qh.fromJSON(t.insertionPosition, e);
                const o = t.graveyardPosition ? Qh.fromJSON(t.graveyardPosition, e) : null;
                const r = new this(n, t.howMany, o, t.baseVersion);
                r.insertionPosition = i;
                return r
            }
        }

        class Mf extends Kh {
            constructor(t, e, n = "main") {
                super(e);
                this._document = t;
                this.rootName = n
            }

            get document() {
                return this._document
            }

            is(t, e) {
                if (!e) {
                    return t === "rootElement" || t === "model:rootElement" || t === "element" || t === "model:element" || t === "node" || t === "model:node"
                }
                return e === this.name && (t === "rootElement" || t === "model:rootElement" || t === "element" || t === "model:element")
            }

            toJSON() {
                return this.rootName
            }
        }

        class Sf {
            constructor(t, e) {
                this.model = t;
                this.batch = e
            }

            createText(t, e) {
                return new Uh(t, e)
            }

            createElement(t, e) {
                return new Kh(t, e)
            }

            createDocumentFragment() {
                return new cf
            }

            cloneElement(t, e = true) {
                return t._clone(e)
            }

            insert(t, e, n = 0) {
                this._assertWriterUsedCorrectly();
                if (t instanceof Uh && t.data == "") {
                    return
                }
                const i = Qh._createAt(e, n);
                if (t.parent) {
                    if (Nf(t.root, i.root)) {
                        this.move(tm._createOn(t), i);
                        return
                    } else {
                        if (t.root.document) {
                            throw new ss["a"]("model-writer-insert-forbidden-move", this)
                        } else {
                            this.remove(t)
                        }
                    }
                }
                const o = i.root.document ? i.root.document.version : null;
                const r = new vf(i, t, o);
                if (t instanceof Uh) {
                    r.shouldReceiveAttributes = true
                }
                this.batch.addOperation(r);
                this.model.applyOperation(r);
                if (t instanceof cf) {
                    for (const [e, n] of t.markers) {
                        const t = Qh._createAt(n.root, 0);
                        const o = new tm(n.start._getCombined(t, i), n.end._getCombined(t, i));
                        const r = {range: o, usingOperation: true, affectsData: true};
                        if (this.model.markers.has(e)) {
                            this.updateMarker(e, r)
                        } else {
                            this.addMarker(e, r)
                        }
                    }
                }
            }

            insertText(t, e, n, i) {
                if (e instanceof cf || e instanceof Kh || e instanceof Qh) {
                    this.insert(this.createText(t), e, n)
                } else {
                    this.insert(this.createText(t, e), n, i)
                }
            }

            insertElement(t, e, n, i) {
                if (e instanceof cf || e instanceof Kh || e instanceof Qh) {
                    this.insert(this.createElement(t), e, n)
                } else {
                    this.insert(this.createElement(t, e), n, i)
                }
            }

            append(t, e) {
                this.insert(t, e, "end")
            }

            appendText(t, e, n) {
                if (e instanceof cf || e instanceof Kh) {
                    this.insert(this.createText(t), e, "end")
                } else {
                    this.insert(this.createText(t, e), n, "end")
                }
            }

            appendElement(t, e, n) {
                if (e instanceof cf || e instanceof Kh) {
                    this.insert(this.createElement(t), e, "end")
                } else {
                    this.insert(this.createElement(t, e), n, "end")
                }
            }

            setAttribute(t, e, n) {
                this._assertWriterUsedCorrectly();
                if (n instanceof tm) {
                    const i = n.getMinimalFlatRanges();
                    for (const n of i) {
                        If(this, t, e, n)
                    }
                } else {
                    Bf(this, t, e, n)
                }
            }

            setAttributes(t, e) {
                for (const [n, i] of Us(t)) {
                    this.setAttribute(n, i, e)
                }
            }

            removeAttribute(t, e) {
                this._assertWriterUsedCorrectly();
                if (e instanceof tm) {
                    const n = e.getMinimalFlatRanges();
                    for (const e of n) {
                        If(this, t, null, e)
                    }
                } else {
                    Bf(this, t, null, e)
                }
            }

            clearAttributes(t) {
                this._assertWriterUsedCorrectly();
                const e = t => {
                    for (const e of t.getAttributeKeys()) {
                        this.removeAttribute(e, t)
                    }
                };
                if (!(t instanceof tm)) {
                    e(t)
                } else {
                    for (const n of t.getItems()) {
                        e(n)
                    }
                }
            }

            move(t, e, n) {
                this._assertWriterUsedCorrectly();
                if (!(t instanceof tm)) {
                    throw new ss["a"]("writer-move-invalid-range", this)
                }
                if (!t.isFlat) {
                    throw new ss["a"]("writer-move-range-not-flat", this)
                }
                const i = Qh._createAt(e, n);
                if (i.isEqual(t.start)) {
                    return
                }
                this._addOperationForAffectedMarkers("move", t);
                if (!Nf(t.root, i.root)) {
                    throw new ss["a"]("writer-move-different-document", this)
                }
                const o = t.root.document ? t.root.document.version : null;
                const r = new Cf(t.start, t.end.offset - t.start.offset, i, o);
                this.batch.addOperation(r);
                this.model.applyOperation(r)
            }

            remove(t) {
                this._assertWriterUsedCorrectly();
                const e = t instanceof tm ? t : tm._createOn(t);
                const n = e.getMinimalFlatRanges().reverse();
                for (const t of n) {
                    this._addOperationForAffectedMarkers("move", t);
                    zf(t.start, t.end.offset - t.start.offset, this.batch, this.model)
                }
            }

            merge(t) {
                this._assertWriterUsedCorrectly();
                const e = t.nodeBefore;
                const n = t.nodeAfter;
                this._addOperationForAffectedMarkers("merge", t);
                if (!(e instanceof Kh)) {
                    throw new ss["a"]("writer-merge-no-element-before", this)
                }
                if (!(n instanceof Kh)) {
                    throw new ss["a"]("writer-merge-no-element-after", this)
                }
                if (!t.root.document) {
                    this._mergeDetached(t)
                } else {
                    this._merge(t)
                }
            }

            createPositionFromPath(t, e, n) {
                return this.model.createPositionFromPath(t, e, n)
            }

            createPositionAt(t, e) {
                return this.model.createPositionAt(t, e)
            }

            createPositionAfter(t) {
                return this.model.createPositionAfter(t)
            }

            createPositionBefore(t) {
                return this.model.createPositionBefore(t)
            }

            createRange(t, e) {
                return this.model.createRange(t, e)
            }

            createRangeIn(t) {
                return this.model.createRangeIn(t)
            }

            createRangeOn(t) {
                return this.model.createRangeOn(t)
            }

            createSelection(t, e, n) {
                return this.model.createSelection(t, e, n)
            }

            _mergeDetached(t) {
                const e = t.nodeBefore;
                const n = t.nodeAfter;
                this.move(tm._createIn(n), Qh._createAt(e, "end"));
                this.remove(n)
            }

            _merge(t) {
                const e = Qh._createAt(t.nodeBefore, "end");
                const n = Qh._createAt(t.nodeAfter, 0);
                const i = t.root.document.graveyard;
                const o = new Qh(i, [0]);
                const r = t.root.document.version;
                const s = new Df(n, t.nodeAfter.maxOffset, e, o, r);
                this.batch.addOperation(s);
                this.model.applyOperation(s)
            }

            rename(t, e) {
                this._assertWriterUsedCorrectly();
                if (!(t instanceof Kh)) {
                    throw new ss["a"]("writer-rename-not-element-instance", this)
                }
                const n = t.root.document ? t.root.document.version : null;
                const i = new xf(Qh._createBefore(t), t.name, e, n);
                this.batch.addOperation(i);
                this.model.applyOperation(i)
            }

            split(t, e) {
                this._assertWriterUsedCorrectly();
                let n = t.parent;
                if (!n.parent) {
                    throw new ss["a"]("writer-split-element-no-parent", this)
                }
                if (!e) {
                    e = n.parent
                }
                if (!t.parent.getAncestors({includeSelf: true}).includes(e)) {
                    throw new ss["a"]("writer-split-invalid-limit-element", this)
                }
                let i, o;
                do {
                    const e = n.root.document ? n.root.document.version : null;
                    const r = n.maxOffset - t.offset;
                    const s = new Tf(t, r, null, e);
                    this.batch.addOperation(s);
                    this.model.applyOperation(s);
                    if (!i && !o) {
                        i = n;
                        o = t.parent.nextSibling
                    }
                    t = this.createPositionAfter(t.parent);
                    n = t.parent
                } while (n !== e);
                return {position: t, range: new tm(Qh._createAt(i, "end"), Qh._createAt(o, 0))}
            }

            wrap(t, e) {
                this._assertWriterUsedCorrectly();
                if (!t.isFlat) {
                    throw new ss["a"]("writer-wrap-range-not-flat", this)
                }
                const n = e instanceof Kh ? e : new Kh(e);
                if (n.childCount > 0) {
                    throw new ss["a"]("writer-wrap-element-not-empty", this)
                }
                if (n.parent !== null) {
                    throw new ss["a"]("writer-wrap-element-attached", this)
                }
                this.insert(n, t.start);
                const i = new tm(t.start.getShiftedBy(1), t.end.getShiftedBy(1));
                this.move(i, Qh._createAt(n, 0))
            }

            unwrap(t) {
                this._assertWriterUsedCorrectly();
                if (t.parent === null) {
                    throw new ss["a"]("writer-unwrap-element-no-parent", this)
                }
                this.move(tm._createIn(t), this.createPositionAfter(t));
                this.remove(t)
            }

            addMarker(t, e) {
                this._assertWriterUsedCorrectly();
                if (!e || typeof e.usingOperation != "boolean") {
                    throw new ss["a"]("writer-addmarker-no-usingoperation", this)
                }
                const n = e.usingOperation;
                const i = e.range;
                const o = e.affectsData === undefined ? false : e.affectsData;
                if (this.model.markers.has(t)) {
                    throw new ss["a"]("writer-addmarker-marker-exists", this)
                }
                if (!i) {
                    throw new ss["a"]("writer-addmarker-no-range", this)
                }
                if (!n) {
                    return this.model.markers._set(t, i, n, o)
                }
                Lf(this, t, null, i, o);
                return this.model.markers.get(t)
            }

            updateMarker(t, e) {
                this._assertWriterUsedCorrectly();
                const n = typeof t == "string" ? t : t.name;
                const i = this.model.markers.get(n);
                if (!i) {
                    throw new ss["a"]("writer-updatemarker-marker-not-exists", this)
                }
                if (!e) {
                    this.model.markers._refresh(i);
                    return
                }
                const o = typeof e.usingOperation == "boolean";
                const r = typeof e.affectsData == "boolean";
                const s = r ? e.affectsData : i.affectsData;
                if (!o && !e.range && !r) {
                    throw new ss["a"]("writer-updatemarker-wrong-options", this)
                }
                const a = i.getRange();
                const c = e.range ? e.range : a;
                if (o && e.usingOperation !== i.managedUsingOperations) {
                    if (e.usingOperation) {
                        Lf(this, n, null, c, s)
                    } else {
                        Lf(this, n, a, null, s);
                        this.model.markers._set(n, c, undefined, s)
                    }
                    return
                }
                if (i.managedUsingOperations) {
                    Lf(this, n, a, c, s)
                } else {
                    this.model.markers._set(n, c, undefined, s)
                }
            }

            removeMarker(t) {
                this._assertWriterUsedCorrectly();
                const e = typeof t == "string" ? t : t.name;
                if (!this.model.markers.has(e)) {
                    throw new ss["a"]("writer-removemarker-no-marker", this)
                }
                const n = this.model.markers.get(e);
                if (!n.managedUsingOperations) {
                    this.model.markers._remove(e);
                    return
                }
                const i = n.getRange();
                Lf(this, e, i, null, n.affectsData)
            }

            setSelection(t, e, n) {
                this._assertWriterUsedCorrectly();
                this.model.document.selection._setTo(t, e, n)
            }

            setSelectionFocus(t, e) {
                this._assertWriterUsedCorrectly();
                this.model.document.selection._setFocus(t, e)
            }

            setSelectionAttribute(t, e) {
                this._assertWriterUsedCorrectly();
                if (typeof t === "string") {
                    this._setSelectionAttribute(t, e)
                } else {
                    for (const [e, n] of Us(t)) {
                        this._setSelectionAttribute(e, n)
                    }
                }
            }

            removeSelectionAttribute(t) {
                this._assertWriterUsedCorrectly();
                if (typeof t === "string") {
                    this._removeSelectionAttribute(t)
                } else {
                    for (const e of t) {
                        this._removeSelectionAttribute(e)
                    }
                }
            }

            overrideSelectionGravity() {
                return this.model.document.selection._overrideGravity()
            }

            restoreSelectionGravity(t) {
                this.model.document.selection._restoreGravity(t)
            }

            _setSelectionAttribute(t, e) {
                const n = this.model.document.selection;
                if (n.isCollapsed && n.anchor.parent.isEmpty) {
                    const i = Am._getStoreAttributeKey(t);
                    this.setAttribute(i, e, n.anchor.parent)
                }
                n._setAttribute(t, e)
            }

            _removeSelectionAttribute(t) {
                const e = this.model.document.selection;
                if (e.isCollapsed && e.anchor.parent.isEmpty) {
                    const n = Am._getStoreAttributeKey(t);
                    this.removeAttribute(n, e.anchor.parent)
                }
                e._removeAttribute(t)
            }

            _assertWriterUsedCorrectly() {
                if (this.model._currentWriter !== this) {
                    throw new ss["a"]("writer-incorrect-use", this)
                }
            }

            _addOperationForAffectedMarkers(t, e) {
                for (const n of this.model.markers) {
                    if (!n.managedUsingOperations) {
                        continue
                    }
                    const i = n.getRange();
                    let o = false;
                    if (t === "move") {
                        o = e.containsPosition(i.start) || e.start.isEqual(i.start) || e.containsPosition(i.end) || e.end.isEqual(i.end)
                    } else {
                        const t = e.nodeBefore;
                        const n = e.nodeAfter;
                        const r = i.start.parent == t && i.start.isAtEnd;
                        const s = i.end.parent == n && i.end.offset == 0;
                        const a = i.end.nodeAfter == n;
                        const c = i.start.nodeAfter == n;
                        o = r || s || a || c
                    }
                    if (o) {
                        this.updateMarker(n.name, {range: i})
                    }
                }
            }
        }

        function If(t, e, n, i) {
            const o = t.model;
            const r = o.document;
            let s = i.start;
            let a;
            let c;
            let l;
            for (const t of i.getWalker({shallow: true})) {
                l = t.item.getAttribute(e);
                if (a && c != l) {
                    if (c != n) {
                        d()
                    }
                    s = a
                }
                a = t.nextPosition;
                c = l
            }
            if (a instanceof Qh && a != s && c != n) {
                d()
            }

            function d() {
                const i = new tm(s, a);
                const l = i.root.document ? r.version : null;
                const d = new Af(i, e, c, n, l);
                t.batch.addOperation(d);
                o.applyOperation(d)
            }
        }

        function Bf(t, e, n, i) {
            const o = t.model;
            const r = o.document;
            const s = i.getAttribute(e);
            let a, c;
            if (s != n) {
                const l = i.root === i;
                if (l) {
                    const t = i.document ? r.version : null;
                    c = new Ef(i, e, s, n, t)
                } else {
                    a = new tm(Qh._createBefore(i), t.createPositionAfter(i));
                    const o = a.root.document ? r.version : null;
                    c = new Af(a, e, s, n, o)
                }
                t.batch.addOperation(c);
                o.applyOperation(c)
            }
        }

        function Lf(t, e, n, i, o) {
            const r = t.model;
            const s = r.document;
            const a = new yf(e, n, i, r.markers, o, s.version);
            t.batch.addOperation(a);
            r.applyOperation(a)
        }

        function zf(t, e, n, i) {
            let o;
            if (t.root.document) {
                const n = i.document;
                const r = new Qh(n.graveyard, [0]);
                o = new Cf(t, e, r, n.version)
            } else {
                o = new _f(t, e)
            }
            n.addOperation(o);
            i.applyOperation(o)
        }

        function Nf(t, e) {
            if (t === e) {
                return true
            }
            if (t instanceof Mf && e instanceof Mf) {
                return true
            }
            return false
        }

        class Pf {
            constructor(t) {
                this._markerCollection = t;
                this._changesInElement = new Map;
                this._elementSnapshots = new Map;
                this._changedMarkers = new Map;
                this._changeCount = 0;
                this._cachedChanges = null;
                this._cachedChangesWithGraveyard = null
            }

            get isEmpty() {
                return this._changesInElement.size == 0 && this._changedMarkers.size == 0
            }

            refreshItem(t) {
                if (this._isInInsertedElement(t.parent)) {
                    return
                }
                this._markRemove(t.parent, t.startOffset, t.offsetSize);
                this._markInsert(t.parent, t.startOffset, t.offsetSize);
                const e = tm._createOn(t);
                for (const t of this._markerCollection.getMarkersIntersectingRange(e)) {
                    const e = t.getRange();
                    this.bufferMarkerChange(t.name, e, e, t.affectsData)
                }
                this._cachedChanges = null
            }

            bufferOperation(t) {
                switch (t.type) {
                    case"insert": {
                        if (this._isInInsertedElement(t.position.parent)) {
                            return
                        }
                        this._markInsert(t.position.parent, t.position.offset, t.nodes.maxOffset);
                        break
                    }
                    case"addAttribute":
                    case"removeAttribute":
                    case"changeAttribute": {
                        for (const e of t.range.getItems({shallow: true})) {
                            if (this._isInInsertedElement(e.parent)) {
                                continue
                            }
                            this._markAttribute(e)
                        }
                        break
                    }
                    case"remove":
                    case"move":
                    case"reinsert": {
                        if (t.sourcePosition.isEqual(t.targetPosition) || t.sourcePosition.getShiftedBy(t.howMany).isEqual(t.targetPosition)) {
                            return
                        }
                        const e = this._isInInsertedElement(t.sourcePosition.parent);
                        const n = this._isInInsertedElement(t.targetPosition.parent);
                        if (!e) {
                            this._markRemove(t.sourcePosition.parent, t.sourcePosition.offset, t.howMany)
                        }
                        if (!n) {
                            this._markInsert(t.targetPosition.parent, t.getMovedRangeStart().offset, t.howMany)
                        }
                        break
                    }
                    case"rename": {
                        if (this._isInInsertedElement(t.position.parent)) {
                            return
                        }
                        this._markRemove(t.position.parent, t.position.offset, 1);
                        this._markInsert(t.position.parent, t.position.offset, 1);
                        const e = tm._createFromPositionAndShift(t.position, 1);
                        for (const t of this._markerCollection.getMarkersIntersectingRange(e)) {
                            const e = t.getRange();
                            this.bufferMarkerChange(t.name, e, e, t.affectsData)
                        }
                        break
                    }
                    case"split": {
                        const e = t.splitPosition.parent;
                        if (!this._isInInsertedElement(e)) {
                            this._markRemove(e, t.splitPosition.offset, t.howMany)
                        }
                        if (!this._isInInsertedElement(t.insertionPosition.parent)) {
                            this._markInsert(t.insertionPosition.parent, t.insertionPosition.offset, 1)
                        }
                        if (t.graveyardPosition) {
                            this._markRemove(t.graveyardPosition.parent, t.graveyardPosition.offset, 1)
                        }
                        break
                    }
                    case"merge": {
                        const e = t.sourcePosition.parent;
                        if (!this._isInInsertedElement(e.parent)) {
                            this._markRemove(e.parent, e.startOffset, 1)
                        }
                        const n = t.graveyardPosition.parent;
                        this._markInsert(n, t.graveyardPosition.offset, 1);
                        const i = t.targetPosition.parent;
                        if (!this._isInInsertedElement(i)) {
                            this._markInsert(i, t.targetPosition.offset, e.maxOffset)
                        }
                        break
                    }
                }
                this._cachedChanges = null
            }

            bufferMarkerChange(t, e, n, i) {
                const o = this._changedMarkers.get(t);
                if (!o) {
                    this._changedMarkers.set(t, {oldRange: e, newRange: n, affectsData: i})
                } else {
                    o.newRange = n;
                    o.affectsData = i;
                    if (o.oldRange == null && o.newRange == null) {
                        this._changedMarkers.delete(t)
                    }
                }
            }

            getMarkersToRemove() {
                const t = [];
                for (const [e, n] of this._changedMarkers) {
                    if (n.oldRange != null) {
                        t.push({name: e, range: n.oldRange})
                    }
                }
                return t
            }

            getMarkersToAdd() {
                const t = [];
                for (const [e, n] of this._changedMarkers) {
                    if (n.newRange != null) {
                        t.push({name: e, range: n.newRange})
                    }
                }
                return t
            }

            getChangedMarkers() {
                return Array.from(this._changedMarkers).map((t => ({
                    name: t[0],
                    data: {oldRange: t[1].oldRange, newRange: t[1].newRange}
                })))
            }

            hasDataChanges() {
                for (const [, t] of this._changedMarkers) {
                    if (t.affectsData) {
                        return true
                    }
                }
                return this._changesInElement.size > 0
            }

            getChanges(t = {includeChangesInGraveyard: false}) {
                if (this._cachedChanges) {
                    if (t.includeChangesInGraveyard) {
                        return this._cachedChangesWithGraveyard.slice()
                    } else {
                        return this._cachedChanges.slice()
                    }
                }
                const e = [];
                for (const t of this._changesInElement.keys()) {
                    const n = this._changesInElement.get(t).sort(((t, e) => {
                        if (t.offset === e.offset) {
                            if (t.type != e.type) {
                                return t.type == "remove" ? -1 : 1
                            }
                            return 0
                        }
                        return t.offset < e.offset ? -1 : 1
                    }));
                    const i = this._elementSnapshots.get(t);
                    const o = Of(t.getChildren());
                    const r = jf(i.length, n);
                    let s = 0;
                    let a = 0;
                    for (const n of r) {
                        if (n === "i") {
                            e.push(this._getInsertDiff(t, s, o[s].name));
                            s++
                        } else if (n === "r") {
                            e.push(this._getRemoveDiff(t, s, i[a].name));
                            a++
                        } else if (n === "a") {
                            const n = o[s].attributes;
                            const r = i[a].attributes;
                            let c;
                            if (o[s].name == "$text") {
                                c = new tm(Qh._createAt(t, s), Qh._createAt(t, s + 1))
                            } else {
                                const e = t.offsetToIndex(s);
                                c = new tm(Qh._createAt(t, s), Qh._createAt(t.getChild(e), 0))
                            }
                            e.push(...this._getAttributesDiff(c, r, n));
                            s++;
                            a++
                        } else {
                            s++;
                            a++
                        }
                    }
                }
                e.sort(((t, e) => {
                    if (t.position.root != e.position.root) {
                        return t.position.root.rootName < e.position.root.rootName ? -1 : 1
                    }
                    if (t.position.isEqual(e.position)) {
                        return t.changeCount - e.changeCount
                    }
                    return t.position.isBefore(e.position) ? -1 : 1
                }));
                for (let t = 1; t < e.length; t++) {
                    const n = e[t - 1];
                    const i = e[t];
                    const o = n.type == "remove" && i.type == "remove" && n.name == "$text" && i.name == "$text" && n.position.isEqual(i.position);
                    const r = n.type == "insert" && i.type == "insert" && n.name == "$text" && i.name == "$text" && n.position.parent == i.position.parent && n.position.offset + n.length == i.position.offset;
                    const s = n.type == "attribute" && i.type == "attribute" && n.position.parent == i.position.parent && n.range.isFlat && i.range.isFlat && n.position.offset + n.length == i.position.offset && n.attributeKey == i.attributeKey && n.attributeOldValue == i.attributeOldValue && n.attributeNewValue == i.attributeNewValue;
                    if (o || r || s) {
                        e[t - 1].length++;
                        if (s) {
                            e[t - 1].range.end = e[t - 1].range.end.getShiftedBy(1)
                        }
                        e.splice(t, 1);
                        t--
                    }
                }
                for (const t of e) {
                    delete t.changeCount;
                    if (t.type == "attribute") {
                        delete t.position;
                        delete t.length
                    }
                }
                this._changeCount = 0;
                this._cachedChangesWithGraveyard = e.slice();
                this._cachedChanges = e.slice().filter(Rf);
                if (t.includeChangesInGraveyard) {
                    return this._cachedChangesWithGraveyard
                } else {
                    return this._cachedChanges
                }
            }

            reset() {
                this._changesInElement.clear();
                this._elementSnapshots.clear();
                this._changedMarkers.clear();
                this._cachedChanges = null
            }

            _markInsert(t, e, n) {
                const i = {type: "insert", offset: e, howMany: n, count: this._changeCount++};
                this._markChange(t, i)
            }

            _markRemove(t, e, n) {
                const i = {type: "remove", offset: e, howMany: n, count: this._changeCount++};
                this._markChange(t, i);
                this._removeAllNestedChanges(t, e, n)
            }

            _markAttribute(t) {
                const e = {type: "attribute", offset: t.startOffset, howMany: t.offsetSize, count: this._changeCount++};
                this._markChange(t.parent, e)
            }

            _markChange(t, e) {
                this._makeSnapshot(t);
                const n = this._getChangesForElement(t);
                this._handleChange(e, n);
                n.push(e);
                for (let t = 0; t < n.length; t++) {
                    if (n[t].howMany < 1) {
                        n.splice(t, 1);
                        t--
                    }
                }
            }

            _getChangesForElement(t) {
                let e;
                if (this._changesInElement.has(t)) {
                    e = this._changesInElement.get(t)
                } else {
                    e = [];
                    this._changesInElement.set(t, e)
                }
                return e
            }

            _makeSnapshot(t) {
                if (!this._elementSnapshots.has(t)) {
                    this._elementSnapshots.set(t, Of(t.getChildren()))
                }
            }

            _handleChange(t, e) {
                t.nodesToHandle = t.howMany;
                for (const n of e) {
                    const i = t.offset + t.howMany;
                    const o = n.offset + n.howMany;
                    if (t.type == "insert") {
                        if (n.type == "insert") {
                            if (t.offset <= n.offset) {
                                n.offset += t.howMany
                            } else if (t.offset < o) {
                                n.howMany += t.nodesToHandle;
                                t.nodesToHandle = 0
                            }
                        }
                        if (n.type == "remove") {
                            if (t.offset < n.offset) {
                                n.offset += t.howMany
                            }
                        }
                        if (n.type == "attribute") {
                            if (t.offset <= n.offset) {
                                n.offset += t.howMany
                            } else if (t.offset < o) {
                                const o = n.howMany;
                                n.howMany = t.offset - n.offset;
                                e.unshift({
                                    type: "attribute",
                                    offset: i,
                                    howMany: o - n.howMany,
                                    count: this._changeCount++
                                })
                            }
                        }
                    }
                    if (t.type == "remove") {
                        if (n.type == "insert") {
                            if (i <= n.offset) {
                                n.offset -= t.howMany
                            } else if (i <= o) {
                                if (t.offset < n.offset) {
                                    const e = i - n.offset;
                                    n.offset = t.offset;
                                    n.howMany -= e;
                                    t.nodesToHandle -= e
                                } else {
                                    n.howMany -= t.nodesToHandle;
                                    t.nodesToHandle = 0
                                }
                            } else {
                                if (t.offset <= n.offset) {
                                    t.nodesToHandle -= n.howMany;
                                    n.howMany = 0
                                } else if (t.offset < o) {
                                    const e = o - t.offset;
                                    n.howMany -= e;
                                    t.nodesToHandle -= e
                                }
                            }
                        }
                        if (n.type == "remove") {
                            if (i <= n.offset) {
                                n.offset -= t.howMany
                            } else if (t.offset < n.offset) {
                                t.nodesToHandle += n.howMany;
                                n.howMany = 0
                            }
                        }
                        if (n.type == "attribute") {
                            if (i <= n.offset) {
                                n.offset -= t.howMany
                            } else if (t.offset < n.offset) {
                                const e = i - n.offset;
                                n.offset = t.offset;
                                n.howMany -= e
                            } else if (t.offset < o) {
                                if (i <= o) {
                                    const i = n.howMany;
                                    n.howMany = t.offset - n.offset;
                                    const o = i - n.howMany - t.nodesToHandle;
                                    e.unshift({
                                        type: "attribute",
                                        offset: t.offset,
                                        howMany: o,
                                        count: this._changeCount++
                                    })
                                } else {
                                    n.howMany -= o - t.offset
                                }
                            }
                        }
                    }
                    if (t.type == "attribute") {
                        if (n.type == "insert") {
                            if (t.offset < n.offset && i > n.offset) {
                                if (i > o) {
                                    const t = {
                                        type: "attribute",
                                        offset: o,
                                        howMany: i - o,
                                        count: this._changeCount++
                                    };
                                    this._handleChange(t, e);
                                    e.push(t)
                                }
                                t.nodesToHandle = n.offset - t.offset;
                                t.howMany = t.nodesToHandle
                            } else if (t.offset >= n.offset && t.offset < o) {
                                if (i > o) {
                                    t.nodesToHandle = i - o;
                                    t.offset = o
                                } else {
                                    t.nodesToHandle = 0
                                }
                            }
                        }
                        if (n.type == "remove") {
                            if (t.offset < n.offset && i > n.offset) {
                                const o = {
                                    type: "attribute",
                                    offset: n.offset,
                                    howMany: i - n.offset,
                                    count: this._changeCount++
                                };
                                this._handleChange(o, e);
                                e.push(o);
                                t.nodesToHandle = n.offset - t.offset;
                                t.howMany = t.nodesToHandle
                            }
                        }
                        if (n.type == "attribute") {
                            if (t.offset >= n.offset && i <= o) {
                                t.nodesToHandle = 0;
                                t.howMany = 0;
                                t.offset = 0
                            } else if (t.offset <= n.offset && i >= o) {
                                n.howMany = 0
                            }
                        }
                    }
                }
                t.howMany = t.nodesToHandle;
                delete t.nodesToHandle
            }

            _getInsertDiff(t, e, n) {
                return {
                    type: "insert",
                    position: Qh._createAt(t, e),
                    name: n,
                    length: 1,
                    changeCount: this._changeCount++
                }
            }

            _getRemoveDiff(t, e, n) {
                return {
                    type: "remove",
                    position: Qh._createAt(t, e),
                    name: n,
                    length: 1,
                    changeCount: this._changeCount++
                }
            }

            _getAttributesDiff(t, e, n) {
                const i = [];
                n = new Map(n);
                for (const [o, r] of e) {
                    const e = n.has(o) ? n.get(o) : null;
                    if (e !== r) {
                        i.push({
                            type: "attribute",
                            position: t.start,
                            range: t.clone(),
                            length: 1,
                            attributeKey: o,
                            attributeOldValue: r,
                            attributeNewValue: e,
                            changeCount: this._changeCount++
                        })
                    }
                    n.delete(o)
                }
                for (const [e, o] of n) {
                    i.push({
                        type: "attribute",
                        position: t.start,
                        range: t.clone(),
                        length: 1,
                        attributeKey: e,
                        attributeOldValue: null,
                        attributeNewValue: o,
                        changeCount: this._changeCount++
                    })
                }
                return i
            }

            _isInInsertedElement(t) {
                const e = t.parent;
                if (!e) {
                    return false
                }
                const n = this._changesInElement.get(e);
                const i = t.startOffset;
                if (n) {
                    for (const t of n) {
                        if (t.type == "insert" && i >= t.offset && i < t.offset + t.howMany) {
                            return true
                        }
                    }
                }
                return this._isInInsertedElement(e)
            }

            _removeAllNestedChanges(t, e, n) {
                const i = new tm(Qh._createAt(t, e), Qh._createAt(t, e + n));
                for (const t of i.getItems({shallow: true})) {
                    if (t.is("element")) {
                        this._elementSnapshots.delete(t);
                        this._changesInElement.delete(t);
                        this._removeAllNestedChanges(t, 0, t.maxOffset)
                    }
                }
            }
        }

        function Of(t) {
            const e = [];
            for (const n of t) {
                if (n.is("$text")) {
                    for (let t = 0; t < n.data.length; t++) {
                        e.push({name: "$text", attributes: new Map(n.getAttributes())})
                    }
                } else {
                    e.push({name: n.name, attributes: new Map(n.getAttributes())})
                }
            }
            return e
        }

        function jf(t, e) {
            const n = [];
            let i = 0;
            let o = 0;
            for (const t of e) {
                if (t.offset > i) {
                    for (let e = 0; e < t.offset - i; e++) {
                        n.push("e")
                    }
                    o += t.offset - i
                }
                if (t.type == "insert") {
                    for (let e = 0; e < t.howMany; e++) {
                        n.push("i")
                    }
                    i = t.offset + t.howMany
                } else if (t.type == "remove") {
                    for (let e = 0; e < t.howMany; e++) {
                        n.push("r")
                    }
                    i = t.offset;
                    o += t.howMany
                } else {
                    n.push(..."a".repeat(t.howMany).split(""));
                    i = t.offset + t.howMany;
                    o += t.howMany
                }
            }
            if (o < t) {
                for (let e = 0; e < t - o - i; e++) {
                    n.push("e")
                }
            }
            return n
        }

        function Rf(t) {
            const e = t.position && t.position.root.rootName == "$graveyard";
            const n = t.range && t.range.root.rootName == "$graveyard";
            return !e && !n
        }

        class Ff {
            constructor() {
                this._operations = [];
                this._undoPairs = new Map;
                this._undoneOperations = new Set
            }

            addOperation(t) {
                if (this._operations.includes(t)) {
                    return
                }
                this._operations.push(t)
            }

            getOperations(t = Number.NEGATIVE_INFINITY, e = Number.POSITIVE_INFINITY) {
                const n = [];
                for (const i of this._operations) {
                    if (i.baseVersion >= t && i.baseVersion < e) {
                        n.push(i)
                    }
                }
                return n
            }

            getOperation(t) {
                for (const e of this._operations) {
                    if (e.baseVersion == t) {
                        return e
                    }
                }
            }

            setOperationAsUndone(t, e) {
                this._undoPairs.set(e, t);
                this._undoneOperations.add(t)
            }

            isUndoingOperation(t) {
                return this._undoPairs.has(t)
            }

            isUndoneOperation(t) {
                return this._undoneOperations.has(t)
            }

            getUndoneOperation(t) {
                return this._undoPairs.get(t)
            }
        }

        function Vf(t) {
            return !!t && t.length == 1 && /[\u0300-\u036f\u1ab0-\u1aff\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/.test(t)
        }

        function Hf(t) {
            return !!t && t.length == 1 && /[\ud800-\udbff]/.test(t)
        }

        function Uf(t) {
            return !!t && t.length == 1 && /[\udc00-\udfff]/.test(t)
        }

        function Wf(t, e) {
            return Hf(t.charAt(e - 1)) && Uf(t.charAt(e))
        }

        function qf(t, e) {
            return Vf(t.charAt(e))
        }

        const Kf = "$graveyard";

        class Gf {
            constructor(t) {
                this.model = t;
                this.version = 0;
                this.history = new Ff(this);
                this.selection = new Am(this);
                this.roots = new vs({idProperty: "rootName"});
                this.differ = new Pf(t.markers);
                this._postFixers = new Set;
                this._hasSelectionChangedFromTheLastChangeBlock = false;
                this.createRoot("$root", Kf);
                this.listenTo(t, "applyOperation", ((t, e) => {
                    const n = e[0];
                    if (n.isDocumentOperation && n.baseVersion !== this.version) {
                        throw new ss["a"]("model-document-applyoperation-wrong-version", this, {operation: n})
                    }
                }), {priority: "highest"});
                this.listenTo(t, "applyOperation", ((t, e) => {
                    const n = e[0];
                    if (n.isDocumentOperation) {
                        this.differ.bufferOperation(n)
                    }
                }), {priority: "high"});
                this.listenTo(t, "applyOperation", ((t, e) => {
                    const n = e[0];
                    if (n.isDocumentOperation) {
                        this.version++;
                        this.history.addOperation(n)
                    }
                }), {priority: "low"});
                this.listenTo(this.selection, "change", (() => {
                    this._hasSelectionChangedFromTheLastChangeBlock = true
                }));
                this.listenTo(t.markers, "update", ((t, e, n, i) => {
                    this.differ.bufferMarkerChange(e.name, n, i, e.affectsData);
                    if (n === null) {
                        e.on("change", ((t, n) => {
                            this.differ.bufferMarkerChange(e.name, n, e.getRange(), e.affectsData)
                        }))
                    }
                }))
            }

            get graveyard() {
                return this.getRoot(Kf)
            }

            createRoot(t = "$root", e = "main") {
                if (this.roots.get(e)) {
                    throw new ss["a"]("model-document-createroot-name-exists", this, {name: e})
                }
                const n = new Mf(this, t, e);
                this.roots.add(n);
                return n
            }

            destroy() {
                this.selection.destroy();
                this.stopListening()
            }

            getRoot(t = "main") {
                return this.roots.get(t)
            }

            getRootNames() {
                return Array.from(this.roots, (t => t.rootName)).filter((t => t != Kf))
            }

            registerPostFixer(t) {
                this._postFixers.add(t)
            }

            toJSON() {
                const t = js(this);
                t.selection = "[engine.model.DocumentSelection]";
                t.model = "[engine.model.Model]";
                return t
            }

            _handleChangeBlock(t) {
                if (this._hasDocumentChangedFromTheLastChangeBlock()) {
                    this._callPostFixers(t);
                    this.selection.refresh();
                    if (this.differ.hasDataChanges()) {
                        this.fire("change:data", t.batch)
                    } else {
                        this.fire("change", t.batch)
                    }
                    this.selection.refresh();
                    this.differ.reset()
                }
                this._hasSelectionChangedFromTheLastChangeBlock = false
            }

            _hasDocumentChangedFromTheLastChangeBlock() {
                return !this.differ.isEmpty || this._hasSelectionChangedFromTheLastChangeBlock
            }

            _getDefaultRoot() {
                for (const t of this.roots) {
                    if (t !== this.graveyard) {
                        return t
                    }
                }
                return this.graveyard
            }

            _getDefaultRange() {
                const t = this._getDefaultRoot();
                const e = this.model;
                const n = e.schema;
                const i = e.createPositionFromPath(t, [0]);
                const o = n.getNearestSelectionRange(i);
                return o || e.createRange(i)
            }

            _validateSelectionRange(t) {
                return $f(t.start) && $f(t.end)
            }

            _callPostFixers(t) {
                let e = false;
                do {
                    for (const n of this._postFixers) {
                        this.selection.refresh();
                        e = n(t);
                        if (e) {
                            break
                        }
                    }
                } while (e)
            }
        }

        Cs(Gf, ds);

        function $f(t) {
            const e = t.textNode;
            if (e) {
                const n = e.data;
                const i = t.offset - e.startOffset;
                return !Wf(n, i) && !qf(n, i)
            }
            return true
        }

        class Yf {
            constructor() {
                this._markers = new Map
            }

            [Symbol.iterator]() {
                return this._markers.values()
            }

            has(t) {
                return this._markers.has(t)
            }

            get(t) {
                return this._markers.get(t) || null
            }

            _set(t, e, n = false, i = false) {
                const o = t instanceof Qf ? t.name : t;
                if (o.includes(",")) {
                    throw new ss["a"]("markercollection-incorrect-marker-name", this)
                }
                const r = this._markers.get(o);
                if (r) {
                    const t = r.getRange();
                    let s = false;
                    if (!t.isEqual(e)) {
                        r._attachLiveRange(fm.fromRange(e));
                        s = true
                    }
                    if (n != r.managedUsingOperations) {
                        r._managedUsingOperations = n;
                        s = true
                    }
                    if (typeof i === "boolean" && i != r.affectsData) {
                        r._affectsData = i;
                        s = true
                    }
                    if (s) {
                        this.fire("update:" + o, r, t, e)
                    }
                    return r
                }
                const s = fm.fromRange(e);
                const a = new Qf(o, s, n, i);
                this._markers.set(o, a);
                this.fire("update:" + o, a, null, e);
                return a
            }

            _remove(t) {
                const e = t instanceof Qf ? t.name : t;
                const n = this._markers.get(e);
                if (n) {
                    this._markers.delete(e);
                    this.fire("update:" + e, n, n.getRange(), null);
                    this._destroyMarker(n);
                    return true
                }
                return false
            }

            _refresh(t) {
                const e = t instanceof Qf ? t.name : t;
                const n = this._markers.get(e);
                if (!n) {
                    throw new ss["a"]("markercollection-refresh-marker-not-exists", this)
                }
                const i = n.getRange();
                this.fire("update:" + e, n, i, i, n.managedUsingOperations, n.affectsData)
            }

            * getMarkersAtPosition(t) {
                for (const e of this) {
                    if (e.getRange().containsPosition(t)) {
                        yield e
                    }
                }
            }

            * getMarkersIntersectingRange(t) {
                for (const e of this) {
                    if (e.getRange().getIntersection(t) !== null) {
                        yield e
                    }
                }
            }

            destroy() {
                for (const t of this._markers.values()) {
                    this._destroyMarker(t)
                }
                this._markers = null;
                this.stopListening()
            }

            * getMarkersGroup(t) {
                for (const e of this._markers.values()) {
                    if (e.name.startsWith(t + ":")) {
                        yield e
                    }
                }
            }

            _destroyMarker(t) {
                t.stopListening();
                t._detachLiveRange()
            }
        }

        Cs(Yf, ds);

        class Qf {
            constructor(t, e, n, i) {
                this.name = t;
                this._liveRange = this._attachLiveRange(e);
                this._managedUsingOperations = n;
                this._affectsData = i
            }

            get managedUsingOperations() {
                if (!this._liveRange) {
                    throw new ss["a"]("marker-destroyed", this)
                }
                return this._managedUsingOperations
            }

            get affectsData() {
                if (!this._liveRange) {
                    throw new ss["a"]("marker-destroyed", this)
                }
                return this._affectsData
            }

            getStart() {
                if (!this._liveRange) {
                    throw new ss["a"]("marker-destroyed", this)
                }
                return this._liveRange.start.clone()
            }

            getEnd() {
                if (!this._liveRange) {
                    throw new ss["a"]("marker-destroyed", this)
                }
                return this._liveRange.end.clone()
            }

            getRange() {
                if (!this._liveRange) {
                    throw new ss["a"]("marker-destroyed", this)
                }
                return this._liveRange.toRange()
            }

            is(t) {
                return t === "marker" || t === "model:marker"
            }

            _attachLiveRange(t) {
                if (this._liveRange) {
                    this._detachLiveRange()
                }
                t.delegate("change:range").to(this);
                t.delegate("change:content").to(this);
                this._liveRange = t;
                return t
            }

            _detachLiveRange() {
                this._liveRange.stopDelegating("change:range", this);
                this._liveRange.stopDelegating("change:content", this);
                this._liveRange.detach();
                this._liveRange = null
            }
        }

        Cs(Qf, ds);

        class Jf extends af {
            get type() {
                return "noop"
            }

            clone() {
                return new Jf(this.baseVersion)
            }

            getReversed() {
                return new Jf(this.baseVersion + 1)
            }

            _execute() {
            }

            static get className() {
                return "NoOperation"
            }
        }

        const Xf = {};
        Xf[Af.className] = Af;
        Xf[vf.className] = vf;
        Xf[yf.className] = yf;
        Xf[Cf.className] = Cf;
        Xf[Jf.className] = Jf;
        Xf[af.className] = af;
        Xf[xf.className] = xf;
        Xf[Ef.className] = Ef;
        Xf[Tf.className] = Tf;
        Xf[Df.className] = Df;

        class Zf {
            static fromJSON(t, e) {
                return Xf[t.__className].fromJSON(t, e)
            }
        }

        class tp extends Qh {
            constructor(t, e, n = "toNone") {
                super(t, e, n);
                if (!this.root.is("rootElement")) {
                    throw new ss["a"]("model-liveposition-root-not-rootelement", t)
                }
                ep.call(this)
            }

            detach() {
                this.stopListening()
            }

            is(t) {
                return t === "livePosition" || t === "model:livePosition" || t == "position" || t === "model:position"
            }

            toPosition() {
                return new Qh(this.root, this.path.slice(), this.stickiness)
            }

            static fromPosition(t, e) {
                return new this(t.root, t.path.slice(), e ? e : t.stickiness)
            }
        }

        function ep() {
            this.listenTo(this.root.document.model, "applyOperation", ((t, e) => {
                const n = e[0];
                if (!n.isDocumentOperation) {
                    return
                }
                np.call(this, n)
            }), {priority: "low"})
        }

        function np(t) {
            const e = this.getTransformedByOperation(t);
            if (!this.isEqual(e)) {
                const t = this.toPosition();
                this.path = e.path;
                this.root = e.root;
                this.fire("change", t)
            }
        }

        Cs(tp, ds);

        function ip(t, e, n, i) {
            return t.change((o => {
                let r;
                if (!n) {
                    r = t.document.selection
                } else if (n instanceof lm || n instanceof Am) {
                    r = n
                } else {
                    r = o.createSelection(n, i)
                }
                if (!r.isCollapsed) {
                    t.deleteContent(r, {doNotAutoparagraph: true})
                }
                const s = new op(t, o, r.anchor);
                let a;
                if (e.is("documentFragment")) {
                    a = e.getChildren()
                } else {
                    a = [e]
                }
                s.handleNodes(a, {isFirst: true, isLast: true});
                const c = s.getSelectionRange();
                if (c) {
                    if (r instanceof Am) {
                        o.setSelection(c)
                    } else {
                        r.setTo(c)
                    }
                } else {
                }
                const l = s.getAffectedRange() || t.createRange(r.anchor);
                s.destroy();
                return l
            }))
        }

        class op {
            constructor(t, e, n) {
                this.model = t;
                this.writer = e;
                this.position = n;
                this.canMergeWith = new Set([this.position.parent]);
                this.schema = t.schema;
                this._filterAttributesOf = [];
                this._affectedStart = null;
                this._affectedEnd = null
            }

            handleNodes(t, e) {
                t = Array.from(t);
                for (let n = 0; n < t.length; n++) {
                    const i = t[n];
                    this._handleNode(i, {isFirst: n === 0 && e.isFirst, isLast: n === t.length - 1 && e.isLast})
                }
                this.schema.removeDisallowedAttributes(this._filterAttributesOf, this.writer);
                this._filterAttributesOf = []
            }

            getSelectionRange() {
                if (this.nodeToSelect) {
                    return tm._createOn(this.nodeToSelect)
                }
                return this.model.schema.getNearestSelectionRange(this.position)
            }

            getAffectedRange() {
                if (!this._affectedStart) {
                    return null
                }
                return new tm(this._affectedStart, this._affectedEnd)
            }

            destroy() {
                if (this._affectedStart) {
                    this._affectedStart.detach()
                }
                if (this._affectedEnd) {
                    this._affectedEnd.detach()
                }
            }

            _handleNode(t, e) {
                if (this.schema.isObject(t)) {
                    this._handleObject(t, e);
                    return
                }
                const n = this._checkAndSplitToAllowedPosition(t, e);
                if (!n) {
                    this._handleDisallowedNode(t, e);
                    return
                }
                this._insert(t);
                this._mergeSiblingsOf(t, e)
            }

            _handleObject(t, e) {
                if (this._checkAndSplitToAllowedPosition(t)) {
                    this._insert(t)
                } else {
                    this._tryAutoparagraphing(t, e)
                }
            }

            _handleDisallowedNode(t, e) {
                if (t.is("element")) {
                    this.handleNodes(t.getChildren(), e)
                } else {
                    this._tryAutoparagraphing(t, e)
                }
            }

            _insert(t) {
                if (!this.schema.checkChild(this.position, t)) {
                    throw new ss["a"]("insertcontent-wrong-position", this, {node: t, position: this.position})
                }
                const e = tp.fromPosition(this.position, "toNext");
                this._setAffectedBoundaries(this.position);
                this.writer.insert(t, this.position);
                this.position = e.toPosition();
                e.detach();
                if (this.schema.isObject(t) && !this.schema.checkChild(this.position, "$text")) {
                    this.nodeToSelect = t
                } else {
                    this.nodeToSelect = null
                }
                this._filterAttributesOf.push(t)
            }

            _setAffectedBoundaries(t) {
                if (!this._affectedStart) {
                    this._affectedStart = tp.fromPosition(t, "toPrevious")
                }
                if (!this._affectedEnd || this._affectedEnd.isBefore(t)) {
                    if (this._affectedEnd) {
                        this._affectedEnd.detach()
                    }
                    this._affectedEnd = tp.fromPosition(t, "toNext")
                }
            }

            _mergeSiblingsOf(t, e) {
                if (!(t instanceof Kh)) {
                    return
                }
                const n = this._canMergeLeft(t, e);
                const i = this._canMergeRight(t, e);
                const o = tp._createBefore(t);
                o.stickiness = "toNext";
                const r = tp._createAfter(t);
                r.stickiness = "toNext";
                if (n) {
                    const t = tp.fromPosition(this.position);
                    t.stickiness = "toNext";
                    if (this._affectedStart.isEqual(o)) {
                        this._affectedStart.detach();
                        this._affectedStart = tp._createAt(o.nodeBefore, "end", "toPrevious")
                    }
                    this.writer.merge(o);
                    if (o.isEqual(this._affectedEnd) && e.isLast) {
                        this._affectedEnd.detach();
                        this._affectedEnd = tp._createAt(o.nodeBefore, "end", "toNext")
                    }
                    this.position = t.toPosition();
                    t.detach()
                }
                if (i) {
                    if (!this.position.isEqual(r)) {
                        throw new ss["a"]("insertcontent-invalid-insertion-position", this)
                    }
                    this.position = Qh._createAt(r.nodeBefore, "end");
                    const t = tp.fromPosition(this.position, "toPrevious");
                    if (this._affectedEnd.isEqual(r)) {
                        this._affectedEnd.detach();
                        this._affectedEnd = tp._createAt(r.nodeBefore, "end", "toNext")
                    }
                    this.writer.merge(r);
                    if (r.getShiftedBy(-1).isEqual(this._affectedStart) && e.isFirst) {
                        this._affectedStart.detach();
                        this._affectedStart = tp._createAt(r.nodeBefore, 0, "toPrevious")
                    }
                    this.position = t.toPosition();
                    t.detach()
                }
                if (n || i) {
                    this._filterAttributesOf.push(this.position.parent)
                }
                o.detach();
                r.detach()
            }

            _canMergeLeft(t, e) {
                const n = t.previousSibling;
                return e.isFirst && n instanceof Kh && this.canMergeWith.has(n) && this.model.schema.checkMerge(n, t)
            }

            _canMergeRight(t, e) {
                const n = t.nextSibling;
                return e.isLast && n instanceof Kh && this.canMergeWith.has(n) && this.model.schema.checkMerge(t, n)
            }

            _tryAutoparagraphing(t, e) {
                const n = this.writer.createElement("paragraph");
                if (this._getAllowedIn(n, this.position.parent) && this.schema.checkChild(n, t)) {
                    n._appendChild(t);
                    this._handleNode(n, e)
                }
            }

            _checkAndSplitToAllowedPosition(t) {
                const e = this._getAllowedIn(t, this.position.parent);
                if (!e) {
                    return false
                }
                while (e != this.position.parent) {
                    if (this.schema.isLimit(this.position.parent)) {
                        return false
                    }
                    if (this.position.isAtStart) {
                        const t = this.position.parent;
                        this.position = this.writer.createPositionBefore(t);
                        if (t.isEmpty && t.parent === e) {
                            this.writer.remove(t)
                        }
                    } else if (this.position.isAtEnd) {
                        this.position = this.writer.createPositionAfter(this.position.parent)
                    } else {
                        const t = this.writer.createPositionAfter(this.position.parent);
                        this._setAffectedBoundaries(this.position);
                        this.writer.split(this.position);
                        this.position = t;
                        this.canMergeWith.add(this.position.nodeAfter)
                    }
                }
                return true
            }

            _getAllowedIn(t, e) {
                if (this.schema.checkChild(e, t)) {
                    return e
                }
                if (e.parent) {
                    return this._getAllowedIn(t, e.parent)
                }
                return null
            }
        }

        function rp(t, e, n = {}) {
            if (e.isCollapsed) {
                return
            }
            const i = e.getFirstRange();
            if (i.root.rootName == "$graveyard") {
                return
            }
            const o = t.schema;
            t.change((t => {
                if (!n.doNotResetEntireContent && kp(o, e)) {
                    bp(t, e, o);
                    return
                }
                const [r, s] = sp(i);
                if (!r.isTouching(s)) {
                    t.remove(t.createRange(r, s))
                }
                if (!n.leaveUnmerged) {
                    cp(t, r, s);
                    o.removeDisallowedAttributes(r.parent.getChildren(), t)
                }
                wp(t, e, r);
                if (!n.doNotAutoparagraph && gp(o, r)) {
                    pp(t, r, e)
                }
                r.detach();
                s.detach()
            }))
        }

        function sp(t) {
            const e = t.root.document.model;
            const n = t.start;
            let i = t.end;
            if (e.hasContent(t, {ignoreMarkers: true})) {
                const n = ap(i);
                if (n && i.isTouching(e.createPositionAt(n, 0))) {
                    const n = e.createSelection(t);
                    e.modifySelection(n, {direction: "backward"});
                    i = n.getLastPosition()
                }
            }
            return [tp.fromPosition(n, "toPrevious"), tp.fromPosition(i, "toNext")]
        }

        function ap(t) {
            const e = t.parent;
            const n = e.root.document.model.schema;
            const i = e.getAncestors({parentFirst: true, includeSelf: true});
            for (const t of i) {
                if (n.isLimit(t)) {
                    return null
                }
                if (n.isBlock(t)) {
                    return t
                }
            }
        }

        function cp(t, e, n) {
            const i = t.model;
            if (!hp(t.model.schema, e, n)) {
                return
            }
            const [o, r] = mp(e, n);
            if (!i.hasContent(o, {ignoreMarkers: true}) && i.hasContent(r, {ignoreMarkers: true})) {
                dp(t, e, n, o.parent)
            } else {
                lp(t, e, n, o.parent)
            }
        }

        function lp(t, e, n, i) {
            const o = e.parent;
            const r = n.parent;
            if (o == i || r == i) {
                return
            }
            e = t.createPositionAfter(o);
            n = t.createPositionBefore(r);
            if (!n.isEqual(e)) {
                t.insert(r, e)
            }
            t.merge(e);
            while (n.parent.isEmpty) {
                const e = n.parent;
                n = t.createPositionBefore(e);
                t.remove(e)
            }
            if (!hp(t.model.schema, e, n)) {
                return
            }
            lp(t, e, n, i)
        }

        function dp(t, e, n, i) {
            const o = e.parent;
            const r = n.parent;
            if (o == i || r == i) {
                return
            }
            e = t.createPositionAfter(o);
            n = t.createPositionBefore(r);
            if (!n.isEqual(e)) {
                t.insert(o, n)
            }
            while (e.parent.isEmpty) {
                const n = e.parent;
                e = t.createPositionBefore(n);
                t.remove(n)
            }
            n = t.createPositionBefore(r);
            up(t, n);
            if (!hp(t.model.schema, e, n)) {
                return
            }
            dp(t, e, n, i)
        }

        function up(t, e) {
            const n = e.nodeBefore;
            const i = e.nodeAfter;
            if (n.name != i.name) {
                t.rename(n, i.name)
            }
            t.clearAttributes(n);
            t.setAttributes(Object.fromEntries(i.getAttributes()), n);
            t.merge(e)
        }

        function hp(t, e, n) {
            const i = e.parent;
            const o = n.parent;
            if (i == o) {
                return false
            }
            if (t.isLimit(i) || t.isLimit(o)) {
                return false
            }
            return fp(e, n, t)
        }

        function mp(t, e) {
            const n = t.getAncestors();
            const i = e.getAncestors();
            let o = 0;
            while (n[o] && n[o] == i[o]) {
                o++
            }
            return [n[o], i[o]]
        }

        function gp(t, e) {
            const n = t.checkChild(e, "$text");
            const i = t.checkChild(e, "paragraph");
            return !n && i
        }

        function fp(t, e, n) {
            const i = new tm(t, e);
            for (const t of i.getWalker()) {
                if (n.isLimit(t.item)) {
                    return false
                }
            }
            return true
        }

        function pp(t, e, n) {
            const i = t.createElement("paragraph");
            t.insert(i, e);
            wp(t, n, t.createPositionAt(i, 0))
        }

        function bp(t, e) {
            const n = t.model.schema.getLimitElement(e);
            t.remove(t.createRangeIn(n));
            pp(t, t.createPositionAt(n, 0), e)
        }

        function kp(t, e) {
            const n = t.getLimitElement(e);
            if (!e.containsEntireContent(n)) {
                return false
            }
            const i = e.getFirstRange();
            if (i.start.parent == i.end.parent) {
                return false
            }
            return t.checkChild(n, "paragraph")
        }

        function wp(t, e, n) {
            if (e instanceof Am) {
                t.setSelection(n)
            } else {
                e.setTo(n)
            }
        }

        const Ap = ' ,.?!:;"-()';

        function _p(t, e, n = {}) {
            const i = t.schema;
            const o = n.direction != "backward";
            const r = n.unit ? n.unit : "character";
            const s = e.focus;
            const a = new $h({boundaries: xp(s, o), singleCharacters: true, direction: o ? "forward" : "backward"});
            const c = {walker: a, schema: i, isForward: o, unit: r};
            let l;
            while (l = a.next()) {
                if (l.done) {
                    return
                }
                const n = Cp(c, l.value);
                if (n) {
                    if (e instanceof Am) {
                        t.change((t => {
                            t.setSelectionFocus(n)
                        }))
                    } else {
                        e.setFocus(n)
                    }
                    return
                }
            }
        }

        function Cp(t, e) {
            const {isForward: n, walker: i, unit: o, schema: r} = t;
            const {type: s, item: a, nextPosition: c} = e;
            if (s == "text") {
                if (t.unit === "word") {
                    return yp(i, n)
                }
                return vp(i, o, n)
            }
            if (s == (n ? "elementStart" : "elementEnd")) {
                if (r.isSelectable(a)) {
                    return Qh._createAt(a, n ? "after" : "before")
                }
                if (r.checkChild(c, "$text")) {
                    return c
                }
            } else {
                if (r.isLimit(a)) {
                    i.skip((() => true));
                    return
                }
                if (r.checkChild(c, "$text")) {
                    return c
                }
            }
        }

        function vp(t, e) {
            const n = t.position.textNode;
            if (n) {
                const i = n.data;
                let o = t.position.offset - n.startOffset;
                while (Wf(i, o) || e == "character" && qf(i, o)) {
                    t.next();
                    o = t.position.offset - n.startOffset
                }
            }
            return t.position
        }

        function yp(t, e) {
            let n = t.position.textNode;
            if (n) {
                let i = t.position.offset - n.startOffset;
                while (!Ep(n.data, i, e) && !Dp(n, i, e)) {
                    t.next();
                    const o = e ? t.position.nodeAfter : t.position.nodeBefore;
                    if (o && o.is("$text")) {
                        const i = o.data.charAt(e ? 0 : o.data.length - 1);
                        if (!Ap.includes(i)) {
                            t.next();
                            n = t.position.textNode
                        }
                    }
                    i = t.position.offset - n.startOffset
                }
            }
            return t.position
        }

        function xp(t, e) {
            const n = t.root;
            const i = Qh._createAt(n, e ? "end" : 0);
            if (e) {
                return new tm(t, i)
            } else {
                return new tm(i, t)
            }
        }

        function Ep(t, e, n) {
            const i = e + (n ? 0 : -1);
            return Ap.includes(t.charAt(i))
        }

        function Dp(t, e, n) {
            return e === (n ? t.endOffset : 0)
        }

        function Tp(t, e) {
            return t.change((t => {
                const n = t.createDocumentFragment();
                const i = e.getFirstRange();
                if (!i || i.isCollapsed) {
                    return n
                }
                const o = i.start.root;
                const r = i.start.getCommonPath(i.end);
                const s = o.getNodeByPath(r);
                let a;
                if (i.start.parent == i.end.parent) {
                    a = i
                } else {
                    a = t.createRange(t.createPositionAt(s, i.start.path[r.length]), t.createPositionAt(s, i.end.path[r.length] + 1))
                }
                const c = a.end.offset - a.start.offset;
                for (const e of a.getItems({shallow: true})) {
                    if (e.is("$textProxy")) {
                        t.appendText(e.data, e.getAttributes(), n)
                    } else {
                        t.append(t.cloneElement(e, true), n)
                    }
                }
                if (a != i) {
                    const e = i._getTransformedByMove(a.start, t.createPositionAt(n, 0), c)[0];
                    const o = t.createRange(t.createPositionAt(n, 0), e.start);
                    const r = t.createRange(e.end, t.createPositionAt(n, "end"));
                    Mp(r, t);
                    Mp(o, t)
                }
                return n
            }))
        }

        function Mp(t, e) {
            const n = [];
            Array.from(t.getItems({direction: "backward"})).map((t => e.createRangeOn(t))).filter((e => {
                const n = (e.start.isAfter(t.start) || e.start.isEqual(t.start)) && (e.end.isBefore(t.end) || e.end.isEqual(t.end));
                return n
            })).forEach((t => {
                n.push(t.start.parent);
                e.remove(t)
            }));
            n.forEach((t => {
                let n = t;
                while (n.parent && n.isEmpty) {
                    const t = e.createRangeOn(n);
                    n = n.parent;
                    e.remove(t)
                }
            }))
        }

        function Sp(t) {
            t.document.registerPostFixer((e => Ip(e, t)))
        }

        function Ip(t, e) {
            const n = e.document.selection;
            const i = e.schema;
            const o = [];
            let r = false;
            for (const t of n.getRanges()) {
                const e = Bp(t, i);
                if (e && !e.isEqual(t)) {
                    o.push(e);
                    r = true
                } else {
                    o.push(t)
                }
            }
            if (r) {
                t.setSelection(Op(o), {backward: n.isBackward})
            }
        }

        function Bp(t, e) {
            if (t.isCollapsed) {
                return Lp(t, e)
            }
            return zp(t, e)
        }

        function Lp(t, e) {
            const n = t.start;
            const i = e.getNearestSelectionRange(n);
            if (!i) {
                return null
            }
            if (!i.isCollapsed) {
                return i
            }
            const o = i.start;
            if (n.isEqual(o)) {
                return null
            }
            return new tm(o)
        }

        function zp(t, e) {
            const {start: n, end: i} = t;
            const o = e.checkChild(n, "$text");
            const r = e.checkChild(i, "$text");
            const s = e.getLimitElement(n);
            const a = e.getLimitElement(i);
            if (s === a) {
                if (o && r) {
                    return null
                }
                if (Pp(n, i, e)) {
                    const t = n.nodeAfter && e.isSelectable(n.nodeAfter);
                    const o = t ? null : e.getNearestSelectionRange(n, "forward");
                    const r = i.nodeBefore && e.isSelectable(i.nodeBefore);
                    const s = r ? null : e.getNearestSelectionRange(i, "backward");
                    const a = o ? o.start : n;
                    const c = s ? s.start : i;
                    return new tm(a, c)
                }
            }
            const c = s && !s.is("rootElement");
            const l = a && !a.is("rootElement");
            if (c || l) {
                const t = n.nodeAfter && i.nodeBefore && n.nodeAfter.parent === i.nodeBefore.parent;
                const o = c && (!t || !jp(n.nodeAfter, e));
                const r = l && (!t || !jp(i.nodeBefore, e));
                let d = n;
                let u = i;
                if (o) {
                    d = Qh._createBefore(Np(s, e))
                }
                if (r) {
                    u = Qh._createAfter(Np(a, e))
                }
                return new tm(d, u)
            }
            return null
        }

        function Np(t, e) {
            let n = t;
            let i = n;
            while (e.isLimit(i) && i.parent) {
                n = i;
                i = i.parent
            }
            return n
        }

        function Pp(t, e, n) {
            const i = t.nodeAfter && !n.isLimit(t.nodeAfter) || n.checkChild(t, "$text");
            const o = e.nodeBefore && !n.isLimit(e.nodeBefore) || n.checkChild(e, "$text");
            return i || o
        }

        function Op(t) {
            const e = [];
            e.push(t.shift());
            for (const n of t) {
                const t = e.pop();
                if (n.isIntersecting(t)) {
                    const i = t.start.isAfter(n.start) ? n.start : t.start;
                    const o = t.end.isAfter(n.end) ? t.end : n.end;
                    const r = new tm(i, o);
                    e.push(r)
                } else {
                    e.push(t);
                    e.push(n)
                }
            }
            return e
        }

        function jp(t, e) {
            return t && e.isSelectable(t)
        }

        class Rp {
            constructor() {
                this.markers = new Yf;
                this.document = new Gf(this);
                this.schema = new Lg;
                this._pendingChanges = [];
                this._currentWriter = null;
                ["insertContent", "deleteContent", "modifySelection", "getSelectedContent", "applyOperation"].forEach((t => this.decorate(t)));
                this.on("applyOperation", ((t, e) => {
                    const n = e[0];
                    n._validate()
                }), {priority: "highest"});
                this.schema.register("$root", {isLimit: true});
                this.schema.register("$block", {allowIn: "$root", isBlock: true});
                this.schema.register("$text", {allowIn: "$block", isInline: true, isContent: true});
                this.schema.register("$clipboardHolder", {allowContentOf: "$root", isLimit: true});
                this.schema.extend("$text", {allowIn: "$clipboardHolder"});
                this.schema.register("$marker");
                this.schema.addChildCheck(((t, e) => {
                    if (e.name === "$marker") {
                        return true
                    }
                }));
                Sp(this);
                this.document.registerPostFixer(sg)
            }

            change(t) {
                try {
                    if (this._pendingChanges.length === 0) {
                        this._pendingChanges.push({batch: new sf, callback: t});
                        return this._runPendingChanges()[0]
                    } else {
                        return t(this._currentWriter)
                    }
                } catch (t) {
                    ss["a"].rethrowUnexpectedError(t, this)
                }
            }

            enqueueChange(t, e) {
                try {
                    if (typeof t === "string") {
                        t = new sf(t)
                    } else if (typeof t == "function") {
                        e = t;
                        t = new sf
                    }
                    this._pendingChanges.push({batch: t, callback: e});
                    if (this._pendingChanges.length == 1) {
                        this._runPendingChanges()
                    }
                } catch (t) {
                    ss["a"].rethrowUnexpectedError(t, this)
                }
            }

            applyOperation(t) {
                t._execute()
            }

            insertContent(t, e, n) {
                return ip(this, t, e, n)
            }

            deleteContent(t, e) {
                rp(this, t, e)
            }

            modifySelection(t, e) {
                _p(this, t, e)
            }

            getSelectedContent(t) {
                return Tp(this, t)
            }

            hasContent(t, e = {}) {
                const n = t instanceof Kh ? tm._createIn(t) : t;
                if (n.isCollapsed) {
                    return false
                }
                const {ignoreWhitespaces: i = false, ignoreMarkers: o = false} = e;
                if (!o) {
                    for (const t of this.markers.getMarkersIntersectingRange(n)) {
                        if (t.affectsData) {
                            return true
                        }
                    }
                }
                for (const t of n.getItems()) {
                    if (this.schema.isContent(t)) {
                        if (t.is("$textProxy")) {
                            if (!i) {
                                return true
                            } else if (t.data.search(/\S/) !== -1) {
                                return true
                            }
                        } else {
                            return true
                        }
                    }
                }
                return false
            }

            createPositionFromPath(t, e, n) {
                return new Qh(t, e, n)
            }

            createPositionAt(t, e) {
                return Qh._createAt(t, e)
            }

            createPositionAfter(t) {
                return Qh._createAfter(t)
            }

            createPositionBefore(t) {
                return Qh._createBefore(t)
            }

            createRange(t, e) {
                return new tm(t, e)
            }

            createRangeIn(t) {
                return tm._createIn(t)
            }

            createRangeOn(t) {
                return tm._createOn(t)
            }

            createSelection(t, e, n) {
                return new lm(t, e, n)
            }

            createBatch(t) {
                return new sf(t)
            }

            createOperationFromJSON(t) {
                return Zf.fromJSON(t, this.document)
            }

            destroy() {
                this.document.destroy();
                this.stopListening()
            }

            _runPendingChanges() {
                const t = [];
                this.fire("_beforeChanges");
                while (this._pendingChanges.length) {
                    const e = this._pendingChanges[0].batch;
                    this._currentWriter = new Sf(this, e);
                    const n = this._pendingChanges[0].callback(this._currentWriter);
                    t.push(n);
                    this.document._handleChangeBlock(this._currentWriter);
                    this._pendingChanges.shift();
                    this._currentWriter = null
                }
                this.fire("_afterChanges");
                return t
            }
        }

        Cs(Rp, Qc);

        class Fp {
            constructor() {
                this._listener = Object.create(Qd)
            }

            listenTo(t) {
                this._listener.listenTo(t, "keydown", ((t, e) => {
                    this._listener.fire("_keydown:" + Pl(e), e)
                }))
            }

            set(t, e, n = {}) {
                const i = Ol(t);
                const o = n.priority;
                this._listener.listenTo(this._listener, "_keydown:" + i, ((t, n) => {
                    e(n, (() => {
                        n.preventDefault();
                        n.stopPropagation();
                        t.stop()
                    }));
                    t.return = true
                }), {priority: o})
            }

            press(t) {
                return !!this._listener.fire("_keydown:" + Pl(t), t)
            }

            destroy() {
                this._listener.stopListening()
            }
        }

        class Vp extends Fp {
            constructor(t) {
                super();
                this.editor = t
            }

            set(t, e, n = {}) {
                if (typeof e == "string") {
                    const t = e;
                    e = (e, n) => {
                        this.editor.execute(t);
                        n()
                    }
                }
                super.set(t, e, n)
            }
        }

        class Hp {
            constructor(t = {}) {
                this._context = t.context || new zs({language: t.language});
                this._context._addEditor(this, !t.context);
                const e = Array.from(this.constructor.builtinPlugins || []);
                this.config = new Yr(t, this.constructor.defaultConfig);
                this.config.define("plugins", e);
                this.config.define(this._context._getEditorConfig());
                this.plugins = new ys(this, e, this._context.plugins);
                this.locale = this._context.locale;
                this.t = this.locale.t;
                this.commands = new Sg;
                this.set("state", "initializing");
                this.once("ready", (() => this.state = "ready"), {priority: "high"});
                this.once("destroy", (() => this.state = "destroyed"), {priority: "high"});
                this.set("isReadOnly", false);
                this.model = new Rp;
                const n = new zc;
                this.data = new tf(this.model, n);
                this.editing = new Mg(this.model, n);
                this.editing.view.document.bind("isReadOnly").to(this);
                this.conversion = new nf([this.editing.downcastDispatcher, this.data.downcastDispatcher], this.data.upcastDispatcher);
                this.conversion.addAlias("dataDowncast", this.data.downcastDispatcher);
                this.conversion.addAlias("editingDowncast", this.editing.downcastDispatcher);
                this.keystrokes = new Vp(this);
                this.keystrokes.listenTo(this.editing.view.document)
            }

            initPlugins() {
                const t = this.config;
                const e = t.get("plugins");
                const n = t.get("removePlugins") || [];
                const i = t.get("extraPlugins") || [];
                return this.plugins.init(e.concat(i), n)
            }

            destroy() {
                let t = Promise.resolve();
                if (this.state == "initializing") {
                    t = new Promise((t => this.once("ready", t)))
                }
                return t.then((() => {
                    this.fire("destroy");
                    this.stopListening();
                    this.commands.destroy()
                })).then((() => this.plugins.destroy())).then((() => {
                    this.model.destroy();
                    this.data.destroy();
                    this.editing.destroy();
                    this.keystrokes.destroy()
                })).then((() => this._context._removeEditor(this)))
            }

            execute(...t) {
                try {
                    return this.commands.execute(...t)
                } catch (t) {
                    ss["a"].rethrowUnexpectedError(t, this)
                }
            }
        }

        Cs(Hp, Qc);
        const Up = {
            setData(t) {
                this.data.set(t)
            }, getData(t) {
                return this.data.get(t)
            }
        };
        var Wp = Up;

        function qp(t, e) {
            if (t instanceof HTMLTextAreaElement) {
                t.value = e
            }
            t.innerHTML = e
        }

        const Kp = {
            updateSourceElement() {
                if (!this.sourceElement) {
                    throw new ss["a"]("editor-missing-sourceelement", this)
                }
                qp(this.sourceElement, this.data.get())
            }
        };
        var Gp = Kp;

        function $p(t) {
            if (!gt(t.updateSourceElement)) {
                throw new ss["a"]("attachtoform-missing-elementapi-interface", t)
            }
            const e = t.sourceElement;
            if (e && e.tagName.toLowerCase() === "textarea" && e.form) {
                let n;
                const i = e.form;
                const o = () => t.updateSourceElement();
                if (gt(i.submit)) {
                    n = i.submit;
                    i.submit = () => {
                        o();
                        n.apply(i)
                    }
                }
                i.addEventListener("submit", o);
                t.on("destroy", (() => {
                    i.removeEventListener("submit", o);
                    if (n) {
                        i.submit = n
                    }
                }))
            }
        }

        class Yp {
            getHtml(t) {
                const e = document.implementation.createHTMLDocument("");
                const n = e.createElement("div");
                n.appendChild(t);
                return n.innerHTML
            }
        }

        class Qp {
            constructor(t) {
                this._domParser = new DOMParser;
                this._domConverter = new Ud(t, {blockFillerMode: "nbsp"});
                this._htmlWriter = new Yp
            }

            toData(t) {
                const e = this._domConverter.viewToDom(t, document);
                return this._htmlWriter.getHtml(e)
            }

            toView(t) {
                const e = this._toDom(t);
                return this._domConverter.domToView(e)
            }

            _toDom(t) {
                const e = this._domParser.parseFromString(t, "text/html");
                const n = e.createDocumentFragment();
                const i = e.body.childNodes;
                while (i.length > 0) {
                    n.appendChild(i[0])
                }
                return n
            }
        }

        class Jp {
            constructor(t) {
                this.editor = t;
                this._components = new Map
            }

            * names() {
                for (const t of this._components.values()) {
                    yield t.originalName
                }
            }

            add(t, e) {
                this._components.set(Xp(t), {callback: e, originalName: t})
            }

            create(t) {
                if (!this.has(t)) {
                    throw new ss["a"]("componentfactory-item-missing", this, {name: t})
                }
                return this._components.get(Xp(t)).callback(this.editor.locale)
            }

            has(t) {
                return this._components.has(Xp(t))
            }
        }

        function Xp(t) {
            return String(t).toLowerCase()
        }

        class Zp {
            constructor() {
                this.set("isFocused", false);
                this.set("focusedElement", null);
                this._elements = new Set;
                this._nextEventLoopTimeout = null
            }

            add(t) {
                if (this._elements.has(t)) {
                    throw new ss["a"]("focustracker-add-element-already-exist", this)
                }
                this.listenTo(t, "focus", (() => this._focus(t)), {useCapture: true});
                this.listenTo(t, "blur", (() => this._blur()), {useCapture: true});
                this._elements.add(t)
            }

            remove(t) {
                if (t === this.focusedElement) {
                    this._blur(t)
                }
                if (this._elements.has(t)) {
                    this.stopListening(t);
                    this._elements.delete(t)
                }
            }

            destroy() {
                this.stopListening()
            }

            _focus(t) {
                clearTimeout(this._nextEventLoopTimeout);
                this.focusedElement = t;
                this.isFocused = true
            }

            _blur() {
                clearTimeout(this._nextEventLoopTimeout);
                this._nextEventLoopTimeout = setTimeout((() => {
                    this.focusedElement = null;
                    this.isFocused = false
                }), 0)
            }
        }

        Cs(Zp, Qd);
        Cs(Zp, Qc);

        class tb {
            constructor(t) {
                this.editor = t;
                this.componentFactory = new Jp(t);
                this.focusTracker = new Zp;
                this._editableElementsMap = new Map;
                this.listenTo(t.editing.view.document, "layoutChanged", (() => this.update()))
            }

            get element() {
                return null
            }

            update() {
                this.fire("update")
            }

            destroy() {
                this.stopListening();
                this.focusTracker.destroy();
                for (const t of this._editableElementsMap.values()) {
                    t.ckeditorInstance = null
                }
                this._editableElementsMap = new Map
            }

            setEditableElement(t, e) {
                this._editableElementsMap.set(t, e);
                if (!e.ckeditorInstance) {
                    e.ckeditorInstance = this.editor
                }
            }

            getEditableElement(t = "main") {
                return this._editableElementsMap.get(t)
            }

            getEditableElementsNames() {
                return this._editableElementsMap.keys()
            }

            get _editableElements() {
                console.warn("editor-ui-deprecated-editable-elements: " + "The EditorUI#_editableElements property has been deprecated and will be removed in the near future.", {editorUI: this});
                return this._editableElementsMap
            }
        }

        Cs(tb, ds);

        function eb({origin: t, originKeystrokeHandler: e, originFocusTracker: n, toolbar: i, beforeFocus: o, afterBlur: r}) {
            n.add(i.element);
            e.set("Alt+F10", ((t, e) => {
                if (n.isFocused && !i.focusTracker.isFocused) {
                    if (o) {
                        o()
                    }
                    i.focus();
                    e()
                }
            }));
            i.keystrokes.set("Esc", ((e, n) => {
                if (i.focusTracker.isFocused) {
                    t.focus();
                    if (r) {
                        r()
                    }
                    n()
                }
            }))
        }

        function nb(t) {
            if (Array.isArray(t)) {
                return {items: t}
            }
            if (!t) {
                return {items: []}
            }
            return Object.assign({items: []}, t)
        }

        var ib = n(1);
        var ob = n.n(ib);
        var rb = n(12);
        var sb = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        sb.insert = "head";
        sb.singleton = true;
        var ab = ob()(rb["a"], sb);
        var cb = rb["a"].locals || {};
        const lb = new WeakMap;

        function db(t) {
            const {view: e, element: n, text: i, isDirectHost: o = true} = t;
            const r = e.document;
            if (!lb.has(r)) {
                lb.set(r, new Map);
                r.registerPostFixer((t => fb(r, t)))
            }
            lb.get(r).set(n, {text: i, isDirectHost: o});
            e.change((t => fb(r, t)))
        }

        function ub(t, e) {
            const n = e.document;
            t.change((t => {
                if (!lb.has(n)) {
                    return
                }
                const i = lb.get(n);
                const o = i.get(e);
                t.removeAttribute("data-placeholder", o.hostElement);
                mb(t, o.hostElement);
                i.delete(e)
            }))
        }

        function hb(t, e) {
            if (!e.hasClass("ck-placeholder")) {
                t.addClass("ck-placeholder", e);
                return true
            }
            return false
        }

        function mb(t, e) {
            if (e.hasClass("ck-placeholder")) {
                t.removeClass("ck-placeholder", e);
                return true
            }
            return false
        }

        function gb(t) {
            if (!t.isAttached()) {
                return false
            }
            const e = !Array.from(t.getChildren()).some((t => !t.is("uiElement")));
            const n = t.document;
            if (!n.isFocused && e) {
                return true
            }
            const i = n.selection;
            const o = i.anchor;
            if (e && o && o.parent !== t) {
                return true
            }
            return false
        }

        function fb(t, e) {
            const n = lb.get(t);
            let i = false;
            for (const [t, o] of n) {
                if (pb(e, t, o)) {
                    i = true
                }
            }
            return i
        }

        function pb(t, e, n) {
            const {text: i, isDirectHost: o} = n;
            const r = o ? e : bb(e);
            let s = false;
            if (!r) {
                return false
            }
            n.hostElement = r;
            if (r.getAttribute("data-placeholder") !== i) {
                t.setAttribute("data-placeholder", i, r);
                s = true
            }
            if (gb(r)) {
                if (hb(t, r)) {
                    s = true
                }
            } else if (mb(t, r)) {
                s = true
            }
            return s
        }

        function bb(t) {
            if (t.childCount === 1) {
                const e = t.getChild(0);
                if (e.is("element") && !e.is("uiElement")) {
                    return e
                }
            }
            return null
        }

        class kb {
            constructor() {
                this._replacedElements = []
            }

            replace(t, e) {
                this._replacedElements.push({element: t, newElement: e});
                t.style.display = "none";
                if (e) {
                    t.parentNode.insertBefore(e, t.nextSibling)
                }
            }

            restore() {
                this._replacedElements.forEach((({element: t, newElement: e}) => {
                    t.style.display = "";
                    if (e) {
                        e.remove()
                    }
                }));
                this._replacedElements = []
            }
        }

        class wb extends tb {
            constructor(t, e) {
                super(t);
                this.view = e;
                this._toolbarConfig = nb(t.config.get("toolbar"));
                this._elementReplacer = new kb
            }

            get element() {
                return this.view.element
            }

            init(t) {
                const e = this.editor;
                const n = this.view;
                const i = e.editing.view;
                const o = n.editable;
                const r = i.document.getRoot();
                o.name = r.rootName;
                n.render();
                const s = o.element;
                this.setEditableElement(o.name, s);
                this.focusTracker.add(s);
                n.editable.bind("isFocused").to(this.focusTracker);
                i.attachDomRoot(s);
                if (t) {
                    this._elementReplacer.replace(t, this.element)
                }
                this._initPlaceholder();
                this._initToolbar();
                this.fire("ready")
            }

            destroy() {
                const t = this.view;
                const e = this.editor.editing.view;
                this._elementReplacer.restore();
                e.detachDomRoot(t.editable.name);
                t.destroy();
                super.destroy()
            }

            _initToolbar() {
                const t = this.editor;
                const e = this.view;
                const n = t.editing.view;
                e.stickyPanel.bind("isActive").to(this.focusTracker, "isFocused");
                e.stickyPanel.limiterElement = e.element;
                if (this._toolbarConfig.viewportTopOffset) {
                    e.stickyPanel.viewportTopOffset = this._toolbarConfig.viewportTopOffset
                }
                e.toolbar.fillFromConfig(this._toolbarConfig.items, this.componentFactory);
                eb({
                    origin: n,
                    originFocusTracker: this.focusTracker,
                    originKeystrokeHandler: t.keystrokes,
                    toolbar: e.toolbar
                })
            }

            _initPlaceholder() {
                const t = this.editor;
                const e = t.editing.view;
                const n = e.document.getRoot();
                const i = t.sourceElement;
                const o = t.config.get("placeholder") || i && i.tagName.toLowerCase() === "textarea" && i.getAttribute("placeholder");
                if (o) {
                    db({view: e, element: n, text: o, isDirectHost: false})
                }
            }
        }

        class Ab extends vs {
            constructor(t = []) {
                super(t, {idProperty: "viewUid"});
                this.on("add", ((t, e, n) => {
                    this._renderViewIntoCollectionParent(e, n)
                }));
                this.on("remove", ((t, e) => {
                    if (e.element && this._parentElement) {
                        e.element.remove()
                    }
                }));
                this._parentElement = null
            }

            destroy() {
                this.map((t => t.destroy()))
            }

            setParent(t) {
                this._parentElement = t;
                for (const t of this) {
                    this._renderViewIntoCollectionParent(t)
                }
            }

            delegate(...t) {
                if (!t.length || !_b(t)) {
                    throw new ss["a"]("ui-viewcollection-delegate-wrong-events", this)
                }
                return {
                    to: e => {
                        for (const n of this) {
                            for (const i of t) {
                                n.delegate(i).to(e)
                            }
                        }
                        this.on("add", ((n, i) => {
                            for (const n of t) {
                                i.delegate(n).to(e)
                            }
                        }));
                        this.on("remove", ((n, i) => {
                            for (const n of t) {
                                i.stopDelegating(n, e)
                            }
                        }))
                    }
                }
            }

            _renderViewIntoCollectionParent(t, e) {
                if (!t.isRendered) {
                    t.render()
                }
                if (t.element && this._parentElement) {
                    this._parentElement.insertBefore(t.element, this._parentElement.children[e])
                }
            }
        }

        function _b(t) {
            return t.every((t => typeof t == "string"))
        }

        const Cb = "http://www.w3.org/1999/xhtml";

        class vb {
            constructor(t) {
                Object.assign(this, zb(Lb(t)));
                this._isRendered = false;
                this._revertData = null
            }

            render() {
                const t = this._renderNode({intoFragment: true});
                this._isRendered = true;
                return t
            }

            apply(t) {
                this._revertData = Gb();
                this._renderNode({node: t, isApplying: true, revertData: this._revertData});
                return t
            }

            revert(t) {
                if (!this._revertData) {
                    throw new ss["a"]("ui-template-revert-not-applied", [this, t])
                }
                this._revertTemplateFromNode(t, this._revertData)
            }

            * getViews() {
                function* t(e) {
                    if (e.children) {
                        for (const n of e.children) {
                            if (Wb(n)) {
                                yield n
                            } else if (qb(n)) {
                                yield* t(n)
                            }
                        }
                    }
                }

                yield* t(this)
            }

            static bind(t, e) {
                return {
                    to(n, i) {
                        return new xb({eventNameOrFunction: n, attribute: n, observable: t, emitter: e, callback: i})
                    }, if(n, i, o) {
                        return new Eb({observable: t, emitter: e, attribute: n, valueIfTrue: i, callback: o})
                    }
                }
            }

            static extend(t, e) {
                if (t._isRendered) {
                    throw new ss["a"]("template-extend-render", [this, t])
                }
                Hb(t, zb(Lb(e)))
            }

            _renderNode(t) {
                let e;
                if (t.node) {
                    e = this.tag && this.text
                } else {
                    e = this.tag ? this.text : !this.text
                }
                if (e) {
                    throw new ss["a"]("ui-template-wrong-syntax", this)
                }
                if (this.text) {
                    return this._renderText(t)
                } else {
                    return this._renderElement(t)
                }
            }

            _renderElement(t) {
                let e = t.node;
                if (!e) {
                    e = t.node = document.createElementNS(this.ns || Cb, this.tag)
                }
                this._renderAttributes(t);
                this._renderElementChildren(t);
                this._setUpListeners(t);
                return e
            }

            _renderText(t) {
                let e = t.node;
                if (e) {
                    t.revertData.text = e.textContent
                } else {
                    e = t.node = document.createTextNode("")
                }
                if (Db(this.text)) {
                    this._bindToObservable({schema: this.text, updater: Sb(e), data: t})
                } else {
                    e.textContent = this.text.join("")
                }
                return e
            }

            _renderAttributes(t) {
                let e, n, i, o;
                if (!this.attributes) {
                    return
                }
                const r = t.node;
                const s = t.revertData;
                for (e in this.attributes) {
                    i = r.getAttribute(e);
                    n = this.attributes[e];
                    if (s) {
                        s.attributes[e] = i
                    }
                    o = ct(n[0]) && n[0].ns ? n[0].ns : null;
                    if (Db(n)) {
                        const a = o ? n[0].value : n;
                        if (s && $b(e)) {
                            a.unshift(i)
                        }
                        this._bindToObservable({schema: a, updater: Ib(r, e, o), data: t})
                    } else if (e == "style" && typeof n[0] !== "string") {
                        this._renderStyleAttribute(n[0], t)
                    } else {
                        if (s && i && $b(e)) {
                            n.unshift(i)
                        }
                        n = n.map((t => t ? t.value || t : t)).reduce(((t, e) => t.concat(e)), []).reduce(Fb, "");
                        if (!Ub(n)) {
                            r.setAttributeNS(o, e, n)
                        }
                    }
                }
            }

            _renderStyleAttribute(t, e) {
                const n = e.node;
                for (const i in t) {
                    const o = t[i];
                    if (Db(o)) {
                        this._bindToObservable({schema: [o], updater: Bb(n, i), data: e})
                    } else {
                        n.style[i] = o
                    }
                }
            }

            _renderElementChildren(t) {
                const e = t.node;
                const n = t.intoFragment ? document.createDocumentFragment() : e;
                const i = t.isApplying;
                let o = 0;
                for (const r of this.children) {
                    if (Kb(r)) {
                        if (!i) {
                            r.setParent(e);
                            for (const t of r) {
                                n.appendChild(t.element)
                            }
                        }
                    } else if (Wb(r)) {
                        if (!i) {
                            if (!r.isRendered) {
                                r.render()
                            }
                            n.appendChild(r.element)
                        }
                    } else if (Md(r)) {
                        n.appendChild(r)
                    } else {
                        if (i) {
                            const e = t.revertData;
                            const i = Gb();
                            e.children.push(i);
                            r._renderNode({node: n.childNodes[o++], isApplying: true, revertData: i})
                        } else {
                            n.appendChild(r.render())
                        }
                    }
                }
                if (t.intoFragment) {
                    e.appendChild(n)
                }
            }

            _setUpListeners(t) {
                if (!this.eventListeners) {
                    return
                }
                for (const e in this.eventListeners) {
                    const n = this.eventListeners[e].map((n => {
                        const [i, o] = e.split("@");
                        return n.activateDomEventListener(i, o, t)
                    }));
                    if (t.revertData) {
                        t.revertData.bindings.push(n)
                    }
                }
            }

            _bindToObservable({schema: t, updater: e, data: n}) {
                const i = n.revertData;
                Mb(t, e, n);
                const o = t.filter((t => !Ub(t))).filter((t => t.observable)).map((i => i.activateAttributeListener(t, e, n)));
                if (i) {
                    i.bindings.push(o)
                }
            }

            _revertTemplateFromNode(t, e) {
                for (const t of e.bindings) {
                    for (const e of t) {
                        e()
                    }
                }
                if (e.text) {
                    t.textContent = e.text;
                    return
                }
                for (const n in e.attributes) {
                    const i = e.attributes[n];
                    if (i === null) {
                        t.removeAttribute(n)
                    } else {
                        t.setAttribute(n, i)
                    }
                }
                for (let n = 0; n < e.children.length; ++n) {
                    this._revertTemplateFromNode(t.childNodes[n], e.children[n])
                }
            }
        }

        Cs(vb, ds);

        class yb {
            constructor(t) {
                Object.assign(this, t)
            }

            getValue(t) {
                const e = this.observable[this.attribute];
                return this.callback ? this.callback(e, t) : e
            }

            activateAttributeListener(t, e, n) {
                const i = () => Mb(t, e, n);
                this.emitter.listenTo(this.observable, "change:" + this.attribute, i);
                return () => {
                    this.emitter.stopListening(this.observable, "change:" + this.attribute, i)
                }
            }
        }

        class xb extends yb {
            activateDomEventListener(t, e, n) {
                const i = (t, n) => {
                    if (!e || n.target.matches(e)) {
                        if (typeof this.eventNameOrFunction == "function") {
                            this.eventNameOrFunction(n)
                        } else {
                            this.observable.fire(this.eventNameOrFunction, n)
                        }
                    }
                };
                this.emitter.listenTo(n.node, t, i);
                return () => {
                    this.emitter.stopListening(n.node, t, i)
                }
            }
        }

        class Eb extends yb {
            getValue(t) {
                const e = super.getValue(t);
                return Ub(e) ? false : this.valueIfTrue || true
            }
        }

        function Db(t) {
            if (!t) {
                return false
            }
            if (t.value) {
                t = t.value
            }
            if (Array.isArray(t)) {
                return t.some(Db)
            } else if (t instanceof yb) {
                return true
            }
            return false
        }

        function Tb(t, e) {
            return t.map((t => {
                if (t instanceof yb) {
                    return t.getValue(e)
                }
                return t
            }))
        }

        function Mb(t, e, {node: n}) {
            let i = Tb(t, n);
            if (t.length == 1 && t[0] instanceof Eb) {
                i = i[0]
            } else {
                i = i.reduce(Fb, "")
            }
            if (Ub(i)) {
                e.remove()
            } else {
                e.set(i)
            }
        }

        function Sb(t) {
            return {
                set(e) {
                    t.textContent = e
                }, remove() {
                    t.textContent = ""
                }
            }
        }

        function Ib(t, e, n) {
            return {
                set(i) {
                    t.setAttributeNS(n, e, i)
                }, remove() {
                    t.removeAttributeNS(n, e)
                }
            }
        }

        function Bb(t, e) {
            return {
                set(n) {
                    t.style[e] = n
                }, remove() {
                    t.style[e] = null
                }
            }
        }

        function Lb(t) {
            const e = Kr(t, (t => {
                if (t && (t instanceof yb || qb(t) || Wb(t) || Kb(t))) {
                    return t
                }
            }));
            return e
        }

        function zb(t) {
            if (typeof t == "string") {
                t = Ob(t)
            } else if (t.text) {
                jb(t)
            }
            if (t.on) {
                t.eventListeners = Pb(t.on);
                delete t.on
            }
            if (!t.text) {
                if (t.attributes) {
                    Nb(t.attributes)
                }
                const e = [];
                if (t.children) {
                    if (Kb(t.children)) {
                        e.push(t.children)
                    } else {
                        for (const n of t.children) {
                            if (qb(n) || Wb(n) || Md(n)) {
                                e.push(n)
                            } else {
                                e.push(new vb(n))
                            }
                        }
                    }
                }
                t.children = e
            }
            return t
        }

        function Nb(t) {
            for (const e in t) {
                if (t[e].value) {
                    t[e].value = [].concat(t[e].value)
                }
                Rb(t, e)
            }
        }

        function Pb(t) {
            for (const e in t) {
                Rb(t, e)
            }
            return t
        }

        function Ob(t) {
            return {text: [t]}
        }

        function jb(t) {
            if (!Array.isArray(t.text)) {
                t.text = [t.text]
            }
        }

        function Rb(t, e) {
            if (!Array.isArray(t[e])) {
                t[e] = [t[e]]
            }
        }

        function Fb(t, e) {
            if (Ub(e)) {
                return t
            } else if (Ub(t)) {
                return e
            } else {
                return `${t} ${e}`
            }
        }

        function Vb(t, e) {
            for (const n in e) {
                if (t[n]) {
                    t[n].push(...e[n])
                } else {
                    t[n] = e[n]
                }
            }
        }

        function Hb(t, e) {
            if (e.attributes) {
                if (!t.attributes) {
                    t.attributes = {}
                }
                Vb(t.attributes, e.attributes)
            }
            if (e.eventListeners) {
                if (!t.eventListeners) {
                    t.eventListeners = {}
                }
                Vb(t.eventListeners, e.eventListeners)
            }
            if (e.text) {
                t.text.push(...e.text)
            }
            if (e.children && e.children.length) {
                if (t.children.length != e.children.length) {
                    throw new ss["a"]("ui-template-extend-children-mismatch", t)
                }
                let n = 0;
                for (const i of e.children) {
                    Hb(t.children[n++], i)
                }
            }
        }

        function Ub(t) {
            return !t && t !== 0
        }

        function Wb(t) {
            return t instanceof Zb
        }

        function qb(t) {
            return t instanceof vb
        }

        function Kb(t) {
            return t instanceof Ab
        }

        function Gb() {
            return {children: [], bindings: [], attributes: {}}
        }

        function $b(t) {
            return t == "class" || t == "style"
        }

        var Yb = n(13);
        var Qb = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        Qb.insert = "head";
        Qb.singleton = true;
        var Jb = ob()(Yb["a"], Qb);
        var Xb = Yb["a"].locals || {};

        class Zb {
            constructor(t) {
                this.element = null;
                this.isRendered = false;
                this.locale = t;
                this.t = t && t.t;
                this._viewCollections = new vs;
                this._unboundChildren = this.createCollection();
                this._viewCollections.on("add", ((e, n) => {
                    n.locale = t
                }));
                this.decorate("render")
            }

            get bindTemplate() {
                if (this._bindTemplate) {
                    return this._bindTemplate
                }
                return this._bindTemplate = vb.bind(this, this)
            }

            createCollection(t) {
                const e = new Ab(t);
                this._viewCollections.add(e);
                return e
            }

            registerChild(t) {
                if (!_s(t)) {
                    t = [t]
                }
                for (const e of t) {
                    this._unboundChildren.add(e)
                }
            }

            deregisterChild(t) {
                if (!_s(t)) {
                    t = [t]
                }
                for (const e of t) {
                    this._unboundChildren.remove(e)
                }
            }

            setTemplate(t) {
                this.template = new vb(t)
            }

            extendTemplate(t) {
                vb.extend(this.template, t)
            }

            render() {
                if (this.isRendered) {
                    throw new ss["a"]("ui-view-render-already-rendered", this)
                }
                if (this.template) {
                    this.element = this.template.render();
                    this.registerChild(this.template.getViews())
                }
                this.isRendered = true
            }

            destroy() {
                this.stopListening();
                this._viewCollections.map((t => t.destroy()));
                if (this.template && this.template._revertData) {
                    this.template.revert(this.element)
                }
            }
        }

        Cs(Zb, Qd);
        Cs(Zb, Qc);
        var tk = "[object String]";

        function ek(t) {
            return typeof t == "string" || !Ye(t) && E(t) && A(t) == tk
        }

        var nk = ek;

        function ik(t, e, n = {}, i = []) {
            const o = n && n.xmlns;
            const r = o ? t.createElementNS(o, e) : t.createElement(e);
            for (const t in n) {
                r.setAttribute(t, n[t])
            }
            if (nk(i) || !_s(i)) {
                i = [i]
            }
            for (let e of i) {
                if (nk(e)) {
                    e = t.createTextNode(e)
                }
                r.appendChild(e)
            }
            return r
        }

        class ok extends Ab {
            constructor(t, e = []) {
                super(e);
                this.locale = t
            }

            attachToDom() {
                this._bodyCollectionContainer = new vb({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-reset_all", "ck-body", "ck-rounded-corners"],
                        dir: this.locale.uiLanguageDirection
                    },
                    children: this
                }).render();
                let t = document.querySelector(".ck-body-wrapper");
                if (!t) {
                    t = ik(document, "div", {class: "ck-body-wrapper"});
                    document.body.appendChild(t)
                }
                t.appendChild(this._bodyCollectionContainer)
            }

            detachFromDom() {
                super.destroy();
                if (this._bodyCollectionContainer) {
                    this._bodyCollectionContainer.remove()
                }
                const t = document.querySelector(".ck-body-wrapper");
                if (t && t.childElementCount == 0) {
                    t.remove()
                }
            }
        }

        var rk = n(14);
        var sk = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        sk.insert = "head";
        sk.singleton = true;
        var ak = ob()(rk["a"], sk);
        var ck = rk["a"].locals || {};

        class lk extends Zb {
            constructor(t) {
                super(t);
                this.body = new ok(t)
            }

            render() {
                super.render();
                this.body.attachToDom()
            }

            destroy() {
                this.body.detachFromDom();
                return super.destroy()
            }
        }

        var dk = n(15);
        var uk = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        uk.insert = "head";
        uk.singleton = true;
        var hk = ob()(dk["a"], uk);
        var mk = dk["a"].locals || {};

        class gk extends Zb {
            constructor(t) {
                super(t);
                this.set("text");
                this.set("for");
                this.id = `ck-editor__label_${ns()}`;
                const e = this.bindTemplate;
                this.setTemplate({
                    tag: "label",
                    attributes: {class: ["ck", "ck-label"], id: this.id, for: e.to("for")},
                    children: [{text: e.to("text")}]
                })
            }
        }

        class fk extends lk {
            constructor(t) {
                super(t);
                this.top = this.createCollection();
                this.main = this.createCollection();
                this._voiceLabelView = this._createVoiceLabel();
                this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-reset", "ck-editor", "ck-rounded-corners"],
                        role: "application",
                        dir: t.uiLanguageDirection,
                        lang: t.uiLanguage,
                        "aria-labelledby": this._voiceLabelView.id
                    },
                    children: [this._voiceLabelView, {
                        tag: "div",
                        attributes: {class: ["ck", "ck-editor__top", "ck-reset_all"], role: "presentation"},
                        children: this.top
                    }, {
                        tag: "div",
                        attributes: {class: ["ck", "ck-editor__main"], role: "presentation"},
                        children: this.main
                    }]
                })
            }

            _createVoiceLabel() {
                const t = this.t;
                const e = new gk;
                e.text = t("Rich Text Editor");
                e.extendTemplate({attributes: {class: "ck-voice-label"}});
                return e
            }
        }

        class pk extends Zb {
            constructor(t, e, n) {
                super(t);
                this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-content", "ck-editor__editable", "ck-rounded-corners"],
                        lang: t.contentLanguage,
                        dir: t.contentLanguageDirection
                    }
                });
                this.name = null;
                this.set("isFocused", false);
                this._editableElement = n;
                this._hasExternalElement = !!this._editableElement;
                this._editingView = e
            }

            render() {
                super.render();
                if (this._hasExternalElement) {
                    this.template.apply(this.element = this._editableElement)
                } else {
                    this._editableElement = this.element
                }
                this.on("change:isFocused", (() => this._updateIsFocusedClasses()));
                this._updateIsFocusedClasses()
            }

            destroy() {
                if (this._hasExternalElement) {
                    this.template.revert(this._editableElement)
                }
                super.destroy()
            }

            _updateIsFocusedClasses() {
                const t = this._editingView;
                if (t.isRenderingInProgress) {
                    n(this)
                } else {
                    e(this)
                }

                function e(e) {
                    t.change((n => {
                        const i = t.document.getRoot(e.name);
                        n.addClass(e.isFocused ? "ck-focused" : "ck-blurred", i);
                        n.removeClass(e.isFocused ? "ck-blurred" : "ck-focused", i)
                    }))
                }

                function n(i) {
                    t.once("change:isRenderingInProgress", ((t, o, r) => {
                        if (!r) {
                            e(i)
                        } else {
                            n(i)
                        }
                    }))
                }
            }
        }

        class bk extends pk {
            constructor(t, e, n) {
                super(t, e, n);
                this.extendTemplate({attributes: {role: "textbox", class: "ck-editor__editable_inline"}})
            }

            render() {
                super.render();
                const t = this._editingView;
                const e = this.t;
                t.change((n => {
                    const i = t.document.getRoot(this.name);
                    n.setAttribute("aria-label", e("Rich Text Editor, %0", this.name), i)
                }))
            }
        }

        function kk(t) {
            return e => e + t
        }

        var wk = n(16);
        var Ak = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        Ak.insert = "head";
        Ak.singleton = true;
        var _k = ob()(wk["a"], Ak);
        var Ck = wk["a"].locals || {};
        const vk = kk("px");

        class yk extends Zb {
            constructor(t) {
                super(t);
                const e = this.bindTemplate;
                this.set("isActive", false);
                this.set("isSticky", false);
                this.set("limiterElement", null);
                this.set("limiterBottomOffset", 50);
                this.set("viewportTopOffset", 0);
                this.set("_marginLeft", null);
                this.set("_isStickyToTheLimiter", false);
                this.set("_hasViewportTopOffset", false);
                this.content = this.createCollection();
                this._contentPanelPlaceholder = new vb({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-sticky-panel__placeholder"],
                        style: {
                            display: e.to("isSticky", (t => t ? "block" : "none")),
                            height: e.to("isSticky", (t => t ? vk(this._panelRect.height) : null))
                        }
                    }
                }).render();
                this._contentPanel = new vb({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-sticky-panel__content", e.if("isSticky", "ck-sticky-panel__content_sticky"), e.if("_isStickyToTheLimiter", "ck-sticky-panel__content_sticky_bottom-limit")],
                        style: {
                            width: e.to("isSticky", (t => t ? vk(this._contentPanelPlaceholder.getBoundingClientRect().width) : null)),
                            top: e.to("_hasViewportTopOffset", (t => t ? vk(this.viewportTopOffset) : null)),
                            bottom: e.to("_isStickyToTheLimiter", (t => t ? vk(this.limiterBottomOffset) : null)),
                            marginLeft: e.to("_marginLeft")
                        }
                    },
                    children: this.content
                }).render();
                this.setTemplate({
                    tag: "div",
                    attributes: {class: ["ck", "ck-sticky-panel"]},
                    children: [this._contentPanelPlaceholder, this._contentPanel]
                })
            }

            render() {
                super.render();
                this._checkIfShouldBeSticky();
                this.listenTo(jd.window, "scroll", (() => {
                    this._checkIfShouldBeSticky()
                }));
                this.listenTo(this, "change:isActive", (() => {
                    this._checkIfShouldBeSticky()
                }))
            }

            _checkIfShouldBeSticky() {
                const t = this._panelRect = this._contentPanel.getBoundingClientRect();
                let e;
                if (!this.limiterElement) {
                    this.isSticky = false
                } else {
                    e = this._limiterRect = this.limiterElement.getBoundingClientRect();
                    this.isSticky = this.isActive && e.top < this.viewportTopOffset && this._panelRect.height + this.limiterBottomOffset < e.height
                }
                if (this.isSticky) {
                    this._isStickyToTheLimiter = e.bottom < t.height + this.limiterBottomOffset + this.viewportTopOffset;
                    this._hasViewportTopOffset = !this._isStickyToTheLimiter && !!this.viewportTopOffset;
                    this._marginLeft = this._isStickyToTheLimiter ? null : vk(-jd.window.scrollX)
                } else {
                    this._isStickyToTheLimiter = false;
                    this._hasViewportTopOffset = false;
                    this._marginLeft = null
                }
            }
        }

        class xk {
            constructor(t) {
                Object.assign(this, t);
                if (t.actions && t.keystrokeHandler) {
                    for (const e in t.actions) {
                        let n = t.actions[e];
                        if (typeof n == "string") {
                            n = [n]
                        }
                        for (const i of n) {
                            t.keystrokeHandler.set(i, ((t, n) => {
                                this[e]();
                                n()
                            }))
                        }
                    }
                }
            }

            get first() {
                return this.focusables.find(Ek) || null
            }

            get last() {
                return this.focusables.filter(Ek).slice(-1)[0] || null
            }

            get next() {
                return this._getFocusableItem(1)
            }

            get previous() {
                return this._getFocusableItem(-1)
            }

            get current() {
                let t = null;
                if (this.focusTracker.focusedElement === null) {
                    return null
                }
                this.focusables.find(((e, n) => {
                    const i = e.element === this.focusTracker.focusedElement;
                    if (i) {
                        t = n
                    }
                    return i
                }));
                return t
            }

            focusFirst() {
                this._focus(this.first)
            }

            focusLast() {
                this._focus(this.last)
            }

            focusNext() {
                this._focus(this.next)
            }

            focusPrevious() {
                this._focus(this.previous)
            }

            _focus(t) {
                if (t) {
                    t.focus()
                }
            }

            _getFocusableItem(t) {
                const e = this.current;
                const n = this.focusables.length;
                if (!n) {
                    return null
                }
                if (e === null) {
                    return this[t === 1 ? "first" : "last"]
                }
                let i = (e + n + t) % n;
                do {
                    const e = this.focusables.get(i);
                    if (Ek(e)) {
                        return e
                    }
                    i = (i + n + t) % n
                } while (i !== e);
                return null
            }
        }

        function Ek(t) {
            return !!(t.focus && jd.window.getComputedStyle(t.element).display != "none")
        }

        class Dk extends Zb {
            constructor(t) {
                super(t);
                this.setTemplate({tag: "span", attributes: {class: ["ck", "ck-toolbar__separator"]}})
            }
        }

        const Tk = 100;

        class Mk {
            constructor(t, e) {
                if (!Mk._observerInstance) {
                    Mk._createObserver()
                }
                this._element = t;
                this._callback = e;
                Mk._addElementCallback(t, e);
                Mk._observerInstance.observe(t)
            }

            destroy() {
                Mk._deleteElementCallback(this._element, this._callback)
            }

            static _addElementCallback(t, e) {
                if (!Mk._elementCallbacks) {
                    Mk._elementCallbacks = new Map
                }
                let n = Mk._elementCallbacks.get(t);
                if (!n) {
                    n = new Set;
                    Mk._elementCallbacks.set(t, n)
                }
                n.add(e)
            }

            static _deleteElementCallback(t, e) {
                const n = Mk._getElementCallbacks(t);
                if (n) {
                    n.delete(e);
                    if (!n.size) {
                        Mk._elementCallbacks.delete(t);
                        Mk._observerInstance.unobserve(t)
                    }
                }
                if (Mk._elementCallbacks && !Mk._elementCallbacks.size) {
                    Mk._observerInstance = null;
                    Mk._elementCallbacks = null
                }
            }

            static _getElementCallbacks(t) {
                if (!Mk._elementCallbacks) {
                    return null
                }
                return Mk._elementCallbacks.get(t)
            }

            static _createObserver() {
                let t;
                if (typeof jd.window.ResizeObserver === "function") {
                    t = jd.window.ResizeObserver
                } else {
                    t = Sk
                }
                Mk._observerInstance = new t((t => {
                    for (const e of t) {
                        const t = Mk._getElementCallbacks(e.target);
                        if (t) {
                            for (const n of t) {
                                n(e)
                            }
                        }
                    }
                }))
            }
        }

        Mk._observerInstance = null;
        Mk._elementCallbacks = null;

        class Sk {
            constructor(t) {
                this._callback = t;
                this._elements = new Set;
                this._previousRects = new Map;
                this._periodicCheckTimeout = null
            }

            observe(t) {
                this._elements.add(t);
                this._checkElementRectsAndExecuteCallback();
                if (this._elements.size === 1) {
                    this._startPeriodicCheck()
                }
            }

            unobserve(t) {
                this._elements.delete(t);
                this._previousRects.delete(t);
                if (!this._elements.size) {
                    this._stopPeriodicCheck()
                }
            }

            _startPeriodicCheck() {
                const t = () => {
                    this._checkElementRectsAndExecuteCallback();
                    this._periodicCheckTimeout = setTimeout(t, Tk)
                };
                this.listenTo(jd.window, "resize", (() => {
                    this._checkElementRectsAndExecuteCallback()
                }));
                this._periodicCheckTimeout = setTimeout(t, Tk)
            }

            _stopPeriodicCheck() {
                clearTimeout(this._periodicCheckTimeout);
                this.stopListening();
                this._previousRects.clear()
            }

            _checkElementRectsAndExecuteCallback() {
                const t = [];
                for (const e of this._elements) {
                    if (this._hasRectChanged(e)) {
                        t.push({target: e, contentRect: this._previousRects.get(e)})
                    }
                }
                if (t.length) {
                    this._callback(t)
                }
            }

            _hasRectChanged(t) {
                if (!t.ownerDocument.body.contains(t)) {
                    return false
                }
                const e = new Eh(t);
                const n = this._previousRects.get(t);
                const i = !n || !n.isEqual(e);
                this._previousRects.set(t, e);
                return i
            }
        }

        Cs(Sk, Qd);

        function Ik(t) {
            return t.bindTemplate.to((e => {
                if (e.target === t.element) {
                    e.preventDefault()
                }
            }))
        }

        class Bk extends Zb {
            constructor(t) {
                super(t);
                const e = this.bindTemplate;
                this.set("isVisible", false);
                this.set("position", "se");
                this.children = this.createCollection();
                this.setTemplate({
                    tag: "div",
                    attributes: {class: ["ck", "ck-reset", "ck-dropdown__panel", e.to("position", (t => `ck-dropdown__panel_${t}`)), e.if("isVisible", "ck-dropdown__panel-visible")]},
                    children: this.children,
                    on: {selectstart: e.to((t => t.preventDefault()))}
                })
            }

            focus() {
                if (this.children.length) {
                    this.children.first.focus()
                }
            }

            focusLast() {
                if (this.children.length) {
                    const t = this.children.last;
                    if (typeof t.focusLast === "function") {
                        t.focusLast()
                    } else {
                        t.focus()
                    }
                }
            }
        }

        var Lk = n(17);
        var zk = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        zk.insert = "head";
        zk.singleton = true;
        var Nk = ob()(Lk["a"], zk);
        var Pk = Lk["a"].locals || {};

        function Ok(t) {
            if (!t || !t.parentNode) {
                return null
            }
            if (t.offsetParent === jd.document.body) {
                return null
            }
            return t.offsetParent
        }

        function jk({element: t, target: e, positions: n, limiter: i, fitInViewport: o}) {
            if (gt(e)) {
                e = e()
            }
            if (gt(i)) {
                i = i()
            }
            const r = Ok(t);
            const s = new Eh(t);
            const a = new Eh(e);
            let c;
            let l;
            if (!i && !o) {
                [l, c] = Rk(n[0], a, s)
            } else {
                const t = i && new Eh(i).getVisible();
                const e = o && new Eh(jd.window);
                const r = Fk(n, {targetRect: a, elementRect: s, limiterRect: t, viewportRect: e});
                [l, c] = r || Rk(n[0], a, s)
            }
            let d = Wk(c);
            if (r) {
                d = Uk(d, r)
            }
            return {left: d.left, top: d.top, name: l}
        }

        function Rk(t, e, n) {
            const i = t(e, n);
            if (!i) {
                return null
            }
            const {left: o, top: r, name: s} = i;
            return [s, n.clone().moveTo(o, r)]
        }

        function Fk(t, e) {
            const {elementRect: n, viewportRect: i} = e;
            const o = n.getArea();
            const r = Vk(t, e);
            if (i) {
                const t = r.filter((({viewportIntersectArea: t}) => t === o));
                const e = Hk(t, o);
                if (e) {
                    return e
                }
            }
            return Hk(r, o)
        }

        function Vk(t, {targetRect: e, elementRect: n, limiterRect: i, viewportRect: o}) {
            const r = [];
            const s = n.getArea();
            for (const a of t) {
                const t = Rk(a, e, n);
                if (!t) {
                    continue
                }
                const [c, l] = t;
                let d = 0;
                let u = 0;
                if (i) {
                    if (o) {
                        const t = i.getIntersection(o);
                        if (t) {
                            d = t.getIntersectionArea(l)
                        }
                    } else {
                        d = i.getIntersectionArea(l)
                    }
                }
                if (o) {
                    u = o.getIntersectionArea(l)
                }
                const h = {positionName: c, positionRect: l, limiterIntersectArea: d, viewportIntersectArea: u};
                if (d === s) {
                    return [h]
                }
                r.push(h)
            }
            return r
        }

        function Hk(t, e) {
            let n = 0;
            let i;
            let o;
            for (const {positionName: r, positionRect: s, limiterIntersectArea: a, viewportIntersectArea: c} of t) {
                if (a === e) {
                    return [r, s]
                }
                const t = c ** 2 + a ** 2;
                if (t > n) {
                    n = t;
                    i = s;
                    o = r
                }
            }
            return i ? [o, i] : null
        }

        function Uk({left: t, top: e}, n) {
            const i = Wk(new Eh(n));
            const o = yh(n);
            t -= i.left;
            e -= i.top;
            t += n.scrollLeft;
            e += n.scrollTop;
            t -= o.left;
            e -= o.top;
            return {left: t, top: e}
        }

        function Wk({left: t, top: e}) {
            const {scrollX: n, scrollY: i} = jd.window;
            return {left: t + n, top: e + i}
        }

        class qk extends Zb {
            constructor(t, e, n) {
                super(t);
                const i = this.bindTemplate;
                this.buttonView = e;
                this.panelView = n;
                this.set("isOpen", false);
                this.set("isEnabled", true);
                this.set("class");
                this.set("id");
                this.set("panelPosition", "auto");
                this.keystrokes = new Fp;
                this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-dropdown", i.to("class"), i.if("isEnabled", "ck-disabled", (t => !t))],
                        id: i.to("id"),
                        "aria-describedby": i.to("ariaDescribedById")
                    },
                    children: [e, n]
                });
                e.extendTemplate({attributes: {class: ["ck-dropdown__button"]}})
            }

            render() {
                super.render();
                this.listenTo(this.buttonView, "open", (() => {
                    this.isOpen = !this.isOpen
                }));
                this.panelView.bind("isVisible").to(this, "isOpen");
                this.on("change:isOpen", (() => {
                    if (!this.isOpen) {
                        return
                    }
                    if (this.panelPosition === "auto") {
                        this.panelView.position = qk._getOptimalPosition({
                            element: this.panelView.element,
                            target: this.buttonView.element,
                            fitInViewport: true,
                            positions: this._panelPositions
                        }).name
                    } else {
                        this.panelView.position = this.panelPosition
                    }
                }));
                this.keystrokes.listenTo(this.element);
                const t = (t, e) => {
                    if (this.isOpen) {
                        this.buttonView.focus();
                        this.isOpen = false;
                        e()
                    }
                };
                this.keystrokes.set("arrowdown", ((t, e) => {
                    if (this.buttonView.isEnabled && !this.isOpen) {
                        this.isOpen = true;
                        e()
                    }
                }));
                this.keystrokes.set("arrowright", ((t, e) => {
                    if (this.isOpen) {
                        e()
                    }
                }));
                this.keystrokes.set("arrowleft", t);
                this.keystrokes.set("esc", t)
            }

            focus() {
                this.buttonView.focus()
            }

            get _panelPositions() {
                const {southEast: t, southWest: e, northEast: n, northWest: i} = qk.defaultPanelPositions;
                if (this.locale.uiLanguageDirection === "ltr") {
                    return [t, e, n, i]
                } else {
                    return [e, t, i, n]
                }
            }
        }

        qk.defaultPanelPositions = {
            southEast: t => ({top: t.bottom, left: t.left, name: "se"}),
            southWest: (t, e) => ({top: t.bottom, left: t.left - e.width + t.width, name: "sw"}),
            northEast: (t, e) => ({top: t.top - e.height, left: t.left, name: "ne"}),
            northWest: (t, e) => ({top: t.bottom - e.height, left: t.left - e.width + t.width, name: "nw"})
        };
        qk._getOptimalPosition = jk;
        var Kk = n(18);
        var Gk = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        Gk.insert = "head";
        Gk.singleton = true;
        var $k = ob()(Kk["a"], Gk);
        var Yk = Kk["a"].locals || {};

        class Qk extends Zb {
            constructor() {
                super();
                const t = this.bindTemplate;
                this.set("content", "");
                this.set("viewBox", "0 0 20 20");
                this.set("fillColor", "");
                this.setTemplate({
                    tag: "svg",
                    ns: "http://www.w3.org/2000/svg",
                    attributes: {class: ["ck", "ck-icon"], viewBox: t.to("viewBox")}
                })
            }

            render() {
                super.render();
                this._updateXMLContent();
                this._colorFillPaths();
                this.on("change:content", (() => {
                    this._updateXMLContent();
                    this._colorFillPaths()
                }));
                this.on("change:fillColor", (() => {
                    this._colorFillPaths()
                }))
            }

            _updateXMLContent() {
                if (this.content) {
                    const t = (new DOMParser).parseFromString(this.content.trim(), "image/svg+xml");
                    const e = t.querySelector("svg");
                    const n = e.getAttribute("viewBox");
                    if (n) {
                        this.viewBox = n
                    }
                    this.element.innerHTML = "";
                    while (e.childNodes.length > 0) {
                        this.element.appendChild(e.childNodes[0])
                    }
                }
            }

            _colorFillPaths() {
                if (this.fillColor) {
                    this.element.querySelectorAll(".ck-icon__fill").forEach((t => {
                        t.style.fill = this.fillColor
                    }))
                }
            }
        }

        var Jk = n(19);
        var Xk = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        Xk.insert = "head";
        Xk.singleton = true;
        var Zk = ob()(Jk["a"], Xk);
        var tw = Jk["a"].locals || {};

        class ew extends Zb {
            constructor(t) {
                super(t);
                this.set("text", "");
                this.set("position", "s");
                const e = this.bindTemplate;
                this.setTemplate({
                    tag: "span",
                    attributes: {class: ["ck", "ck-tooltip", e.to("position", (t => "ck-tooltip_" + t)), e.if("text", "ck-hidden", (t => !t.trim()))]},
                    children: [{
                        tag: "span",
                        attributes: {class: ["ck", "ck-tooltip__text"]},
                        children: [{text: e.to("text")}]
                    }]
                })
            }
        }

        var nw = n(20);
        var iw = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        iw.insert = "head";
        iw.singleton = true;
        var ow = ob()(nw["a"], iw);
        var rw = nw["a"].locals || {};

        class sw extends Zb {
            constructor(t) {
                super(t);
                const e = this.bindTemplate;
                const n = ns();
                this.set("class");
                this.set("labelStyle");
                this.set("icon");
                this.set("isEnabled", true);
                this.set("isOn", false);
                this.set("isVisible", true);
                this.set("isToggleable", false);
                this.set("keystroke");
                this.set("label");
                this.set("tabindex", -1);
                this.set("tooltip");
                this.set("tooltipPosition", "s");
                this.set("type", "button");
                this.set("withText", false);
                this.set("withKeystroke", false);
                this.children = this.createCollection();
                this.tooltipView = this._createTooltipView();
                this.labelView = this._createLabelView(n);
                this.iconView = new Qk;
                this.iconView.extendTemplate({attributes: {class: "ck-button__icon"}});
                this.keystrokeView = this._createKeystrokeView();
                this.bind("_tooltipString").to(this, "tooltip", this, "label", this, "keystroke", this._getTooltipString.bind(this));
                this.setTemplate({
                    tag: "button",
                    attributes: {
                        class: ["ck", "ck-button", e.to("class"), e.if("isEnabled", "ck-disabled", (t => !t)), e.if("isVisible", "ck-hidden", (t => !t)), e.to("isOn", (t => t ? "ck-on" : "ck-off")), e.if("withText", "ck-button_with-text"), e.if("withKeystroke", "ck-button_with-keystroke")],
                        type: e.to("type", (t => t ? t : "button")),
                        tabindex: e.to("tabindex"),
                        "aria-labelledby": `ck-editor__aria-label_${n}`,
                        "aria-disabled": e.if("isEnabled", true, (t => !t)),
                        "aria-pressed": e.to("isOn", (t => this.isToggleable ? String(t) : false))
                    },
                    children: this.children,
                    on: {
                        mousedown: e.to((t => {
                            t.preventDefault()
                        })), click: e.to((t => {
                            if (this.isEnabled) {
                                this.fire("execute")
                            } else {
                                t.preventDefault()
                            }
                        }))
                    }
                })
            }

            render() {
                super.render();
                if (this.icon) {
                    this.iconView.bind("content").to(this, "icon");
                    this.children.add(this.iconView)
                }
                this.children.add(this.tooltipView);
                this.children.add(this.labelView);
                if (this.withKeystroke) {
                    this.children.add(this.keystrokeView)
                }
            }

            focus() {
                this.element.focus()
            }

            _createTooltipView() {
                const t = new ew;
                t.bind("text").to(this, "_tooltipString");
                t.bind("position").to(this, "tooltipPosition");
                return t
            }

            _createLabelView(t) {
                const e = new Zb;
                const n = this.bindTemplate;
                e.setTemplate({
                    tag: "span",
                    attributes: {
                        class: ["ck", "ck-button__label"],
                        style: n.to("labelStyle"),
                        id: `ck-editor__aria-label_${t}`
                    },
                    children: [{text: this.bindTemplate.to("label")}]
                });
                return e
            }

            _createKeystrokeView() {
                const t = new Zb;
                t.setTemplate({
                    tag: "span",
                    attributes: {class: ["ck", "ck-button__keystroke"]},
                    children: [{text: this.bindTemplate.to("keystroke", (t => jl(t)))}]
                });
                return t
            }

            _getTooltipString(t, e, n) {
                if (t) {
                    if (typeof t == "string") {
                        return t
                    } else {
                        if (n) {
                            n = jl(n)
                        }
                        if (t instanceof Function) {
                            return t(e, n)
                        } else {
                            return `${e}${n ? ` (${n})` : ""}`
                        }
                    }
                }
                return ""
            }
        }

        var aw = '<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M.941 4.523a.75.75 0 1 1 1.06-1.06l3.006 3.005 3.005-3.005a.75.75 0 1 1 1.06 1.06l-3.549 3.55a.75.75 0 0 1-1.168-.136L.941 4.523z"/></svg>';

        class cw extends sw {
            constructor(t) {
                super(t);
                this.arrowView = this._createArrowView();
                this.extendTemplate({attributes: {"aria-haspopup": true}});
                this.delegate("execute").to(this, "open")
            }

            render() {
                super.render();
                this.children.add(this.arrowView)
            }

            _createArrowView() {
                const t = new Qk;
                t.content = aw;
                t.extendTemplate({attributes: {class: "ck-dropdown__arrow"}});
                return t
            }
        }

        var lw = n(21);
        var dw = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        dw.insert = "head";
        dw.singleton = true;
        var uw = ob()(lw["a"], dw);
        var hw = lw["a"].locals || {};

        class mw extends Zb {
            constructor() {
                super();
                this.items = this.createCollection();
                this.focusTracker = new Zp;
                this.keystrokes = new Fp;
                this._focusCycler = new xk({
                    focusables: this.items,
                    focusTracker: this.focusTracker,
                    keystrokeHandler: this.keystrokes,
                    actions: {focusPrevious: "arrowup", focusNext: "arrowdown"}
                });
                this.setTemplate({tag: "ul", attributes: {class: ["ck", "ck-reset", "ck-list"]}, children: this.items})
            }

            render() {
                super.render();
                for (const t of this.items) {
                    this.focusTracker.add(t.element)
                }
                this.items.on("add", ((t, e) => {
                    this.focusTracker.add(e.element)
                }));
                this.items.on("remove", ((t, e) => {
                    this.focusTracker.remove(e.element)
                }));
                this.keystrokes.listenTo(this.element)
            }

            focus() {
                this._focusCycler.focusFirst()
            }

            focusLast() {
                this._focusCycler.focusLast()
            }
        }

        class gw extends Zb {
            constructor(t) {
                super(t);
                this.children = this.createCollection();
                this.setTemplate({tag: "li", attributes: {class: ["ck", "ck-list__item"]}, children: this.children})
            }

            focus() {
                this.children.first.focus()
            }
        }

        class fw extends Zb {
            constructor(t) {
                super(t);
                this.setTemplate({tag: "li", attributes: {class: ["ck", "ck-list__separator"]}})
            }
        }

        var pw = n(22);
        var bw = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        bw.insert = "head";
        bw.singleton = true;
        var kw = ob()(pw["a"], bw);
        var ww = pw["a"].locals || {};

        class Aw extends sw {
            constructor(t) {
                super(t);
                this.isToggleable = true;
                this.toggleSwitchView = this._createToggleView();
                this.extendTemplate({attributes: {class: "ck-switchbutton"}})
            }

            render() {
                super.render();
                this.children.add(this.toggleSwitchView)
            }

            _createToggleView() {
                const t = new Zb;
                t.setTemplate({
                    tag: "span",
                    attributes: {class: ["ck", "ck-button__toggle"]},
                    children: [{tag: "span", attributes: {class: ["ck", "ck-button__toggle__inner"]}}]
                });
                return t
            }
        }

        function _w({emitter: t, activator: e, callback: n, contextElements: i}) {
            t.listenTo(document, "mousedown", ((t, o) => {
                if (!e()) {
                    return
                }
                const r = typeof o.composedPath == "function" ? o.composedPath() : [];
                for (const t of i) {
                    if (t.contains(o.target) || r.includes(t)) {
                        return
                    }
                }
                n()
            }))
        }

        var Cw = n(23);
        var vw = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        vw.insert = "head";
        vw.singleton = true;
        var yw = ob()(Cw["a"], vw);
        var xw = Cw["a"].locals || {};
        var Ew = n(24);
        var Dw = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        Dw.insert = "head";
        Dw.singleton = true;
        var Tw = ob()(Ew["a"], Dw);
        var Mw = Ew["a"].locals || {};

        function Sw(t, e = cw) {
            const n = new e(t);
            const i = new Bk(t);
            const o = new qk(t, n, i);
            n.bind("isEnabled").to(o);
            if (n instanceof cw) {
                n.bind("isOn").to(o, "isOpen")
            } else {
                n.arrowView.bind("isOn").to(o, "isOpen")
            }
            Lw(o);
            return o
        }

        function Iw(t, e) {
            const n = t.locale;
            const i = n.t;
            const o = t.toolbarView = new Hw(n);
            o.set("ariaLabel", i("Dropdown toolbar"));
            t.extendTemplate({attributes: {class: ["ck-toolbar-dropdown"]}});
            e.map((t => o.items.add(t)));
            t.panelView.children.add(o);
            o.items.delegate("execute").to(t)
        }

        function Bw(t, e) {
            const n = t.locale;
            const i = t.listView = new mw(n);
            i.items.bindTo(e).using((({type: t, model: e}) => {
                if (t === "separator") {
                    return new fw(n)
                } else if (t === "button" || t === "switchbutton") {
                    const i = new gw(n);
                    let o;
                    if (t === "button") {
                        o = new sw(n)
                    } else {
                        o = new Aw(n)
                    }
                    o.bind(...Object.keys(e)).to(e);
                    o.delegate("execute").to(i);
                    i.children.add(o);
                    return i
                }
            }));
            t.panelView.children.add(i);
            i.items.delegate("execute").to(t)
        }

        function Lw(t) {
            zw(t);
            Nw(t);
            Pw(t)
        }

        function zw(t) {
            t.on("render", (() => {
                _w({
                    emitter: t, activator: () => t.isOpen, callback: () => {
                        t.isOpen = false
                    }, contextElements: [t.element]
                })
            }))
        }

        function Nw(t) {
            t.on("execute", (e => {
                if (e.source instanceof Aw) {
                    return
                }
                t.isOpen = false
            }))
        }

        function Pw(t) {
            t.keystrokes.set("arrowdown", ((e, n) => {
                if (t.isOpen) {
                    t.panelView.focus();
                    n()
                }
            }));
            t.keystrokes.set("arrowup", ((e, n) => {
                if (t.isOpen) {
                    t.panelView.focusLast();
                    n()
                }
            }))
        }

        var Ow = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><circle cx="9.5" cy="4.5" r="1.5"/><circle cx="9.5" cy="10.5" r="1.5"/><circle cx="9.5" cy="16.5" r="1.5"/></svg>';
        var jw = n(25);
        var Rw = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        Rw.insert = "head";
        Rw.singleton = true;
        var Fw = ob()(jw["a"], Rw);
        var Vw = jw["a"].locals || {};

        class Hw extends Zb {
            constructor(t, e) {
                super(t);
                const n = this.bindTemplate;
                const i = this.t;
                this.options = e || {};
                this.set("ariaLabel", i("Editor toolbar"));
                this.set("maxWidth", "auto");
                this.items = this.createCollection();
                this.focusTracker = new Zp;
                this.keystrokes = new Fp;
                this.set("class");
                this.set("isCompact", false);
                this.itemsView = new Uw(t);
                this.children = this.createCollection();
                this.children.add(this.itemsView);
                this.focusables = this.createCollection();
                this._focusCycler = new xk({
                    focusables: this.focusables,
                    focusTracker: this.focusTracker,
                    keystrokeHandler: this.keystrokes,
                    actions: {focusPrevious: ["arrowleft", "arrowup"], focusNext: ["arrowright", "arrowdown"]}
                });
                this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-toolbar", n.to("class"), n.if("isCompact", "ck-toolbar_compact")],
                        role: "toolbar",
                        "aria-label": n.to("ariaLabel"),
                        style: {maxWidth: n.to("maxWidth")}
                    },
                    children: this.children,
                    on: {mousedown: Ik(this)}
                });
                this._behavior = this.options.shouldGroupWhenFull ? new qw(this) : new Ww(this)
            }

            render() {
                super.render();
                for (const t of this.items) {
                    this.focusTracker.add(t.element)
                }
                this.items.on("add", ((t, e) => {
                    this.focusTracker.add(e.element)
                }));
                this.items.on("remove", ((t, e) => {
                    this.focusTracker.remove(e.element)
                }));
                this.keystrokes.listenTo(this.element);
                this._behavior.render(this)
            }

            destroy() {
                this._behavior.destroy();
                return super.destroy()
            }

            focus() {
                this._focusCycler.focusFirst()
            }

            focusLast() {
                this._focusCycler.focusLast()
            }

            fillFromConfig(t, e) {
                this.items.addMany(t.map((t => {
                    if (t == "|") {
                        return new Dk
                    } else if (e.has(t)) {
                        return e.create(t)
                    } else {
                        Object(ss["c"])("toolbarview-item-unavailable", {name: t})
                    }
                })).filter((t => t !== undefined)))
            }
        }

        class Uw extends Zb {
            constructor(t) {
                super(t);
                this.children = this.createCollection();
                this.setTemplate({
                    tag: "div",
                    attributes: {class: ["ck", "ck-toolbar__items"]},
                    children: this.children
                })
            }
        }

        class Ww {
            constructor(t) {
                const e = t.bindTemplate;
                t.set("isVertical", false);
                t.itemsView.children.bindTo(t.items).using((t => t));
                t.focusables.bindTo(t.items).using((t => t));
                t.extendTemplate({attributes: {class: [e.if("isVertical", "ck-toolbar_vertical")]}})
            }

            render() {
            }

            destroy() {
            }
        }

        class qw {
            constructor(t) {
                this.view = t;
                this.viewChildren = t.children;
                this.viewFocusables = t.focusables;
                this.viewItemsView = t.itemsView;
                this.viewFocusTracker = t.focusTracker;
                this.viewLocale = t.locale;
                this.ungroupedItems = t.createCollection();
                this.groupedItems = t.createCollection();
                this.groupedItemsDropdown = this._createGroupedItemsDropdown();
                this.resizeObserver = null;
                this.cachedPadding = null;
                this.shouldUpdateGroupingOnNextResize = false;
                t.itemsView.children.bindTo(this.ungroupedItems).using((t => t));
                this.ungroupedItems.on("add", this._updateFocusCycleableItems.bind(this));
                this.ungroupedItems.on("remove", this._updateFocusCycleableItems.bind(this));
                t.children.on("add", this._updateFocusCycleableItems.bind(this));
                t.children.on("remove", this._updateFocusCycleableItems.bind(this));
                t.items.on("change", ((t, e) => {
                    const n = e.index;
                    for (const t of e.removed) {
                        if (n >= this.ungroupedItems.length) {
                            this.groupedItems.remove(t)
                        } else {
                            this.ungroupedItems.remove(t)
                        }
                    }
                    for (let t = n; t < n + e.added.length; t++) {
                        const i = e.added[t - n];
                        if (t > this.ungroupedItems.length) {
                            this.groupedItems.add(i, t - this.ungroupedItems.length)
                        } else {
                            this.ungroupedItems.add(i, t)
                        }
                    }
                    this._updateGrouping()
                }));
                t.extendTemplate({attributes: {class: ["ck-toolbar_grouping"]}})
            }

            render(t) {
                this.viewElement = t.element;
                this._enableGroupingOnResize();
                this._enableGroupingOnMaxWidthChange(t)
            }

            destroy() {
                this.groupedItemsDropdown.destroy();
                this.resizeObserver.destroy()
            }

            _updateGrouping() {
                if (!this.viewElement.ownerDocument.body.contains(this.viewElement)) {
                    return
                }
                if (!this.viewElement.offsetParent) {
                    this.shouldUpdateGroupingOnNextResize = true;
                    return
                }
                const t = this.groupedItems.length;
                let e;
                while (this._areItemsOverflowing) {
                    this._groupLastItem();
                    e = true
                }
                if (!e && this.groupedItems.length) {
                    while (this.groupedItems.length && !this._areItemsOverflowing) {
                        this._ungroupFirstItem()
                    }
                    if (this._areItemsOverflowing) {
                        this._groupLastItem()
                    }
                }
                if (this.groupedItems.length !== t) {
                    this.view.fire("groupedItemsUpdate")
                }
            }

            get _areItemsOverflowing() {
                if (!this.ungroupedItems.length) {
                    return false
                }
                const t = this.viewElement;
                const e = this.viewLocale.uiLanguageDirection;
                const n = new Eh(t.lastChild);
                const i = new Eh(t);
                if (!this.cachedPadding) {
                    const n = jd.window.getComputedStyle(t);
                    const i = e === "ltr" ? "paddingRight" : "paddingLeft";
                    this.cachedPadding = Number.parseInt(n[i])
                }
                if (e === "ltr") {
                    return n.right > i.right - this.cachedPadding
                } else {
                    return n.left < i.left + this.cachedPadding
                }
            }

            _enableGroupingOnResize() {
                let t;
                this.resizeObserver = new Mk(this.viewElement, (e => {
                    if (!t || t !== e.contentRect.width || this.shouldUpdateGroupingOnNextResize) {
                        this.shouldUpdateGroupingOnNextResize = false;
                        this._updateGrouping();
                        t = e.contentRect.width
                    }
                }));
                this._updateGrouping()
            }

            _enableGroupingOnMaxWidthChange(t) {
                t.on("change:maxWidth", (() => {
                    this._updateGrouping()
                }))
            }

            _groupLastItem() {
                if (!this.groupedItems.length) {
                    this.viewChildren.add(new Dk);
                    this.viewChildren.add(this.groupedItemsDropdown);
                    this.viewFocusTracker.add(this.groupedItemsDropdown.element)
                }
                this.groupedItems.add(this.ungroupedItems.remove(this.ungroupedItems.last), 0)
            }

            _ungroupFirstItem() {
                this.ungroupedItems.add(this.groupedItems.remove(this.groupedItems.first));
                if (!this.groupedItems.length) {
                    this.viewChildren.remove(this.groupedItemsDropdown);
                    this.viewChildren.remove(this.viewChildren.last);
                    this.viewFocusTracker.remove(this.groupedItemsDropdown.element)
                }
            }

            _createGroupedItemsDropdown() {
                const t = this.viewLocale;
                const e = t.t;
                const n = Sw(t);
                n.class = "ck-toolbar__grouped-dropdown";
                n.panelPosition = t.uiLanguageDirection === "ltr" ? "sw" : "se";
                Iw(n, []);
                n.buttonView.set({label: e("Show more items"), tooltip: true, icon: Ow});
                n.toolbarView.items.bindTo(this.groupedItems).using((t => t));
                return n
            }

            _updateFocusCycleableItems() {
                this.viewFocusables.clear();
                this.ungroupedItems.map((t => {
                    this.viewFocusables.add(t)
                }));
                if (this.groupedItems.length) {
                    this.viewFocusables.add(this.groupedItemsDropdown)
                }
            }
        }

        var Kw = n(26);
        var Gw = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        Gw.insert = "head";
        Gw.singleton = true;
        var $w = ob()(Kw["a"], Gw);
        var Yw = Kw["a"].locals || {};

        class Qw extends fk {
            constructor(t, e, n = {}) {
                super(t);
                this.stickyPanel = new yk(t);
                this.toolbar = new Hw(t, {shouldGroupWhenFull: n.shouldToolbarGroupWhenFull});
                this.editable = new bk(t, e)
            }

            render() {
                super.render();
                this.stickyPanel.content.add(this.toolbar);
                this.top.add(this.stickyPanel);
                this.main.add(this.editable)
            }
        }

        function Jw(t) {
            if (t instanceof HTMLTextAreaElement) {
                return t.value
            }
            return t.innerHTML
        }

        class Xw extends Hp {
            constructor(t, e) {
                super(e);
                if ($r(t)) {
                    this.sourceElement = t
                }
                this.data.processor = new Qp(this.data.viewDocument);
                this.model.document.createRoot();
                const n = !this.config.get("toolbar.shouldNotGroupWhenFull");
                const i = new Qw(this.locale, this.editing.view, {shouldToolbarGroupWhenFull: n});
                this.ui = new wb(this, i);
                $p(this)
            }

            destroy() {
                if (this.sourceElement) {
                    this.updateSourceElement()
                }
                this.ui.destroy();
                return super.destroy()
            }

            static create(t, e = {}) {
                return new Promise((n => {
                    const i = new this(t, e);
                    n(i.initPlugins().then((() => i.ui.init($r(t) ? t : null))).then((() => {
                        if (!$r(t) && e.initialData) {
                            throw new ss["a"]("editor-create-initial-data", null)
                        }
                        const n = e.initialData || Zw(t);
                        return i.data.init(n)
                    })).then((() => i.fire("ready"))).then((() => i)))
                }))
            }
        }

        Cs(Xw, Wp);
        Cs(Xw, Gp);

        function Zw(t) {
            return $r(t) ? Jw(t) : t
        }

        class tA {
            constructor(t) {
                this.editor = t;
                this.set("isEnabled", true);
                this._disableStack = new Set
            }

            forceDisabled(t) {
                this._disableStack.add(t);
                if (this._disableStack.size == 1) {
                    this.on("set:isEnabled", eA, {priority: "highest"});
                    this.isEnabled = false
                }
            }

            clearForceDisabled(t) {
                this._disableStack.delete(t);
                if (this._disableStack.size == 0) {
                    this.off("set:isEnabled", eA);
                    this.isEnabled = true
                }
            }

            destroy() {
                this.stopListening()
            }

            static get isContextPlugin() {
                return false
            }
        }

        Cs(tA, Qc);

        function eA(t) {
            t.return = false;
            t.stop()
        }

        class nA {
            constructor(t) {
                this.editor = t;
                this.set("value", undefined);
                this.set("isEnabled", false);
                this._disableStack = new Set;
                this.decorate("execute");
                this.listenTo(this.editor.model.document, "change", (() => {
                    this.refresh()
                }));
                this.on("execute", (t => {
                    if (!this.isEnabled) {
                        t.stop()
                    }
                }), {priority: "high"});
                this.listenTo(t, "change:isReadOnly", ((t, e, n) => {
                    if (n) {
                        this.forceDisabled("readOnlyMode")
                    } else {
                        this.clearForceDisabled("readOnlyMode")
                    }
                }))
            }

            refresh() {
                this.isEnabled = true
            }

            forceDisabled(t) {
                this._disableStack.add(t);
                if (this._disableStack.size == 1) {
                    this.on("set:isEnabled", iA, {priority: "highest"});
                    this.isEnabled = false
                }
            }

            clearForceDisabled(t) {
                this._disableStack.delete(t);
                if (this._disableStack.size == 0) {
                    this.off("set:isEnabled", iA);
                    this.refresh()
                }
            }

            execute() {
            }

            destroy() {
                this.stopListening()
            }
        }

        Cs(nA, Qc);

        function iA(t) {
            t.return = false;
            t.stop()
        }

        function oA(t) {
            const e = t.next();
            if (e.done) {
                return null
            }
            return e.value
        }

        const rA = ["left", "right", "center", "justify"];

        function sA(t) {
            return rA.includes(t)
        }

        function aA(t, e) {
            if (e.contentLanguageDirection == "rtl") {
                return t === "right"
            } else {
                return t === "left"
            }
        }

        const cA = "alignment";

        class lA extends nA {
            refresh() {
                const t = this.editor;
                const e = t.locale;
                const n = oA(this.editor.model.document.selection.getSelectedBlocks());
                this.isEnabled = !!n && this._canBeAligned(n);
                if (this.isEnabled && n.hasAttribute("alignment")) {
                    this.value = n.getAttribute("alignment")
                } else {
                    this.value = e.contentLanguageDirection === "rtl" ? "right" : "left"
                }
            }

            execute(t = {}) {
                const e = this.editor;
                const n = e.locale;
                const i = e.model;
                const o = i.document;
                const r = t.value;
                i.change((t => {
                    const e = Array.from(o.selection.getSelectedBlocks()).filter((t => this._canBeAligned(t)));
                    const i = e[0].getAttribute("alignment");
                    const s = aA(r, n) || i === r || !r;
                    if (s) {
                        dA(e, t)
                    } else {
                        uA(e, t, r)
                    }
                }))
            }

            _canBeAligned(t) {
                return this.editor.model.schema.checkAttribute(t, cA)
            }
        }

        function dA(t, e) {
            for (const n of t) {
                e.removeAttribute(cA, n)
            }
        }

        function uA(t, e, n) {
            for (const i of t) {
                e.setAttribute(cA, n, i)
            }
        }

        class hA extends tA {
            static get pluginName() {
                return "AlignmentEditing"
            }

            constructor(t) {
                super(t);
                t.config.define("alignment", {options: [...rA]})
            }

            init() {
                const t = this.editor;
                const e = t.locale;
                const n = t.model.schema;
                const i = t.config.get("alignment.options").filter(sA);
                n.extend("$block", {allowAttributes: "alignment"});
                t.model.schema.setAttributeProperties("alignment", {isFormatting: true});
                const o = mA(i.filter((t => !aA(t, e))));
                t.conversion.attributeToAttribute(o);
                t.commands.add("alignment", new lA(t))
            }
        }

        function mA(t) {
            const e = {model: {key: "alignment", values: t.slice()}, view: {}};
            for (const n of t) {
                e.view[n] = {key: "style", value: {"text-align": n}}
            }
            return e
        }

        var gA = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>';
        var fA = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M18 3.75a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 8a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 4a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75zm0-8a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75z"/></svg>';
        var pA = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm2.286 4c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75z"/></svg>';
        var bA = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>';
        const kA = new Map([["left", gA], ["right", fA], ["center", pA], ["justify", bA]]);

        class wA extends tA {
            get localizedOptionTitles() {
                const t = this.editor.t;
                return {
                    left: t("Align left"),
                    right: t("Align right"),
                    center: t("Align center"),
                    justify: t("Justify")
                }
            }

            static get pluginName() {
                return "AlignmentUI"
            }

            init() {
                const t = this.editor;
                const e = t.ui.componentFactory;
                const n = t.t;
                const i = t.config.get("alignment.options");
                i.filter(sA).forEach((t => this._addButton(t)));
                e.add("alignment", (t => {
                    const o = Sw(t);
                    const r = i.map((t => e.create(`alignment:${t}`)));
                    Iw(o, r);
                    o.buttonView.set({label: n("Text alignment"), tooltip: true});
                    o.toolbarView.isVertical = true;
                    o.toolbarView.ariaLabel = n("Text alignment toolbar");
                    o.extendTemplate({attributes: {class: "ck-alignment-dropdown"}});
                    const s = t.contentLanguageDirection === "rtl" ? fA : gA;
                    o.buttonView.bind("icon").toMany(r, "isOn", ((...t) => {
                        const e = t.findIndex((t => t));
                        if (e < 0) {
                            return s
                        }
                        return r[e].icon
                    }));
                    o.bind("isEnabled").toMany(r, "isEnabled", ((...t) => t.some((t => t))));
                    return o
                }))
            }

            _addButton(t) {
                const e = this.editor;
                e.ui.componentFactory.add(`alignment:${t}`, (n => {
                    const i = e.commands.get("alignment");
                    const o = new sw(n);
                    o.set({label: this.localizedOptionTitles[t], icon: kA.get(t), tooltip: true, isToggleable: true});
                    o.bind("isEnabled").to(i);
                    o.bind("isOn").to(i, "value", (e => e === t));
                    this.listenTo(o, "execute", (() => {
                        e.execute("alignment", {value: t});
                        e.editing.view.focus()
                    }));
                    return o
                }))
            }
        }

        class AA extends tA {
            static get requires() {
                return [hA, wA]
            }

            static get pluginName() {
                return "Alignment"
            }
        }

        function _A(t, e, n, i) {
            let o;
            let r = null;
            if (typeof i == "function") {
                o = i
            } else {
                r = t.commands.get(i);
                o = () => {
                    t.execute(i)
                }
            }
            t.model.document.on("change:data", ((i, s) => {
                if (r && !r.isEnabled || !e.isEnabled) {
                    return
                }
                const a = oA(t.model.document.selection.getRanges());
                if (!a.isCollapsed) {
                    return
                }
                if (s.type == "transparent") {
                    return
                }
                const c = Array.from(t.model.document.differ.getChanges());
                const l = c[0];
                if (c.length != 1 || l.type !== "insert" || l.name != "$text" || l.length != 1) {
                    return
                }
                const d = l.position.parent;
                if (d.is("element", "codeBlock")) {
                    return
                }
                if (r && r.value === true) {
                    return
                }
                const u = d.getChild(0);
                const h = t.model.createRangeOn(u);
                if (!h.containsRange(a) && !a.end.isEqual(h.end)) {
                    return
                }
                const m = n.exec(u.data.substr(0, a.end.offset));
                if (!m) {
                    return
                }
                t.model.enqueueChange((t => {
                    const e = t.createPositionAt(d, 0);
                    const n = t.createPositionAt(d, m[0].length);
                    const i = new fm(e, n);
                    const r = o({match: m});
                    if (r !== false) {
                        t.remove(i)
                    }
                    i.detach()
                }))
            }))
        }

        function CA(t, e, n, i) {
            let o;
            let r;
            if (n instanceof RegExp) {
                o = n
            } else {
                r = n
            }
            r = r || (t => {
                let e;
                const n = [];
                const i = [];
                while ((e = o.exec(t)) !== null) {
                    if (e && e.length < 4) {
                        break
                    }
                    let {index: t, 1: o, 2: r, 3: s} = e;
                    const a = o + r + s;
                    t += e[0].length - a.length;
                    const c = [t, t + o.length];
                    const l = [t + o.length + r.length, t + o.length + r.length + s.length];
                    n.push(c);
                    n.push(l);
                    i.push([t + o.length, t + o.length + r.length])
                }
                return {remove: n, format: i}
            });
            t.model.document.on("change:data", ((n, o) => {
                if (o.type == "transparent" || !e.isEnabled) {
                    return
                }
                const s = t.model;
                const a = s.document.selection;
                if (!a.isCollapsed) {
                    return
                }
                const c = Array.from(s.document.differ.getChanges());
                const l = c[0];
                if (c.length != 1 || l.type !== "insert" || l.name != "$text" || l.length != 1) {
                    return
                }
                const d = a.focus;
                const u = d.parent;
                const {text: h, range: m} = yA(s.createRange(s.createPositionAt(u, 0), d), s);
                const g = r(h);
                const f = vA(m.start, g.format, s);
                const p = vA(m.start, g.remove, s);
                if (!(f.length && p.length)) {
                    return
                }
                s.enqueueChange((t => {
                    const e = i(t, f);
                    if (e === false) {
                        return
                    }
                    for (const e of p.reverse()) {
                        t.remove(e)
                    }
                }))
            }))
        }

        function vA(t, e, n) {
            return e.filter((t => t[0] !== undefined && t[1] !== undefined)).map((e => n.createRange(t.getShiftedBy(e[0]), t.getShiftedBy(e[1]))))
        }

        function yA(t, e) {
            let n = t.start;
            const i = Array.from(t.getItems()).reduce(((t, i) => {
                if (!(i.is("$text") || i.is("$textProxy")) || i.getAttribute("code")) {
                    n = e.createPositionAfter(i);
                    return ""
                }
                return t + i.data
            }), "");
            return {text: i, range: e.createRange(n, t.end)}
        }

        class xA extends tA {
            static get pluginName() {
                return "Autoformat"
            }

            afterInit() {
                this._addListAutoformats();
                this._addBasicStylesAutoformats();
                this._addHeadingAutoformats();
                this._addBlockQuoteAutoformats();
                this._addCodeBlockAutoformats()
            }

            _addListAutoformats() {
                const t = this.editor.commands;
                if (t.get("bulletedList")) {
                    _A(this.editor, this, /^[*-]\s$/, "bulletedList")
                }
                if (t.get("numberedList")) {
                    _A(this.editor, this, /^1[.|)]\s$/, "numberedList")
                }
            }

            _addBasicStylesAutoformats() {
                const t = this.editor.commands;
                if (t.get("bold")) {
                    const t = EA(this.editor, "bold");
                    CA(this.editor, this, /(\*\*)([^*]+)(\*\*)$/g, t);
                    CA(this.editor, this, /(__)([^_]+)(__)$/g, t)
                }
                if (t.get("italic")) {
                    const t = EA(this.editor, "italic");
                    CA(this.editor, this, /(?:^|[^*])(\*)([^*_]+)(\*)$/g, t);
                    CA(this.editor, this, /(?:^|[^_])(_)([^_]+)(_)$/g, t)
                }
                if (t.get("code")) {
                    const t = EA(this.editor, "code");
                    CA(this.editor, this, /(`)([^`]+)(`)$/g, t)
                }
                if (t.get("strikethrough")) {
                    const t = EA(this.editor, "strikethrough");
                    CA(this.editor, this, /(~~)([^~]+)(~~)$/g, t)
                }
            }

            _addHeadingAutoformats() {
                const t = this.editor.commands.get("heading");
                if (t) {
                    t.modelElements.filter((t => t.match(/^heading[1-6]$/))).forEach((e => {
                        const n = e[7];
                        const i = new RegExp(`^(#{${n}})\\s$`);
                        _A(this.editor, this, i, (() => {
                            if (!t.isEnabled || t.value === e) {
                                return false
                            }
                            this.editor.execute("heading", {value: e})
                        }))
                    }))
                }
            }

            _addBlockQuoteAutoformats() {
                if (this.editor.commands.get("blockQuote")) {
                    _A(this.editor, this, /^>\s$/, "blockQuote")
                }
            }

            _addCodeBlockAutoformats() {
                if (this.editor.commands.get("codeBlock")) {
                    _A(this.editor, this, /^```$/, "codeBlock")
                }
            }
        }

        function EA(t, e) {
            return (n, i) => {
                const o = t.commands.get(e);
                if (!o.isEnabled) {
                    return false
                }
                const r = t.model.schema.getValidRanges(i, e);
                for (const t of r) {
                    n.setAttribute(e, true, t)
                }
                n.removeSelectionAttribute(e)
            }
        }

        function DA(t, e) {
            let n = t.start;
            const i = Array.from(t.getItems()).reduce(((t, i) => {
                if (!(i.is("$text") || i.is("$textProxy"))) {
                    n = e.createPositionAfter(i);
                    return ""
                }
                return t + i.data
            }), "");
            return {text: i, range: e.createRange(n, t.end)}
        }

        class TA {
            constructor(t, e) {
                this.model = t;
                this.testCallback = e;
                this.hasMatch = false;
                this.set("isEnabled", true);
                this.on("change:isEnabled", (() => {
                    if (this.isEnabled) {
                        this._startListening()
                    } else {
                        this.stopListening(t.document.selection);
                        this.stopListening(t.document)
                    }
                }));
                this._startListening()
            }

            _startListening() {
                const t = this.model;
                const e = t.document;
                this.listenTo(e.selection, "change:range", ((t, {directChange: n}) => {
                    if (!n) {
                        return
                    }
                    if (!e.selection.isCollapsed) {
                        if (this.hasMatch) {
                            this.fire("unmatched");
                            this.hasMatch = false
                        }
                        return
                    }
                    this._evaluateTextBeforeSelection("selection")
                }));
                this.listenTo(e, "change:data", ((t, e) => {
                    if (e.type == "transparent") {
                        return
                    }
                    this._evaluateTextBeforeSelection("data", {batch: e})
                }))
            }

            _evaluateTextBeforeSelection(t, e = {}) {
                const n = this.model;
                const i = n.document;
                const o = i.selection;
                const r = n.createRange(n.createPositionAt(o.focus.parent, 0), o.focus);
                const {text: s, range: a} = DA(r, n);
                const c = this.testCallback(s);
                if (!c && this.hasMatch) {
                    this.fire("unmatched")
                }
                this.hasMatch = !!c;
                if (c) {
                    const n = Object.assign(e, {text: s, range: a});
                    if (typeof c == "object") {
                        Object.assign(n, c)
                    }
                    this.fire(`matched:${t}`, n)
                }
            }
        }

        Cs(TA, Qc);

        function MA(t, e, n) {
            var i = t.length;
            n = n === undefined ? i : n;
            return !e && n >= i ? t : Ba(t, e, n)
        }

        var SA = MA;
        var IA = "\\ud800-\\udfff", BA = "\\u0300-\\u036f", LA = "\\ufe20-\\ufe2f", zA = "\\u20d0-\\u20ff",
            NA = BA + LA + zA, PA = "\\ufe0e\\ufe0f";
        var OA = "\\u200d";
        var jA = RegExp("[" + OA + IA + NA + PA + "]");

        function RA(t) {
            return jA.test(t)
        }

        var FA = RA;

        function VA(t) {
            return t.split("")
        }

        var HA = VA;
        var UA = "\\ud800-\\udfff", WA = "\\u0300-\\u036f", qA = "\\ufe20-\\ufe2f", KA = "\\u20d0-\\u20ff",
            GA = WA + qA + KA, $A = "\\ufe0e\\ufe0f";
        var YA = "[" + UA + "]", QA = "[" + GA + "]", JA = "\\ud83c[\\udffb-\\udfff]", XA = "(?:" + QA + "|" + JA + ")",
            ZA = "[^" + UA + "]", t_ = "(?:\\ud83c[\\udde6-\\uddff]){2}", e_ = "[\\ud800-\\udbff][\\udc00-\\udfff]",
            n_ = "\\u200d";
        var i_ = XA + "?", o_ = "[" + $A + "]?",
            r_ = "(?:" + n_ + "(?:" + [ZA, t_, e_].join("|") + ")" + o_ + i_ + ")*", s_ = o_ + i_ + r_,
            a_ = "(?:" + [ZA + QA + "?", QA, t_, e_, YA].join("|") + ")";
        var c_ = RegExp(JA + "(?=" + JA + ")|" + a_ + s_, "g");

        function l_(t) {
            return t.match(c_) || []
        }

        var d_ = l_;

        function u_(t) {
            return FA(t) ? d_(t) : HA(t)
        }

        var h_ = u_;

        function m_(t) {
            return function (e) {
                e = _a(e);
                var n = FA(e) ? h_(e) : undefined;
                var i = n ? n[0] : e.charAt(0);
                var o = n ? SA(n, 1).join("") : e.slice(1);
                return i[t]() + o
            }
        }

        var g_ = m_;
        var f_ = g_("toUpperCase");
        var p_ = f_;
        const b_ = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g;
        const k_ = /^(?:(?:https?|ftps?|mailto):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))/i;
        const w_ = /^[\S]+@((?![-_])(?:[-\w\u00a1-\uffff]{0,63}[^-_]\.))+(?:[a-z\u00a1-\uffff]{2,})$/i;
        const A_ = /^((\w+:(\/{2,})?)|(\W))/i;
        const __ = "Ctrl+K";

        function C_(t) {
            return t.is("attributeElement") && !!t.getCustomProperty("link")
        }

        function v_(t, {writer: e}) {
            const n = e.createAttributeElement("a", {href: t}, {priority: 5});
            e.setCustomProperty("link", true, n);
            return n
        }

        function y_(t) {
            t = String(t);
            return x_(t) ? t : "#"
        }

        function x_(t) {
            const e = t.replace(b_, "");
            return e.match(k_)
        }

        function E_(t, e) {
            const n = {"Open in a new tab": t("Open in a new tab"), Downloadable: t("Downloadable")};
            e.forEach((t => {
                if (t.label && n[t.label]) {
                    t.label = n[t.label]
                }
                return t
            }));
            return e
        }

        function D_(t) {
            const e = [];
            if (t) {
                for (const [n, i] of Object.entries(t)) {
                    const t = Object.assign({}, i, {id: `link${p_(n)}`});
                    e.push(t)
                }
            }
            return e
        }

        function T_(t, e) {
            if (!t) {
                return false
            }
            return t.is("element", "image") && e.checkAttribute("image", "linkHref")
        }

        function M_(t) {
            return w_.test(t)
        }

        function S_(t, e) {
            const n = M_(t) ? "mailto:" : e;
            const i = !!n && !A_.test(t);
            return t && i ? n + t : t
        }

        const I_ = 4;
        const B_ = new RegExp("(^|\\s)" + "(" + "(" + "(?:(?:(?:https?|ftp):)?\\/\\/)" + "(?:\\S+(?::\\S*)?@)?" + "(?:" + "(?![-_])(?:[-\\w\\u00a1-\\uffff]{0,63}[^-_]\\.)+" + "(?:[a-z\\u00a1-\\uffff]{2,})" + ")" + "(?::\\d{2,5})?" + "(?:[/?#]\\S*)?" + ")" + "|" + "(" + "(www.|(\\S+@))" + "((?![-_])(?:[-\\w\\u00a1-\\uffff]{0,63}[^-_]\\.))+" + "(?:[a-z\\u00a1-\\uffff]{2,})" + ")" + ")$", "i");
        const L_ = 2;

        class z_ extends tA {
            static get pluginName() {
                return "AutoLink"
            }

            init() {
                const t = this.editor;
                const e = t.model.document.selection;
                e.on("change:range", (() => {
                    this.isEnabled = !e.anchor.parent.is("element", "codeBlock")
                }));
                this._enableTypingHandling()
            }

            afterInit() {
                this._enableEnterHandling();
                this._enableShiftEnterHandling()
            }

            _enableTypingHandling() {
                const t = this.editor;
                const e = new TA(t.model, (t => {
                    if (!N_(t)) {
                        return
                    }
                    const e = P_(t.substr(0, t.length - 1));
                    if (e) {
                        return {url: e}
                    }
                }));
                const n = t.plugins.get("Input");
                e.on("matched:data", ((e, i) => {
                    const {batch: o, range: r, url: s} = i;
                    if (!n.isInput(o)) {
                        return
                    }
                    const a = r.end.getShiftedBy(-1);
                    const c = a.getShiftedBy(-s.length);
                    const l = t.model.createRange(c, a);
                    this._applyAutoLink(s, l)
                }));
                e.bind("isEnabled").to(this)
            }

            _enableEnterHandling() {
                const t = this.editor;
                const e = t.model;
                const n = t.commands.get("enter");
                if (!n) {
                    return
                }
                n.on("execute", (() => {
                    const t = e.document.selection.getFirstPosition();
                    if (!t.parent.previousSibling) {
                        return
                    }
                    const n = e.createRangeIn(t.parent.previousSibling);
                    this._checkAndApplyAutoLinkOnRange(n)
                }))
            }

            _enableShiftEnterHandling() {
                const t = this.editor;
                const e = t.model;
                const n = t.commands.get("shiftEnter");
                if (!n) {
                    return
                }
                n.on("execute", (() => {
                    const t = e.document.selection.getFirstPosition();
                    const n = e.createRange(e.createPositionAt(t.parent, 0), t.getShiftedBy(-1));
                    this._checkAndApplyAutoLinkOnRange(n)
                }))
            }

            _checkAndApplyAutoLinkOnRange(t) {
                const e = this.editor.model;
                const {text: n, range: i} = DA(t, e);
                const o = P_(n);
                if (o) {
                    const t = e.createRange(i.end.getShiftedBy(-o.length), i.end);
                    this._applyAutoLink(o, t)
                }
            }

            _applyAutoLink(t, e) {
                const n = this.editor.model;
                if (!this.isEnabled || !O_(e, n)) {
                    return
                }
                n.enqueueChange((n => {
                    const i = this.editor.config.get("link.defaultProtocol");
                    const o = S_(t, i);
                    n.setAttribute("linkHref", o, e)
                }))
            }
        }

        function N_(t) {
            return t.length > I_ && t[t.length - 1] === " " && t[t.length - 2] !== " "
        }

        function P_(t) {
            const e = B_.exec(t);
            return e ? e[L_] : null
        }

        function O_(t, e) {
            return e.schema.checkAttributeInSelection(e.createSelection(t), "linkHref")
        }

        class j_ {
            constructor(t) {
                this.context = t
            }

            destroy() {
                this.stopListening()
            }

            static get isContextPlugin() {
                return true
            }
        }

        Cs(j_, Qc);

        class R_ extends j_ {
            static get pluginName() {
                return "PendingActions"
            }

            init() {
                this.set("hasAny", false);
                this._actions = new vs({idProperty: "_id"});
                this._actions.delegate("add", "remove").to(this)
            }

            add(t) {
                if (typeof t !== "string") {
                    throw new ss["a"]("pendingactions-add-invalid-message", this)
                }
                const e = Object.create(Qc);
                e.set("message", t);
                this._actions.add(e);
                this.hasAny = true;
                return e
            }

            remove(t) {
                this._actions.remove(t);
                this.hasAny = !!this._actions.length
            }

            get first() {
                return this._actions.get(0)
            }

            [Symbol.iterator]() {
                return this._actions[Symbol.iterator]()
            }
        }

        class F_ extends tA {
            static get pluginName() {
                return "Autosave"
            }

            static get requires() {
                return [R_]
            }

            constructor(t) {
                super(t);
                const e = t.config.get("autosave") || {};
                const n = e.waitingTime || 1e3;
                this.set("state", "synchronized");
                this._debouncedSave = bh(this._save.bind(this), n);
                this._lastDocumentVersion = t.model.document.version;
                this._domEmitter = Object.create(Qd);
                this._config = e
            }

            init() {
                const t = this.editor;
                const e = t.model.document;
                const n = t.t;
                this._pendingActions = t.plugins.get(R_);
                this.listenTo(e, "change:data", (() => {
                    if (!this._saveCallbacks.length) {
                        return
                    }
                    if (this.state == "synchronized") {
                        this._action = this._pendingActions.add(n("Saving changes"));
                        this.state = "waiting";
                        this._debouncedSave()
                    } else if (this.state == "waiting") {
                        this._debouncedSave()
                    }
                }));
                this.listenTo(t, "destroy", (() => this._flush()), {priority: "highest"});
                this._domEmitter.listenTo(window, "beforeunload", ((t, e) => {
                    if (this._pendingActions.hasAny) {
                        e.returnValue = this._pendingActions.first.message
                    }
                }))
            }

            destroy() {
                this._domEmitter.stopListening();
                super.destroy()
            }

            _flush() {
                this._debouncedSave.flush()
            }

            _save() {
                const t = this.editor.model.document.version;
                if (t < this._lastDocumentVersion || this.editor.state === "initializing") {
                    this._debouncedSave.cancel();
                    return
                }
                this._lastDocumentVersion = t;
                this.state = "saving";
                Promise.resolve().then((() => Promise.all(this._saveCallbacks.map((t => t(this.editor)))))).catch((t => {
                    this.state = "error";
                    this.state = "saving";
                    this._debouncedSave();
                    throw t
                })).then((() => {
                    if (this.editor.model.document.version > this._lastDocumentVersion) {
                        this.state = "waiting";
                        this._debouncedSave()
                    } else {
                        this.state = "synchronized";
                        this._pendingActions.remove(this._action);
                        this._action = null
                    }
                }))
            }

            get _saveCallbacks() {
                const t = [];
                if (this.adapter && this.adapter.save) {
                    t.push(this.adapter.save)
                }
                if (this._config.save) {
                    t.push(this._config.save)
                }
                return t
            }
        }

        Cs(F_, Qc);

        class V_ {
            constructor() {
                const t = new window.FileReader;
                this._reader = t;
                this._data = undefined;
                this.set("loaded", 0);
                t.onprogress = t => {
                    this.loaded = t.loaded
                }
            }

            get error() {
                return this._reader.error
            }

            get data() {
                return this._data
            }

            read(t) {
                const e = this._reader;
                this.total = t.size;
                return new Promise(((n, i) => {
                    e.onload = () => {
                        const t = e.result;
                        this._data = t;
                        n(t)
                    };
                    e.onerror = () => {
                        i("error")
                    };
                    e.onabort = () => {
                        i("aborted")
                    };
                    this._reader.readAsDataURL(t)
                }))
            }

            abort() {
                this._reader.abort()
            }
        }

        Cs(V_, Qc);

        class H_ extends tA {
            static get pluginName() {
                return "FileRepository"
            }

            static get requires() {
                return [R_]
            }

            init() {
                this.loaders = new vs;
                this.loaders.on("add", (() => this._updatePendingAction()));
                this.loaders.on("remove", (() => this._updatePendingAction()));
                this._loadersMap = new Map;
                this._pendingAction = null;
                this.set("uploaded", 0);
                this.set("uploadTotal", null);
                this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", ((t, e) => e ? t / e * 100 : 0))
            }

            getLoader(t) {
                return this._loadersMap.get(t) || null
            }

            createLoader(t) {
                if (!this.createUploadAdapter) {
                    Object(ss["c"])("filerepository-no-upload-adapter");
                    return null
                }
                const e = new U_(Promise.resolve(t), this.createUploadAdapter);
                this.loaders.add(e);
                this._loadersMap.set(t, e);
                if (t instanceof Promise) {
                    e.file.then((t => {
                        this._loadersMap.set(t, e)
                    })).catch((() => {
                    }))
                }
                e.on("change:uploaded", (() => {
                    let t = 0;
                    for (const e of this.loaders) {
                        t += e.uploaded
                    }
                    this.uploaded = t
                }));
                e.on("change:uploadTotal", (() => {
                    let t = 0;
                    for (const e of this.loaders) {
                        if (e.uploadTotal) {
                            t += e.uploadTotal
                        }
                    }
                    this.uploadTotal = t
                }));
                return e
            }

            destroyLoader(t) {
                const e = t instanceof U_ ? t : this.getLoader(t);
                e._destroy();
                this.loaders.remove(e);
                this._loadersMap.forEach(((t, n) => {
                    if (t === e) {
                        this._loadersMap.delete(n)
                    }
                }))
            }

            _updatePendingAction() {
                const t = this.editor.plugins.get(R_);
                if (this.loaders.length) {
                    if (!this._pendingAction) {
                        const e = this.editor.t;
                        const n = t => `${e("Upload in progress")} ${parseInt(t)}%.`;
                        this._pendingAction = t.add(n(this.uploadedPercent));
                        this._pendingAction.bind("message").to(this, "uploadedPercent", n)
                    }
                } else {
                    t.remove(this._pendingAction);
                    this._pendingAction = null
                }
            }
        }

        Cs(H_, Qc);

        class U_ {
            constructor(t, e) {
                this.id = ns();
                this._filePromiseWrapper = this._createFilePromiseWrapper(t);
                this._adapter = e(this);
                this._reader = new V_;
                this.set("status", "idle");
                this.set("uploaded", 0);
                this.set("uploadTotal", null);
                this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", ((t, e) => e ? t / e * 100 : 0));
                this.set("uploadResponse", null)
            }

            get file() {
                if (!this._filePromiseWrapper) {
                    return Promise.resolve(null)
                } else {
                    return this._filePromiseWrapper.promise.then((t => this._filePromiseWrapper ? t : null))
                }
            }

            get data() {
                return this._reader.data
            }

            read() {
                if (this.status != "idle") {
                    throw new ss["a"]("filerepository-read-wrong-status", this)
                }
                this.status = "reading";
                return this.file.then((t => this._reader.read(t))).then((t => {
                    if (this.status !== "reading") {
                        throw this.status
                    }
                    this.status = "idle";
                    return t
                })).catch((t => {
                    if (t === "aborted") {
                        this.status = "aborted";
                        throw"aborted"
                    }
                    this.status = "error";
                    throw this._reader.error ? this._reader.error : t
                }))
            }

            upload() {
                if (this.status != "idle") {
                    throw new ss["a"]("filerepository-upload-wrong-status", this)
                }
                this.status = "uploading";
                return this.file.then((() => this._adapter.upload())).then((t => {
                    this.uploadResponse = t;
                    this.status = "idle";
                    return t
                })).catch((t => {
                    if (this.status === "aborted") {
                        throw"aborted"
                    }
                    this.status = "error";
                    throw t
                }))
            }

            abort() {
                const t = this.status;
                this.status = "aborted";
                if (!this._filePromiseWrapper.isFulfilled) {
                    this._filePromiseWrapper.promise.catch((() => {
                    }));
                    this._filePromiseWrapper.rejecter("aborted")
                } else if (t == "reading") {
                    this._reader.abort()
                } else if (t == "uploading" && this._adapter.abort) {
                    this._adapter.abort()
                }
                this._destroy()
            }

            _destroy() {
                this._filePromiseWrapper = undefined;
                this._reader = undefined;
                this._adapter = undefined;
                this.uploadResponse = undefined
            }

            _createFilePromiseWrapper(t) {
                const e = {};
                e.promise = new Promise(((n, i) => {
                    e.rejecter = i;
                    e.isFulfilled = false;
                    t.then((t => {
                        e.isFulfilled = true;
                        n(t)
                    })).catch((t => {
                        e.isFulfilled = true;
                        i(t)
                    }))
                }));
                return e
            }
        }

        Cs(U_, Qc);

        class W_ extends tA {
            static get requires() {
                return [H_]
            }

            static get pluginName() {
                return "Base64UploadAdapter"
            }

            init() {
                this.editor.plugins.get(H_).createUploadAdapter = t => new q_(t)
            }
        }

        class q_ {
            constructor(t) {
                this.loader = t
            }

            upload() {
                return new Promise(((t, e) => {
                    const n = this.reader = new window.FileReader;
                    n.addEventListener("load", (() => {
                        t({default: n.result})
                    }));
                    n.addEventListener("error", (t => {
                        e(t)
                    }));
                    n.addEventListener("abort", (() => {
                        e()
                    }));
                    this.loader.file.then((t => {
                        n.readAsDataURL(t)
                    }))
                }))
            }

            abort() {
                this.reader.abort()
            }
        }

        class K_ extends nA {
            refresh() {
                this.value = this._getValue();
                this.isEnabled = this._checkEnabled()
            }

            execute(t = {}) {
                const e = this.editor.model;
                const n = e.schema;
                const i = e.document.selection;
                const o = Array.from(i.getSelectedBlocks());
                const r = t.forceValue === undefined ? !this.value : t.forceValue;
                e.change((t => {
                    if (!r) {
                        this._removeQuote(t, o.filter(G_))
                    } else {
                        const e = o.filter((t => G_(t) || Y_(n, t)));
                        this._applyQuote(t, e)
                    }
                }))
            }

            _getValue() {
                const t = this.editor.model.document.selection;
                const e = oA(t.getSelectedBlocks());
                return !!(e && G_(e))
            }

            _checkEnabled() {
                if (this.value) {
                    return true
                }
                const t = this.editor.model.document.selection;
                const e = this.editor.model.schema;
                const n = oA(t.getSelectedBlocks());
                if (!n) {
                    return false
                }
                return Y_(e, n)
            }

            _removeQuote(t, e) {
                $_(t, e).reverse().forEach((e => {
                    if (e.start.isAtStart && e.end.isAtEnd) {
                        t.unwrap(e.start.parent);
                        return
                    }
                    if (e.start.isAtStart) {
                        const n = t.createPositionBefore(e.start.parent);
                        t.move(e, n);
                        return
                    }
                    if (!e.end.isAtEnd) {
                        t.split(e.end)
                    }
                    const n = t.createPositionAfter(e.end.parent);
                    t.move(e, n)
                }))
            }

            _applyQuote(t, e) {
                const n = [];
                $_(t, e).reverse().forEach((e => {
                    let i = G_(e.start);
                    if (!i) {
                        i = t.createElement("blockQuote");
                        t.wrap(e, i)
                    }
                    n.push(i)
                }));
                n.reverse().reduce(((e, n) => {
                    if (e.nextSibling == n) {
                        t.merge(t.createPositionAfter(e));
                        return e
                    }
                    return n
                }))
            }
        }

        function G_(t) {
            return t.parent.name == "blockQuote" ? t.parent : null
        }

        function $_(t, e) {
            let n;
            let i = 0;
            const o = [];
            while (i < e.length) {
                const r = e[i];
                const s = e[i + 1];
                if (!n) {
                    n = t.createPositionBefore(r)
                }
                if (!s || r.nextSibling != s) {
                    o.push(t.createRange(n, t.createPositionAfter(r)));
                    n = null
                }
                i++
            }
            return o
        }

        function Y_(t, e) {
            const n = t.checkChild(e.parent, "blockQuote");
            const i = t.checkChild(["$root", "blockQuote"], e);
            return n && i
        }

        class Q_ extends tA {
            static get pluginName() {
                return "BlockQuoteEditing"
            }

            init() {
                const t = this.editor;
                const e = t.model.schema;
                t.commands.add("blockQuote", new K_(t));
                e.register("blockQuote", {allowWhere: "$block", allowContentOf: "$root"});
                e.addChildCheck(((t, e) => {
                    if (t.endsWith("blockQuote") && e.name == "blockQuote") {
                        return false
                    }
                }));
                t.conversion.elementToElement({model: "blockQuote", view: "blockquote"});
                t.model.document.registerPostFixer((n => {
                    const i = t.model.document.differ.getChanges();
                    for (const t of i) {
                        if (t.type == "insert") {
                            const i = t.position.nodeAfter;
                            if (!i) {
                                continue
                            }
                            if (i.is("element", "blockQuote") && i.isEmpty) {
                                n.remove(i);
                                return true
                            } else if (i.is("element", "blockQuote") && !e.checkChild(t.position, i)) {
                                n.unwrap(i);
                                return true
                            } else if (i.is("element")) {
                                const t = n.createRangeIn(i);
                                for (const i of t.getItems()) {
                                    if (i.is("element", "blockQuote") && !e.checkChild(n.createPositionBefore(i), i)) {
                                        n.unwrap(i);
                                        return true
                                    }
                                }
                            }
                        } else if (t.type == "remove") {
                            const e = t.position.parent;
                            if (e.is("element", "blockQuote") && e.isEmpty) {
                                n.remove(e);
                                return true
                            }
                        }
                    }
                    return false
                }))
            }

            afterInit() {
                const t = this.editor;
                const e = t.commands.get("blockQuote");
                this.listenTo(this.editor.editing.view.document, "enter", ((t, n) => {
                    const i = this.editor.model.document;
                    const o = i.selection.getLastPosition().parent;
                    if (i.selection.isCollapsed && o.isEmpty && e.value) {
                        this.editor.execute("blockQuote");
                        this.editor.editing.view.scrollToTheSelection();
                        n.preventDefault();
                        t.stop()
                    }
                }))
            }
        }

        var J_ = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z"/></svg>';
        var X_ = n(27);
        var Z_ = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        Z_.insert = "head";
        Z_.singleton = true;
        var tC = ob()(X_["a"], Z_);
        var eC = X_["a"].locals || {};

        class nC extends tA {
            init() {
                const t = this.editor;
                const e = t.t;
                t.ui.componentFactory.add("blockQuote", (n => {
                    const i = t.commands.get("blockQuote");
                    const o = new sw(n);
                    o.set({label: e("Block quote"), icon: J_, tooltip: true, isToggleable: true});
                    o.bind("isOn", "isEnabled").to(i, "value", "isEnabled");
                    this.listenTo(o, "execute", (() => {
                        t.execute("blockQuote");
                        t.editing.view.focus()
                    }));
                    return o
                }))
            }
        }

        class iC extends tA {
            static get requires() {
                return [Q_, nC]
            }

            static get pluginName() {
                return "BlockQuote"
            }
        }

        class oC extends nA {
            constructor(t, e) {
                super(t);
                this.attributeKey = e
            }

            refresh() {
                const t = this.editor.model;
                const e = t.document;
                this.value = this._getValueFromFirstAllowedNode();
                this.isEnabled = t.schema.checkAttributeInSelection(e.selection, this.attributeKey)
            }

            execute(t = {}) {
                const e = this.editor.model;
                const n = e.document;
                const i = n.selection;
                const o = t.forceValue === undefined ? !this.value : t.forceValue;
                e.change((t => {
                    if (i.isCollapsed) {
                        if (o) {
                            t.setSelectionAttribute(this.attributeKey, true)
                        } else {
                            t.removeSelectionAttribute(this.attributeKey)
                        }
                    } else {
                        const n = e.schema.getValidRanges(i.getRanges(), this.attributeKey);
                        for (const e of n) {
                            if (o) {
                                t.setAttribute(this.attributeKey, o, e)
                            } else {
                                t.removeAttribute(this.attributeKey, e)
                            }
                        }
                    }
                }))
            }

            _getValueFromFirstAllowedNode() {
                const t = this.editor.model;
                const e = t.schema;
                const n = t.document.selection;
                if (n.isCollapsed) {
                    return n.hasAttribute(this.attributeKey)
                }
                for (const t of n.getRanges()) {
                    for (const n of t.getItems()) {
                        if (e.checkAttribute(n, this.attributeKey)) {
                            return n.hasAttribute(this.attributeKey)
                        }
                    }
                }
                return false
            }
        }

        const rC = "bold";

        class sC extends tA {
            static get pluginName() {
                return "BoldEditing"
            }

            init() {
                const t = this.editor;
                t.model.schema.extend("$text", {allowAttributes: rC});
                t.model.schema.setAttributeProperties(rC, {isFormatting: true, copyOnEnter: true});
                t.conversion.attributeToElement({
                    model: rC, view: "strong", upcastAlso: ["b", t => {
                        const e = t.getStyle("font-weight");
                        if (!e) {
                            return null
                        }
                        if (e == "bold" || Number(e) >= 600) {
                            return {name: true, styles: ["font-weight"]}
                        }
                    }]
                });
                t.commands.add(rC, new oC(t, rC));
                t.keystrokes.set("CTRL+B", rC)
            }
        }

        var aC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.187 17H5.773c-.637 0-1.092-.138-1.364-.415-.273-.277-.409-.718-.409-1.323V4.738c0-.617.14-1.062.419-1.332.279-.27.73-.406 1.354-.406h4.68c.69 0 1.288.041 1.793.124.506.083.96.242 1.36.478.341.197.644.447.906.75a3.262 3.262 0 0 1 .808 2.162c0 1.401-.722 2.426-2.167 3.075C15.05 10.175 16 11.315 16 13.01a3.756 3.756 0 0 1-2.296 3.504 6.1 6.1 0 0 1-1.517.377c-.571.073-1.238.11-2 .11zm-.217-6.217H7v4.087h3.069c1.977 0 2.965-.69 2.965-2.072 0-.707-.256-1.22-.768-1.537-.512-.319-1.277-.478-2.296-.478zM7 5.13v3.619h2.606c.729 0 1.292-.067 1.69-.2a1.6 1.6 0 0 0 .91-.765c.165-.267.247-.566.247-.897 0-.707-.26-1.176-.778-1.409-.519-.232-1.31-.348-2.375-.348H7z"/></svg>';
        const cC = "bold";

        class lC extends tA {
            init() {
                const t = this.editor;
                const e = t.t;
                t.ui.componentFactory.add(cC, (n => {
                    const i = t.commands.get(cC);
                    const o = new sw(n);
                    o.set({label: e("Bold"), icon: aC, keystroke: "CTRL+B", tooltip: true, isToggleable: true});
                    o.bind("isOn", "isEnabled").to(i, "value", "isEnabled");
                    this.listenTo(o, "execute", (() => {
                        t.execute(cC);
                        t.editing.view.focus()
                    }));
                    return o
                }))
            }
        }

        class dC extends tA {
            static get requires() {
                return [sC, lC]
            }

            static get pluginName() {
                return "Bold"
            }
        }

        class uC extends tA {
            static get pluginName() {
                return "TwoStepCaretMovement"
            }

            constructor(t) {
                super(t);
                this.attributes = new Set;
                this._overrideUid = null
            }

            init() {
                const t = this.editor;
                const e = t.model;
                const n = t.editing.view;
                const i = t.locale;
                const o = e.document.selection;
                this.listenTo(n.document, "keydown", ((t, e) => {
                    if (!o.isCollapsed) {
                        return
                    }
                    if (e.shiftKey || e.altKey || e.ctrlKey) {
                        return
                    }
                    const n = e.keyCode == Nl.arrowright;
                    const r = e.keyCode == Nl.arrowleft;
                    if (!n && !r) {
                        return
                    }
                    const s = i.contentLanguageDirection;
                    let a = false;
                    if (s === "ltr" && n || s === "rtl" && r) {
                        a = this._handleForwardMovement(e)
                    } else {
                        a = this._handleBackwardMovement(e)
                    }
                    if (a === true) {
                        t.stop()
                    }
                }), {priority: os.get("high") + 1});
                this._isNextGravityRestorationSkipped = false;
                this.listenTo(o, "change:range", ((t, e) => {
                    if (this._isNextGravityRestorationSkipped) {
                        this._isNextGravityRestorationSkipped = false;
                        return
                    }
                    if (!this._isGravityOverridden) {
                        return
                    }
                    if (!e.directChange && pC(o.getFirstPosition(), this.attributes)) {
                        return
                    }
                    this._restoreGravity()
                }))
            }

            registerAttribute(t) {
                this.attributes.add(t)
            }

            _handleForwardMovement(t) {
                const e = this.attributes;
                const n = this.editor.model;
                const i = n.document.selection;
                const o = i.getFirstPosition();
                if (this._isGravityOverridden) {
                    return false
                }
                if (o.isAtStart && hC(i, e)) {
                    return false
                }
                if (pC(o, e)) {
                    gC(t);
                    this._overrideGravity();
                    return true
                }
            }

            _handleBackwardMovement(t) {
                const e = this.attributes;
                const n = this.editor.model;
                const i = n.document.selection;
                const o = i.getFirstPosition();
                if (this._isGravityOverridden) {
                    gC(t);
                    this._restoreGravity();
                    mC(n, e, o);
                    return true
                } else {
                    if (o.isAtStart) {
                        if (hC(i, e)) {
                            gC(t);
                            mC(n, e, o);
                            return true
                        }
                        return false
                    }
                    if (fC(o, e)) {
                        if (o.isAtEnd && !hC(i, e) && pC(o, e)) {
                            gC(t);
                            mC(n, e, o);
                            return true
                        }
                        this._isNextGravityRestorationSkipped = true;
                        this._overrideGravity();
                        return false
                    }
                }
            }

            get _isGravityOverridden() {
                return !!this._overrideUid
            }

            _overrideGravity() {
                this._overrideUid = this.editor.model.change((t => t.overrideSelectionGravity()))
            }

            _restoreGravity() {
                this.editor.model.change((t => {
                    t.restoreSelectionGravity(this._overrideUid);
                    this._overrideUid = null
                }))
            }
        }

        function hC(t, e) {
            for (const n of e) {
                if (t.hasAttribute(n)) {
                    return true
                }
            }
            return false
        }

        function mC(t, e, n) {
            const i = n.nodeBefore;
            t.change((t => {
                if (i) {
                    t.setSelectionAttribute(i.getAttributes())
                } else {
                    t.removeSelectionAttribute(e)
                }
            }))
        }

        function gC(t) {
            t.preventDefault()
        }

        function fC(t, e) {
            const n = t.getShiftedBy(-1);
            return pC(n, e)
        }

        function pC(t, e) {
            const {nodeBefore: n, nodeAfter: i} = t;
            for (const t of e) {
                const e = n ? n.getAttribute(t) : undefined;
                const o = i ? i.getAttribute(t) : undefined;
                if (o !== e) {
                    return true
                }
            }
            return false
        }

        function bC(t, e, n, i) {
            return i.createRange(kC(t, e, n, true, i), kC(t, e, n, false, i))
        }

        function kC(t, e, n, i, o) {
            let r = t.textNode || (i ? t.nodeBefore : t.nodeAfter);
            let s = null;
            while (r && r.getAttribute(e) == n) {
                s = r;
                r = i ? r.previousSibling : r.nextSibling
            }
            return s ? o.createPositionAt(s, i ? "before" : "after") : t
        }

        function wC(t, e, n, i) {
            const o = t.editing.view;
            const r = new Set;
            o.document.registerPostFixer((o => {
                const s = t.model.document.selection;
                let a = false;
                if (s.hasAttribute(e)) {
                    const c = bC(s.getFirstPosition(), e, s.getAttribute(e), t.model);
                    const l = t.editing.mapper.toViewRange(c);
                    for (const t of l.getItems()) {
                        if (t.is("element", n) && !t.hasClass(i)) {
                            o.addClass(i, t);
                            r.add(t);
                            a = true
                        }
                    }
                }
                return a
            }));
            t.conversion.for("editingDowncast").add((t => {
                t.on("insert", e, {priority: "highest"});
                t.on("remove", e, {priority: "highest"});
                t.on("attribute", e, {priority: "highest"});
                t.on("selection", e, {priority: "highest"});

                function e() {
                    o.change((t => {
                        for (const e of r.values()) {
                            t.removeClass(i, e);
                            r.delete(e)
                        }
                    }))
                }
            }))
        }

        const AC = "code";
        const _C = "ck-code_selected";

        class CC extends tA {
            static get pluginName() {
                return "CodeEditing"
            }

            static get requires() {
                return [uC]
            }

            init() {
                const t = this.editor;
                t.model.schema.extend("$text", {allowAttributes: AC});
                t.model.schema.setAttributeProperties(AC, {isFormatting: true, copyOnEnter: true});
                t.conversion.attributeToElement({
                    model: AC,
                    view: "code",
                    upcastAlso: {styles: {"word-wrap": "break-word"}}
                });
                t.commands.add(AC, new oC(t, AC));
                t.plugins.get(uC).registerAttribute(AC);
                wC(t, AC, "code", _C)
            }
        }

        var vC = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.5 5.7l5.2 3.9v1.3l-5.6 4c-.1.2-.3.2-.5.2-.3-.1-.6-.7-.6-1l.3-.4 4.7-3.5L11.5 7l-.2-.2c-.1-.3-.1-.6 0-.8.2-.2.5-.4.8-.4a.8.8 0 0 1 .4.1zm-5.2 0L2 9.6v1.3l5.6 4c.1.2.3.2.5.2.3-.1.7-.7.6-1 0-.1 0-.3-.2-.4l-5-3.5L8.2 7l.2-.2c.1-.3.1-.6 0-.8-.2-.2-.5-.4-.8-.4a.8.8 0 0 0-.3.1z"/></svg>';
        var yC = n(28);
        var xC = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        xC.insert = "head";
        xC.singleton = true;
        var EC = ob()(yC["a"], xC);
        var DC = yC["a"].locals || {};
        const TC = "code";

        class MC extends tA {
            init() {
                const t = this.editor;
                const e = t.t;
                t.ui.componentFactory.add(TC, (n => {
                    const i = t.commands.get(TC);
                    const o = new sw(n);
                    o.set({label: e("Code"), icon: vC, tooltip: true, isToggleable: true});
                    o.bind("isOn", "isEnabled").to(i, "value", "isEnabled");
                    this.listenTo(o, "execute", (() => {
                        t.execute(TC);
                        t.editing.view.focus()
                    }));
                    return o
                }))
            }
        }

        class SC extends tA {
            static get requires() {
                return [CC, MC]
            }

            static get pluginName() {
                return "Code"
            }
        }

        function* IC(t, e) {
            for (const n of e) {
                if (n && t.getAttributeProperties(n[0]).copyOnEnter) {
                    yield n
                }
            }
        }

        class BC extends nA {
            execute() {
                const t = this.editor.model;
                const e = t.document;
                t.change((n => {
                    zC(t, n, e.selection);
                    this.fire("afterExecute", {writer: n})
                }))
            }

            refresh() {
                const t = this.editor.model;
                const e = t.document;
                this.isEnabled = LC(t.schema, e.selection)
            }
        }

        function LC(t, e) {
            if (e.rangeCount > 1) {
                return false
            }
            const n = e.anchor;
            if (!n || !t.checkChild(n, "softBreak")) {
                return false
            }
            const i = e.getFirstRange();
            const o = i.start.parent;
            const r = i.end.parent;
            if ((PC(o, t) || PC(r, t)) && o !== r) {
                return false
            }
            return true
        }

        function zC(t, e, n) {
            const i = n.isCollapsed;
            const o = n.getFirstRange();
            const r = o.start.parent;
            const s = o.end.parent;
            const a = r == s;
            if (i) {
                const i = IC(t.schema, n.getAttributes());
                NC(t, e, o.end);
                e.removeSelectionAttribute(n.getAttributeKeys());
                e.setSelectionAttribute(i)
            } else {
                const i = !(o.start.isAtStart && o.end.isAtEnd);
                t.deleteContent(n, {leaveUnmerged: i});
                if (a) {
                    NC(t, e, n.focus)
                } else {
                    if (i) {
                        e.setSelection(s, 0)
                    }
                }
            }
        }

        function NC(t, e, n) {
            const i = e.createElement("softBreak");
            t.insertContent(i, n);
            e.setSelection(i, "after")
        }

        function PC(t, e) {
            if (t.is("rootElement")) {
                return false
            }
            return e.isLimit(t) || PC(t.parent, e)
        }

        class OC extends Zd {
            constructor(t) {
                super(t);
                const e = this.document;
                e.on("keydown", ((t, n) => {
                    if (this.isEnabled && n.keyCode == Nl.enter) {
                        let i;
                        e.once("enter", (t => i = t), {priority: "highest"});
                        e.fire("enter", new th(e, n.domEvent, {isSoft: n.shiftKey}));
                        if (i && i.stop.called) {
                            t.stop()
                        }
                    }
                }))
            }

            observe() {
            }
        }

        class jC extends tA {
            static get pluginName() {
                return "ShiftEnter"
            }

            init() {
                const t = this.editor;
                const e = t.model.schema;
                const n = t.conversion;
                const i = t.editing.view;
                const o = i.document;
                e.register("softBreak", {allowWhere: "$text", isInline: true});
                n.for("upcast").elementToElement({model: "softBreak", view: "br"});
                n.for("downcast").elementToElement({
                    model: "softBreak",
                    view: (t, {writer: e}) => e.createEmptyElement("br")
                });
                i.addObserver(OC);
                t.commands.add("shiftEnter", new BC(t));
                this.listenTo(o, "enter", ((e, n) => {
                    n.preventDefault();
                    if (!n.isSoft) {
                        return
                    }
                    t.execute("shiftEnter");
                    i.scrollToTheSelection()
                }), {priority: "low"})
            }
        }

        function RC(t) {
            const e = t.t;
            const n = t.config.get("codeBlock.languages");
            for (const t of n) {
                if (t.label === "Plain text") {
                    t.label = e("Plain text")
                }
                if (t.class === undefined) {
                    t.class = `language-${t.language}`
                }
            }
            return n
        }

        function FC(t, e, n) {
            const i = {};
            for (const o of t) {
                if (e === "class") {
                    i[o[e].split(" ").shift()] = o[n]
                } else {
                    i[o[e]] = o[n]
                }
            }
            return i
        }

        function VC(t) {
            return t.data.match(/^(\s*)/)[0]
        }

        function HC(t, e) {
            const n = t.createDocumentFragment();
            const i = e.split("\n").map((e => t.createText(e)));
            const o = i[i.length - 1];
            for (const e of i) {
                t.append(e, n);
                if (e !== o) {
                    t.appendElement("softBreak", n)
                }
            }
            return n
        }

        function UC(t) {
            const e = t.document.selection;
            const n = [];
            if (e.isCollapsed) {
                n.push(e.anchor)
            } else {
                const i = e.getFirstRange().getWalker({ignoreElementEnd: true, direction: "backward"});
                for (const {item: e} of i) {
                    if (e.is("$textProxy") && e.parent.is("element", "codeBlock")) {
                        const i = VC(e.textNode);
                        const {parent: o, startOffset: r} = e.textNode;
                        const s = t.createPositionAt(o, r + i.length);
                        n.push(s)
                    }
                }
            }
            return n
        }

        function WC(t) {
            const e = oA(t.getSelectedBlocks());
            return e && e.is("element", "codeBlock")
        }

        class qC extends nA {
            refresh() {
                this.value = this._getValue();
                this.isEnabled = this._checkEnabled()
            }

            execute(t = {}) {
                const e = this.editor;
                const n = e.model;
                const i = n.document.selection;
                const o = RC(e);
                const r = o[0];
                const s = Array.from(i.getSelectedBlocks());
                const a = t.forceValue === undefined ? !this.value : t.forceValue;
                const c = t.language || r.language;
                n.change((t => {
                    if (a) {
                        this._applyCodeBlock(t, s, c)
                    } else {
                        this._removeCodeBlock(t, s)
                    }
                }))
            }

            _getValue() {
                const t = this.editor.model.document.selection;
                const e = oA(t.getSelectedBlocks());
                const n = !!(e && e.is("element", "codeBlock"));
                return n ? e.getAttribute("language") : false
            }

            _checkEnabled() {
                if (this.value) {
                    return true
                }
                const t = this.editor.model.document.selection;
                const e = this.editor.model.schema;
                const n = oA(t.getSelectedBlocks());
                if (!n) {
                    return false
                }
                return KC(e, n)
            }

            _applyCodeBlock(t, e, n) {
                const i = this.editor.model.schema;
                const o = e.filter((t => KC(i, t)));
                for (const e of o) {
                    t.rename(e, "codeBlock");
                    t.setAttribute("language", n, e);
                    i.removeDisallowedAttributes([e], t)
                }
                o.reverse().forEach(((e, n) => {
                    const i = o[n + 1];
                    if (e.previousSibling === i) {
                        t.appendElement("softBreak", i);
                        t.merge(t.createPositionBefore(e))
                    }
                }))
            }

            _removeCodeBlock(t, e) {
                const n = e.filter((t => t.is("element", "codeBlock")));
                for (const e of n) {
                    const n = t.createRangeOn(e);
                    for (const e of Array.from(n.getItems()).reverse()) {
                        if (e.is("element", "softBreak") && e.parent.is("element", "codeBlock")) {
                            const {position: n} = t.split(t.createPositionBefore(e));
                            t.rename(n.nodeAfter, "paragraph");
                            t.removeAttribute("language", n.nodeAfter);
                            t.remove(e)
                        }
                    }
                    t.rename(e, "paragraph");
                    t.removeAttribute("language", e)
                }
            }
        }

        function KC(t, e) {
            if (e.is("rootElement") || t.isLimit(e)) {
                return false
            }
            return t.checkChild(e.parent, "codeBlock")
        }

        class GC extends nA {
            constructor(t) {
                super(t);
                this._indentSequence = t.config.get("codeBlock.indentSequence")
            }

            refresh() {
                this.isEnabled = this._checkEnabled()
            }

            execute() {
                const t = this.editor;
                const e = t.model;
                e.change((t => {
                    const n = UC(e);
                    for (const e of n) {
                        t.insertText(this._indentSequence, e)
                    }
                }))
            }

            _checkEnabled() {
                if (!this._indentSequence) {
                    return false
                }
                return WC(this.editor.model.document.selection)
            }
        }

        class $C extends nA {
            constructor(t) {
                super(t);
                this._indentSequence = t.config.get("codeBlock.indentSequence")
            }

            refresh() {
                this.isEnabled = this._checkEnabled()
            }

            execute() {
                const t = this.editor;
                const e = t.model;
                e.change((t => {
                    const n = UC(e);
                    for (const e of n) {
                        const n = YC(this.editor.model, e, this._indentSequence);
                        if (n) {
                            t.remove(n)
                        }
                    }
                }))
            }

            _checkEnabled() {
                if (!this._indentSequence) {
                    return false
                }
                const t = this.editor.model;
                if (!WC(t.document.selection)) {
                    return false
                }
                return UC(t).some((e => YC(t, e, this._indentSequence)))
            }
        }

        function YC(t, e, n) {
            const i = QC(e);
            if (!i) {
                return null
            }
            const o = VC(i);
            const r = o.lastIndexOf(n);
            if (r + n.length !== o.length) {
                return null
            }
            if (r === -1) {
                return null
            }
            const {parent: s, startOffset: a} = i;
            return t.createRange(t.createPositionAt(s, a + r), t.createPositionAt(s, a + r + n.length))
        }

        function QC(t) {
            let e = t.parent.getChild(t.index);
            if (!e || e.is("element", "softBreak")) {
                e = t.nodeBefore
            }
            if (!e || e.is("element", "softBreak")) {
                return null
            }
            return e
        }

        function JC(t, e, n = false) {
            const i = FC(e, "language", "class");
            const o = FC(e, "language", "label");
            return (e, r, s) => {
                const {writer: a, mapper: c, consumable: l} = s;
                if (!l.consume(r.item, "insert")) {
                    return
                }
                const d = r.item.getAttribute("language");
                const u = c.toViewPosition(t.createPositionBefore(r.item));
                const h = {};
                if (n) {
                    h["data-language"] = o[d];
                    h.spellcheck = "false"
                }
                const m = a.createContainerElement("pre", h);
                const g = a.createContainerElement("code", {class: i[d] || null});
                a.insert(a.createPositionAt(m, 0), g);
                a.insert(u, m);
                c.bindElements(r.item, g)
            }
        }

        function XC(t) {
            return (e, n, i) => {
                if (n.item.parent.name !== "codeBlock") {
                    return
                }
                const {writer: o, mapper: r, consumable: s} = i;
                if (!s.consume(n.item, "insert")) {
                    return
                }
                const a = r.toViewPosition(t.createPositionBefore(n.item));
                o.insert(a, o.createText("\n"))
            }
        }

        function ZC(t, e) {
            const n = FC(e, "class", "language");
            const i = e[0].language;
            return (e, o, r) => {
                const s = o.viewItem;
                const a = s.getChild(0);
                if (!a || !a.is("element", "code")) {
                    return
                }
                const {consumable: c, writer: l} = r;
                if (!c.test(s, {name: true}) || !c.test(a, {name: true})) {
                    return
                }
                const d = l.createElement("codeBlock");
                const u = [...a.getClassNames()];
                if (!u.length) {
                    u.push("")
                }
                for (const t of u) {
                    const e = n[t];
                    if (e) {
                        l.setAttribute("language", e, d);
                        break
                    }
                }
                if (!d.hasAttribute("language")) {
                    l.setAttribute("language", i, d)
                }
                const h = [...t.createRangeIn(a)].filter((t => t.type === "text")).map((({item: t}) => t.data)).join("");
                const m = HC(l, h);
                l.append(m, d);
                if (!r.safeInsert(d, o.modelCursor)) {
                    return
                }
                c.consume(s, {name: true});
                c.consume(a, {name: true});
                r.updateConversionResult(d, o)
            }
        }

        const tv = "paragraph";

        class ev extends tA {
            static get pluginName() {
                return "CodeBlockEditing"
            }

            static get requires() {
                return [jC]
            }

            constructor(t) {
                super(t);
                t.config.define("codeBlock", {
                    languages: [{language: "plaintext", label: "Plain text"}, {
                        language: "c",
                        label: "C"
                    }, {language: "cs", label: "C#"}, {language: "cpp", label: "C++"}, {
                        language: "css",
                        label: "CSS"
                    }, {language: "diff", label: "Diff"}, {language: "html", label: "HTML"}, {
                        language: "java",
                        label: "Java"
                    }, {language: "javascript", label: "JavaScript"}, {
                        language: "php",
                        label: "PHP"
                    }, {language: "python", label: "Python"}, {
                        language: "ruby",
                        label: "Ruby"
                    }, {language: "typescript", label: "TypeScript"}, {language: "xml", label: "XML"}],
                    indentSequence: "\t"
                })
            }

            init() {
                const t = this.editor;
                const e = t.model.schema;
                const n = t.model;
                const i = RC(t);
                t.commands.add("codeBlock", new qC(t));
                t.commands.add("indentCodeBlock", new GC(t));
                t.commands.add("outdentCodeBlock", new $C(t));
                const o = t => (e, n) => {
                    const i = this.editor.commands.get(t);
                    if (i.isEnabled) {
                        this.editor.execute(t);
                        n()
                    }
                };
                t.keystrokes.set("Tab", o("indentCodeBlock"));
                t.keystrokes.set("Shift+Tab", o("outdentCodeBlock"));
                e.register("codeBlock", {allowWhere: "$block", isBlock: true, allowAttributes: ["language"]});
                e.extend("$text", {allowIn: "codeBlock"});
                e.addAttributeCheck((t => {
                    if (t.endsWith("codeBlock $text")) {
                        return false
                    }
                }));
                t.editing.downcastDispatcher.on("insert:codeBlock", JC(n, i, true));
                t.data.downcastDispatcher.on("insert:codeBlock", JC(n, i));
                t.data.downcastDispatcher.on("insert:softBreak", XC(n), {priority: "high"});
                t.data.upcastDispatcher.on("element:pre", ZC(t.editing.view, i));
                this.listenTo(t.editing.view.document, "clipboardInput", ((t, e) => {
                    const i = n.document.selection;
                    if (!i.anchor.parent.is("element", "codeBlock")) {
                        return
                    }
                    const o = e.dataTransfer.getData("text/plain");
                    n.change((e => {
                        n.insertContent(HC(e, o), i);
                        t.stop()
                    }))
                }));
                this.listenTo(n, "getSelectedContent", ((t, [i]) => {
                    const o = i.anchor;
                    if (i.isCollapsed || !o.parent.is("element", "codeBlock") || !o.hasSameParentAs(i.focus)) {
                        return
                    }
                    n.change((n => {
                        const r = t.return;
                        if (r.childCount > 1 || i.containsEntireContent(o.parent)) {
                            const e = n.createElement("codeBlock", o.parent.getAttributes());
                            n.append(r, e);
                            const i = n.createDocumentFragment();
                            n.append(e, i);
                            t.return = i
                        } else {
                            const t = r.getChild(0);
                            if (e.checkAttribute(t, "code")) {
                                n.setAttribute("code", true, t)
                            }
                        }
                    }))
                }))
            }

            afterInit() {
                const t = this.editor;
                const e = t.commands;
                const n = e.get("indent");
                const i = e.get("outdent");
                if (n) {
                    n.registerChildCommand(e.get("indentCodeBlock"))
                }
                if (i) {
                    i.registerChildCommand(e.get("outdentCodeBlock"))
                }
                this.listenTo(t.editing.view.document, "enter", ((e, n) => {
                    const i = t.model.document.selection.getLastPosition().parent;
                    if (!i.is("element", "codeBlock")) {
                        return
                    }
                    if (!iv(t, n.isSoft) && !ov(t, n.isSoft)) {
                        nv(t)
                    }
                    n.preventDefault();
                    e.stop()
                }))
            }
        }

        function nv(t) {
            const e = t.model;
            const n = e.document;
            const i = n.selection.getLastPosition();
            const o = i.nodeBefore || i.textNode;
            let r;
            if (o && o.is("$text")) {
                r = VC(o)
            }
            t.model.change((e => {
                t.execute("shiftEnter");
                if (r) {
                    e.insertText(r, n.selection.anchor)
                }
            }))
        }

        function iv(t, e) {
            const n = t.model;
            const i = n.document;
            const o = t.editing.view;
            const r = i.selection.getLastPosition();
            const s = r.nodeAfter;
            if (e || !i.selection.isCollapsed || !r.isAtStart) {
                return false
            }
            if (!s || !s.is("element", "softBreak")) {
                return false
            }
            t.model.change((e => {
                t.execute("enter");
                const n = i.selection.anchor.parent.previousSibling;
                e.rename(n, tv);
                e.setSelection(n, "in");
                t.model.schema.removeDisallowedAttributes([n], e);
                e.remove(s)
            }));
            o.scrollToTheSelection();
            return true
        }

        function ov(t, e) {
            const n = t.model;
            const i = n.document;
            const o = t.editing.view;
            const r = i.selection.getLastPosition();
            const s = r.nodeBefore;
            let a;
            if (e || !i.selection.isCollapsed || !r.isAtEnd || !s) {
                return false
            }
            if (s.is("element", "softBreak")) {
                a = n.createRangeOn(s)
            } else if (s.is("$text") && !s.data.match(/\S/) && s.previousSibling && s.previousSibling.is("element", "softBreak")) {
                a = n.createRange(n.createPositionBefore(s.previousSibling), n.createPositionAfter(s))
            } else {
                return false
            }
            t.model.change((e => {
                e.remove(a);
                t.execute("enter");
                const n = i.selection.anchor.parent;
                e.rename(n, tv);
                t.model.schema.removeDisallowedAttributes([n], e)
            }));
            o.scrollToTheSelection();
            return true
        }

        class rv {
            constructor(t, e) {
                if (e) {
                    qc(this, e)
                }
                if (t) {
                    this.set(t)
                }
            }
        }

        Cs(rv, Qc);
        var sv = n(29);
        var av = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        av.insert = "head";
        av.singleton = true;
        var cv = ob()(sv["a"], av);
        var lv = sv["a"].locals || {};

        class dv extends Zb {
            constructor(t) {
                super(t);
                const e = this.bindTemplate;
                this.set("icon");
                this.set("isEnabled", true);
                this.set("isOn", false);
                this.set("isToggleable", false);
                this.set("isVisible", true);
                this.set("keystroke");
                this.set("label");
                this.set("tabindex", -1);
                this.set("tooltip");
                this.set("tooltipPosition", "s");
                this.set("type", "button");
                this.set("withText", false);
                this.children = this.createCollection();
                this.actionView = this._createActionView();
                this.arrowView = this._createArrowView();
                this.keystrokes = new Fp;
                this.focusTracker = new Zp;
                this.setTemplate({
                    tag: "div",
                    attributes: {class: ["ck", "ck-splitbutton", e.if("isVisible", "ck-hidden", (t => !t)), this.arrowView.bindTemplate.if("isOn", "ck-splitbutton_open")]},
                    children: this.children
                })
            }

            render() {
                super.render();
                this.children.add(this.actionView);
                this.children.add(this.arrowView);
                this.focusTracker.add(this.actionView.element);
                this.focusTracker.add(this.arrowView.element);
                this.keystrokes.listenTo(this.element);
                this.keystrokes.set("arrowright", ((t, e) => {
                    if (this.focusTracker.focusedElement === this.actionView.element) {
                        this.arrowView.focus();
                        e()
                    }
                }));
                this.keystrokes.set("arrowleft", ((t, e) => {
                    if (this.focusTracker.focusedElement === this.arrowView.element) {
                        this.actionView.focus();
                        e()
                    }
                }))
            }

            focus() {
                this.actionView.focus()
            }

            _createActionView() {
                const t = new sw;
                t.bind("icon", "isEnabled", "isOn", "isToggleable", "keystroke", "label", "tabindex", "tooltip", "tooltipPosition", "type", "withText").to(this);
                t.extendTemplate({attributes: {class: "ck-splitbutton__action"}});
                t.delegate("execute").to(this);
                return t
            }

            _createArrowView() {
                const t = new sw;
                const e = t.bindTemplate;
                t.icon = aw;
                t.extendTemplate({
                    attributes: {
                        class: "ck-splitbutton__arrow",
                        "aria-haspopup": true,
                        "aria-expanded": e.to("isOn", (t => String(t)))
                    }
                });
                t.bind("isEnabled").to(this);
                t.delegate("execute").to(this, "open");
                return t
            }
        }

        var uv = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.87 12.61a.75.75 0 0 1-.089.976l-.085.07-3.154 2.254 3.412 2.414a.75.75 0 0 1 .237.95l-.057.095a.75.75 0 0 1-.95.237l-.096-.058-4.272-3.022-.003-1.223 4.01-2.867a.75.75 0 0 1 1.047.174zm2.795-.231l.095.057 4.011 2.867-.003 1.223-4.272 3.022-.095.058a.75.75 0 0 1-.88-.151l-.07-.086-.058-.095a.75.75 0 0 1 .15-.88l.087-.07 3.412-2.414-3.154-2.253-.085-.071a.75.75 0 0 1 .862-1.207zM16 0a2 2 0 0 1 2 2v9.354l-.663-.492-.837-.001V2a.5.5 0 0 0-.5-.5H2a.5.5 0 0 0-.5.5v15a.5.5 0 0 0 .5.5h3.118L7.156 19H2a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h14zM5.009 15l.003 1H3v-1h2.009zm2.188-2l-1.471 1H5v-1h2.197zM10 11v.095L8.668 12H7v-1h3zm4-2v1H7V9h7zm0-2v1H7V7h7zm-4-2v1H5V5h5zM6 3v1H3V3h3z"/></svg>';
        var hv = n(30);
        var mv = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        mv.insert = "head";
        mv.singleton = true;
        var gv = ob()(hv["a"], mv);
        var fv = hv["a"].locals || {};

        class pv extends tA {
            init() {
                const t = this.editor;
                const e = t.t;
                const n = t.ui.componentFactory;
                const i = RC(t);
                const o = i[0];
                n.add("codeBlock", (n => {
                    const r = t.commands.get("codeBlock");
                    const s = Sw(n, dv);
                    const a = s.buttonView;
                    a.set({label: e("Insert code block"), tooltip: true, icon: uv, isToggleable: true});
                    a.bind("isOn").to(r, "value", (t => !!t));
                    a.on("execute", (() => {
                        t.execute("codeBlock", {language: o.language});
                        t.editing.view.focus()
                    }));
                    s.on("execute", (e => {
                        t.execute("codeBlock", {language: e.source._codeBlockLanguage, forceValue: true});
                        t.editing.view.focus()
                    }));
                    s.class = "ck-code-block-dropdown";
                    s.bind("isEnabled").to(r);
                    Bw(s, this._getLanguageListItemDefinitions(i));
                    return s
                }))
            }

            _getLanguageListItemDefinitions(t) {
                const e = this.editor;
                const n = e.commands.get("codeBlock");
                const i = new vs;
                for (const e of t) {
                    const t = {
                        type: "button",
                        model: new rv({_codeBlockLanguage: e.language, label: e.label, withText: true})
                    };
                    t.model.bind("isOn").to(n, "value", (e => e === t.model._codeBlockLanguage));
                    i.add(t)
                }
                return i
            }
        }

        class bv extends tA {
            static get requires() {
                return [ev, pv]
            }

            static get pluginName() {
                return "CodeBlock"
            }
        }

        class kv {
            constructor(t) {
                this.files = wv(t);
                this._native = t
            }

            get types() {
                return this._native.types
            }

            getData(t) {
                return this._native.getData(t)
            }

            setData(t, e) {
                this._native.setData(t, e)
            }
        }

        function wv(t) {
            const e = t.files ? Array.from(t.files) : [];
            const n = t.items ? Array.from(t.items) : [];
            if (e.length) {
                return e
            }
            return n.filter((t => t.kind === "file")).map((t => t.getAsFile()))
        }

        class Av extends eh {
            constructor(t) {
                super(t);
                const e = this.document;
                this.domEventType = ["paste", "copy", "cut", "drop", "dragover"];
                this.listenTo(e, "paste", n, {priority: "low"});
                this.listenTo(e, "drop", n, {priority: "low"});

                function n(t, n) {
                    n.preventDefault();
                    const i = n.dropRange ? [n.dropRange] : Array.from(e.selection.getRanges());
                    const o = new ts(e, "clipboardInput");
                    e.fire(o, {dataTransfer: n.dataTransfer, targetRanges: i});
                    if (o.stop.called) {
                        n.stopPropagation()
                    }
                }
            }

            onDomEvent(t) {
                const e = {dataTransfer: new kv(t.clipboardData ? t.clipboardData : t.dataTransfer)};
                if (t.type == "drop") {
                    e.dropRange = _v(this.view, t)
                }
                this.fire(t.type, t, e)
            }
        }

        function _v(t, e) {
            const n = e.target.ownerDocument;
            const i = e.clientX;
            const o = e.clientY;
            let r;
            if (n.caretRangeFromPoint && n.caretRangeFromPoint(i, o)) {
                r = n.caretRangeFromPoint(i, o)
            } else if (e.rangeParent) {
                r = n.createRange();
                r.setStart(e.rangeParent, e.rangeOffset);
                r.collapse(true)
            }
            if (r) {
                return t.domConverter.domRangeToView(r)
            } else {
                return t.document.selection.getFirstRange()
            }
        }

        class Cv extends tA {
            static get pluginName() {
                return "PastePlainText"
            }

            init() {
                const t = this.editor.editing.view;
                const e = t.document;
                let n = false;
                t.addObserver(Av);
                this.listenTo(e, "keydown", ((t, e) => {
                    n = e.shiftKey
                }));
                this.listenTo(e, "clipboardInput", ((t, e) => {
                    if (n) {
                        e.asPlainText = true
                    }
                }), {priority: "high"})
            }
        }

        function vv(t) {
            t = t.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r?\n\r?\n/g, "</p><p>").replace(/\r?\n/g, "<br>").replace(/^\s/, "&nbsp;").replace(/\s$/, "&nbsp;").replace(/\s\s/g, " &nbsp;");
            if (t.includes("</p><p>") || t.includes("<br>")) {
                t = `<p>${t}</p>`
            }
            return t
        }

        function yv(t) {
            return t.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, ((t, e) => {
                if (e.length == 1) {
                    return " "
                }
                return e
            }))
        }

        const xv = ["figcaption", "li"];

        function Ev(t) {
            let e = "";
            if (t.is("$text") || t.is("$textProxy")) {
                e = t.data
            } else if (t.is("element", "img") && t.hasAttribute("alt")) {
                e = t.getAttribute("alt")
            } else if (t.is("element", "br")) {
                e = "\n"
            } else {
                let n = null;
                for (const i of t.getChildren()) {
                    const t = Ev(i);
                    if (n && (n.is("containerElement") || i.is("containerElement"))) {
                        if (xv.includes(n.name) || xv.includes(i.name)) {
                            e += "\n"
                        } else {
                            e += "\n\n"
                        }
                    }
                    e += t;
                    n = i
                }
            }
            return e
        }

        class Dv extends tA {
            static get pluginName() {
                return "Clipboard"
            }

            static get requires() {
                return [Cv]
            }

            init() {
                const t = this.editor;
                const e = t.model.document;
                const n = t.editing.view;
                const i = n.document;
                this._htmlDataProcessor = new Qp(i);
                n.addObserver(Av);
                this.listenTo(i, "clipboardInput", (e => {
                    if (t.isReadOnly) {
                        e.stop()
                    }
                }), {priority: "highest"});
                this.listenTo(i, "clipboardInput", ((t, e) => {
                    const i = e.dataTransfer;
                    let o = "";
                    if (i.getData("text/html")) {
                        o = yv(i.getData("text/html"))
                    } else if (i.getData("text/plain")) {
                        o = vv(i.getData("text/plain"))
                    }
                    o = this._htmlDataProcessor.toView(o);
                    const r = new ts(this, "inputTransformation");
                    this.fire(r, {content: o, dataTransfer: i, asPlainText: e.asPlainText});
                    if (r.stop.called) {
                        t.stop()
                    }
                    n.scrollToTheSelection()
                }), {priority: "low"});
                this.listenTo(this, "inputTransformation", ((n, i) => {
                    if (!i.content.isEmpty) {
                        const o = this.editor.data;
                        const r = this.editor.model;
                        const s = o.toModel(i.content, "$clipboardHolder");
                        if (s.childCount == 0) {
                            return
                        }
                        if (i.asPlainText || Tv(s)) {
                            const n = new Map(Array.from(e.selection.getAttributes()).filter((e => t.model.schema.getAttributeProperties(e[0]).isFormatting)));
                            r.change((t => {
                                const e = t.createRangeIn(s);
                                for (const i of e.getItems()) {
                                    if (i.is("$text") || i.is("$textProxy")) {
                                        t.setAttributes(n, i)
                                    }
                                }
                            }))
                        }
                        r.insertContent(s);
                        n.stop()
                    }
                }), {priority: "low"});

                function o(n, o) {
                    const r = o.dataTransfer;
                    o.preventDefault();
                    const s = t.data.toView(t.model.getSelectedContent(e.selection));
                    i.fire("clipboardOutput", {dataTransfer: r, content: s, method: n.name})
                }

                this.listenTo(i, "copy", o, {priority: "low"});
                this.listenTo(i, "cut", ((e, n) => {
                    if (t.isReadOnly) {
                        n.preventDefault()
                    } else {
                        o(e, n)
                    }
                }), {priority: "low"});
                this.listenTo(i, "clipboardOutput", ((n, i) => {
                    if (!i.content.isEmpty) {
                        i.dataTransfer.setData("text/html", this._htmlDataProcessor.toData(i.content));
                        i.dataTransfer.setData("text/plain", Ev(i.content))
                    }
                    if (i.method == "cut") {
                        t.model.deleteContent(e.selection)
                    }
                }), {priority: "low"})
            }
        }

        function Tv(t) {
            if (t.childCount > 1) {
                return false
            }
            const e = t.getChild(0);
            return [...e.getAttributeKeys()].length == 0
        }

        class Mv extends nA {
            execute() {
                const t = this.editor.model;
                const e = t.document;
                t.change((n => {
                    Sv(this.editor.model, n, e.selection, t.schema);
                    this.fire("afterExecute", {writer: n})
                }))
            }
        }

        function Sv(t, e, n, i) {
            const o = n.isCollapsed;
            const r = n.getFirstRange();
            const s = r.start.parent;
            const a = r.end.parent;
            if (i.isLimit(s) || i.isLimit(a)) {
                if (!o && s == a) {
                    t.deleteContent(n)
                }
                return
            }
            if (o) {
                const t = IC(e.model.schema, n.getAttributes());
                Iv(e, r.start);
                e.setSelectionAttribute(t)
            } else {
                const i = !(r.start.isAtStart && r.end.isAtEnd);
                const o = s == a;
                t.deleteContent(n, {leaveUnmerged: i});
                if (i) {
                    if (o) {
                        Iv(e, n.focus)
                    } else {
                        e.setSelection(a, 0)
                    }
                }
            }
        }

        function Iv(t, e) {
            t.split(e);
            t.setSelection(e.parent.nextSibling, 0)
        }

        class Bv extends tA {
            static get pluginName() {
                return "Enter"
            }

            init() {
                const t = this.editor;
                const e = t.editing.view;
                const n = e.document;
                e.addObserver(OC);
                t.commands.add("enter", new Mv(t));
                this.listenTo(n, "enter", ((n, i) => {
                    i.preventDefault();
                    if (i.isSoft) {
                        return
                    }
                    t.execute("enter");
                    e.scrollToTheSelection()
                }), {priority: "low"})
            }
        }

        class Lv extends nA {
            execute() {
                const t = this.editor.model;
                const e = t.document.selection;
                let n = t.schema.getLimitElement(e);
                if (e.containsEntireContent(n) || !zv(t.schema, n)) {
                    do {
                        n = n.parent;
                        if (!n) {
                            return
                        }
                    } while (!zv(t.schema, n))
                }
                t.change((t => {
                    t.setSelection(n, "in")
                }))
            }
        }

        function zv(t, e) {
            return t.isLimit(e) && (t.checkChild(e, "$text") || t.checkChild(e, "paragraph"))
        }

        const Nv = Ol("Ctrl+A");

        class Pv extends tA {
            static get pluginName() {
                return "SelectAllEditing"
            }

            init() {
                const t = this.editor;
                const e = t.editing.view;
                const n = e.document;
                t.commands.add("selectAll", new Lv(t));
                this.listenTo(n, "keydown", ((e, n) => {
                    if (Pl(n) === Nv) {
                        t.execute("selectAll");
                        n.preventDefault()
                    }
                }))
            }
        }

        var Ov = '<svg width="20" height="20" xmlns="http://www.w3.org/2000/svg"><path d="M.75 15.5a.75.75 0 0 1 .75.75V18l.008.09A.5.5 0 0 0 2 18.5h1.75a.75.75 0 1 1 0 1.5H1.5l-.144-.007a1.5 1.5 0 0 1-1.35-1.349L0 18.5v-2.25a.75.75 0 0 1 .75-.75zm18.5 0a.75.75 0 0 1 .75.75v2.25l-.007.144a1.5 1.5 0 0 1-1.349 1.35L18.5 20h-2.25a.75.75 0 1 1 0-1.5H18a.5.5 0 0 0 .492-.41L18.5 18v-1.75a.75.75 0 0 1 .75-.75zm-10.45 3c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm.45-5.5a.75.75 0 1 1 0 1.5h-8.5a.75.75 0 1 1 0-1.5h8.5zM1.3 11c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM1.3 7c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5h-2.5a.75.75 0 1 1 0-1.5h2.5zm-5 0a.75.75 0 1 1 0 1.5h-5.5a.75.75 0 0 1 0-1.5h5.5zm-6.5-5a.75.75 0 0 1 0 1.5H2a.5.5 0 0 0-.492.41L1.5 2v1.75a.75.75 0 0 1-1.5 0V1.5l.007-.144A1.5 1.5 0 0 1 1.356.006L1.5 0h2.25zM18.5 0l.144.007a1.5 1.5 0 0 1 1.35 1.349L20 1.5v2.25a.75.75 0 1 1-1.5 0V2l-.008-.09A.5.5 0 0 0 18 1.5h-1.75a.75.75 0 1 1 0-1.5h2.25zM8.8 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6z"/></svg>';

        class jv extends tA {
            static get pluginName() {
                return "SelectAllUI"
            }

            init() {
                const t = this.editor;
                t.ui.componentFactory.add("selectAll", (e => {
                    const n = t.commands.get("selectAll");
                    const i = new sw(e);
                    const o = e.t;
                    i.set({label: o("Select all"), icon: Ov, keystroke: "Ctrl+A", tooltip: true});
                    i.bind("isOn", "isEnabled").to(n, "value", "isEnabled");
                    this.listenTo(i, "execute", (() => {
                        t.execute("selectAll");
                        t.editing.view.focus()
                    }));
                    return i
                }))
            }
        }

        class Rv extends tA {
            static get requires() {
                return [Pv, jv]
            }

            static get pluginName() {
                return "SelectAll"
            }
        }

        class Fv {
            constructor(t, e = 20) {
                this.model = t;
                this.size = 0;
                this.limit = e;
                this.isLocked = false;
                this._changeCallback = (t, e) => {
                    if (e.type != "transparent" && e !== this._batch) {
                        this._reset(true)
                    }
                };
                this._selectionChangeCallback = () => {
                    this._reset()
                };
                this.model.document.on("change", this._changeCallback);
                this.model.document.selection.on("change:range", this._selectionChangeCallback);
                this.model.document.selection.on("change:attribute", this._selectionChangeCallback)
            }

            get batch() {
                if (!this._batch) {
                    this._batch = this.model.createBatch()
                }
                return this._batch
            }

            input(t) {
                this.size += t;
                if (this.size >= this.limit) {
                    this._reset(true)
                }
            }

            lock() {
                this.isLocked = true
            }

            unlock() {
                this.isLocked = false
            }

            destroy() {
                this.model.document.off("change", this._changeCallback);
                this.model.document.selection.off("change:range", this._selectionChangeCallback);
                this.model.document.selection.off("change:attribute", this._selectionChangeCallback)
            }

            _reset(t) {
                if (!this.isLocked || t) {
                    this._batch = null;
                    this.size = 0
                }
            }
        }

        class Vv extends nA {
            constructor(t, e) {
                super(t);
                this._buffer = new Fv(t.model, e);
                this._batches = new WeakSet
            }

            get buffer() {
                return this._buffer
            }

            destroy() {
                super.destroy();
                this._buffer.destroy()
            }

            execute(t = {}) {
                const e = this.editor.model;
                const n = e.document;
                const i = t.text || "";
                const o = i.length;
                const r = t.range ? e.createSelection(t.range) : n.selection;
                const s = t.resultRange;
                e.enqueueChange(this._buffer.batch, (t => {
                    this._buffer.lock();
                    this._batches.add(this._buffer.batch);
                    e.deleteContent(r);
                    if (i) {
                        e.insertContent(t.createText(i, n.selection.getAttributes()), r)
                    }
                    if (s) {
                        t.setSelection(s)
                    } else if (!r.is("documentSelection")) {
                        t.setSelection(r)
                    }
                    this._buffer.unlock();
                    this._buffer.input(o)
                }))
            }
        }

        function Hv(t) {
            let e = null;
            const n = t.model;
            const i = t.editing.view;
            const o = t.commands.get("input");
            if (El.isAndroid) {
                i.document.on("beforeinput", ((t, e) => r(e)), {priority: "lowest"})
            } else {
                i.document.on("keydown", ((t, e) => r(e)), {priority: "lowest"})
            }
            i.document.on("compositionstart", s, {priority: "lowest"});
            i.document.on("compositionend", (() => {
                e = n.createSelection(n.document.selection)
            }), {priority: "lowest"});

            function r(t) {
                const r = n.document;
                const s = i.document.isComposing;
                const c = e && e.isEqual(r.selection);
                e = null;
                if (!o.isEnabled) {
                    return
                }
                if (Wv(t) || r.selection.isCollapsed) {
                    return
                }
                if (s && t.keyCode === 229) {
                    return
                }
                if (!s && t.keyCode === 229 && c) {
                    return
                }
                a()
            }

            function s() {
                const t = n.document;
                const e = t.selection.rangeCount === 1 ? t.selection.getFirstRange().isFlat : true;
                if (t.selection.isCollapsed || e) {
                    return
                }
                a()
            }

            function a() {
                const t = o.buffer;
                t.lock();
                const e = t.batch;
                o._batches.add(e);
                n.enqueueChange(e, (() => {
                    n.deleteContent(n.document.selection)
                }));
                t.unlock()
            }
        }

        const Uv = [Pl("arrowUp"), Pl("arrowRight"), Pl("arrowDown"), Pl("arrowLeft"), 9, 16, 17, 18, 19, 20, 27, 33, 34, 35, 36, 45, 91, 93, 144, 145, 173, 174, 175, 176, 177, 178, 179, 255];
        for (let t = 112; t <= 135; t++) {
            Uv.push(t)
        }

        function Wv(t) {
            if (t.ctrlKey) {
                return true
            }
            return Uv.includes(t.keyCode)
        }

        function qv(t, e) {
            const n = [];
            let i = 0;
            let o;
            t.forEach((t => {
                if (t == "equal") {
                    r();
                    i++
                } else if (t == "insert") {
                    if (s("insert")) {
                        o.values.push(e[i])
                    } else {
                        r();
                        o = {type: "insert", index: i, values: [e[i]]}
                    }
                    i++
                } else {
                    if (s("delete")) {
                        o.howMany++
                    } else {
                        r();
                        o = {type: "delete", index: i, howMany: 1}
                    }
                }
            }));
            r();
            return n;

            function r() {
                if (o) {
                    n.push(o);
                    o = null
                }
            }

            function s(t) {
                return o && o.type == t
            }
        }

        function Kv(t) {
            if (t.length == 0) {
                return false
            }
            for (const e of t) {
                if (e.type === "children" && !Gv(e)) {
                    return true
                }
            }
            return false
        }

        function Gv(t) {
            if (t.newChildren.length - t.oldChildren.length != 1) {
                return
            }
            const e = Ed(t.oldChildren, t.newChildren, $v);
            const n = qv(e, t.newChildren);
            if (n.length > 1) {
                return
            }
            const i = n[0];
            if (!(!!i.values[0] && i.values[0].is("$text"))) {
                return
            }
            return i
        }

        function $v(t, e) {
            if (!!t && t.is("$text") && !!e && e.is("$text")) {
                return t.data === e.data
            } else {
                return t === e
            }
        }

        function Yv(t) {
            t.editing.view.document.on("mutations", ((e, n, i) => {
                new Qv(t).handle(n, i)
            }))
        }

        class Qv {
            constructor(t) {
                this.editor = t;
                this.editing = this.editor.editing
            }

            handle(t, e) {
                if (Kv(t)) {
                    this._handleContainerChildrenMutations(t, e)
                } else {
                    for (const n of t) {
                        this._handleTextMutation(n, e);
                        this._handleTextNodeInsertion(n)
                    }
                }
            }

            _handleContainerChildrenMutations(t, e) {
                const n = Jv(t);
                if (!n) {
                    return
                }
                const i = this.editor.editing.view.domConverter;
                const o = i.mapViewToDom(n);
                const r = new Ud(this.editor.editing.view.document);
                const s = this.editor.data.toModel(r.domToView(o)).getChild(0);
                const a = this.editor.editing.mapper.toModelElement(n);
                if (!a) {
                    return
                }
                const c = Array.from(s.getChildren());
                const l = Array.from(a.getChildren());
                const d = c[c.length - 1];
                const u = l[l.length - 1];
                const h = d && d.is("element", "softBreak");
                const m = u && !u.is("element", "softBreak");
                if (h && m) {
                    c.pop()
                }
                const g = this.editor.model.schema;
                if (!Xv(c, g) || !Xv(l, g)) {
                    return
                }
                const f = c.map((t => t.is("$text") ? t.data : "@")).join("").replace(/\u00A0/g, " ");
                const p = l.map((t => t.is("$text") ? t.data : "@")).join("").replace(/\u00A0/g, " ");
                if (p === f) {
                    return
                }
                const b = Ed(p, f);
                const {firstChangeAt: k, insertions: w, deletions: A} = Zv(b);
                let _ = null;
                if (e) {
                    _ = this.editing.mapper.toModelRange(e.getFirstRange())
                }
                const C = f.substr(k, w);
                const v = this.editor.model.createRange(this.editor.model.createPositionAt(a, k), this.editor.model.createPositionAt(a, k + A));
                this.editor.execute("input", {text: C, range: v, resultRange: _})
            }

            _handleTextMutation(t, e) {
                if (t.type != "text") {
                    return
                }
                const n = t.newText.replace(/\u00A0/g, " ");
                const i = t.oldText.replace(/\u00A0/g, " ");
                if (i === n) {
                    return
                }
                const o = Ed(i, n);
                const {firstChangeAt: r, insertions: s, deletions: a} = Zv(o);
                let c = null;
                if (e) {
                    c = this.editing.mapper.toModelRange(e.getFirstRange())
                }
                const l = this.editing.view.createPositionAt(t.node, r);
                const d = this.editing.mapper.toModelPosition(l);
                const u = this.editor.model.createRange(d, d.getShiftedBy(a));
                const h = n.substr(r, s);
                this.editor.execute("input", {text: h, range: u, resultRange: c})
            }

            _handleTextNodeInsertion(t) {
                if (t.type != "children") {
                    return
                }
                const e = Gv(t);
                const n = this.editing.view.createPositionAt(t.node, e.index);
                const i = this.editing.mapper.toModelPosition(n);
                const o = e.values[0].data;
                this.editor.execute("input", {text: o.replace(/\u00A0/g, " "), range: this.editor.model.createRange(i)})
            }
        }

        function Jv(t) {
            const e = t.map((t => t.node)).reduce(((t, e) => t.getCommonAncestor(e, {includeSelf: true})));
            if (!e) {
                return
            }
            return e.getAncestors({
                includeSelf: true,
                parentFirst: true
            }).find((t => t.is("containerElement") || t.is("rootElement")))
        }

        function Xv(t, e) {
            return t.every((t => e.isInline(t)))
        }

        function Zv(t) {
            let e = null;
            let n = null;
            for (let i = 0; i < t.length; i++) {
                const o = t[i];
                if (o != "equal") {
                    e = e === null ? i : e;
                    n = i
                }
            }
            let i = 0;
            let o = 0;
            for (let r = e; r <= n; r++) {
                if (t[r] != "insert") {
                    i++
                }
                if (t[r] != "delete") {
                    o++
                }
            }
            return {insertions: o, deletions: i, firstChangeAt: e}
        }

        class ty extends tA {
            static get pluginName() {
                return "Input"
            }

            init() {
                const t = this.editor;
                const e = new Vv(t, t.config.get("typing.undoStep") || 20);
                t.commands.add("input", e);
                Hv(t);
                Yv(t)
            }

            isInput(t) {
                const e = this.editor.commands.get("input");
                return e._batches.has(t)
            }
        }

        class ey extends nA {
            constructor(t, e) {
                super(t);
                this.direction = e;
                this._buffer = new Fv(t.model, t.config.get("typing.undoStep"))
            }

            get buffer() {
                return this._buffer
            }

            execute(t = {}) {
                const e = this.editor.model;
                const n = e.document;
                e.enqueueChange(this._buffer.batch, (i => {
                    this._buffer.lock();
                    const o = i.createSelection(t.selection || n.selection);
                    const r = o.isCollapsed;
                    if (o.isCollapsed) {
                        e.modifySelection(o, {direction: this.direction, unit: t.unit})
                    }
                    if (this._shouldEntireContentBeReplacedWithParagraph(t.sequence || 1)) {
                        this._replaceEntireContentWithParagraph(i);
                        return
                    }
                    if (o.isCollapsed) {
                        return
                    }
                    let s = 0;
                    o.getFirstRange().getMinimalFlatRanges().forEach((t => {
                        s += gl(t.getWalker({singleCharacters: true, ignoreElementEnd: true, shallow: true}))
                    }));
                    e.deleteContent(o, {doNotResetEntireContent: r, direction: this.direction});
                    this._buffer.input(s);
                    i.setSelection(o);
                    this._buffer.unlock()
                }))
            }

            _shouldEntireContentBeReplacedWithParagraph(t) {
                if (t > 1) {
                    return false
                }
                const e = this.editor.model;
                const n = e.document;
                const i = n.selection;
                const o = e.schema.getLimitElement(i);
                const r = i.isCollapsed && i.containsEntireContent(o);
                if (!r) {
                    return false
                }
                if (!e.schema.checkChild(o, "paragraph")) {
                    return false
                }
                const s = o.getChild(0);
                if (s && s.name === "paragraph") {
                    return false
                }
                return true
            }

            _replaceEntireContentWithParagraph(t) {
                const e = this.editor.model;
                const n = e.document;
                const i = n.selection;
                const o = e.schema.getLimitElement(i);
                const r = t.createElement("paragraph");
                t.remove(t.createRangeIn(o));
                t.insert(r, o);
                t.setSelection(r, 0)
            }
        }

        class ny extends Zd {
            constructor(t) {
                super(t);
                const e = t.document;
                let n = 0;
                e.on("keyup", ((t, e) => {
                    if (e.keyCode == Nl.delete || e.keyCode == Nl.backspace) {
                        n = 0
                    }
                }));
                e.on("keydown", ((t, e) => {
                    const o = {};
                    if (e.keyCode == Nl.delete) {
                        o.direction = "forward";
                        o.unit = "character"
                    } else if (e.keyCode == Nl.backspace) {
                        o.direction = "backward";
                        o.unit = "codePoint"
                    } else {
                        return
                    }
                    const r = El.isMac ? e.altKey : e.ctrlKey;
                    o.unit = r ? "word" : o.unit;
                    o.sequence = ++n;
                    i(t, e.domEvent, o)
                }));
                if (El.isAndroid) {
                    e.on("beforeinput", ((e, n) => {
                        if (n.domEvent.inputType != "deleteContentBackward") {
                            return
                        }
                        const o = {unit: "codepoint", direction: "backward", sequence: 1};
                        const r = n.domTarget.ownerDocument.defaultView.getSelection();
                        if (r.anchorNode == r.focusNode && r.anchorOffset + 1 != r.focusOffset) {
                            o.selectionToRemove = t.domConverter.domSelectionToView(r)
                        }
                        i(e, n.domEvent, o)
                    }))
                }

                function i(t, n, i) {
                    let o;
                    e.once("delete", (t => o = t), {priority: Number.POSITIVE_INFINITY});
                    e.fire("delete", new th(e, n, i));
                    if (o && o.stop.called) {
                        t.stop()
                    }
                }
            }

            observe() {
            }
        }

        class iy extends tA {
            static get pluginName() {
                return "Delete"
            }

            init() {
                const t = this.editor;
                const e = t.editing.view;
                const n = e.document;
                e.addObserver(ny);
                t.commands.add("forwardDelete", new ey(t, "forward"));
                t.commands.add("delete", new ey(t, "backward"));
                this.listenTo(n, "delete", ((n, i) => {
                    const o = {unit: i.unit, sequence: i.sequence};
                    if (i.selectionToRemove) {
                        const e = t.model.createSelection();
                        const n = [];
                        for (const e of i.selectionToRemove.getRanges()) {
                            n.push(t.editing.mapper.toModelRange(e))
                        }
                        e.setTo(n);
                        o.selection = e
                    }
                    t.execute(i.direction == "forward" ? "forwardDelete" : "delete", o);
                    i.preventDefault();
                    e.scrollToTheSelection()
                }));
                if (El.isAndroid) {
                    let t = null;
                    this.listenTo(n, "delete", ((e, n) => {
                        const i = n.domTarget.ownerDocument.defaultView.getSelection();
                        t = {
                            anchorNode: i.anchorNode,
                            anchorOffset: i.anchorOffset,
                            focusNode: i.focusNode,
                            focusOffset: i.focusOffset
                        }
                    }), {priority: "lowest"});
                    this.listenTo(n, "keyup", ((e, n) => {
                        if (t) {
                            const e = n.domTarget.ownerDocument.defaultView.getSelection();
                            e.collapse(t.anchorNode, t.anchorOffset);
                            e.extend(t.focusNode, t.focusOffset);
                            t = null
                        }
                    }))
                }
            }
        }

        class oy extends tA {
            static get requires() {
                return [ty, iy]
            }

            static get pluginName() {
                return "Typing"
            }
        }

        const ry = new Map;

        function sy(t, e, n) {
            let i = ry.get(t);
            if (!i) {
                i = new Map;
                ry.set(t, i)
            }
            i.set(e, n)
        }

        function ay(t, e) {
            const n = ry.get(t);
            if (n && n.has(e)) {
                return n.get(e)
            }
            return cy
        }

        function cy(t) {
            return [t]
        }

        function ly(t, e, n = {}) {
            const i = ay(t.constructor, e.constructor);
            try {
                t = t.clone();
                return i(t, e, n)
            } catch (t) {
                throw t
            }
        }

        function dy(t, e, n) {
            t = t.slice();
            e = e.slice();
            const i = new uy(n.document, n.useRelations, n.forceWeakRemove);
            i.setOriginalOperations(t);
            i.setOriginalOperations(e);
            const o = i.originalOperations;
            if (t.length == 0 || e.length == 0) {
                return {operationsA: t, operationsB: e, originalOperations: o}
            }
            const r = new WeakMap;
            for (const e of t) {
                r.set(e, 0)
            }
            const s = {
                nextBaseVersionA: t[t.length - 1].baseVersion + 1,
                nextBaseVersionB: e[e.length - 1].baseVersion + 1,
                originalOperationsACount: t.length,
                originalOperationsBCount: e.length
            };
            let a = 0;
            while (a < t.length) {
                const n = t[a];
                const o = r.get(n);
                if (o == e.length) {
                    a++;
                    continue
                }
                const s = e[o];
                const c = ly(n, s, i.getContext(n, s, true));
                const l = ly(s, n, i.getContext(s, n, false));
                i.updateRelation(n, s);
                i.setOriginalOperations(c, n);
                i.setOriginalOperations(l, s);
                for (const t of c) {
                    r.set(t, o + l.length)
                }
                t.splice(a, 1, ...c);
                e.splice(o, 1, ...l)
            }
            if (n.padWithNoOps) {
                const n = t.length - s.originalOperationsACount;
                const i = e.length - s.originalOperationsBCount;
                my(t, i - n);
                my(e, n - i)
            }
            hy(t, s.nextBaseVersionB);
            hy(e, s.nextBaseVersionA);
            return {operationsA: t, operationsB: e, originalOperations: o}
        }

        class uy {
            constructor(t, e, n = false) {
                this.originalOperations = new Map;
                this._history = t.history;
                this._useRelations = e;
                this._forceWeakRemove = !!n;
                this._relations = new Map
            }

            setOriginalOperations(t, e = null) {
                const n = e ? this.originalOperations.get(e) : null;
                for (const e of t) {
                    this.originalOperations.set(e, n || e)
                }
            }

            updateRelation(t, e) {
                switch (t.constructor) {
                    case Cf: {
                        switch (e.constructor) {
                            case Df: {
                                if (t.targetPosition.isEqual(e.sourcePosition) || e.movedRange.containsPosition(t.targetPosition)) {
                                    this._setRelation(t, e, "insertAtSource")
                                } else if (t.targetPosition.isEqual(e.deletionPosition)) {
                                    this._setRelation(t, e, "insertBetween")
                                } else if (t.targetPosition.isAfter(e.sourcePosition)) {
                                    this._setRelation(t, e, "moveTargetAfter")
                                }
                                break
                            }
                            case Cf: {
                                if (t.targetPosition.isEqual(e.sourcePosition) || t.targetPosition.isBefore(e.sourcePosition)) {
                                    this._setRelation(t, e, "insertBefore")
                                } else {
                                    this._setRelation(t, e, "insertAfter")
                                }
                                break
                            }
                        }
                        break
                    }
                    case Tf: {
                        switch (e.constructor) {
                            case Df: {
                                if (t.splitPosition.isBefore(e.sourcePosition)) {
                                    this._setRelation(t, e, "splitBefore")
                                }
                                break
                            }
                            case Cf: {
                                if (t.splitPosition.isEqual(e.sourcePosition) || t.splitPosition.isBefore(e.sourcePosition)) {
                                    this._setRelation(t, e, "splitBefore")
                                }
                                break
                            }
                        }
                        break
                    }
                    case Df: {
                        switch (e.constructor) {
                            case Df: {
                                if (!t.targetPosition.isEqual(e.sourcePosition)) {
                                    this._setRelation(t, e, "mergeTargetNotMoved")
                                }
                                if (t.sourcePosition.isEqual(e.targetPosition)) {
                                    this._setRelation(t, e, "mergeSourceNotMoved")
                                }
                                if (t.sourcePosition.isEqual(e.sourcePosition)) {
                                    this._setRelation(t, e, "mergeSameElement")
                                }
                                break
                            }
                            case Tf: {
                                if (t.sourcePosition.isEqual(e.splitPosition)) {
                                    this._setRelation(t, e, "splitAtSource")
                                }
                            }
                        }
                        break
                    }
                    case yf: {
                        const n = t.newRange;
                        if (!n) {
                            return
                        }
                        switch (e.constructor) {
                            case Cf: {
                                const i = tm._createFromPositionAndShift(e.sourcePosition, e.howMany);
                                const o = i.containsPosition(n.start) || i.start.isEqual(n.start);
                                const r = i.containsPosition(n.end) || i.end.isEqual(n.end);
                                if ((o || r) && !i.containsRange(n)) {
                                    this._setRelation(t, e, {
                                        side: o ? "left" : "right",
                                        path: o ? n.start.path.slice() : n.end.path.slice()
                                    })
                                }
                                break
                            }
                            case Df: {
                                const i = n.start.isEqual(e.targetPosition);
                                const o = n.start.isEqual(e.deletionPosition);
                                const r = n.end.isEqual(e.deletionPosition);
                                const s = n.end.isEqual(e.sourcePosition);
                                if (i || o || r || s) {
                                    this._setRelation(t, e, {
                                        wasInLeftElement: i,
                                        wasStartBeforeMergedElement: o,
                                        wasEndBeforeMergedElement: r,
                                        wasInRightElement: s
                                    })
                                }
                                break
                            }
                        }
                        break
                    }
                }
            }

            getContext(t, e, n) {
                return {
                    aIsStrong: n,
                    aWasUndone: this._wasUndone(t),
                    bWasUndone: this._wasUndone(e),
                    abRelation: this._useRelations ? this._getRelation(t, e) : null,
                    baRelation: this._useRelations ? this._getRelation(e, t) : null,
                    forceWeakRemove: this._forceWeakRemove
                }
            }

            _wasUndone(t) {
                const e = this.originalOperations.get(t);
                return e.wasUndone || this._history.isUndoneOperation(e)
            }

            _getRelation(t, e) {
                const n = this.originalOperations.get(e);
                const i = this._history.getUndoneOperation(n);
                if (!i) {
                    return null
                }
                const o = this.originalOperations.get(t);
                const r = this._relations.get(o);
                if (r) {
                    return r.get(i) || null
                }
                return null
            }

            _setRelation(t, e, n) {
                const i = this.originalOperations.get(t);
                const o = this.originalOperations.get(e);
                let r = this._relations.get(i);
                if (!r) {
                    r = new Map;
                    this._relations.set(i, r)
                }
                r.set(o, n)
            }
        }

        function hy(t, e) {
            for (const n of t) {
                n.baseVersion = e++
            }
        }

        function my(t, e) {
            for (let n = 0; n < e; n++) {
                t.push(new Jf(0))
            }
        }

        sy(Af, Af, ((t, e, n) => {
            if (t.key === e.key && t.range.start.hasSameParentAs(e.range.start)) {
                const i = t.range.getDifference(e.range).map((e => new Af(e, t.key, t.oldValue, t.newValue, 0)));
                const o = t.range.getIntersection(e.range);
                if (o) {
                    if (n.aIsStrong) {
                        i.push(new Af(o, e.key, e.newValue, t.newValue, 0))
                    }
                }
                if (i.length == 0) {
                    return [new Jf(0)]
                }
                return i
            } else {
                return [t]
            }
        }));
        sy(Af, vf, ((t, e) => {
            if (t.range.start.hasSameParentAs(e.position) && t.range.containsPosition(e.position)) {
                const n = t.range._getTransformedByInsertion(e.position, e.howMany, !e.shouldReceiveAttributes);
                const i = n.map((e => new Af(e, t.key, t.oldValue, t.newValue, t.baseVersion)));
                if (e.shouldReceiveAttributes) {
                    const n = gy(e, t.key, t.oldValue);
                    if (n) {
                        i.unshift(n)
                    }
                }
                return i
            }
            t.range = t.range._getTransformedByInsertion(e.position, e.howMany, false)[0];
            return [t]
        }));

        function gy(t, e, n) {
            const i = t.nodes;
            const o = i.getNode(0).getAttribute(e);
            if (o == n) {
                return null
            }
            const r = new tm(t.position, t.position.getShiftedBy(t.howMany));
            return new Af(r, e, o, n, 0)
        }

        sy(Af, Df, ((t, e) => {
            const n = [];
            if (t.range.start.hasSameParentAs(e.deletionPosition)) {
                if (t.range.containsPosition(e.deletionPosition) || t.range.start.isEqual(e.deletionPosition)) {
                    n.push(tm._createFromPositionAndShift(e.graveyardPosition, 1))
                }
            }
            const i = t.range._getTransformedByMergeOperation(e);
            if (!i.isCollapsed) {
                n.push(i)
            }
            return n.map((e => new Af(e, t.key, t.oldValue, t.newValue, t.baseVersion)))
        }));
        sy(Af, Cf, ((t, e) => {
            const n = fy(t.range, e);
            return n.map((e => new Af(e, t.key, t.oldValue, t.newValue, t.baseVersion)))
        }));

        function fy(t, e) {
            const n = tm._createFromPositionAndShift(e.sourcePosition, e.howMany);
            let i = null;
            let o = [];
            if (n.containsRange(t, true)) {
                i = t
            } else if (t.start.hasSameParentAs(n.start)) {
                o = t.getDifference(n);
                i = t.getIntersection(n)
            } else {
                o = [t]
            }
            const r = [];
            for (let t of o) {
                t = t._getTransformedByDeletion(e.sourcePosition, e.howMany);
                const n = e.getMovedRangeStart();
                const i = t.start.hasSameParentAs(n);
                t = t._getTransformedByInsertion(n, e.howMany, i);
                r.push(...t)
            }
            if (i) {
                r.push(i._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany, false)[0])
            }
            return r
        }

        sy(Af, Tf, ((t, e) => {
            if (t.range.end.isEqual(e.insertionPosition)) {
                if (!e.graveyardPosition) {
                    t.range.end.offset++
                }
                return [t]
            }
            if (t.range.start.hasSameParentAs(e.splitPosition) && t.range.containsPosition(e.splitPosition)) {
                const n = t.clone();
                n.range = new tm(e.moveTargetPosition.clone(), t.range.end._getCombined(e.splitPosition, e.moveTargetPosition));
                t.range.end = e.splitPosition.clone();
                t.range.end.stickiness = "toPrevious";
                return [t, n]
            }
            t.range = t.range._getTransformedBySplitOperation(e);
            return [t]
        }));
        sy(vf, Af, ((t, e) => {
            const n = [t];
            if (t.shouldReceiveAttributes && t.position.hasSameParentAs(e.range.start) && e.range.containsPosition(t.position)) {
                const i = gy(t, e.key, e.newValue);
                if (i) {
                    n.push(i)
                }
            }
            return n
        }));
        sy(vf, vf, ((t, e, n) => {
            if (t.position.isEqual(e.position) && n.aIsStrong) {
                return [t]
            }
            t.position = t.position._getTransformedByInsertOperation(e);
            return [t]
        }));
        sy(vf, Cf, ((t, e) => {
            t.position = t.position._getTransformedByMoveOperation(e);
            return [t]
        }));
        sy(vf, Tf, ((t, e) => {
            t.position = t.position._getTransformedBySplitOperation(e);
            return [t]
        }));
        sy(vf, Df, ((t, e) => {
            t.position = t.position._getTransformedByMergeOperation(e);
            return [t]
        }));
        sy(yf, vf, ((t, e) => {
            if (t.oldRange) {
                t.oldRange = t.oldRange._getTransformedByInsertOperation(e)[0]
            }
            if (t.newRange) {
                t.newRange = t.newRange._getTransformedByInsertOperation(e)[0]
            }
            return [t]
        }));
        sy(yf, yf, ((t, e, n) => {
            if (t.name == e.name) {
                if (n.aIsStrong) {
                    t.oldRange = e.newRange ? e.newRange.clone() : null
                } else {
                    return [new Jf(0)]
                }
            }
            return [t]
        }));
        sy(yf, Df, ((t, e) => {
            if (t.oldRange) {
                t.oldRange = t.oldRange._getTransformedByMergeOperation(e)
            }
            if (t.newRange) {
                t.newRange = t.newRange._getTransformedByMergeOperation(e)
            }
            return [t]
        }));
        sy(yf, Cf, ((t, e, n) => {
            if (t.oldRange) {
                t.oldRange = tm._createFromRanges(t.oldRange._getTransformedByMoveOperation(e))
            }
            if (t.newRange) {
                if (n.abRelation) {
                    const i = tm._createFromRanges(t.newRange._getTransformedByMoveOperation(e));
                    if (n.abRelation.side == "left" && e.targetPosition.isEqual(t.newRange.start)) {
                        t.newRange.start.path = n.abRelation.path;
                        t.newRange.end = i.end;
                        return [t]
                    } else if (n.abRelation.side == "right" && e.targetPosition.isEqual(t.newRange.end)) {
                        t.newRange.start = i.start;
                        t.newRange.end.path = n.abRelation.path;
                        return [t]
                    }
                }
                t.newRange = tm._createFromRanges(t.newRange._getTransformedByMoveOperation(e))
            }
            return [t]
        }));
        sy(yf, Tf, ((t, e, n) => {
            if (t.oldRange) {
                t.oldRange = t.oldRange._getTransformedBySplitOperation(e)
            }
            if (t.newRange) {
                if (n.abRelation) {
                    const i = t.newRange._getTransformedBySplitOperation(e);
                    if (t.newRange.start.isEqual(e.splitPosition) && n.abRelation.wasStartBeforeMergedElement) {
                        t.newRange.start = Qh._createAt(e.insertionPosition)
                    } else if (t.newRange.start.isEqual(e.splitPosition) && !n.abRelation.wasInLeftElement) {
                        t.newRange.start = Qh._createAt(e.moveTargetPosition)
                    }
                    if (t.newRange.end.isEqual(e.splitPosition) && n.abRelation.wasInRightElement) {
                        t.newRange.end = Qh._createAt(e.moveTargetPosition)
                    } else if (t.newRange.end.isEqual(e.splitPosition) && n.abRelation.wasEndBeforeMergedElement) {
                        t.newRange.end = Qh._createAt(e.insertionPosition)
                    } else {
                        t.newRange.end = i.end
                    }
                    return [t]
                }
                t.newRange = t.newRange._getTransformedBySplitOperation(e)
            }
            return [t]
        }));
        sy(Df, vf, ((t, e) => {
            if (t.sourcePosition.hasSameParentAs(e.position)) {
                t.howMany += e.howMany
            }
            t.sourcePosition = t.sourcePosition._getTransformedByInsertOperation(e);
            t.targetPosition = t.targetPosition._getTransformedByInsertOperation(e);
            return [t]
        }));
        sy(Df, Df, ((t, e, n) => {
            if (t.sourcePosition.isEqual(e.sourcePosition) && t.targetPosition.isEqual(e.targetPosition)) {
                if (!n.bWasUndone) {
                    return [new Jf(0)]
                } else {
                    const n = e.graveyardPosition.path.slice();
                    n.push(0);
                    t.sourcePosition = new Qh(e.graveyardPosition.root, n);
                    t.howMany = 0;
                    return [t]
                }
            }
            if (t.sourcePosition.isEqual(e.sourcePosition) && !t.targetPosition.isEqual(e.targetPosition) && !n.bWasUndone && n.abRelation != "splitAtSource") {
                const i = t.targetPosition.root.rootName == "$graveyard";
                const o = e.targetPosition.root.rootName == "$graveyard";
                const r = i && !o;
                const s = o && !i;
                const a = s || !r && n.aIsStrong;
                if (a) {
                    const n = e.targetPosition._getTransformedByMergeOperation(e);
                    const i = t.targetPosition._getTransformedByMergeOperation(e);
                    return [new Cf(n, t.howMany, i, 0)]
                } else {
                    return [new Jf(0)]
                }
            }
            if (t.sourcePosition.hasSameParentAs(e.targetPosition)) {
                t.howMany += e.howMany
            }
            t.sourcePosition = t.sourcePosition._getTransformedByMergeOperation(e);
            t.targetPosition = t.targetPosition._getTransformedByMergeOperation(e);
            if (!t.graveyardPosition.isEqual(e.graveyardPosition) || !n.aIsStrong) {
                t.graveyardPosition = t.graveyardPosition._getTransformedByMergeOperation(e)
            }
            return [t]
        }));
        sy(Df, Cf, ((t, e, n) => {
            const i = tm._createFromPositionAndShift(e.sourcePosition, e.howMany);
            if (e.type == "remove" && !n.bWasUndone && !n.forceWeakRemove) {
                if (t.deletionPosition.hasSameParentAs(e.sourcePosition) && i.containsPosition(t.sourcePosition)) {
                    return [new Jf(0)]
                }
            }
            if (t.sourcePosition.hasSameParentAs(e.targetPosition)) {
                t.howMany += e.howMany
            }
            if (t.sourcePosition.hasSameParentAs(e.sourcePosition)) {
                t.howMany -= e.howMany
            }
            t.sourcePosition = t.sourcePosition._getTransformedByMoveOperation(e);
            t.targetPosition = t.targetPosition._getTransformedByMoveOperation(e);
            if (!t.graveyardPosition.isEqual(e.targetPosition)) {
                t.graveyardPosition = t.graveyardPosition._getTransformedByMoveOperation(e)
            }
            return [t]
        }));
        sy(Df, Tf, ((t, e, n) => {
            if (e.graveyardPosition) {
                t.graveyardPosition = t.graveyardPosition._getTransformedByDeletion(e.graveyardPosition, 1);
                if (t.deletionPosition.isEqual(e.graveyardPosition)) {
                    t.howMany = e.howMany
                }
            }
            if (t.targetPosition.isEqual(e.splitPosition)) {
                const i = e.howMany != 0;
                const o = e.graveyardPosition && t.deletionPosition.isEqual(e.graveyardPosition);
                if (i || o || n.abRelation == "mergeTargetNotMoved") {
                    t.sourcePosition = t.sourcePosition._getTransformedBySplitOperation(e);
                    return [t]
                }
            }
            if (t.sourcePosition.isEqual(e.splitPosition)) {
                if (n.abRelation == "mergeSourceNotMoved") {
                    t.howMany = 0;
                    t.targetPosition = t.targetPosition._getTransformedBySplitOperation(e);
                    return [t]
                }
                if (n.abRelation == "mergeSameElement" || t.sourcePosition.offset > 0) {
                    t.sourcePosition = e.moveTargetPosition.clone();
                    t.targetPosition = t.targetPosition._getTransformedBySplitOperation(e);
                    return [t]
                }
            }
            if (t.sourcePosition.hasSameParentAs(e.splitPosition)) {
                t.howMany = e.splitPosition.offset
            }
            t.sourcePosition = t.sourcePosition._getTransformedBySplitOperation(e);
            t.targetPosition = t.targetPosition._getTransformedBySplitOperation(e);
            return [t]
        }));
        sy(Cf, vf, ((t, e) => {
            const n = tm._createFromPositionAndShift(t.sourcePosition, t.howMany);
            const i = n._getTransformedByInsertOperation(e, false)[0];
            t.sourcePosition = i.start;
            t.howMany = i.end.offset - i.start.offset;
            if (!t.targetPosition.isEqual(e.position)) {
                t.targetPosition = t.targetPosition._getTransformedByInsertOperation(e)
            }
            return [t]
        }));
        sy(Cf, Cf, ((t, e, n) => {
            const i = tm._createFromPositionAndShift(t.sourcePosition, t.howMany);
            const o = tm._createFromPositionAndShift(e.sourcePosition, e.howMany);
            let r = n.aIsStrong;
            let s = !n.aIsStrong;
            if (n.abRelation == "insertBefore" || n.baRelation == "insertAfter") {
                s = true
            } else if (n.abRelation == "insertAfter" || n.baRelation == "insertBefore") {
                s = false
            }
            let a;
            if (t.targetPosition.isEqual(e.targetPosition) && s) {
                a = t.targetPosition._getTransformedByDeletion(e.sourcePosition, e.howMany)
            } else {
                a = t.targetPosition._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany)
            }
            if (py(t, e) && py(e, t)) {
                return [e.getReversed()]
            }
            const c = i.containsPosition(e.targetPosition);
            if (c && i.containsRange(o, true)) {
                i.start = i.start._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany);
                i.end = i.end._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany);
                return by([i], a)
            }
            const l = o.containsPosition(t.targetPosition);
            if (l && o.containsRange(i, true)) {
                i.start = i.start._getCombined(e.sourcePosition, e.getMovedRangeStart());
                i.end = i.end._getCombined(e.sourcePosition, e.getMovedRangeStart());
                return by([i], a)
            }
            const d = Ns(t.sourcePosition.getParentPath(), e.sourcePosition.getParentPath());
            if (d == "prefix" || d == "extension") {
                i.start = i.start._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany);
                i.end = i.end._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany);
                return by([i], a)
            }
            if (t.type == "remove" && e.type != "remove" && !n.aWasUndone && !n.forceWeakRemove) {
                r = true
            } else if (t.type != "remove" && e.type == "remove" && !n.bWasUndone && !n.forceWeakRemove) {
                r = false
            }
            const u = [];
            const h = i.getDifference(o);
            for (const t of h) {
                t.start = t.start._getTransformedByDeletion(e.sourcePosition, e.howMany);
                t.end = t.end._getTransformedByDeletion(e.sourcePosition, e.howMany);
                const n = Ns(t.start.getParentPath(), e.getMovedRangeStart().getParentPath()) == "same";
                const i = t._getTransformedByInsertion(e.getMovedRangeStart(), e.howMany, n);
                u.push(...i)
            }
            const m = i.getIntersection(o);
            if (m !== null && r) {
                m.start = m.start._getCombined(e.sourcePosition, e.getMovedRangeStart());
                m.end = m.end._getCombined(e.sourcePosition, e.getMovedRangeStart());
                if (u.length === 0) {
                    u.push(m)
                } else if (u.length == 1) {
                    if (o.start.isBefore(i.start) || o.start.isEqual(i.start)) {
                        u.unshift(m)
                    } else {
                        u.push(m)
                    }
                } else {
                    u.splice(1, 0, m)
                }
            }
            if (u.length === 0) {
                return [new Jf(t.baseVersion)]
            }
            return by(u, a)
        }));
        sy(Cf, Tf, ((t, e, n) => {
            let i = t.targetPosition.clone();
            if (!t.targetPosition.isEqual(e.insertionPosition) || !e.graveyardPosition || n.abRelation == "moveTargetAfter") {
                i = t.targetPosition._getTransformedBySplitOperation(e)
            }
            const o = tm._createFromPositionAndShift(t.sourcePosition, t.howMany);
            if (o.end.isEqual(e.insertionPosition)) {
                if (!e.graveyardPosition) {
                    t.howMany++
                }
                t.targetPosition = i;
                return [t]
            }
            if (o.start.hasSameParentAs(e.splitPosition) && o.containsPosition(e.splitPosition)) {
                let t = new tm(e.splitPosition, o.end);
                t = t._getTransformedBySplitOperation(e);
                const n = [new tm(o.start, e.splitPosition), t];
                return by(n, i)
            }
            if (t.targetPosition.isEqual(e.splitPosition) && n.abRelation == "insertAtSource") {
                i = e.moveTargetPosition
            }
            if (t.targetPosition.isEqual(e.insertionPosition) && n.abRelation == "insertBetween") {
                i = t.targetPosition
            }
            const r = o._getTransformedBySplitOperation(e);
            const s = [r];
            if (e.graveyardPosition) {
                const i = o.start.isEqual(e.graveyardPosition) || o.containsPosition(e.graveyardPosition);
                if (t.howMany > 1 && i && !n.aWasUndone) {
                    s.push(tm._createFromPositionAndShift(e.insertionPosition, 1))
                }
            }
            return by(s, i)
        }));
        sy(Cf, Df, ((t, e, n) => {
            const i = tm._createFromPositionAndShift(t.sourcePosition, t.howMany);
            if (e.deletionPosition.hasSameParentAs(t.sourcePosition) && i.containsPosition(e.sourcePosition)) {
                if (t.type == "remove" && !n.forceWeakRemove) {
                    if (!n.aWasUndone) {
                        const n = [];
                        let i = e.graveyardPosition.clone();
                        let o = e.targetPosition._getTransformedByMergeOperation(e);
                        if (t.howMany > 1) {
                            n.push(new Cf(t.sourcePosition, t.howMany - 1, t.targetPosition, 0));
                            i = i._getTransformedByMove(t.sourcePosition, t.targetPosition, t.howMany - 1);
                            o = o._getTransformedByMove(t.sourcePosition, t.targetPosition, t.howMany - 1)
                        }
                        const r = e.deletionPosition._getCombined(t.sourcePosition, t.targetPosition);
                        const s = new Cf(i, 1, r, 0);
                        const a = s.getMovedRangeStart().path.slice();
                        a.push(0);
                        const c = new Qh(s.targetPosition.root, a);
                        o = o._getTransformedByMove(i, r, 1);
                        const l = new Cf(o, e.howMany, c, 0);
                        n.push(s);
                        n.push(l);
                        return n
                    }
                } else {
                    if (t.howMany == 1) {
                        if (!n.bWasUndone) {
                            return [new Jf(0)]
                        } else {
                            t.sourcePosition = e.graveyardPosition.clone();
                            t.targetPosition = t.targetPosition._getTransformedByMergeOperation(e);
                            return [t]
                        }
                    }
                }
            }
            const o = tm._createFromPositionAndShift(t.sourcePosition, t.howMany);
            const r = o._getTransformedByMergeOperation(e);
            t.sourcePosition = r.start;
            t.howMany = r.end.offset - r.start.offset;
            t.targetPosition = t.targetPosition._getTransformedByMergeOperation(e);
            return [t]
        }));
        sy(xf, vf, ((t, e) => {
            t.position = t.position._getTransformedByInsertOperation(e);
            return [t]
        }));
        sy(xf, Df, ((t, e) => {
            if (t.position.isEqual(e.deletionPosition)) {
                t.position = e.graveyardPosition.clone();
                t.position.stickiness = "toNext";
                return [t]
            }
            t.position = t.position._getTransformedByMergeOperation(e);
            return [t]
        }));
        sy(xf, Cf, ((t, e) => {
            t.position = t.position._getTransformedByMoveOperation(e);
            return [t]
        }));
        sy(xf, xf, ((t, e, n) => {
            if (t.position.isEqual(e.position)) {
                if (n.aIsStrong) {
                    t.oldName = e.newName
                } else {
                    return [new Jf(0)]
                }
            }
            return [t]
        }));
        sy(xf, Tf, ((t, e) => {
            const n = t.position.path;
            const i = e.splitPosition.getParentPath();
            if (Ns(n, i) == "same" && !e.graveyardPosition) {
                const e = new xf(t.position.getShiftedBy(1), t.oldName, t.newName, 0);
                return [t, e]
            }
            t.position = t.position._getTransformedBySplitOperation(e);
            return [t]
        }));
        sy(Ef, Ef, ((t, e, n) => {
            if (t.root === e.root && t.key === e.key) {
                if (!n.aIsStrong || t.newValue === e.newValue) {
                    return [new Jf(0)]
                } else {
                    t.oldValue = e.newValue
                }
            }
            return [t]
        }));
        sy(Tf, vf, ((t, e) => {
            if (t.splitPosition.hasSameParentAs(e.position) && t.splitPosition.offset < e.position.offset) {
                t.howMany += e.howMany
            }
            t.splitPosition = t.splitPosition._getTransformedByInsertOperation(e);
            t.insertionPosition = Tf.getInsertionPosition(t.splitPosition);
            return [t]
        }));
        sy(Tf, Df, ((t, e, n) => {
            if (!t.graveyardPosition && !n.bWasUndone && t.splitPosition.hasSameParentAs(e.sourcePosition)) {
                const n = e.graveyardPosition.path.slice();
                n.push(0);
                const i = new Qh(e.graveyardPosition.root, n);
                const o = Tf.getInsertionPosition(new Qh(e.graveyardPosition.root, n));
                const r = new Tf(i, 0, null, 0);
                r.insertionPosition = o;
                t.splitPosition = t.splitPosition._getTransformedByMergeOperation(e);
                t.insertionPosition = Tf.getInsertionPosition(t.splitPosition);
                t.graveyardPosition = r.insertionPosition.clone();
                t.graveyardPosition.stickiness = "toNext";
                return [r, t]
            }
            if (t.splitPosition.hasSameParentAs(e.deletionPosition) && !t.splitPosition.isAfter(e.deletionPosition)) {
                t.howMany--
            }
            if (t.splitPosition.hasSameParentAs(e.targetPosition)) {
                t.howMany += e.howMany
            }
            t.splitPosition = t.splitPosition._getTransformedByMergeOperation(e);
            t.insertionPosition = Tf.getInsertionPosition(t.splitPosition);
            if (t.graveyardPosition) {
                t.graveyardPosition = t.graveyardPosition._getTransformedByMergeOperation(e)
            }
            return [t]
        }));
        sy(Tf, Cf, ((t, e, n) => {
            const i = tm._createFromPositionAndShift(e.sourcePosition, e.howMany);
            if (t.graveyardPosition) {
                const o = i.start.isEqual(t.graveyardPosition) || i.containsPosition(t.graveyardPosition);
                if (!n.bWasUndone && o) {
                    const n = t.splitPosition._getTransformedByMoveOperation(e);
                    const i = t.graveyardPosition._getTransformedByMoveOperation(e);
                    const o = i.path.slice();
                    o.push(0);
                    const r = new Qh(i.root, o);
                    const s = new Cf(n, t.howMany, r, 0);
                    return [s]
                }
                t.graveyardPosition = t.graveyardPosition._getTransformedByMoveOperation(e)
            }
            if (t.splitPosition.hasSameParentAs(e.sourcePosition) && i.containsPosition(t.splitPosition)) {
                const n = e.howMany - (t.splitPosition.offset - e.sourcePosition.offset);
                t.howMany -= n;
                if (t.splitPosition.hasSameParentAs(e.targetPosition) && t.splitPosition.offset < e.targetPosition.offset) {
                    t.howMany += e.howMany
                }
                t.splitPosition = e.sourcePosition.clone();
                t.insertionPosition = Tf.getInsertionPosition(t.splitPosition);
                return [t]
            }
            const o = t.splitPosition.isEqual(e.targetPosition);
            if (o && (n.baRelation == "insertAtSource" || n.abRelation == "splitBefore")) {
                t.howMany += e.howMany;
                t.splitPosition = t.splitPosition._getTransformedByDeletion(e.sourcePosition, e.howMany);
                t.insertionPosition = Tf.getInsertionPosition(t.splitPosition);
                return [t]
            }
            if (!e.sourcePosition.isEqual(e.targetPosition)) {
                if (t.splitPosition.hasSameParentAs(e.sourcePosition) && t.splitPosition.offset <= e.sourcePosition.offset) {
                    t.howMany -= e.howMany
                }
                if (t.splitPosition.hasSameParentAs(e.targetPosition) && t.splitPosition.offset < e.targetPosition.offset) {
                    t.howMany += e.howMany
                }
            }
            t.splitPosition.stickiness = "toNone";
            t.splitPosition = t.splitPosition._getTransformedByMoveOperation(e);
            t.splitPosition.stickiness = "toNext";
            if (t.graveyardPosition) {
                t.insertionPosition = t.insertionPosition._getTransformedByMoveOperation(e)
            } else {
                t.insertionPosition = Tf.getInsertionPosition(t.splitPosition)
            }
            return [t]
        }));
        sy(Tf, Tf, ((t, e, n) => {
            if (t.splitPosition.isEqual(e.splitPosition)) {
                if (!t.graveyardPosition && !e.graveyardPosition) {
                    return [new Jf(0)]
                }
                if (t.graveyardPosition && e.graveyardPosition && t.graveyardPosition.isEqual(e.graveyardPosition)) {
                    return [new Jf(0)]
                }
                if (n.abRelation == "splitBefore") {
                    t.howMany = 0;
                    t.graveyardPosition = t.graveyardPosition._getTransformedBySplitOperation(e);
                    return [t]
                }
            }
            if (t.graveyardPosition && e.graveyardPosition && t.graveyardPosition.isEqual(e.graveyardPosition)) {
                const i = t.splitPosition.root.rootName == "$graveyard";
                const o = e.splitPosition.root.rootName == "$graveyard";
                const r = i && !o;
                const s = o && !i;
                const a = s || !r && n.aIsStrong;
                if (a) {
                    const n = [];
                    if (e.howMany) {
                        n.push(new Cf(e.moveTargetPosition, e.howMany, e.splitPosition, 0))
                    }
                    if (t.howMany) {
                        n.push(new Cf(t.splitPosition, t.howMany, t.moveTargetPosition, 0))
                    }
                    return n
                } else {
                    return [new Jf(0)]
                }
            }
            if (t.graveyardPosition) {
                t.graveyardPosition = t.graveyardPosition._getTransformedBySplitOperation(e)
            }
            if (t.splitPosition.isEqual(e.insertionPosition) && n.abRelation == "splitBefore") {
                t.howMany++;
                return [t]
            }
            if (e.splitPosition.isEqual(t.insertionPosition) && n.baRelation == "splitBefore") {
                const n = e.insertionPosition.path.slice();
                n.push(0);
                const i = new Qh(e.insertionPosition.root, n);
                const o = new Cf(t.insertionPosition, 1, i, 0);
                return [t, o]
            }
            if (t.splitPosition.hasSameParentAs(e.splitPosition) && t.splitPosition.offset < e.splitPosition.offset) {
                t.howMany -= e.howMany
            }
            t.splitPosition = t.splitPosition._getTransformedBySplitOperation(e);
            t.insertionPosition = Tf.getInsertionPosition(t.splitPosition);
            return [t]
        }));

        function py(t, e) {
            return t.targetPosition._getTransformedByDeletion(e.sourcePosition, e.howMany) === null
        }

        function by(t, e) {
            const n = [];
            for (let i = 0; i < t.length; i++) {
                const o = t[i];
                const r = new Cf(o.start, o.end.offset - o.start.offset, e, 0);
                n.push(r);
                for (let e = i + 1; e < t.length; e++) {
                    t[e] = t[e]._getTransformedByMove(r.sourcePosition, r.targetPosition, r.howMany)[0]
                }
                e = e._getTransformedByMove(r.sourcePosition, r.targetPosition, r.howMany)
            }
            return n
        }

        class ky extends nA {
            constructor(t) {
                super(t);
                this._stack = [];
                this._createdBatches = new WeakSet;
                this.refresh();
                this.listenTo(t.data, "set", (() => this.clearStack()))
            }

            refresh() {
                this.isEnabled = this._stack.length > 0
            }

            addBatch(t) {
                const e = this.editor.model.document.selection;
                const n = {ranges: e.hasOwnRange ? Array.from(e.getRanges()) : [], isBackward: e.isBackward};
                this._stack.push({batch: t, selection: n});
                this.refresh()
            }

            clearStack() {
                this._stack = [];
                this.refresh()
            }

            _restoreSelection(t, e, n) {
                const i = this.editor.model;
                const o = i.document;
                const r = [];
                const s = t.map((t => t.getTransformedByOperations(n)));
                const a = s.flat();
                for (const t of s) {
                    const e = t.filter((t => !Ay(t, a)));
                    wy(e);
                    const n = e.find((t => t.root != o.graveyard));
                    if (n) {
                        r.push(n)
                    }
                }
                if (r.length) {
                    i.change((t => {
                        t.setSelection(r, {backward: e})
                    }))
                }
            }

            _undo(t, e) {
                const n = this.editor.model;
                const i = n.document;
                this._createdBatches.add(e);
                const o = t.operations.slice().filter((t => t.isDocumentOperation));
                o.reverse();
                for (const t of o) {
                    const o = t.baseVersion + 1;
                    const r = Array.from(i.history.getOperations(o));
                    const s = dy([t.getReversed()], r, {
                        useRelations: true,
                        document: this.editor.model.document,
                        padWithNoOps: false,
                        forceWeakRemove: true
                    });
                    const a = s.operationsA;
                    for (const o of a) {
                        e.addOperation(o);
                        n.applyOperation(o);
                        i.history.setOperationAsUndone(t, o)
                    }
                }
            }
        }

        function wy(t) {
            t.sort(((t, e) => t.start.isBefore(e.start) ? -1 : 1));
            for (let e = 1; e < t.length; e++) {
                const n = t[e - 1];
                const i = n.getJoined(t[e], true);
                if (i) {
                    e--;
                    t.splice(e, 2, i)
                }
            }
        }

        function Ay(t, e) {
            return e.some((e => e !== t && e.containsRange(t, true)))
        }

        class _y extends ky {
            execute(t = null) {
                const e = t ? this._stack.findIndex((e => e.batch == t)) : this._stack.length - 1;
                const n = this._stack.splice(e, 1)[0];
                const i = this.editor.model.createBatch("transparent");
                this.editor.model.enqueueChange(i, (() => {
                    this._undo(n.batch, i);
                    const t = this.editor.model.document.history.getOperations(n.batch.baseVersion);
                    this._restoreSelection(n.selection.ranges, n.selection.isBackward, t);
                    this.fire("revert", n.batch, i)
                }));
                this.refresh()
            }
        }

        class Cy extends ky {
            execute() {
                const t = this._stack.pop();
                const e = this.editor.model.createBatch("transparent");
                this.editor.model.enqueueChange(e, (() => {
                    const n = t.batch.operations[t.batch.operations.length - 1];
                    const i = n.baseVersion + 1;
                    const o = this.editor.model.document.history.getOperations(i);
                    this._restoreSelection(t.selection.ranges, t.selection.isBackward, o);
                    this._undo(t.batch, e)
                }));
                this.refresh()
            }
        }

        class vy extends tA {
            static get pluginName() {
                return "UndoEditing"
            }

            constructor(t) {
                super(t);
                this._batchRegistry = new WeakSet
            }

            init() {
                const t = this.editor;
                this._undoCommand = new _y(t);
                this._redoCommand = new Cy(t);
                t.commands.add("undo", this._undoCommand);
                t.commands.add("redo", this._redoCommand);
                this.listenTo(t.model, "applyOperation", ((t, e) => {
                    const n = e[0];
                    if (!n.isDocumentOperation) {
                        return
                    }
                    const i = n.batch;
                    const o = this._redoCommand._createdBatches.has(i);
                    const r = this._undoCommand._createdBatches.has(i);
                    const s = this._batchRegistry.has(i);
                    if (s || i.type == "transparent" && !o && !r) {
                        return
                    } else {
                        if (o) {
                            this._undoCommand.addBatch(i)
                        } else if (!r) {
                            this._undoCommand.addBatch(i);
                            this._redoCommand.clearStack()
                        }
                    }
                    this._batchRegistry.add(i)
                }), {priority: "highest"});
                this.listenTo(this._undoCommand, "revert", ((t, e, n) => {
                    this._redoCommand.addBatch(n)
                }));
                t.keystrokes.set("CTRL+Z", "undo");
                t.keystrokes.set("CTRL+Y", "redo");
                t.keystrokes.set("CTRL+SHIFT+Z", "redo")
            }
        }

        var yy = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5.042 9.367l2.189 1.837a.75.75 0 0 1-.965 1.149l-3.788-3.18a.747.747 0 0 1-.21-.284.75.75 0 0 1 .17-.945L6.23 4.762a.75.75 0 1 1 .964 1.15L4.863 7.866h8.917A.75.75 0 0 1 14 7.9a4 4 0 1 1-1.477 7.718l.344-1.489a2.5 2.5 0 1 0 1.094-4.73l.008-.032H5.042z"/></svg>';
        var xy = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M14.958 9.367l-2.189 1.837a.75.75 0 0 0 .965 1.149l3.788-3.18a.747.747 0 0 0 .21-.284.75.75 0 0 0-.17-.945L13.77 4.762a.75.75 0 1 0-.964 1.15l2.331 1.955H6.22A.75.75 0 0 0 6 7.9a4 4 0 1 0 1.477 7.718l-.344-1.489A2.5 2.5 0 1 1 6.039 9.4l-.008-.032h8.927z"/></svg>';

        class Ey extends tA {
            init() {
                const t = this.editor;
                const e = t.locale;
                const n = t.t;
                const i = e.uiLanguageDirection == "ltr" ? yy : xy;
                const o = e.uiLanguageDirection == "ltr" ? xy : yy;
                this._addButton("undo", n("Undo"), "CTRL+Z", i);
                this._addButton("redo", n("Redo"), "CTRL+Y", o)
            }

            _addButton(t, e, n, i) {
                const o = this.editor;
                o.ui.componentFactory.add(t, (r => {
                    const s = o.commands.get(t);
                    const a = new sw(r);
                    a.set({label: e, icon: i, keystroke: n, tooltip: true});
                    a.bind("isEnabled").to(s, "isEnabled");
                    this.listenTo(a, "execute", (() => {
                        o.execute(t);
                        o.editing.view.focus()
                    }));
                    return a
                }))
            }
        }

        class Dy extends tA {
            static get requires() {
                return [vy, Ey]
            }

            static get pluginName() {
                return "Undo"
            }
        }

        class Ty extends tA {
            static get requires() {
                return [Dv, Bv, Rv, jC, oy, Dy]
            }

            static get pluginName() {
                return "Essentials"
            }
        }

        class My extends nA {
            constructor(t, e) {
                super(t);
                this.attributeKey = e
            }

            refresh() {
                const t = this.editor.model;
                const e = t.document;
                this.value = e.selection.getAttribute(this.attributeKey);
                this.isEnabled = t.schema.checkAttributeInSelection(e.selection, this.attributeKey)
            }

            execute(t = {}) {
                const e = this.editor.model;
                const n = e.document;
                const i = n.selection;
                const o = t.value;
                e.change((t => {
                    if (i.isCollapsed) {
                        if (o) {
                            t.setSelectionAttribute(this.attributeKey, o)
                        } else {
                            t.removeSelectionAttribute(this.attributeKey)
                        }
                    } else {
                        const n = e.schema.getValidRanges(i.getRanges(), this.attributeKey);
                        for (const e of n) {
                            if (o) {
                                t.setAttribute(this.attributeKey, o, e)
                            } else {
                                t.removeAttribute(this.attributeKey, e)
                            }
                        }
                    }
                }))
            }
        }

        var Sy = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path class="ck-icon__fill" d="M16.935 5.328a2 2 0 0 1 0 2.829l-7.778 7.778a2 2 0 0 1-2.829 0L3.5 13.107a1.999 1.999 0 1 1 2.828-2.829l.707.707a1 1 0 0 0 1.414 0l5.658-5.657a2 2 0 0 1 2.828 0z"/><path d="M14.814 6.035L8.448 12.4a1 1 0 0 1-1.414 0l-1.413-1.415A1 1 0 1 0 4.207 12.4l2.829 2.829a1 1 0 0 0 1.414 0l7.778-7.778a1 1 0 1 0-1.414-1.415z"/></svg>';

        class Iy extends sw {
            constructor(t) {
                super(t);
                const e = this.bindTemplate;
                this.set("color");
                this.set("hasBorder");
                this.icon = Sy;
                this.extendTemplate({
                    attributes: {
                        style: {backgroundColor: e.to("color")},
                        class: ["ck", "ck-color-grid__tile", e.if("hasBorder", "ck-color-table__color-tile_bordered")]
                    }
                })
            }

            render() {
                super.render();
                this.iconView.fillColor = "hsl(0, 0%, 100%)"
            }
        }

        var By = n(31);
        var Ly = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        Ly.insert = "head";
        Ly.singleton = true;
        var zy = ob()(By["a"], Ly);
        var Ny = By["a"].locals || {};

        class Py extends Zb {
            constructor(t, e) {
                super(t);
                const n = e && e.colorDefinitions || [];
                const i = {};
                if (e && e.columns) {
                    i.gridTemplateColumns = `repeat( ${e.columns}, 1fr)`
                }
                this.set("selectedColor");
                this.items = this.createCollection();
                this.focusTracker = new Zp;
                this.keystrokes = new Fp;
                this._focusCycler = new xk({
                    focusables: this.items,
                    focusTracker: this.focusTracker,
                    keystrokeHandler: this.keystrokes,
                    actions: {focusPrevious: "arrowleft", focusNext: "arrowright"}
                });
                this.items.on("add", ((t, e) => {
                    e.isOn = e.color === this.selectedColor
                }));
                n.forEach((t => {
                    const e = new Iy;
                    e.set({color: t.color, label: t.label, tooltip: true, hasBorder: t.options.hasBorder});
                    e.on("execute", (() => {
                        this.fire("execute", {value: t.color, hasBorder: t.options.hasBorder, label: t.label})
                    }));
                    this.items.add(e)
                }));
                this.setTemplate({
                    tag: "div",
                    children: this.items,
                    attributes: {class: ["ck", "ck-color-grid"], style: i}
                });
                this.on("change:selectedColor", ((t, e, n) => {
                    for (const t of this.items) {
                        t.isOn = t.color === n
                    }
                }))
            }

            focus() {
                if (this.items.length) {
                    this.items.first.focus()
                }
            }

            focusLast() {
                if (this.items.length) {
                    this.items.last.focus()
                }
            }

            render() {
                super.render();
                for (const t of this.items) {
                    this.focusTracker.add(t.element)
                }
                this.items.on("add", ((t, e) => {
                    this.focusTracker.add(e.element)
                }));
                this.items.on("remove", ((t, e) => {
                    this.focusTracker.remove(e.element)
                }));
                this.keystrokes.listenTo(this.element)
            }
        }

        class Oy extends vs {
            constructor(t) {
                super(t);
                this.set("isEmpty", true);
                this.on("change", (() => {
                    this.set("isEmpty", this.length === 0)
                }))
            }

            add(t, e) {
                if (this.find((e => e.color === t.color))) {
                    return
                }
                super.add(t, e)
            }

            hasColor(t) {
                return !!this.find((e => e.color === t))
            }
        }

        Cs(Oy, Qc);
        var jy = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.636 9.531l-2.758 3.94a.5.5 0 0 0 .122.696l3.224 2.284h1.314l2.636-3.736L8.636 9.53zm.288 8.451L5.14 15.396a2 2 0 0 1-.491-2.786l6.673-9.53a2 2 0 0 1 2.785-.49l3.742 2.62a2 2 0 0 1 .491 2.785l-7.269 10.053-2.147-.066z"/><path d="M4 18h5.523v-1H4zm-2 0h1v-1H2z"/></svg>';
        var Ry = n(32);
        var Fy = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        Fy.insert = "head";
        Fy.singleton = true;
        var Vy = ob()(Ry["a"], Fy);
        var Hy = Ry["a"].locals || {};

        class Uy extends Zb {
            constructor(t, {colors: e, columns: n, removeButtonLabel: i, documentColorsLabel: o, documentColorsCount: r}) {
                super(t);
                this.items = this.createCollection();
                this.colorDefinitions = e;
                this.focusTracker = new Zp;
                this.keystrokes = new Fp;
                this.set("selectedColor");
                this.removeButtonLabel = i;
                this.columns = n;
                this.documentColors = new Oy;
                this.documentColorsCount = r;
                this._focusCycler = new xk({
                    focusables: this.items,
                    focusTracker: this.focusTracker,
                    keystrokeHandler: this.keystrokes,
                    actions: {focusPrevious: "arrowup", focusNext: "arrowdown"}
                });
                this._documentColorsLabel = o;
                this.setTemplate({tag: "div", attributes: {class: ["ck", "ck-color-table"]}, children: this.items});
                this.items.add(this._removeColorButton())
            }

            updateDocumentColors(t, e) {
                const n = t.document;
                const i = this.documentColorsCount;
                this.documentColors.clear();
                for (const o of n.getRootNames()) {
                    const r = n.getRoot(o);
                    const s = t.createRangeIn(r);
                    for (const t of s.getItems()) {
                        if (t.is("$textProxy") && t.hasAttribute(e)) {
                            this._addColorToDocumentColors(t.getAttribute(e));
                            if (this.documentColors.length >= i) {
                                return
                            }
                        }
                    }
                }
            }

            updateSelectedColors() {
                const t = this.documentColorsGrid;
                const e = this.staticColorsGrid;
                const n = this.selectedColor;
                e.selectedColor = n;
                if (t) {
                    t.selectedColor = n
                }
            }

            render() {
                super.render();
                for (const t of this.items) {
                    this.focusTracker.add(t.element)
                }
                this.keystrokes.listenTo(this.element)
            }

            appendGrids() {
                if (this.staticColorsGrid) {
                    return
                }
                this.staticColorsGrid = this._createStaticColorsGrid();
                this.items.add(this.staticColorsGrid);
                if (this.documentColorsCount) {
                    const t = vb.bind(this.documentColors, this.documentColors);
                    const e = new gk(this.locale);
                    e.text = this._documentColorsLabel;
                    e.extendTemplate({attributes: {class: ["ck", "ck-color-grid__label", t.if("isEmpty", "ck-hidden")]}});
                    this.items.add(e);
                    this.documentColorsGrid = this._createDocumentColorsGrid();
                    this.items.add(this.documentColorsGrid)
                }
            }

            focus() {
                this._focusCycler.focusFirst()
            }

            focusLast() {
                this._focusCycler.focusLast()
            }

            _removeColorButton() {
                const t = new sw;
                t.set({withText: true, icon: jy, tooltip: true, label: this.removeButtonLabel});
                t.class = "ck-color-table__remove-color";
                t.on("execute", (() => {
                    this.fire("execute", {value: null})
                }));
                return t
            }

            _createStaticColorsGrid() {
                const t = new Py(this.locale, {colorDefinitions: this.colorDefinitions, columns: this.columns});
                t.delegate("execute").to(this);
                return t
            }

            _createDocumentColorsGrid() {
                const t = vb.bind(this.documentColors, this.documentColors);
                const e = new Py(this.locale, {columns: this.columns});
                e.delegate("execute").to(this);
                e.extendTemplate({attributes: {class: t.if("isEmpty", "ck-hidden")}});
                e.items.bindTo(this.documentColors).using((t => {
                    const e = new Iy;
                    e.set({color: t.color, hasBorder: t.options && t.options.hasBorder});
                    if (t.label) {
                        e.set({label: t.label, tooltip: true})
                    }
                    e.on("execute", (() => {
                        this.fire("execute", {value: t.color})
                    }));
                    return e
                }));
                this.documentColors.on("change:isEmpty", ((t, n, i) => {
                    if (i) {
                        e.selectedColor = null
                    }
                }));
                return e
            }

            _addColorToDocumentColors(t) {
                const e = this.colorDefinitions.find((e => e.color === t));
                if (!e) {
                    this.documentColors.add({color: t, label: t, options: {hasBorder: false}})
                } else {
                    this.documentColors.add(Object.assign({}, e))
                }
            }
        }

        const Wy = "fontSize";
        const qy = "fontFamily";
        const Ky = "fontColor";
        const Gy = "fontBackgroundColor";

        function $y(t, e) {
            const n = {model: {key: t, values: []}, view: {}, upcastAlso: {}};
            for (const t of e) {
                n.model.values.push(t.model);
                n.view[t.model] = t.view;
                if (t.upcastAlso) {
                    n.upcastAlso[t.model] = t.upcastAlso
                }
            }
            return n
        }

        function Yy(t) {
            return e => Xy(e.getStyle(t))
        }

        function Qy(t) {
            return (e, {writer: n}) => n.createAttributeElement("span", {style: `${t}:${e}`}, {priority: 7})
        }

        function Jy({dropdownView: t, colors: e, columns: n, removeButtonLabel: i, documentColorsLabel: o, documentColorsCount: r}) {
            const s = t.locale;
            const a = new Uy(s, {
                colors: e,
                columns: n,
                removeButtonLabel: i,
                documentColorsLabel: o,
                documentColorsCount: r
            });
            t.colorTableView = a;
            t.panelView.children.add(a);
            a.delegate("execute").to(t, "execute");
            return a
        }

        function Xy(t) {
            return t.replace(/\s/g, "")
        }

        class Zy extends My {
            constructor(t) {
                super(t, Gy)
            }
        }

        const tx = /^#([0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/i;
        const ex = /^rgb\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}[0-9]{1,3}[ %]?\)$/i;
        const nx = /^rgba\([ ]?([0-9]{1,3}[ %]?,[ ]?){3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i;
        const ix = /^hsl\([ ]?([0-9]{1,3}[ %]?[,]?[ ]*){3}(1|[0-9]+%|[0]?\.?[0-9]+)?\)$/i;
        const ox = /^hsla\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i;
        const rx = new Set(["black", "silver", "gray", "white", "maroon", "red", "purple", "fuchsia", "green", "lime", "olive", "yellow", "navy", "blue", "teal", "aqua", "orange", "aliceblue", "antiquewhite", "aquamarine", "azure", "beige", "bisque", "blanchedalmond", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "gainsboro", "ghostwhite", "gold", "goldenrod", "greenyellow", "grey", "honeydew", "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "limegreen", "linen", "magenta", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "oldlace", "olivedrab", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "thistle", "tomato", "turquoise", "violet", "wheat", "whitesmoke", "yellowgreen", "rebeccapurple", "currentcolor", "transparent"]);

        function sx(t) {
            if (t.startsWith("#")) {
                return tx.test(t)
            }
            if (t.startsWith("rgb")) {
                return ex.test(t) || nx.test(t)
            }
            if (t.startsWith("hsl")) {
                return ix.test(t) || ox.test(t)
            }
            return rx.has(t.toLowerCase())
        }

        const ax = ["none", "hidden", "dotted", "dashed", "solid", "double", "groove", "ridge", "inset", "outset"];

        function cx(t) {
            return ax.includes(t)
        }

        const lx = /^([+-]?[0-9]*[.]?[0-9]+(px|cm|mm|in|pc|pt|ch|em|ex|rem|vh|vw|vmin|vmax)|0)$/;

        function dx(t) {
            return lx.test(t)
        }

        const ux = /^[+-]?[0-9]*[.]?[0-9]+%$/;

        function hx(t) {
            return ux.test(t)
        }

        const mx = ["repeat-x", "repeat-y", "repeat", "space", "round", "no-repeat"];

        function gx(t) {
            return mx.includes(t)
        }

        const fx = ["center", "top", "bottom", "left", "right"];

        function px(t) {
            return fx.includes(t)
        }

        const bx = ["fixed", "scroll", "local"];

        function kx(t) {
            return bx.includes(t)
        }

        const wx = /^url\(/;

        function Ax(t) {
            return wx.test(t)
        }

        function _x(t = "") {
            if (t === "") {
                return {top: undefined, right: undefined, bottom: undefined, left: undefined}
            }
            const e = xx(t);
            const n = e[0];
            const i = e[2] || n;
            const o = e[1] || n;
            const r = e[3] || o;
            return {top: n, bottom: i, right: o, left: r}
        }

        function Cx(t) {
            return e => {
                const {top: n, right: i, bottom: o, left: r} = e;
                const s = [];
                if (![n, i, r, o].every((t => !!t))) {
                    if (n) {
                        s.push([t + "-top", n])
                    }
                    if (i) {
                        s.push([t + "-right", i])
                    }
                    if (o) {
                        s.push([t + "-bottom", o])
                    }
                    if (r) {
                        s.push([t + "-left", r])
                    }
                } else {
                    s.push([t, vx(e)])
                }
                return s
            }
        }

        function vx({top: t, right: e, bottom: n, left: i}) {
            const o = [];
            if (i !== e) {
                o.push(t, e, n, i)
            } else if (n !== t) {
                o.push(t, e, n)
            } else if (e !== t) {
                o.push(t, e)
            } else {
                o.push(t)
            }
            return o.join(" ")
        }

        function yx(t) {
            return e => ({path: t, value: _x(e)})
        }

        function xx(t) {
            return t.replace(/, /g, ",").split(" ").map((t => t.replace(/,/g, ", ")))
        }

        function Ex(t) {
            t.setNormalizer("background", Dx);
            t.setNormalizer("background-color", (t => ({path: "background.color", value: t})));
            t.setReducer("background", (t => {
                const e = [];
                e.push(["background-color", t.color]);
                return e
            }))
        }

        function Dx(t) {
            const e = {};
            const n = xx(t);
            for (const t of n) {
                if (gx(t)) {
                    e.repeat = e.repeat || [];
                    e.repeat.push(t)
                } else if (px(t)) {
                    e.position = e.position || [];
                    e.position.push(t)
                } else if (kx(t)) {
                    e.attachment = t
                } else if (sx(t)) {
                    e.color = t
                } else if (Ax(t)) {
                    e.image = t
                }
            }
            return {path: "background", value: e}
        }

        class Tx extends tA {
            static get pluginName() {
                return "FontBackgroundColorEditing"
            }

            constructor(t) {
                super(t);
                t.config.define(Gy, {
                    colors: [{color: "hsl(0, 0%, 0%)", label: "Black"}, {
                        color: "hsl(0, 0%, 30%)",
                        label: "Dim grey"
                    }, {color: "hsl(0, 0%, 60%)", label: "Grey"}, {
                        color: "hsl(0, 0%, 90%)",
                        label: "Light grey"
                    }, {color: "hsl(0, 0%, 100%)", label: "White", hasBorder: true}, {
                        color: "hsl(0, 75%, 60%)",
                        label: "Red"
                    }, {color: "hsl(30, 75%, 60%)", label: "Orange"}, {
                        color: "hsl(60, 75%, 60%)",
                        label: "Yellow"
                    }, {color: "hsl(90, 75%, 60%)", label: "Light green"}, {
                        color: "hsl(120, 75%, 60%)",
                        label: "Green"
                    }, {color: "hsl(150, 75%, 60%)", label: "Aquamarine"}, {
                        color: "hsl(180, 75%, 60%)",
                        label: "Turquoise"
                    }, {color: "hsl(210, 75%, 60%)", label: "Light blue"}, {
                        color: "hsl(240, 75%, 60%)",
                        label: "Blue"
                    }, {color: "hsl(270, 75%, 60%)", label: "Purple"}], columns: 5
                });
                t.data.addStyleProcessorRules(Ex);
                t.conversion.for("upcast").elementToAttribute({
                    view: {
                        name: "span",
                        styles: {"background-color": /[\s\S]+/}
                    }, model: {key: Gy, value: Yy("background-color")}
                });
                t.conversion.for("downcast").attributeToElement({model: Gy, view: Qy("background-color")});
                t.commands.add(Gy, new Zy(t));
                t.model.schema.extend("$text", {allowAttributes: Gy});
                t.model.schema.setAttributeProperties(Gy, {isFormatting: true, copyOnEnter: true})
            }
        }

        function Mx(t, e) {
            const n = t.t;
            const i = {
                Black: n("Black"),
                "Dim grey": n("Dim grey"),
                Grey: n("Grey"),
                "Light grey": n("Light grey"),
                White: n("White"),
                Red: n("Red"),
                Orange: n("Orange"),
                Yellow: n("Yellow"),
                "Light green": n("Light green"),
                Green: n("Green"),
                Aquamarine: n("Aquamarine"),
                Turquoise: n("Turquoise"),
                "Light blue": n("Light blue"),
                Blue: n("Blue"),
                Purple: n("Purple")
            };
            return e.map((t => {
                const e = i[t.label];
                if (e && e != t.label) {
                    t.label = e
                }
                return t
            }))
        }

        function Sx(t) {
            return t.map(Ix).filter((t => !!t))
        }

        function Ix(t) {
            if (typeof t === "string") {
                return {model: t, label: t, hasBorder: false, view: {name: "span", styles: {color: t}}}
            } else {
                return {
                    model: t.color,
                    label: t.label || t.color,
                    hasBorder: t.hasBorder === undefined ? false : t.hasBorder,
                    view: {name: "span", styles: {color: `${t.color}`}}
                }
            }
        }

        class Bx extends tA {
            constructor(t, {commandName: e, icon: n, componentName: i, dropdownLabel: o}) {
                super(t);
                this.commandName = e;
                this.componentName = i;
                this.icon = n;
                this.dropdownLabel = o;
                this.columns = t.config.get(`${this.componentName}.columns`);
                this.colorTableView = undefined
            }

            init() {
                const t = this.editor;
                const e = t.locale;
                const n = e.t;
                const i = t.commands.get(this.commandName);
                const o = Sx(t.config.get(this.componentName).colors);
                const r = Mx(e, o);
                const s = t.config.get(`${this.componentName}.documentColors`);
                t.ui.componentFactory.add(this.componentName, (e => {
                    const o = Sw(e);
                    this.colorTableView = Jy({
                        dropdownView: o,
                        colors: r.map((t => ({label: t.label, color: t.model, options: {hasBorder: t.hasBorder}}))),
                        columns: this.columns,
                        removeButtonLabel: n("Remove color"),
                        documentColorsLabel: s !== 0 ? n("Document colors") : undefined,
                        documentColorsCount: s === undefined ? this.columns : s
                    });
                    this.colorTableView.bind("selectedColor").to(i, "value");
                    o.buttonView.set({label: this.dropdownLabel, icon: this.icon, tooltip: true});
                    o.extendTemplate({attributes: {class: "ck-color-ui-dropdown"}});
                    o.bind("isEnabled").to(i);
                    o.on("execute", ((e, n) => {
                        t.execute(this.commandName, n);
                        t.editing.view.focus()
                    }));
                    o.on("change:isOpen", ((e, n, i) => {
                        o.colorTableView.appendGrids();
                        if (i) {
                            if (s !== 0) {
                                this.colorTableView.updateDocumentColors(t.model, this.componentName)
                            }
                            this.colorTableView.updateSelectedColors()
                        }
                    }));
                    return o
                }))
            }
        }

        var Lx = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M4 2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2zm8.38 9.262H7.62L10 5.506l2.38 5.756zm.532 1.285L14.34 16h1.426L10.804 4H9.196L4.234 16H5.66l1.428-3.453h5.824z"/></svg>';

        class zx extends Bx {
            constructor(t) {
                const e = t.locale.t;
                super(t, {commandName: Gy, componentName: Gy, icon: Lx, dropdownLabel: e("Font Background Color")})
            }

            static get pluginName() {
                return "FontBackgroundColorUI"
            }
        }

        class Nx extends tA {
            static get requires() {
                return [Tx, zx]
            }

            static get pluginName() {
                return "FontBackgroundColor"
            }
        }

        class Px extends My {
            constructor(t) {
                super(t, Ky)
            }
        }

        class Ox extends tA {
            static get pluginName() {
                return "FontColorEditing"
            }

            constructor(t) {
                super(t);
                t.config.define(Ky, {
                    colors: [{color: "hsl(0, 0%, 0%)", label: "Black"}, {
                        color: "hsl(0, 0%, 30%)",
                        label: "Dim grey"
                    }, {color: "hsl(0, 0%, 60%)", label: "Grey"}, {
                        color: "hsl(0, 0%, 90%)",
                        label: "Light grey"
                    }, {color: "hsl(0, 0%, 100%)", label: "White", hasBorder: true}, {
                        color: "hsl(0, 75%, 60%)",
                        label: "Red"
                    }, {color: "hsl(30, 75%, 60%)", label: "Orange"}, {
                        color: "hsl(60, 75%, 60%)",
                        label: "Yellow"
                    }, {color: "hsl(90, 75%, 60%)", label: "Light green"}, {
                        color: "hsl(120, 75%, 60%)",
                        label: "Green"
                    }, {color: "hsl(150, 75%, 60%)", label: "Aquamarine"}, {
                        color: "hsl(180, 75%, 60%)",
                        label: "Turquoise"
                    }, {color: "hsl(210, 75%, 60%)", label: "Light blue"}, {
                        color: "hsl(240, 75%, 60%)",
                        label: "Blue"
                    }, {color: "hsl(270, 75%, 60%)", label: "Purple"}], columns: 5
                });
                t.conversion.for("upcast").elementToAttribute({
                    view: {name: "span", styles: {color: /[\s\S]+/}},
                    model: {key: Ky, value: Yy("color")}
                });
                t.conversion.for("downcast").attributeToElement({model: Ky, view: Qy("color")});
                t.commands.add(Ky, new Px(t));
                t.model.schema.extend("$text", {allowAttributes: Ky});
                t.model.schema.setAttributeProperties(Ky, {isFormatting: true, copyOnEnter: true})
            }
        }

        var jx = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.4 10.3L10 4.5l-2.4 5.8h4.8zm.5 1.2H7.1L5.7 15H4.2l5-12h1.6l5 12h-1.5L13 11.5zm3.1 7H4a1 1 0 0 1 0-2h12a1 1 0 0 1 0 2z"/></svg>';

        class Rx extends Bx {
            constructor(t) {
                const e = t.locale.t;
                super(t, {commandName: Ky, componentName: Ky, icon: jx, dropdownLabel: e("Font Color")})
            }

            static get pluginName() {
                return "FontColorUI"
            }
        }

        class Fx extends tA {
            static get requires() {
                return [Ox, Rx]
            }

            static get pluginName() {
                return "FontColor"
            }
        }

        class Vx extends My {
            constructor(t) {
                super(t, qy)
            }
        }

        function Hx(t) {
            return t.map(Ux).filter((t => !!t))
        }

        function Ux(t) {
            if (typeof t === "object") {
                return t
            }
            if (t === "default") {
                return {title: "Default", model: undefined}
            }
            if (typeof t !== "string") {
                return
            }
            return Wx(t)
        }

        function Wx(t) {
            const e = t.replace(/"|'/g, "").split(",");
            const n = e[0];
            const i = e.map(qx).join(", ");
            return {title: n, model: i, view: {name: "span", styles: {"font-family": i}, priority: 7}}
        }

        function qx(t) {
            t = t.trim();
            if (t.indexOf(" ") > 0) {
                t = `'${t}'`
            }
            return t
        }

        class Kx extends tA {
            static get pluginName() {
                return "FontFamilyEditing"
            }

            constructor(t) {
                super(t);
                t.config.define(qy, {
                    options: ["default", "Arial, Helvetica, sans-serif", "Courier New, Courier, monospace", "Georgia, serif", "Lucida Sans Unicode, Lucida Grande, sans-serif", "Tahoma, Geneva, sans-serif", "Times New Roman, Times, serif", "Trebuchet MS, Helvetica, sans-serif", "Verdana, Geneva, sans-serif"],
                    supportAllValues: false
                })
            }

            init() {
                const t = this.editor;
                t.model.schema.extend("$text", {allowAttributes: qy});
                t.model.schema.setAttributeProperties(qy, {isFormatting: true, copyOnEnter: true});
                const e = Hx(t.config.get("fontFamily.options")).filter((t => t.model));
                const n = $y(qy, e);
                if (t.config.get("fontFamily.supportAllValues")) {
                    this._prepareAnyValueConverters()
                } else {
                    t.conversion.attributeToElement(n)
                }
                t.commands.add(qy, new Vx(t))
            }

            _prepareAnyValueConverters() {
                const t = this.editor;
                t.conversion.for("downcast").attributeToElement({
                    model: qy,
                    view: (t, {writer: e}) => e.createAttributeElement("span", {style: "font-family:" + t}, {priority: 7})
                });
                t.conversion.for("upcast").attributeToAttribute({
                    model: {
                        key: qy,
                        value: t => t.getStyle("font-family")
                    }, view: {name: "span", styles: {"font-family": /.*/}}
                })
            }
        }

        var Gx = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.03 3h6.149a.75.75 0 1 1 0 1.5h-5.514L11.03 3zm1.27 3h4.879a.75.75 0 1 1 0 1.5h-4.244L12.3 6zm1.27 3h3.609a.75.75 0 1 1 0 1.5h-2.973L13.57 9zm-2.754 2.5L8.038 4.785 5.261 11.5h5.555zm.62 1.5H4.641l-1.666 4.028H1.312l5.789-14h1.875l5.789 14h-1.663L11.436 13z"/></svg>';

        class $x extends tA {
            init() {
                const t = this.editor;
                const e = t.t;
                const n = this._getLocalizedOptions();
                const i = t.commands.get(qy);
                t.ui.componentFactory.add(qy, (o => {
                    const r = Sw(o);
                    Bw(r, Yx(n, i));
                    r.buttonView.set({label: e("Font Family"), icon: Gx, tooltip: true});
                    r.extendTemplate({attributes: {class: "ck-font-family-dropdown"}});
                    r.bind("isEnabled").to(i);
                    this.listenTo(r, "execute", (e => {
                        t.execute(e.source.commandName, {value: e.source.commandParam});
                        t.editing.view.focus()
                    }));
                    return r
                }))
            }

            _getLocalizedOptions() {
                const t = this.editor;
                const e = t.t;
                const n = Hx(t.config.get(qy).options);
                return n.map((t => {
                    if (t.title === "Default") {
                        t.title = e("Default")
                    }
                    return t
                }))
            }
        }

        function Yx(t, e) {
            const n = new vs;
            for (const i of t) {
                const t = {
                    type: "button",
                    model: new rv({commandName: qy, commandParam: i.model, label: i.title, withText: true})
                };
                t.model.bind("isOn").to(e, "value", (t => {
                    if (t === i.model) {
                        return true
                    }
                    if (!t || !i.model) {
                        return false
                    }
                    return t.split(",")[0].replace(/'/g, "").toLowerCase() === i.model.toLowerCase()
                }));
                if (i.view && i.view.styles) {
                    t.model.set("labelStyle", `font-family: ${i.view.styles["font-family"]}`)
                }
                n.add(t)
            }
            return n
        }

        class Qx extends tA {
            static get requires() {
                return [Kx, $x]
            }

            static get pluginName() {
                return "FontFamily"
            }
        }

        class Jx extends My {
            constructor(t) {
                super(t, Wy)
            }
        }

        function Xx(t) {
            return t.map((t => tE(t))).filter((t => !!t))
        }

        const Zx = {
            get tiny() {
                return {title: "Tiny", model: "tiny", view: {name: "span", classes: "text-tiny", priority: 7}}
            }, get small() {
                return {title: "Small", model: "small", view: {name: "span", classes: "text-small", priority: 7}}
            }, get big() {
                return {title: "Big", model: "big", view: {name: "span", classes: "text-big", priority: 7}}
            }, get huge() {
                return {title: "Huge", model: "huge", view: {name: "span", classes: "text-huge", priority: 7}}
            }
        };

        function tE(t) {
            if (oE(t)) {
                return nE(t)
            }
            const e = iE(t);
            if (e) {
                return nE(e)
            }
            if (t === "default") {
                return {model: undefined, title: "Default"}
            }
            if (rE(t)) {
                return
            }
            return eE(t)
        }

        function eE(t) {
            if (typeof t === "number" || typeof t === "string") {
                t = {title: String(t), model: `${parseFloat(t)}px`}
            }
            t.view = {name: "span", styles: {"font-size": t.model}};
            return nE(t)
        }

        function nE(t) {
            if (!t.view.priority) {
                t.view.priority = 7
            }
            return t
        }

        function iE(t) {
            return Zx[t] || Zx[t.model]
        }

        function oE(t) {
            return typeof t === "object" && t.title && t.model && t.view
        }

        function rE(t) {
            let e;
            if (typeof t === "object") {
                if (!t.model) {
                    throw new ss["a"]("font-size-invalid-definition", null, t)
                } else {
                    e = parseFloat(t.model)
                }
            } else {
                e = parseFloat(t)
            }
            return isNaN(e)
        }

        class sE extends tA {
            static get pluginName() {
                return "FontSizeEditing"
            }

            constructor(t) {
                super(t);
                t.config.define(Wy, {options: ["tiny", "small", "default", "big", "huge"], supportAllValues: false})
            }

            init() {
                const t = this.editor;
                t.model.schema.extend("$text", {allowAttributes: Wy});
                t.model.schema.setAttributeProperties(Wy, {isFormatting: true, copyOnEnter: true});
                const e = t.config.get("fontSize.supportAllValues");
                const n = Xx(this.editor.config.get("fontSize.options")).filter((t => t.model));
                const i = $y(Wy, n);
                if (e) {
                    this._prepareAnyValueConverters(i)
                } else {
                    t.conversion.attributeToElement(i)
                }
                t.commands.add(Wy, new Jx(t))
            }

            _prepareAnyValueConverters(t) {
                const e = this.editor;
                const n = t.model.values.filter((t => !String(t).match(/[\d.]+[\w%]+/)));
                if (n.length) {
                    throw new ss["a"]("font-size-invalid-use-of-named-presets", null, {presets: n})
                }
                e.conversion.for("downcast").attributeToElement({
                    model: Wy, view: (t, {writer: e}) => {
                        if (!t) {
                            return
                        }
                        return e.createAttributeElement("span", {style: "font-size:" + t}, {priority: 7})
                    }
                });
                e.conversion.for("upcast").attributeToAttribute({
                    model: {key: Wy, value: t => t.getStyle("font-size")},
                    view: {name: "span"}
                })
            }
        }

        var aE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.816 11.5L7.038 4.785 4.261 11.5h5.555zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663L10.436 13zm7.55 2.279l.779-.779.707.707-2.265 2.265-2.193-2.265.707-.707.765.765V4.825c0-.042 0-.083.002-.123l-.77.77-.707-.707L17.207 2.5l2.265 2.265-.707.707-.782-.782c.002.043.003.089.003.135v10.454z"/></svg>';
        var cE = n(33);
        var lE = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        lE.insert = "head";
        lE.singleton = true;
        var dE = ob()(cE["a"], lE);
        var uE = cE["a"].locals || {};

        class hE extends tA {
            init() {
                const t = this.editor;
                const e = t.t;
                const n = this._getLocalizedOptions();
                const i = t.commands.get(Wy);
                t.ui.componentFactory.add(Wy, (o => {
                    const r = Sw(o);
                    Bw(r, mE(n, i));
                    r.buttonView.set({label: e("Font Size"), icon: aE, tooltip: true});
                    r.extendTemplate({attributes: {class: ["ck-font-size-dropdown"]}});
                    r.bind("isEnabled").to(i);
                    this.listenTo(r, "execute", (e => {
                        t.execute(e.source.commandName, {value: e.source.commandParam});
                        t.editing.view.focus()
                    }));
                    return r
                }))
            }

            _getLocalizedOptions() {
                const t = this.editor;
                const e = t.t;
                const n = {Default: e("Default"), Tiny: e("Tiny"), Small: e("Small"), Big: e("Big"), Huge: e("Huge")};
                const i = Xx(t.config.get(Wy).options);
                return i.map((t => {
                    const e = n[t.title];
                    if (e && e != t.title) {
                        t = Object.assign({}, t, {title: e})
                    }
                    return t
                }))
            }
        }

        function mE(t, e) {
            const n = new vs;
            for (const i of t) {
                const t = {
                    type: "button",
                    model: new rv({
                        commandName: Wy,
                        commandParam: i.model,
                        label: i.title,
                        class: "ck-fontsize-option",
                        withText: true
                    })
                };
                if (i.view && i.view.styles) {
                    t.model.set("labelStyle", `font-size:${i.view.styles["font-size"]}`)
                }
                if (i.view && i.view.classes) {
                    t.model.set("class", `${t.model.class} ${i.view.classes}`)
                }
                t.model.bind("isOn").to(e, "value", (t => t === i.model));
                n.add(t)
            }
            return n
        }

        class gE extends tA {
            static get requires() {
                return [sE, hE]
            }

            static get pluginName() {
                return "FontSize"
            }
        }

        class fE extends nA {
            refresh() {
                const t = this.editor.model;
                const e = t.document;
                const n = oA(e.selection.getSelectedBlocks());
                this.value = !!n && n.is("element", "paragraph");
                this.isEnabled = !!n && pE(n, t.schema)
            }

            execute(t = {}) {
                const e = this.editor.model;
                const n = e.document;
                e.change((i => {
                    const o = (t.selection || n.selection).getSelectedBlocks();
                    for (const t of o) {
                        if (!t.is("element", "paragraph") && pE(t, e.schema)) {
                            i.rename(t, "paragraph")
                        }
                    }
                }))
            }
        }

        function pE(t, e) {
            return e.checkChild(t.parent, "paragraph") && !e.isObject(t)
        }

        class bE extends nA {
            execute(t) {
                const e = this.editor.model;
                let n = t.position;
                e.change((t => {
                    const i = t.createElement("paragraph");
                    if (!e.schema.checkChild(n.parent, i)) {
                        const o = e.schema.findAllowedParent(n, i);
                        if (!o) {
                            return
                        }
                        n = t.split(n, o).position
                    }
                    e.insertContent(i, n);
                    t.setSelection(i, "in")
                }))
            }
        }

        class kE extends tA {
            static get pluginName() {
                return "Paragraph"
            }

            init() {
                const t = this.editor;
                const e = t.model;
                t.commands.add("paragraph", new fE(t));
                t.commands.add("insertParagraph", new bE(t));
                e.schema.register("paragraph", {inheritAllFrom: "$block"});
                t.conversion.elementToElement({model: "paragraph", view: "p"});
                t.conversion.for("upcast").elementToElement({
                    model: (t, {writer: e}) => {
                        if (!kE.paragraphLikeElements.has(t.name)) {
                            return null
                        }
                        if (t.isEmpty) {
                            return null
                        }
                        return e.createElement("paragraph")
                    }, view: /.+/, converterPriority: "low"
                })
            }
        }

        kE.paragraphLikeElements = new Set(["blockquote", "dd", "div", "dt", "h1", "h2", "h3", "h4", "h5", "h6", "li", "p", "td", "th"]);

        class wE extends nA {
            constructor(t, e) {
                super(t);
                this.modelElements = e
            }

            refresh() {
                const t = oA(this.editor.model.document.selection.getSelectedBlocks());
                this.value = !!t && this.modelElements.includes(t.name) && t.name;
                this.isEnabled = !!t && this.modelElements.some((e => AE(t, e, this.editor.model.schema)))
            }

            execute(t) {
                const e = this.editor.model;
                const n = e.document;
                const i = t.value;
                e.change((t => {
                    const o = Array.from(n.selection.getSelectedBlocks()).filter((t => AE(t, i, e.schema)));
                    for (const e of o) {
                        if (!e.is("element", i)) {
                            t.rename(e, i)
                        }
                    }
                }))
            }
        }

        function AE(t, e, n) {
            return n.checkChild(t.parent, e) && !n.isObject(t)
        }

        const _E = "paragraph";

        class CE extends tA {
            static get pluginName() {
                return "HeadingEditing"
            }

            constructor(t) {
                super(t);
                t.config.define("heading", {
                    options: [{
                        model: "paragraph",
                        title: "Paragraph",
                        class: "ck-heading_paragraph"
                    }, {
                        model: "heading1",
                        view: "h2",
                        title: "Heading 1",
                        class: "ck-heading_heading1"
                    }, {
                        model: "heading2",
                        view: "h3",
                        title: "Heading 2",
                        class: "ck-heading_heading2"
                    }, {model: "heading3", view: "h4", title: "Heading 3", class: "ck-heading_heading3"}]
                })
            }

            static get requires() {
                return [kE]
            }

            init() {
                const t = this.editor;
                const e = t.config.get("heading.options");
                const n = [];
                for (const i of e) {
                    if (i.model !== _E) {
                        t.model.schema.register(i.model, {inheritAllFrom: "$block"});
                        t.conversion.elementToElement(i);
                        n.push(i.model)
                    }
                }
                this._addDefaultH1Conversion(t);
                t.commands.add("heading", new wE(t, n))
            }

            afterInit() {
                const t = this.editor;
                const e = t.commands.get("enter");
                const n = t.config.get("heading.options");
                if (e) {
                    this.listenTo(e, "afterExecute", ((e, i) => {
                        const o = t.model.document.selection.getFirstPosition().parent;
                        const r = n.some((t => o.is("element", t.model)));
                        if (r && !o.is("element", _E) && o.childCount === 0) {
                            i.writer.rename(o, _E)
                        }
                    }))
                }
            }

            _addDefaultH1Conversion(t) {
                t.conversion.for("upcast").elementToElement({
                    model: "heading1",
                    view: "h1",
                    converterPriority: os.get("low") + 1
                })
            }
        }

        function vE(t) {
            const e = t.t;
            const n = {
                Paragraph: e("Paragraph"),
                "Heading 1": e("Heading 1"),
                "Heading 2": e("Heading 2"),
                "Heading 3": e("Heading 3"),
                "Heading 4": e("Heading 4"),
                "Heading 5": e("Heading 5"),
                "Heading 6": e("Heading 6")
            };
            return t.config.get("heading.options").map((t => {
                const e = n[t.title];
                if (e && e != t.title) {
                    t.title = e
                }
                return t
            }))
        }

        var yE = n(34);
        var xE = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        xE.insert = "head";
        xE.singleton = true;
        var EE = ob()(yE["a"], xE);
        var DE = yE["a"].locals || {};

        class TE extends tA {
            init() {
                const t = this.editor;
                const e = t.t;
                const n = vE(t);
                const i = e("Choose heading");
                const o = e("Heading");
                t.ui.componentFactory.add("heading", (e => {
                    const r = {};
                    const s = new vs;
                    const a = t.commands.get("heading");
                    const c = t.commands.get("paragraph");
                    const l = [a];
                    for (const t of n) {
                        const e = {type: "button", model: new rv({label: t.title, class: t.class, withText: true})};
                        if (t.model === "paragraph") {
                            e.model.bind("isOn").to(c, "value");
                            e.model.set("commandName", "paragraph");
                            l.push(c)
                        } else {
                            e.model.bind("isOn").to(a, "value", (e => e === t.model));
                            e.model.set({commandName: "heading", commandValue: t.model})
                        }
                        s.add(e);
                        r[t.model] = t.title
                    }
                    const d = Sw(e);
                    Bw(d, s);
                    d.buttonView.set({isOn: false, withText: true, tooltip: o});
                    d.extendTemplate({attributes: {class: ["ck-heading-dropdown"]}});
                    d.bind("isEnabled").toMany(l, "isEnabled", ((...t) => t.some((t => t))));
                    d.buttonView.bind("label").to(a, "value", c, "value", ((t, e) => {
                        const n = t || e && "paragraph";
                        return r[n] ? r[n] : i
                    }));
                    this.listenTo(d, "execute", (e => {
                        t.execute(e.source.commandName, e.source.commandValue ? {value: e.source.commandValue} : undefined);
                        t.editing.view.focus()
                    }));
                    return d
                }))
            }
        }

        class ME extends tA {
            static get requires() {
                return [CE, TE]
            }

            static get pluginName() {
                return "Heading"
            }
        }

        class SE extends nA {
            refresh() {
                const t = this.editor.model;
                const e = t.document;
                this.value = e.selection.getAttribute("highlight");
                this.isEnabled = t.schema.checkAttributeInSelection(e.selection, "highlight")
            }

            execute(t = {}) {
                const e = this.editor.model;
                const n = e.document;
                const i = n.selection;
                const o = t.value;
                e.change((t => {
                    const n = e.schema.getValidRanges(i.getRanges(), "highlight");
                    if (i.isCollapsed) {
                        const e = i.getFirstPosition();
                        if (i.hasAttribute("highlight")) {
                            const n = t => t.item.hasAttribute("highlight") && t.item.getAttribute("highlight") === this.value;
                            const i = e.getLastMatchingPosition(n, {direction: "backward"});
                            const r = e.getLastMatchingPosition(n);
                            const s = t.createRange(i, r);
                            if (!o || this.value === o) {
                                t.removeAttribute("highlight", s);
                                t.removeSelectionAttribute("highlight")
                            } else {
                                t.setAttribute("highlight", o, s);
                                t.setSelectionAttribute("highlight", o)
                            }
                        } else if (o) {
                            t.setSelectionAttribute("highlight", o)
                        }
                    } else {
                        for (const e of n) {
                            if (o) {
                                t.setAttribute("highlight", o, e)
                            } else {
                                t.removeAttribute("highlight", e)
                            }
                        }
                    }
                }))
            }
        }

        class IE extends tA {
            static get pluginName() {
                return "HighlightEditing"
            }

            constructor(t) {
                super(t);
                t.config.define("highlight", {
                    options: [{
                        model: "yellowMarker",
                        class: "marker-yellow",
                        title: "Yellow marker",
                        color: "var(--ck-highlight-marker-yellow)",
                        type: "marker"
                    }, {
                        model: "greenMarker",
                        class: "marker-green",
                        title: "Green marker",
                        color: "var(--ck-highlight-marker-green)",
                        type: "marker"
                    }, {
                        model: "pinkMarker",
                        class: "marker-pink",
                        title: "Pink marker",
                        color: "var(--ck-highlight-marker-pink)",
                        type: "marker"
                    }, {
                        model: "blueMarker",
                        class: "marker-blue",
                        title: "Blue marker",
                        color: "var(--ck-highlight-marker-blue)",
                        type: "marker"
                    }, {
                        model: "redPen",
                        class: "pen-red",
                        title: "Red pen",
                        color: "var(--ck-highlight-pen-red)",
                        type: "pen"
                    }, {
                        model: "greenPen",
                        class: "pen-green",
                        title: "Green pen",
                        color: "var(--ck-highlight-pen-green)",
                        type: "pen"
                    }]
                })
            }

            init() {
                const t = this.editor;
                t.model.schema.extend("$text", {allowAttributes: "highlight"});
                const e = t.config.get("highlight.options");
                t.conversion.attributeToElement(BE(e));
                t.commands.add("highlight", new SE(t))
            }
        }

        function BE(t) {
            const e = {model: {key: "highlight", values: []}, view: {}};
            for (const n of t) {
                e.model.values.push(n.model);
                e.view[n.model] = {name: "mark", classes: n.class}
            }
            return e
        }

        var LE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path class="ck-icon__fill" d="M10.798 1.59L3.002 12.875l1.895 1.852 2.521 1.402 6.997-12.194z"/><path d="M2.556 16.727l.234-.348c-.297-.151-.462-.293-.498-.426-.036-.137.002-.416.115-.837.094-.25.15-.449.169-.595a4.495 4.495 0 0 0 0-.725c-.209-.621-.303-1.041-.284-1.26.02-.218.178-.506.475-.862l6.77-9.414c.539-.91 1.605-.85 3.199.18 1.594 1.032 2.188 1.928 1.784 2.686l-5.877 10.36c-.158.412-.333.673-.526.782-.193.108-.604.179-1.232.21-.362.131-.608.237-.738.318-.13.081-.305.238-.526.47-.293.265-.504.397-.632.397-.096 0-.27-.075-.524-.226l-.31.41-1.6-1.12zm-.279.415l1.575 1.103-.392.515H1.19l1.087-1.618zm8.1-13.656l-4.953 6.9L8.75 12.57l4.247-7.574c.175-.25-.188-.647-1.092-1.192-.903-.546-1.412-.652-1.528-.32zM8.244 18.5L9.59 17h9.406v1.5H8.245z"/></svg>';
        var zE = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path class="ck-icon__fill" d="M10.126 2.268L2.002 13.874l1.895 1.852 2.521 1.402L14.47 5.481l-1.543-2.568-2.801-.645z"/><path d="M4.5 18.088l-2.645-1.852-.04-2.95-.006-.005.006-.008v-.025l.011.008L8.73 2.97c.165-.233.356-.417.567-.557l-1.212.308L4.604 7.9l-.83-.558 3.694-5.495 2.708-.69 1.65 1.145.046.018.85-1.216 2.16 1.512-.856 1.222c.828.967 1.144 2.141.432 3.158L7.55 17.286l.006.005-3.055.797H4.5zm-.634.166l-1.976.516-.026-1.918 2.002 1.402zM9.968 3.817l-.006-.004-6.123 9.184 3.277 2.294 6.108-9.162.005.003c.317-.452-.16-1.332-1.064-1.966-.891-.624-1.865-.776-2.197-.349zM8.245 18.5L9.59 17h9.406v1.5H8.245z"/></svg>';
        var NE = n(35);
        var PE = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        PE.insert = "head";
        PE.singleton = true;
        var OE = ob()(NE["a"], PE);
        var jE = NE["a"].locals || {};

        class RE extends tA {
            get localizedOptionTitles() {
                const t = this.editor.t;
                return {
                    "Yellow marker": t("Yellow marker"),
                    "Green marker": t("Green marker"),
                    "Pink marker": t("Pink marker"),
                    "Blue marker": t("Blue marker"),
                    "Red pen": t("Red pen"),
                    "Green pen": t("Green pen")
                }
            }

            static get pluginName() {
                return "HighlightUI"
            }

            init() {
                const t = this.editor.config.get("highlight.options");
                for (const e of t) {
                    this._addHighlighterButton(e)
                }
                this._addRemoveHighlightButton();
                this._addDropdown(t)
            }

            _addRemoveHighlightButton() {
                const t = this.editor.t;
                this._addButton("removeHighlight", t("Remove highlight"), jy)
            }

            _addHighlighterButton(t) {
                const e = this.editor.commands.get("highlight");
                this._addButton("highlight:" + t.model, t.title, VE(t.type), t.model, n);

                function n(n) {
                    n.bind("isEnabled").to(e, "isEnabled");
                    n.bind("isOn").to(e, "value", (e => e === t.model));
                    n.iconView.fillColor = t.color;
                    n.isToggleable = true
                }
            }

            _addButton(t, e, n, i, o = (() => {
            })) {
                const r = this.editor;
                r.ui.componentFactory.add(t, (t => {
                    const s = new sw(t);
                    const a = this.localizedOptionTitles[e] ? this.localizedOptionTitles[e] : e;
                    s.set({label: a, icon: n, tooltip: true});
                    s.on("execute", (() => {
                        r.execute("highlight", {value: i});
                        r.editing.view.focus()
                    }));
                    o(s);
                    return s
                }))
            }

            _addDropdown(t) {
                const e = this.editor;
                const n = e.t;
                const i = e.ui.componentFactory;
                const o = t[0];
                const r = t.reduce(((t, e) => {
                    t[e.model] = e;
                    return t
                }), {});
                i.add("highlight", (s => {
                    const a = e.commands.get("highlight");
                    const c = Sw(s, dv);
                    const l = c.buttonView;
                    l.set({tooltip: n("Highlight"), lastExecuted: o.model, commandValue: o.model, isToggleable: true});
                    l.bind("icon").to(a, "value", (t => VE(u(t, "type"))));
                    l.bind("color").to(a, "value", (t => u(t, "color")));
                    l.bind("commandValue").to(a, "value", (t => u(t, "model")));
                    l.bind("isOn").to(a, "value", (t => !!t));
                    l.delegate("execute").to(c);
                    const d = t.map((t => {
                        const e = i.create("highlight:" + t.model);
                        this.listenTo(e, "execute", (() => c.buttonView.set({lastExecuted: t.model})));
                        return e
                    }));
                    c.bind("isEnabled").toMany(d, "isEnabled", ((...t) => t.some((t => t))));
                    d.push(new Dk);
                    d.push(i.create("removeHighlight"));
                    Iw(c, d);
                    FE(c);
                    c.toolbarView.ariaLabel = n("Text highlight toolbar");
                    l.on("execute", (() => {
                        e.execute("highlight", {value: l.commandValue});
                        e.editing.view.focus()
                    }));

                    function u(t, e) {
                        const n = !t || t === l.lastExecuted ? l.lastExecuted : t;
                        return r[n][e]
                    }

                    return c
                }))
            }
        }

        function FE(t) {
            const e = t.buttonView.actionView;
            e.iconView.bind("fillColor").to(t.buttonView, "color")
        }

        function VE(t) {
            return t === "marker" ? LE : zE
        }

        class HE extends tA {
            static get requires() {
                return [IE, RE]
            }

            static get pluginName() {
                return "Highlight"
            }
        }

        class UE {
            constructor() {
                this._stack = []
            }

            add(t, e) {
                const n = this._stack;
                const i = n[0];
                this._insertDescriptor(t);
                const o = n[0];
                if (i !== o && !WE(i, o)) {
                    this.fire("change:top", {oldDescriptor: i, newDescriptor: o, writer: e})
                }
            }

            remove(t, e) {
                const n = this._stack;
                const i = n[0];
                this._removeDescriptor(t);
                const o = n[0];
                if (i !== o && !WE(i, o)) {
                    this.fire("change:top", {oldDescriptor: i, newDescriptor: o, writer: e})
                }
            }

            _insertDescriptor(t) {
                const e = this._stack;
                const n = e.findIndex((e => e.id === t.id));
                if (WE(t, e[n])) {
                    return
                }
                if (n > -1) {
                    e.splice(n, 1)
                }
                let i = 0;
                while (e[i] && qE(e[i], t)) {
                    i++
                }
                e.splice(i, 0, t)
            }

            _removeDescriptor(t) {
                const e = this._stack;
                const n = e.findIndex((e => e.id === t));
                if (n > -1) {
                    e.splice(n, 1)
                }
            }
        }

        Cs(UE, ds);

        function WE(t, e) {
            return t && e && t.priority == e.priority && KE(t.classes) == KE(e.classes)
        }

        function qE(t, e) {
            if (t.priority > e.priority) {
                return true
            } else if (t.priority < e.priority) {
                return false
            }
            return KE(t.classes) > KE(e.classes)
        }

        function KE(t) {
            return Array.isArray(t) ? t.sort().join(",") : t
        }

        var GE = n(36);
        var $E = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        $E.insert = "head";
        $E.singleton = true;
        var YE = ob()(GE["a"], $E);
        var QE = GE["a"].locals || {};
        const JE = kk("px");
        const XE = jd.document.body;

        class ZE extends Zb {
            constructor(t) {
                super(t);
                const e = this.bindTemplate;
                this.set("top", 0);
                this.set("left", 0);
                this.set("position", "arrow_nw");
                this.set("isVisible", false);
                this.set("withArrow", true);
                this.set("class");
                this.content = this.createCollection();
                this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-balloon-panel", e.to("position", (t => `ck-balloon-panel_${t}`)), e.if("isVisible", "ck-balloon-panel_visible"), e.if("withArrow", "ck-balloon-panel_with-arrow"), e.to("class")],
                        style: {top: e.to("top", JE), left: e.to("left", JE)}
                    },
                    children: this.content
                })
            }

            show() {
                this.isVisible = true
            }

            hide() {
                this.isVisible = false
            }

            attachTo(t) {
                this.show();
                const e = ZE.defaultPositions;
                const n = Object.assign({}, {
                    element: this.element,
                    positions: [e.southArrowNorth, e.southArrowNorthMiddleWest, e.southArrowNorthMiddleEast, e.southArrowNorthWest, e.southArrowNorthEast, e.northArrowSouth, e.northArrowSouthMiddleWest, e.northArrowSouthMiddleEast, e.northArrowSouthWest, e.northArrowSouthEast],
                    limiter: XE,
                    fitInViewport: true
                }, t);
                const i = ZE._getOptimalPosition(n);
                const o = parseInt(i.left);
                const r = parseInt(i.top);
                const s = i.name;
                Object.assign(this, {top: r, left: o, position: s})
            }

            pin(t) {
                this.unpin();
                this._pinWhenIsVisibleCallback = () => {
                    if (this.isVisible) {
                        this._startPinning(t)
                    } else {
                        this._stopPinning()
                    }
                };
                this._startPinning(t);
                this.listenTo(this, "change:isVisible", this._pinWhenIsVisibleCallback)
            }

            unpin() {
                if (this._pinWhenIsVisibleCallback) {
                    this._stopPinning();
                    this.stopListening(this, "change:isVisible", this._pinWhenIsVisibleCallback);
                    this._pinWhenIsVisibleCallback = null;
                    this.hide()
                }
            }

            _startPinning(t) {
                this.attachTo(t);
                const e = tD(t.target);
                const n = t.limiter ? tD(t.limiter) : XE;
                this.listenTo(jd.document, "scroll", ((i, o) => {
                    const r = o.target;
                    const s = e && r.contains(e);
                    const a = n && r.contains(n);
                    if (s || a || !e || !n) {
                        this.attachTo(t)
                    }
                }), {useCapture: true});
                this.listenTo(jd.window, "resize", (() => {
                    this.attachTo(t)
                }))
            }

            _stopPinning() {
                this.stopListening(jd.document, "scroll");
                this.stopListening(jd.window, "resize")
            }
        }

        function tD(t) {
            if ($r(t)) {
                return t
            }
            if (vh(t)) {
                return t.commonAncestorContainer
            }
            if (typeof t == "function") {
                return tD(t())
            }
            return null
        }

        ZE.arrowHorizontalOffset = 25;
        ZE.arrowVerticalOffset = 10;
        ZE._getOptimalPosition = jk;
        ZE.defaultPositions = {
            northWestArrowSouthWest: (t, e) => ({
                top: eD(t, e),
                left: t.left - ZE.arrowHorizontalOffset,
                name: "arrow_sw"
            }),
            northWestArrowSouthMiddleWest: (t, e) => ({
                top: eD(t, e),
                left: t.left - e.width * .25 - ZE.arrowHorizontalOffset,
                name: "arrow_smw"
            }),
            northWestArrowSouth: (t, e) => ({top: eD(t, e), left: t.left - e.width / 2, name: "arrow_s"}),
            northWestArrowSouthMiddleEast: (t, e) => ({
                top: eD(t, e),
                left: t.left - e.width * .75 + ZE.arrowHorizontalOffset,
                name: "arrow_sme"
            }),
            northWestArrowSouthEast: (t, e) => ({
                top: eD(t, e),
                left: t.left - e.width + ZE.arrowHorizontalOffset,
                name: "arrow_se"
            }),
            northArrowSouthWest: (t, e) => ({
                top: eD(t, e),
                left: t.left + t.width / 2 - ZE.arrowHorizontalOffset,
                name: "arrow_sw"
            }),
            northArrowSouthMiddleWest: (t, e) => ({
                top: eD(t, e),
                left: t.left + t.width / 2 - e.width * .25 - ZE.arrowHorizontalOffset,
                name: "arrow_smw"
            }),
            northArrowSouth: (t, e) => ({top: eD(t, e), left: t.left + t.width / 2 - e.width / 2, name: "arrow_s"}),
            northArrowSouthMiddleEast: (t, e) => ({
                top: eD(t, e),
                left: t.left + t.width / 2 - e.width * .75 + ZE.arrowHorizontalOffset,
                name: "arrow_sme"
            }),
            northArrowSouthEast: (t, e) => ({
                top: eD(t, e),
                left: t.left + t.width / 2 - e.width + ZE.arrowHorizontalOffset,
                name: "arrow_se"
            }),
            northEastArrowSouthWest: (t, e) => ({
                top: eD(t, e),
                left: t.right - ZE.arrowHorizontalOffset,
                name: "arrow_sw"
            }),
            northEastArrowSouthMiddleWest: (t, e) => ({
                top: eD(t, e),
                left: t.right - e.width * .25 - ZE.arrowHorizontalOffset,
                name: "arrow_smw"
            }),
            northEastArrowSouth: (t, e) => ({top: eD(t, e), left: t.right - e.width / 2, name: "arrow_s"}),
            northEastArrowSouthMiddleEast: (t, e) => ({
                top: eD(t, e),
                left: t.right - e.width * .75 + ZE.arrowHorizontalOffset,
                name: "arrow_sme"
            }),
            northEastArrowSouthEast: (t, e) => ({
                top: eD(t, e),
                left: t.right - e.width + ZE.arrowHorizontalOffset,
                name: "arrow_se"
            }),
            southWestArrowNorthWest: (t, e) => ({
                top: nD(t, e),
                left: t.left - ZE.arrowHorizontalOffset,
                name: "arrow_nw"
            }),
            southWestArrowNorthMiddleWest: (t, e) => ({
                top: nD(t, e),
                left: t.left - e.width * .25 - ZE.arrowHorizontalOffset,
                name: "arrow_nmw"
            }),
            southWestArrowNorth: (t, e) => ({top: nD(t, e), left: t.left - e.width / 2, name: "arrow_n"}),
            southWestArrowNorthMiddleEast: (t, e) => ({
                top: nD(t, e),
                left: t.left - e.width * .75 + ZE.arrowHorizontalOffset,
                name: "arrow_nme"
            }),
            southWestArrowNorthEast: (t, e) => ({
                top: nD(t, e),
                left: t.left - e.width + ZE.arrowHorizontalOffset,
                name: "arrow_ne"
            }),
            southArrowNorthWest: (t, e) => ({
                top: nD(t, e),
                left: t.left + t.width / 2 - ZE.arrowHorizontalOffset,
                name: "arrow_nw"
            }),
            southArrowNorthMiddleWest: (t, e) => ({
                top: nD(t, e),
                left: t.left + t.width / 2 - e.width * .25 - ZE.arrowHorizontalOffset,
                name: "arrow_nmw"
            }),
            southArrowNorth: (t, e) => ({top: nD(t, e), left: t.left + t.width / 2 - e.width / 2, name: "arrow_n"}),
            southArrowNorthMiddleEast: (t, e) => ({
                top: nD(t, e),
                left: t.left + t.width / 2 - e.width * .75 + ZE.arrowHorizontalOffset,
                name: "arrow_nme"
            }),
            southArrowNorthEast: (t, e) => ({
                top: nD(t, e),
                left: t.left + t.width / 2 - e.width + ZE.arrowHorizontalOffset,
                name: "arrow_ne"
            }),
            southEastArrowNorthWest: (t, e) => ({
                top: nD(t, e),
                left: t.right - ZE.arrowHorizontalOffset,
                name: "arrow_nw"
            }),
            southEastArrowNorthMiddleWest: (t, e) => ({
                top: nD(t, e),
                left: t.right - e.width * .25 - ZE.arrowHorizontalOffset,
                name: "arrow_nmw"
            }),
            southEastArrowNorth: (t, e) => ({top: nD(t, e), left: t.right - e.width / 2, name: "arrow_n"}),
            southEastArrowNorthMiddleEast: (t, e) => ({
                top: nD(t, e),
                left: t.right - e.width * .75 + ZE.arrowHorizontalOffset,
                name: "arrow_nme"
            }),
            southEastArrowNorthEast: (t, e) => ({
                top: nD(t, e),
                left: t.right - e.width + ZE.arrowHorizontalOffset,
                name: "arrow_ne"
            })
        };

        function eD(t, e) {
            return t.top - e.height - ZE.arrowVerticalOffset
        }

        function nD(t) {
            return t.bottom + ZE.arrowVerticalOffset
        }

        var iD = '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M4 0v1H1v3H0V.5A.5.5 0 0 1 .5 0H4zm8 0h3.5a.5.5 0 0 1 .5.5V4h-1V1h-3V0zM4 16H.5a.5.5 0 0 1-.5-.5V12h1v3h3v1zm8 0v-1h3v-3h1v3.5a.5.5 0 0 1-.5.5H12z"/><path fill-opacity=".256" d="M1 1h14v14H1z"/><g class="ck-icon__selected-indicator"><path d="M7 0h2v1H7V0zM0 7h1v2H0V7zm15 0h1v2h-1V7zm-8 8h2v1H7v-1z"/><path fill-opacity=".254" d="M1 1h14v14H1z"/></g></svg>';
        const oD = "widget-type-around";

        function rD(t, e, n) {
            return t && hD(t) && !n.isInline(e)
        }

        function sD(t) {
            return t.closest(".ck-widget__type-around__button")
        }

        function aD(t) {
            return t.classList.contains("ck-widget__type-around__button_before") ? "before" : "after"
        }

        function cD(t, e) {
            const n = t.closest(".ck-widget");
            return e.mapDomToView(n)
        }

        function lD(t) {
            return t.getAttribute(oD)
        }

        const dD = "ck-widget";
        const uD = "ck-widget_selected";

        function hD(t) {
            if (!t.is("element")) {
                return false
            }
            return !!t.getCustomProperty("widget")
        }

        function mD(t, e, n = {}) {
            if (!t.is("containerElement")) {
                throw new ss["a"]("widget-to-widget-wrong-element-type", null, {element: t})
            }
            e.setAttribute("contenteditable", "false", t);
            e.addClass(dD, t);
            e.setCustomProperty("widget", true, t);
            t.getFillerOffset = _D;
            if (n.label) {
                fD(t, n.label, e)
            }
            if (n.hasSelectionHandle) {
                CD(t, e)
            }
            gD(t, e, ((t, e, n) => n.addClass(i(e.classes), t)), ((t, e, n) => n.removeClass(i(e.classes), t)));
            return t;

            function i(t) {
                return Array.isArray(t) ? t : [t]
            }
        }

        function gD(t, e, n, i) {
            const o = new UE;
            o.on("change:top", ((e, o) => {
                if (o.oldDescriptor) {
                    i(t, o.oldDescriptor, o.writer)
                }
                if (o.newDescriptor) {
                    n(t, o.newDescriptor, o.writer)
                }
            }));
            e.setCustomProperty("addHighlight", ((t, e, n) => o.add(e, n)), t);
            e.setCustomProperty("removeHighlight", ((t, e, n) => o.remove(e, n)), t)
        }

        function fD(t, e, n) {
            n.setCustomProperty("widgetLabel", e, t)
        }

        function pD(t) {
            const e = t.getCustomProperty("widgetLabel");
            if (!e) {
                return ""
            }
            return typeof e == "function" ? e() : e
        }

        function bD(t, e) {
            e.addClass(["ck-editor__editable", "ck-editor__nested-editable"], t);
            e.setAttribute("contenteditable", t.isReadOnly ? "false" : "true", t);
            t.on("change:isReadOnly", ((n, i, o) => {
                e.setAttribute("contenteditable", o ? "false" : "true", t)
            }));
            t.on("change:isFocused", ((n, i, o) => {
                if (o) {
                    e.addClass("ck-editor__nested-editable_focused", t)
                } else {
                    e.removeClass("ck-editor__nested-editable_focused", t)
                }
            }));
            return t
        }

        function kD(t, e) {
            const n = t.getSelectedElement();
            if (n) {
                const i = lD(t);
                if (i) {
                    return e.createPositionAt(n, i)
                }
                if (e.schema.isBlock(n)) {
                    return e.createPositionAfter(n)
                }
            }
            const i = t.getSelectedBlocks().next().value;
            if (i) {
                if (i.isEmpty) {
                    return e.createPositionAt(i, 0)
                }
                const n = e.createPositionAfter(i);
                if (t.focus.isTouching(n)) {
                    return n
                }
                return e.createPositionBefore(i)
            }
            return t.focus
        }

        function wD(t, e) {
            return (n, i) => {
                const {mapper: o, viewPosition: r} = i;
                const s = o.findMappedViewAncestor(r);
                if (!e(s)) {
                    return
                }
                const a = o.toModelElement(s);
                i.modelPosition = t.createPositionAt(a, r.isAtStart ? "before" : "after")
            }
        }

        function AD(t, e) {
            const n = new Eh(jd.window);
            const i = n.getIntersection(t);
            const o = e.height + ZE.arrowVerticalOffset;
            if (t.top - o > n.top || t.bottom + o < n.bottom) {
                return null
            }
            const r = i || t;
            const s = r.left + r.width / 2 - e.width / 2;
            return {top: Math.max(t.top, 0) + ZE.arrowVerticalOffset, left: s, name: "arrow_n"}
        }

        function _D() {
            return null
        }

        function CD(t, e) {
            const n = e.createUIElement("div", {class: "ck ck-widget__selection-handle"}, (function (t) {
                const e = this.toDomElement(t);
                const n = new Qk;
                n.set("content", iD);
                n.render();
                e.appendChild(n.element);
                return e
            }));
            e.insert(e.createPositionAt(t, 0), n);
            e.addClass(["ck-widget_with-selection-handle"], t)
        }

        class vD extends nA {
            refresh() {
                this.isEnabled = yD(this.editor.model)
            }

            execute() {
                const t = this.editor.model;
                t.change((e => {
                    const n = e.createElement("horizontalLine");
                    t.insertContent(n);
                    let i = n.nextSibling;
                    const o = i && t.schema.checkChild(i, "$text");
                    if (!o && t.schema.checkChild(n.parent, "paragraph")) {
                        i = e.createElement("paragraph");
                        t.insertContent(i, e.createPositionAfter(n))
                    }
                    if (i) {
                        e.setSelection(i, 0)
                    }
                }))
            }
        }

        function yD(t) {
            const e = t.schema;
            const n = t.document.selection;
            return xD(n, e, t) && !ED(n, e)
        }

        function xD(t, e, n) {
            const i = DD(t, n);
            return e.checkChild(i, "horizontalLine")
        }

        function ED(t, e) {
            const n = t.getSelectedElement();
            return n && e.isObject(n)
        }

        function DD(t, e) {
            const n = kD(t, e);
            const i = n.parent;
            if (i.isEmpty && !i.is("element", "$root")) {
                return i.parent
            }
            return i
        }

        var TD = n(37);
        var MD = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        MD.insert = "head";
        MD.singleton = true;
        var SD = ob()(TD["a"], MD);
        var ID = TD["a"].locals || {};

        class BD extends tA {
            static get pluginName() {
                return "HorizontalLineEditing"
            }

            init() {
                const t = this.editor;
                const e = t.model.schema;
                const n = t.t;
                const i = t.conversion;
                e.register("horizontalLine", {isObject: true, allowWhere: "$block"});
                i.for("dataDowncast").elementToElement({
                    model: "horizontalLine",
                    view: (t, {writer: e}) => e.createEmptyElement("hr")
                });
                i.for("editingDowncast").elementToElement({
                    model: "horizontalLine", view: (t, {writer: e}) => {
                        const i = n("Horizontal line");
                        const o = e.createContainerElement("div");
                        const r = e.createEmptyElement("hr");
                        e.addClass("ck-horizontal-line", o);
                        e.setCustomProperty("hr", true, o);
                        e.insert(e.createPositionAt(o, 0), r);
                        return LD(o, e, i)
                    }
                });
                i.for("upcast").elementToElement({view: "hr", model: "horizontalLine"});
                t.commands.add("horizontalLine", new vD(t))
            }
        }

        function LD(t, e, n) {
            e.setCustomProperty("horizontalLine", true, t);
            return mD(t, e, {label: n})
        }

        var zD = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 9h16v2H2z"/></svg>';

        class ND extends tA {
            init() {
                const t = this.editor;
                const e = t.t;
                t.ui.componentFactory.add("horizontalLine", (n => {
                    const i = t.commands.get("horizontalLine");
                    const o = new sw(n);
                    o.set({label: e("Horizontal line"), icon: zD, tooltip: true});
                    o.bind("isEnabled").to(i, "isEnabled");
                    this.listenTo(o, "execute", (() => {
                        t.execute("horizontalLine");
                        t.editing.view.focus()
                    }));
                    return o
                }))
            }
        }

        class PD extends tA {
            static get requires() {
                return [BD, ND]
            }

            static get pluginName() {
                return "HorizontalLine"
            }
        }

        class OD {
            constructor(t) {
                this.document = t
            }

            createDocumentFragment(t) {
                return new Ql(this.document, t)
            }

            createElement(t, e, n) {
                return new jc(this.document, t, e, n)
            }

            createText(t) {
                return new Fs(this.document, t)
            }

            clone(t, e = false) {
                return t._clone(e)
            }

            appendChild(t, e) {
                return e._appendChild(t)
            }

            insertChild(t, e, n) {
                return n._insertChild(t, e)
            }

            removeChildren(t, e, n) {
                return n._removeChildren(t, e)
            }

            remove(t) {
                const e = t.parent;
                if (e) {
                    return this.removeChildren(e.getChildIndex(t), 1, e)
                }
                return []
            }

            replace(t, e) {
                const n = t.parent;
                if (n) {
                    const i = n.getChildIndex(t);
                    this.removeChildren(i, 1, n);
                    this.insertChild(i, e, n);
                    return true
                }
                return false
            }

            unwrapElement(t) {
                const e = t.parent;
                if (e) {
                    const n = e.getChildIndex(t);
                    this.remove(t);
                    this.insertChild(n, t.getChildren(), e)
                }
            }

            rename(t, e) {
                const n = new jc(this.document, t, e.getAttributes(), e.getChildren());
                return this.replace(e, n) ? n : null
            }

            setAttribute(t, e, n) {
                n._setAttribute(t, e)
            }

            removeAttribute(t, e) {
                e._removeAttribute(t)
            }

            addClass(t, e) {
                e._addClass(t)
            }

            removeClass(t, e) {
                e._removeClass(t)
            }

            setStyle(t, e, n) {
                if (z(t) && n === undefined) {
                    n = e
                }
                n._setStyle(t, e)
            }

            removeStyle(t, e) {
                e._removeStyle(t)
            }

            setCustomProperty(t, e, n) {
                n._setCustomProperty(t, e)
            }

            removeCustomProperty(t, e) {
                return e._removeCustomProperty(t)
            }

            createPositionAt(t, e) {
                return ul._createAt(t, e)
            }

            createPositionAfter(t) {
                return ul._createAfter(t)
            }

            createPositionBefore(t) {
                return ul._createBefore(t)
            }

            createRange(t, e) {
                return new hl(t, e)
            }

            createRangeOn(t) {
                return hl._createOn(t)
            }

            createRangeIn(t) {
                return hl._createIn(t)
            }

            createSelection(t, e, n) {
                return new fl(t, e, n)
            }
        }

        class jD extends nA {
            refresh() {
                this.isEnabled = RD(this.editor.model)
            }

            execute() {
                const t = this.editor.model;
                t.change((e => {
                    const n = e.createElement("rawHtml");
                    t.insertContent(n);
                    e.setSelection(n, "on")
                }))
            }
        }

        function RD(t) {
            const e = t.schema;
            const n = t.document.selection;
            return FD(n, e, t) && !VD(n, e)
        }

        function FD(t, e, n) {
            const i = HD(t, n);
            return e.checkChild(i, "rawHtml")
        }

        function VD(t, e) {
            const n = t.getSelectedElement();
            return n && e.isObject(n)
        }

        function HD(t, e) {
            const n = kD(t, e);
            const i = n.parent;
            if (i.isEmpty && !i.is("element", "$root")) {
                return i.parent
            }
            return i
        }

        class UD extends nA {
            refresh() {
                const t = this.editor.model;
                const e = t.document.selection;
                const n = WD(e);
                this.isEnabled = !!n
            }

            execute(t) {
                const e = this.editor.model;
                const n = e.document.selection;
                const i = WD(n);
                e.change((e => {
                    e.setAttribute("value", t, i)
                }))
            }
        }

        function WD(t) {
            const e = t.getSelectedElement();
            if (e && e.is("element", "rawHtml")) {
                return e
            }
            return null
        }

        var qD = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7.3 17.37l-.061.088a1.518 1.518 0 0 1-.934.535l-4.178.663-.806-4.153a1.495 1.495 0 0 1 .187-1.058l.056-.086L8.77 2.639c.958-1.351 2.803-1.076 4.296-.03 1.497 1.047 2.387 2.693 1.433 4.055L7.3 17.37zM9.14 4.728l-5.545 8.346 3.277 2.294 5.544-8.346L9.14 4.728zM6.07 16.512l-3.276-2.295.53 2.73 2.746-.435zM9.994 3.506L13.271 5.8c.316-.452-.16-1.333-1.065-1.966-.905-.634-1.895-.78-2.212-.328zM8 18.5L9.375 17H19v1.5H8z"/></svg>';
        var KD = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.972 16.615a.997.997 0 0 1-.744-.292l-4.596-4.596a1 1 0 1 1 1.414-1.414l3.926 3.926 9.937-9.937a1 1 0 0 1 1.414 1.415L7.717 16.323a.997.997 0 0 1-.745.292z"/></svg>';
        var GD = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.591 10.177l4.243 4.242a1 1 0 0 1-1.415 1.415l-4.242-4.243-4.243 4.243a1 1 0 0 1-1.414-1.415l4.243-4.242L4.52 5.934A1 1 0 0 1 5.934 4.52l4.243 4.243 4.242-4.243a1 1 0 1 1 1.415 1.414l-4.243 4.243z"/></svg>';
        var $D = n(38);
        var YD = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        YD.insert = "head";
        YD.singleton = true;
        var QD = ob()($D["a"], YD);
        var JD = $D["a"].locals || {};

        class XD extends tA {
            static get pluginName() {
                return "HtmlEmbedEditing"
            }

            constructor(t) {
                super(t);
                t.config.define("htmlEmbed", {
                    showPreviews: false, sanitizeHtml: t => {
                        Object(ss["c"])("html-embed-provide-sanitize-function");
                        return {html: t, hasChanged: false}
                    }
                })
            }

            init() {
                const t = this.editor;
                const e = t.model.schema;
                e.register("rawHtml", {isObject: true, allowWhere: "$block", allowAttributes: ["value"]});
                t.commands.add("updateHtmlEmbed", new UD(t));
                t.commands.add("insertHtmlEmbed", new jD(t));
                this._setupConversion()
            }

            _setupConversion() {
                const t = this.editor;
                const e = t.t;
                const n = t.editing.view;
                const i = t.config.get("htmlEmbed");
                const o = new OD(n.document);
                const r = new Qp(n.document);
                t.conversion.for("upcast").elementToElement({
                    view: {name: "div", classes: "raw-html-embed"},
                    model: (t, {writer: e}) => {
                        const n = o.createDocumentFragment(t.getChildren());
                        const i = r.toData(n);
                        return e.createElement("rawHtml", {value: i})
                    }
                });
                t.conversion.for("dataDowncast").elementToElement({
                    model: "rawHtml",
                    view: (t, {writer: e}) => e.createRawElement("div", {class: "raw-html-embed"}, (function (e) {
                        e.innerHTML = t.getAttribute("value") || ""
                    }))
                });
                t.conversion.for("editingDowncast").elementToElement({
                    triggerBy: {attributes: ["value"]}, model: "rawHtml", view: (o, {writer: r}) => {
                        let a, c, l;
                        const d = r.createContainerElement("div", {
                            class: "raw-html-embed",
                            "data-html-embed-label": e("HTML snippet")
                        });
                        const u = r.createRawElement("div", {class: "raw-html-embed__content-wrapper"}, (function (e) {
                            a = e;
                            s({domElement: e, editor: t, state: c, props: l})
                        }));
                        const h = {
                            makeEditable() {
                                c = Object.assign({}, c, {isEditable: true});
                                s({domElement: a, editor: t, state: c, props: l});
                                n.change((t => {
                                    t.setAttribute("data-cke-ignore-events", "true", u)
                                }));
                                a.querySelector("textarea").focus()
                            }, save(e) {
                                if (e !== c.getRawHtmlValue()) {
                                    t.execute("updateHtmlEmbed", e)
                                } else {
                                    this.cancel()
                                }
                            }, cancel() {
                                c = Object.assign({}, c, {isEditable: false});
                                s({domElement: a, editor: t, state: c, props: l});
                                n.change((t => {
                                    t.removeAttribute("data-cke-ignore-events", u)
                                }))
                            }
                        };
                        c = {
                            showPreviews: i.showPreviews,
                            isEditable: false,
                            getRawHtmlValue: () => o.getAttribute("value") || ""
                        };
                        l = {
                            sanitizeHtml: i.sanitizeHtml,
                            textareaPlaceholder: e("Paste raw HTML here..."),
                            onEditClick() {
                                h.makeEditable()
                            },
                            onSaveClick(t) {
                                h.save(t)
                            },
                            onCancelClick() {
                                h.cancel()
                            }
                        };
                        r.insert(r.createPositionAt(d, 0), u);
                        r.setCustomProperty("rawHtmlApi", h, d);
                        r.setCustomProperty("rawHtml", true, d);
                        return mD(d, r, {widgetLabel: e("HTML snippet"), hasSelectionHandle: true})
                    }
                });

                function s({domElement: t, editor: e, state: n, props: i}) {
                    t.textContent = "";
                    const o = t.ownerDocument;
                    let r;
                    if (n.isEditable) {
                        const e = {isDisabled: false, placeholder: i.textareaPlaceholder};
                        r = c({domDocument: o, state: n, props: e});
                        t.append(r)
                    } else if (n.showPreviews) {
                        const e = {sanitizeHtml: i.sanitizeHtml};
                        t.append(l({domDocument: o, state: n, props: e}))
                    } else {
                        const e = {isDisabled: true, placeholder: i.textareaPlaceholder};
                        t.append(c({domDocument: o, state: n, props: e}))
                    }
                    const s = {
                        onEditClick: i.onEditClick, onSaveClick: () => {
                            i.onSaveClick(r.value)
                        }, onCancelClick: i.onCancelClick
                    };
                    t.prepend(a({editor: e, domDocument: o, state: n, props: s}))
                }

                function a({editor: t, domDocument: e, state: n, props: i}) {
                    const o = ik(e, "div", {class: "raw-html-embed__buttons-wrapper"});
                    const r = ZD(t.locale, "edit");
                    const s = ZD(t.locale, "save");
                    const a = ZD(t.locale, "cancel");
                    if (n.isEditable) {
                        const t = s.cloneNode(true);
                        const e = a.cloneNode(true);
                        t.addEventListener("click", (t => {
                            t.preventDefault();
                            i.onSaveClick()
                        }));
                        e.addEventListener("click", (t => {
                            t.preventDefault();
                            i.onCancelClick()
                        }));
                        o.appendChild(t);
                        o.appendChild(e)
                    } else {
                        const t = r.cloneNode(true);
                        t.addEventListener("click", (t => {
                            t.preventDefault();
                            i.onEditClick()
                        }));
                        o.appendChild(t)
                    }
                    return o
                }

                function c({domDocument: t, state: e, props: n}) {
                    const i = ik(t, "textarea", {
                        placeholder: n.placeholder,
                        class: "ck ck-reset ck-input ck-input-text raw-html-embed__source"
                    });
                    i.disabled = n.isDisabled;
                    i.value = e.getRawHtmlValue();
                    return i
                }

                function l({domDocument: t, state: e, props: n}) {
                    const i = ik(t, "div", {class: "raw-html-embed__preview"});
                    const o = n.sanitizeHtml(e.getRawHtmlValue());
                    i.innerHTML = o.html;
                    return i
                }
            }
        }

        function ZD(t, e) {
            const n = t.t;
            const i = new sw(t);
            i.set({tooltipPosition: "sw", icon: qD, tooltip: true});
            i.render();
            if (e === "edit") {
                i.set({icon: qD, label: n("Edit source"), class: "raw-html-embed__edit-button"})
            } else if (e === "save") {
                i.set({icon: KD, label: n("Save changes"), class: "raw-html-embed__save-button"})
            } else {
                i.set({icon: GD, label: n("Cancel"), class: "raw-html-embed__cancel-button"})
            }
            i.destroy();
            return i.element.cloneNode(true)
        }

        var tT = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M17 0a2 2 0 0 1 2 2v7a1 1 0 0 1 1 1v5a1 1 0 0 1-.883.993l-.118.006L19 17a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2l-.001-1.001-.116-.006A1 1 0 0 1 0 15v-5a1 1 0 0 1 .999-1L1 2a2 2 0 0 1 2-2h14zm.499 15.999h-15L2.5 17a.5.5 0 0 0 .5.5h14a.5.5 0 0 0 .5-.5l-.001-1.001zm-3.478-6.013l-.014.014H14v.007l-1.525 1.525-1.46-1.46-.015.013V10h-1v5h1v-3.53l1.428 1.43.048.043.131-.129L14 11.421V15h1v-5h-.965l-.014-.014zM2 10H1v5h1v-2h2v2h1v-5H4v2H2v-2zm7 0H6v1h1v4h1v-4h1v-1zm8 0h-1v5h3v-1h-2v-4zm0-8.5H3a.5.5 0 0 0-.5.5l-.001 6.999h15L17.5 2a.5.5 0 0 0-.5-.5zM10 7v1H4V7h6zm3-2v1H4V5h9zm-3-2v1H4V3h6z"/></svg>';

        class eT extends tA {
            init() {
                const t = this.editor;
                const e = t.t;
                t.ui.componentFactory.add("htmlEmbed", (n => {
                    const i = t.commands.get("insertHtmlEmbed");
                    const o = new sw(n);
                    o.set({label: e("Insert HTML"), icon: tT, tooltip: true});
                    o.bind("isEnabled").to(i, "isEnabled");
                    this.listenTo(o, "execute", (() => {
                        t.execute("insertHtmlEmbed");
                        t.editing.view.focus();
                        const e = t.editing.view.document.selection.getSelectedElement();
                        e.getCustomProperty("rawHtmlApi").makeEditable()
                    }));
                    return o
                }))
            }
        }

        class nT extends tA {
            static get requires() {
                return [XD, eT]
            }

            static get pluginName() {
                return "HtmlEmbed"
            }
        }

        class iT extends Zd {
            observe(t) {
                this.listenTo(t, "load", ((t, e) => {
                    const n = e.target;
                    if (this.checkShouldIgnoreEventFromTarget(n)) {
                        return
                    }
                    if (n.tagName == "IMG") {
                        this._fireEvents(e)
                    }
                }), {useCapture: true})
            }

            _fireEvents(t) {
                if (this.isEnabled) {
                    this.document.fire("layoutChanged");
                    this.document.fire("imageLoaded", t)
                }
            }
        }

        function oT(t, e, n) {
            e.setCustomProperty("image", true, t);
            return mD(t, e, {label: i});

            function i() {
                const e = dT(t);
                const i = e.getAttribute("alt");
                return i ? `${i} ${n}` : n
            }
        }

        function rT(t) {
            return !!t.getCustomProperty("image") && hD(t)
        }

        function sT(t) {
            const e = t.getSelectedElement();
            if (e && rT(e)) {
                return e
            }
            return null
        }

        function aT(t) {
            return !!t && t.is("element", "image")
        }

        function cT(t, e, n = {}) {
            const i = t.createElement("image", n);
            const o = kD(e.document.selection, e);
            e.insertContent(i, o);
            if (i.parent) {
                t.setSelection(i, "on")
            }
        }

        function lT(t) {
            const e = t.schema;
            const n = t.document.selection;
            return uT(n, e, t) && !hT(n, e) && mT(n)
        }

        function dT(t) {
            const e = [];
            for (const n of t.getChildren()) {
                e.push(n);
                if (n.is("element")) {
                    e.push(...n.getChildren())
                }
            }
            return e.find((t => t.is("element", "img")))
        }

        function uT(t, e, n) {
            const i = gT(t, n);
            return e.checkChild(i, "image")
        }

        function hT(t, e) {
            const n = t.getSelectedElement();
            return n && e.isObject(n)
        }

        function mT(t) {
            return [...t.focus.getAncestors()].every((t => !t.is("element", "image")))
        }

        function gT(t, e) {
            const n = kD(t, e);
            const i = n.parent;
            if (i.isEmpty && !i.is("element", "$root")) {
                return i.parent
            }
            return i
        }

        function fT() {
            return e => {
                e.on("element:figure", t)
            };

            function t(t, e, n) {
                if (!n.consumable.test(e.viewItem, {name: true, classes: "image"})) {
                    return
                }
                const i = dT(e.viewItem);
                if (!i || !i.hasAttribute("src") || !n.consumable.test(i, {name: true})) {
                    return
                }
                const o = n.convertItem(i, e.modelCursor);
                const r = oA(o.modelRange.getItems());
                if (!r) {
                    return
                }
                n.convertChildren(e.viewItem, r);
                n.updateConversionResult(r, e)
            }
        }

        function pT() {
            return e => {
                e.on("attribute:srcset:image", t)
            };

            function t(t, e, n) {
                if (!n.consumable.consume(e.item, t.name)) {
                    return
                }
                const i = n.writer;
                const o = n.mapper.toViewElement(e.item);
                const r = dT(o);
                if (e.attributeNewValue === null) {
                    const t = e.attributeOldValue;
                    if (t.data) {
                        i.removeAttribute("srcset", r);
                        i.removeAttribute("sizes", r);
                        if (t.width) {
                            i.removeAttribute("width", r)
                        }
                    }
                } else {
                    const t = e.attributeNewValue;
                    if (t.data) {
                        i.setAttribute("srcset", t.data, r);
                        i.setAttribute("sizes", "100vw", r);
                        if (t.width) {
                            i.setAttribute("width", t.width, r)
                        }
                    }
                }
            }
        }

        function bT(t) {
            return n => {
                n.on(`attribute:${t}:image`, e)
            };

            function e(t, e, n) {
                if (!n.consumable.consume(e.item, t.name)) {
                    return
                }
                const i = n.writer;
                const o = n.mapper.toViewElement(e.item);
                const r = dT(o);
                i.setAttribute(e.attributeKey, e.attributeNewValue || "", r)
            }
        }

        class kT extends nA {
            refresh() {
                this.isEnabled = lT(this.editor.model)
            }

            execute(t) {
                const e = this.editor.model;
                e.change((n => {
                    const i = Array.isArray(t.source) ? t.source : [t.source];
                    for (const t of i) {
                        cT(n, e, {src: t})
                    }
                }))
            }
        }

        class wT extends tA {
            static get pluginName() {
                return "ImageEditing"
            }

            init() {
                const t = this.editor;
                const e = t.model.schema;
                const n = t.t;
                const i = t.conversion;
                t.editing.view.addObserver(iT);
                e.register("image", {
                    isObject: true,
                    isBlock: true,
                    allowWhere: "$block",
                    allowAttributes: ["alt", "src", "srcset"]
                });
                i.for("dataDowncast").elementToElement({model: "image", view: (t, {writer: e}) => AT(e)});
                i.for("editingDowncast").elementToElement({
                    model: "image",
                    view: (t, {writer: e}) => oT(AT(e), e, n("image widget"))
                });
                i.for("downcast").add(bT("src")).add(bT("alt")).add(pT());
                i.for("upcast").elementToElement({
                    view: {name: "img", attributes: {src: true}},
                    model: (t, {writer: e}) => e.createElement("image", {src: t.getAttribute("src")})
                }).attributeToAttribute({
                    view: {name: "img", key: "alt"},
                    model: "alt"
                }).attributeToAttribute({
                    view: {name: "img", key: "srcset"}, model: {
                        key: "srcset", value: t => {
                            const e = {data: t.getAttribute("srcset")};
                            if (t.hasAttribute("width")) {
                                e.width = t.getAttribute("width")
                            }
                            return e
                        }
                    }
                }).add(fT());
                t.commands.add("imageInsert", new kT(t))
            }
        }

        function AT(t) {
            const e = t.createEmptyElement("img");
            const n = t.createContainerElement("figure", {class: "image"});
            t.insert(t.createPositionAt(n, 0), e);
            return n
        }

        class _T extends eh {
            constructor(t) {
                super(t);
                this.domEventType = "mousedown"
            }

            onDomEvent(t) {
                this.fire(t.type, t)
            }
        }

        var CT = '<svg viewBox="0 0 10 8" xmlns="http://www.w3.org/2000/svg"><path d="M9.055.263v3.972h-6.77M1 4.216l2-2.038M1 4.178l2 2.038"/></svg>';
        var vT = n(39);
        var yT = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        yT.insert = "head";
        yT.singleton = true;
        var xT = ob()(vT["a"], yT);
        var ET = vT["a"].locals || {};
        const DT = ["before", "after"];
        const TT = (new DOMParser).parseFromString(CT, "image/svg+xml").firstChild;
        const MT = "ck-widget__type-around_disabled";

        class ST extends tA {
            static get pluginName() {
                return "WidgetTypeAround"
            }

            constructor(t) {
                super(t);
                this._currentFakeCaretModelElement = null
            }

            init() {
                const t = this.editor;
                const e = t.editing.view;
                this.on("change:isEnabled", ((n, i, o) => {
                    e.change((t => {
                        for (const n of e.document.roots) {
                            if (o) {
                                t.removeClass(MT, n)
                            } else {
                                t.addClass(MT, n)
                            }
                        }
                    }));
                    if (!o) {
                        t.model.change((t => {
                            t.removeSelectionAttribute(oD)
                        }))
                    }
                }));
                this._enableTypeAroundUIInjection();
                this._enableInsertingParagraphsOnButtonClick();
                this._enableInsertingParagraphsOnEnterKeypress();
                this._enableInsertingParagraphsOnTypingKeystroke();
                this._enableTypeAroundFakeCaretActivationUsingKeyboardArrows();
                this._enableDeleteIntegration();
                this._enableInsertContentIntegration()
            }

            destroy() {
                this._currentFakeCaretModelElement = null
            }

            _insertParagraph(t, e) {
                const n = this.editor;
                const i = n.editing.view;
                n.execute("insertParagraph", {position: n.model.createPositionAt(t, e)});
                i.focus();
                i.scrollToTheSelection()
            }

            _listenToIfEnabled(t, e, n, i) {
                this.listenTo(t, e, ((...t) => {
                    if (this.isEnabled) {
                        n(...t)
                    }
                }), i)
            }

            _insertParagraphAccordingToFakeCaretPosition() {
                const t = this.editor;
                const e = t.model;
                const n = e.document.selection;
                const i = lD(n);
                if (!i) {
                    return false
                }
                const o = n.getSelectedElement();
                this._insertParagraph(o, i);
                return true
            }

            _enableTypeAroundUIInjection() {
                const t = this.editor;
                const e = t.model.schema;
                const n = t.locale.t;
                const i = {before: n("Insert paragraph before block"), after: n("Insert paragraph after block")};
                t.editing.downcastDispatcher.on("insert", ((t, n, o) => {
                    const r = o.mapper.toViewElement(n.item);
                    if (rD(r, n.item, e)) {
                        IT(o.writer, i, r)
                    }
                }), {priority: "low"})
            }

            _enableTypeAroundFakeCaretActivationUsingKeyboardArrows() {
                const t = this.editor;
                const e = t.model;
                const n = e.document.selection;
                const i = e.schema;
                const o = t.editing.view;
                this._listenToIfEnabled(o.document, "keydown", ((t, e) => {
                    if (Rl(e.keyCode)) {
                        this._handleArrowKeyPress(t, e)
                    }
                }), {priority: os.get("high") + 10});
                this._listenToIfEnabled(n, "change:range", ((e, n) => {
                    if (!n.directChange) {
                        return
                    }
                    t.model.change((t => {
                        t.removeSelectionAttribute(oD)
                    }))
                }));
                this._listenToIfEnabled(e.document, "change:data", (() => {
                    const e = n.getSelectedElement();
                    if (e) {
                        const n = t.editing.mapper.toViewElement(e);
                        if (rD(n, e, i)) {
                            return
                        }
                    }
                    t.model.change((t => {
                        t.removeSelectionAttribute(oD)
                    }))
                }));
                this._listenToIfEnabled(t.editing.downcastDispatcher, "selection", ((t, e, n) => {
                    const o = n.writer;
                    if (this._currentFakeCaretModelElement) {
                        const t = n.mapper.toViewElement(this._currentFakeCaretModelElement);
                        if (t) {
                            o.removeClass(DT.map(r), t);
                            this._currentFakeCaretModelElement = null
                        }
                    }
                    const s = e.selection.getSelectedElement();
                    if (!s) {
                        return
                    }
                    const a = n.mapper.toViewElement(s);
                    if (!rD(a, s, i)) {
                        return
                    }
                    const c = lD(e.selection);
                    if (!c) {
                        return
                    }
                    o.addClass(r(c), a);
                    this._currentFakeCaretModelElement = s
                }));
                this._listenToIfEnabled(t.ui.focusTracker, "change:isFocused", ((e, n, i) => {
                    if (!i) {
                        t.model.change((t => {
                            t.removeSelectionAttribute(oD)
                        }))
                    }
                }));

                function r(t) {
                    return `ck-widget_type-around_show-fake-caret_${t}`
                }
            }

            _handleArrowKeyPress(t, e) {
                const n = this.editor;
                const i = n.model;
                const o = i.document.selection;
                const r = i.schema;
                const s = n.editing.view;
                const a = e.keyCode;
                const c = Vl(a, n.locale.contentLanguageDirection);
                const l = s.document.selection.getSelectedElement();
                const d = n.editing.mapper.toModelElement(l);
                let u;
                if (rD(l, d, r)) {
                    u = this._handleArrowKeyPressOnSelectedWidget(c)
                } else if (o.isCollapsed) {
                    u = this._handleArrowKeyPressWhenSelectionNextToAWidget(c)
                }
                if (u) {
                    e.preventDefault();
                    t.stop()
                }
            }

            _handleArrowKeyPressOnSelectedWidget(t) {
                const e = this.editor;
                const n = e.model;
                const i = n.document.selection;
                const o = lD(i);
                return n.change((e => {
                    if (o) {
                        const n = o === (t ? "after" : "before");
                        if (!n) {
                            e.removeSelectionAttribute(oD);
                            return true
                        }
                    } else {
                        e.setSelectionAttribute(oD, t ? "after" : "before");
                        return true
                    }
                    return false
                }))
            }

            _handleArrowKeyPressWhenSelectionNextToAWidget(t) {
                const e = this.editor;
                const n = e.model;
                const i = n.schema;
                const o = e.plugins.get("Widget");
                const r = o._getObjectElementNextToSelection(t);
                const s = e.editing.mapper.toViewElement(r);
                if (rD(s, r, i)) {
                    n.change((e => {
                        o._setSelectionOverElement(r);
                        e.setSelectionAttribute(oD, t ? "before" : "after")
                    }));
                    return true
                }
                return false
            }

            _enableInsertingParagraphsOnButtonClick() {
                const t = this.editor;
                const e = t.editing.view;
                this._listenToIfEnabled(e.document, "mousedown", ((n, i) => {
                    const o = sD(i.domTarget);
                    if (!o) {
                        return
                    }
                    const r = aD(o);
                    const s = cD(o, e.domConverter);
                    const a = t.editing.mapper.toModelElement(s);
                    this._insertParagraph(a, r);
                    i.preventDefault();
                    n.stop()
                }))
            }

            _enableInsertingParagraphsOnEnterKeypress() {
                const t = this.editor;
                const e = t.editing.view;
                this._listenToIfEnabled(e.document, "enter", ((n, i) => {
                    const o = e.document.selection.getSelectedElement();
                    const r = t.editing.mapper.toModelElement(o);
                    const s = t.model.schema;
                    let a;
                    if (this._insertParagraphAccordingToFakeCaretPosition()) {
                        a = true
                    } else if (rD(o, r, s)) {
                        this._insertParagraph(r, i.isSoft ? "before" : "after");
                        a = true
                    }
                    if (a) {
                        i.preventDefault();
                        n.stop()
                    }
                }))
            }

            _enableInsertingParagraphsOnTypingKeystroke() {
                const t = this.editor;
                const e = t.editing.view;
                const n = [Nl.enter, Nl.delete, Nl.backspace];
                this._listenToIfEnabled(e.document, "keydown", ((t, e) => {
                    if (!n.includes(e.keyCode) && !Wv(e)) {
                        this._insertParagraphAccordingToFakeCaretPosition()
                    }
                }), {priority: os.get("high") + 1})
            }

            _enableDeleteIntegration() {
                const t = this.editor;
                const e = t.editing.view;
                const n = t.model;
                const i = n.schema;
                this._listenToIfEnabled(e.document, "delete", ((e, o) => {
                    const r = lD(n.document.selection);
                    if (!r) {
                        return
                    }
                    const s = o.direction;
                    const a = n.document.selection.getSelectedElement();
                    const c = r === "before";
                    const l = s == "forward";
                    const d = c === l;
                    if (d) {
                        t.execute("delete", {selection: n.createSelection(a, "on")})
                    } else {
                        const e = i.getNearestSelectionRange(n.createPositionAt(a, r), s);
                        if (e) {
                            if (!e.isCollapsed) {
                                n.change((n => {
                                    n.setSelection(e);
                                    t.execute(l ? "forwardDelete" : "delete")
                                }))
                            } else {
                                const o = n.createSelection(e.start);
                                n.modifySelection(o, {direction: s});
                                if (!o.focus.isEqual(e.start)) {
                                    n.change((n => {
                                        n.setSelection(e);
                                        t.execute(l ? "forwardDelete" : "delete")
                                    }))
                                } else {
                                    const t = zT(i, e.start.parent);
                                    n.deleteContent(n.createSelection(t, "on"), {doNotAutoparagraph: true})
                                }
                            }
                        }
                    }
                    o.preventDefault();
                    e.stop()
                }), {priority: os.get("high") + 1})
            }

            _enableInsertContentIntegration() {
                const t = this.editor;
                const e = this.editor.model;
                const n = e.document.selection;
                this._listenToIfEnabled(t.model, "insertContent", ((t, [i, o]) => {
                    if (o && !o.is("documentSelection")) {
                        return
                    }
                    const r = lD(n);
                    if (!r) {
                        return
                    }
                    t.stop();
                    return e.change((t => {
                        const o = n.getSelectedElement();
                        const s = e.createPositionAt(o, r);
                        const a = t.createSelection(s);
                        const c = e.insertContent(i, a);
                        t.setSelection(a);
                        return c
                    }))
                }), {priority: "high"})
            }
        }

        function IT(t, e, n) {
            const i = t.createUIElement("div", {class: "ck ck-reset_all ck-widget__type-around"}, (function (t) {
                const n = this.toDomElement(t);
                BT(n, e);
                LT(n);
                return n
            }));
            t.insert(t.createPositionAt(n, "end"), i)
        }

        function BT(t, e) {
            for (const n of DT) {
                const i = new vb({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-widget__type-around__button", `ck-widget__type-around__button_${n}`],
                        title: e[n]
                    },
                    children: [t.ownerDocument.importNode(TT, true)]
                });
                t.appendChild(i.render())
            }
        }

        function LT(t) {
            const e = new vb({tag: "div", attributes: {class: ["ck", "ck-widget__type-around__fake-caret"]}});
            t.appendChild(e.render())
        }

        function zT(t, e) {
            let n = e;
            for (const i of e.getAncestors({parentFirst: true})) {
                if (i.childCount > 1 || t.isLimit(i)) {
                    break
                }
                n = i
            }
            return n
        }

        var NT = n(40);
        var PT = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        PT.insert = "head";
        PT.singleton = true;
        var OT = ob()(NT["a"], PT);
        var jT = NT["a"].locals || {};

        function RT(t) {
            const e = t.model;
            return (n, i) => {
                const o = i.keyCode == Nl.arrowup;
                const r = i.keyCode == Nl.arrowdown;
                const s = i.shiftKey;
                const a = e.document.selection;
                if (!o && !r) {
                    return
                }
                const c = r;
                if (s && WT(a, c)) {
                    return
                }
                const l = FT(t, a, c);
                if (!l || l.isCollapsed) {
                    return
                }
                if (UT(t, l, c)) {
                    e.change((t => {
                        const n = c ? l.end : l.start;
                        if (s) {
                            const i = e.createSelection(a.anchor);
                            i.setFocus(n);
                            t.setSelection(i)
                        } else {
                            t.setSelection(n)
                        }
                    }));
                    n.stop();
                    i.preventDefault();
                    i.stopPropagation()
                }
            }
        }

        function FT(t, e, n) {
            const i = t.model;
            if (n) {
                const t = e.isCollapsed ? e.focus : e.getLastPosition();
                const n = VT(i, t, "forward");
                if (!n) {
                    return null
                }
                const o = i.createRange(t, n);
                const r = HT(i.schema, o, "backward");
                if (r && t.isBefore(r)) {
                    return i.createRange(t, r)
                }
                return null
            } else {
                const t = e.isCollapsed ? e.focus : e.getFirstPosition();
                const n = VT(i, t, "backward");
                if (!n) {
                    return null
                }
                const o = i.createRange(n, t);
                const r = HT(i.schema, o, "forward");
                if (r && t.isAfter(r)) {
                    return i.createRange(r, t)
                }
                return null
            }
        }

        function VT(t, e, n) {
            const i = t.schema;
            const o = t.createRangeIn(e.root);
            const r = n == "forward" ? "elementStart" : "elementEnd";
            for (const {previousPosition: t, item: s, type: a} of o.getWalker({startPosition: e, direction: n})) {
                if (i.isLimit(s) && !i.isInline(s)) {
                    return t
                }
                if (a == r && i.isBlock(s)) {
                    return null
                }
            }
            return null
        }

        function HT(t, e, n) {
            const i = n == "backward" ? e.end : e.start;
            if (t.checkChild(i, "$text")) {
                return i
            }
            for (const {nextPosition: i} of e.getWalker({direction: n})) {
                if (t.checkChild(i, "$text")) {
                    return i
                }
            }
        }

        function UT(t, e, n) {
            const i = t.model;
            const o = t.view.domConverter;
            if (n) {
                const t = i.createSelection(e.start);
                i.modifySelection(t);
                if (!t.focus.isAtEnd && !e.start.isEqual(t.focus)) {
                    e = i.createRange(t.focus, e.end)
                }
            }
            const r = t.mapper.toViewRange(e);
            const s = o.viewRangeToDom(r);
            const a = Eh.getDomRangeRects(s);
            let c;
            for (const t of a) {
                if (c === undefined) {
                    c = Math.round(t.bottom);
                    continue
                }
                if (Math.round(t.top) >= c) {
                    return false
                }
                c = Math.max(c, Math.round(t.bottom))
            }
            return true
        }

        function WT(t, e) {
            return !t.isCollapsed && t.isBackward == e
        }

        class qT extends tA {
            static get pluginName() {
                return "Widget"
            }

            static get requires() {
                return [ST]
            }

            init() {
                const t = this.editor.editing.view;
                const e = t.document;
                this._previouslySelected = new Set;
                this.editor.editing.downcastDispatcher.on("selection", ((t, e, n) => {
                    this._clearPreviouslySelectedWidgets(n.writer);
                    const i = n.writer;
                    const o = i.document.selection;
                    const r = o.getSelectedElement();
                    let s = null;
                    for (const t of o.getRanges()) {
                        for (const e of t) {
                            const t = e.item;
                            if (hD(t) && !GT(t, s)) {
                                i.addClass(uD, t);
                                this._previouslySelected.add(t);
                                s = t;
                                if (t == r) {
                                    i.setSelection(o.getRanges(), {fake: true, label: pD(r)})
                                }
                            }
                        }
                    }
                }), {priority: "low"});
                t.addObserver(_T);
                this.listenTo(e, "mousedown", ((...t) => this._onMousedown(...t)));
                this.listenTo(e, "keydown", ((...t) => {
                    this._handleSelectionChangeOnArrowKeyPress(...t)
                }), {priority: "high"});
                this.listenTo(e, "keydown", ((...t) => {
                    this._preventDefaultOnArrowKeyPress(...t)
                }), {priority: os.get("high") - 20});
                this.listenTo(e, "keydown", RT(this.editor.editing));
                this.listenTo(e, "delete", ((t, e) => {
                    if (this._handleDelete(e.direction == "forward")) {
                        e.preventDefault();
                        t.stop()
                    }
                }), {priority: "high"})
            }

            _onMousedown(t, e) {
                const n = this.editor;
                const i = n.editing.view;
                const o = i.document;
                let r = e.target;
                if (KT(r)) {
                    if ((El.isSafari || El.isGecko) && e.domEvent.detail >= 3) {
                        const t = n.editing.mapper;
                        const i = r.is("attributeElement") ? r.findAncestor((t => !t.is("attributeElement"))) : r;
                        const o = t.toModelElement(i);
                        e.preventDefault();
                        this.editor.model.change((t => {
                            t.setSelection(o, "in")
                        }))
                    }
                    return
                }
                if (!hD(r)) {
                    r = r.findAncestor(hD);
                    if (!r) {
                        return
                    }
                }
                e.preventDefault();
                if (!o.isFocused) {
                    i.focus()
                }
                const s = n.editing.mapper.toModelElement(r);
                this._setSelectionOverElement(s)
            }

            _handleSelectionChangeOnArrowKeyPress(t, e) {
                const n = e.keyCode;
                if (!Rl(n)) {
                    return
                }
                const i = this.editor.model;
                const o = i.schema;
                const r = i.document.selection;
                const s = r.getSelectedElement();
                const a = Vl(n, this.editor.locale.contentLanguageDirection);
                if (s && o.isObject(s)) {
                    const n = a ? r.getLastPosition() : r.getFirstPosition();
                    const s = o.getNearestSelectionRange(n, a ? "forward" : "backward");
                    if (s) {
                        i.change((t => {
                            t.setSelection(s)
                        }));
                        e.preventDefault();
                        t.stop()
                    }
                    return
                }
                if (!r.isCollapsed) {
                    return
                }
                const c = this._getObjectElementNextToSelection(a);
                if (c && o.isObject(c)) {
                    this._setSelectionOverElement(c);
                    e.preventDefault();
                    t.stop()
                }
            }

            _preventDefaultOnArrowKeyPress(t, e) {
                const n = e.keyCode;
                if (!Rl(n)) {
                    return
                }
                const i = this.editor.model;
                const o = i.schema;
                const r = i.document.selection.getSelectedElement();
                if (r && o.isObject(r)) {
                    e.preventDefault();
                    t.stop()
                }
            }

            _handleDelete(t) {
                if (this.editor.isReadOnly) {
                    return
                }
                const e = this.editor.model.document;
                const n = e.selection;
                if (!n.isCollapsed) {
                    return
                }
                const i = this._getObjectElementNextToSelection(t);
                if (i) {
                    this.editor.model.change((t => {
                        let e = n.anchor.parent;
                        while (e.isEmpty) {
                            const n = e;
                            e = n.parent;
                            t.remove(n)
                        }
                        this._setSelectionOverElement(i)
                    }));
                    return true
                }
            }

            _setSelectionOverElement(t) {
                this.editor.model.change((e => {
                    e.setSelection(e.createRangeOn(t))
                }))
            }

            _getObjectElementNextToSelection(t) {
                const e = this.editor.model;
                const n = e.schema;
                const i = e.document.selection;
                const o = e.createSelection(i);
                e.modifySelection(o, {direction: t ? "forward" : "backward"});
                const r = t ? o.focus.nodeBefore : o.focus.nodeAfter;
                if (!!r && n.isObject(r)) {
                    return r
                }
                return null
            }

            _clearPreviouslySelectedWidgets(t) {
                for (const e of this._previouslySelected) {
                    t.removeClass(uD, e)
                }
                this._previouslySelected.clear()
            }
        }

        function KT(t) {
            while (t) {
                if (t.is("editableElement") && !t.is("rootElement")) {
                    return true
                }
                if (hD(t)) {
                    return false
                }
                t = t.parent
            }
            return false
        }

        function GT(t, e) {
            if (!e) {
                return false
            }
            return Array.from(t.getAncestors()).includes(e)
        }

        class $T extends nA {
            refresh() {
                const t = this.editor.model.document.selection.getSelectedElement();
                this.isEnabled = aT(t);
                if (aT(t) && t.hasAttribute("alt")) {
                    this.value = t.getAttribute("alt")
                } else {
                    this.value = false
                }
            }

            execute(t) {
                const e = this.editor.model;
                const n = e.document.selection.getSelectedElement();
                e.change((e => {
                    e.setAttribute("alt", t.newValue, n)
                }))
            }
        }

        class YT extends tA {
            static get pluginName() {
                return "ImageTextAlternativeEditing"
            }

            init() {
                this.editor.commands.add("imageTextAlternative", new $T(this.editor))
            }
        }

        var QT = n(41);
        var JT = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        JT.insert = "head";
        JT.singleton = true;
        var XT = ob()(QT["a"], JT);
        var ZT = QT["a"].locals || {};

        class tM extends Zb {
            constructor(t, e) {
                super(t);
                const n = `ck-labeled-field-view-${ns()}`;
                const i = `ck-labeled-field-view-status-${ns()}`;
                this.fieldView = e(this, n, i);
                this.set("label");
                this.set("isEnabled", true);
                this.set("errorText", null);
                this.set("infoText", null);
                this.set("class");
                this.labelView = this._createLabelView(n);
                this.statusView = this._createStatusView(i);
                this.bind("_statusText").to(this, "errorText", this, "infoText", ((t, e) => t || e));
                const o = this.bindTemplate;
                this.setTemplate({
                    tag: "div",
                    attributes: {class: ["ck", "ck-labeled-field-view", o.to("class"), o.if("isEnabled", "ck-disabled", (t => !t))]},
                    children: [this.labelView, this.fieldView, this.statusView]
                })
            }

            _createLabelView(t) {
                const e = new gk(this.locale);
                e.for = t;
                e.bind("text").to(this, "label");
                return e
            }

            _createStatusView(t) {
                const e = new Zb(this.locale);
                const n = this.bindTemplate;
                e.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-labeled-field-view__status", n.if("errorText", "ck-labeled-field-view__status_error"), n.if("_statusText", "ck-hidden", (t => !t))],
                        id: t,
                        role: n.if("errorText", "alert")
                    },
                    children: [{text: n.to("_statusText")}]
                });
                return e
            }

            focus() {
                this.fieldView.focus()
            }
        }

        var eM = n(42);
        var nM = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        nM.insert = "head";
        nM.singleton = true;
        var iM = ob()(eM["a"], nM);
        var oM = eM["a"].locals || {};

        class rM extends Zb {
            constructor(t) {
                super(t);
                this.set("value");
                this.set("id");
                this.set("placeholder");
                this.set("isReadOnly", false);
                this.set("hasError", false);
                this.set("ariaDescribedById");
                const e = this.bindTemplate;
                this.setTemplate({
                    tag: "input",
                    attributes: {
                        type: "text",
                        class: ["ck", "ck-input", "ck-input-text", e.if("hasError", "ck-error")],
                        id: e.to("id"),
                        placeholder: e.to("placeholder"),
                        readonly: e.to("isReadOnly"),
                        "aria-invalid": e.if("hasError", true),
                        "aria-describedby": e.to("ariaDescribedById")
                    },
                    on: {input: e.to("input")}
                })
            }

            render() {
                super.render();
                const t = t => {
                    this.element.value = !t && t !== 0 ? "" : t
                };
                t(this.value);
                this.on("change:value", ((e, n, i) => {
                    t(i)
                }))
            }

            select() {
                this.element.select()
            }

            focus() {
                this.element.focus()
            }
        }

        function sM(t, e, n) {
            const i = new rM(t.locale);
            i.set({id: e, ariaDescribedById: n});
            i.bind("isReadOnly").to(t, "isEnabled", (t => !t));
            i.bind("hasError").to(t, "errorText", (t => !!t));
            i.on("input", (() => {
                t.errorText = null
            }));
            return i
        }

        function aM(t, e, n) {
            const i = Sw(t.locale);
            i.set({id: e, ariaDescribedById: n});
            i.bind("isEnabled").to(t);
            return i
        }

        function cM({view: t}) {
            t.listenTo(t.element, "submit", ((e, n) => {
                n.preventDefault();
                t.fire("submit")
            }), {useCapture: true})
        }

        var lM = n(43);
        var dM = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        dM.insert = "head";
        dM.singleton = true;
        var uM = ob()(lM["a"], dM);
        var hM = lM["a"].locals || {};
        var mM = n(44);
        var gM = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        gM.insert = "head";
        gM.singleton = true;
        var fM = ob()(mM["a"], gM);
        var pM = mM["a"].locals || {};

        class bM extends Zb {
            constructor(t) {
                super(t);
                const e = this.locale.t;
                this.focusTracker = new Zp;
                this.keystrokes = new Fp;
                this.labeledInput = this._createLabeledInputView();
                this.saveButtonView = this._createButton(e("Save"), KD, "ck-button-save");
                this.saveButtonView.type = "submit";
                this.cancelButtonView = this._createButton(e("Cancel"), GD, "ck-button-cancel", "cancel");
                this._focusables = new Ab;
                this._focusCycler = new xk({
                    focusables: this._focusables,
                    focusTracker: this.focusTracker,
                    keystrokeHandler: this.keystrokes,
                    actions: {focusPrevious: "shift + tab", focusNext: "tab"}
                });
                this.setTemplate({
                    tag: "form",
                    attributes: {class: ["ck", "ck-text-alternative-form", "ck-responsive-form"], tabindex: "-1"},
                    children: [this.labeledInput, this.saveButtonView, this.cancelButtonView]
                })
            }

            render() {
                super.render();
                this.keystrokes.listenTo(this.element);
                cM({view: this});
                [this.labeledInput, this.saveButtonView, this.cancelButtonView].forEach((t => {
                    this._focusables.add(t);
                    this.focusTracker.add(t.element)
                }))
            }

            _createButton(t, e, n, i) {
                const o = new sw(this.locale);
                o.set({label: t, icon: e, tooltip: true});
                o.extendTemplate({attributes: {class: n}});
                if (i) {
                    o.delegate("execute").to(this, i)
                }
                return o
            }

            _createLabeledInputView() {
                const t = this.locale.t;
                const e = new tM(this.locale, sM);
                e.label = t("Text alternative");
                e.fieldView.placeholder = t("Text alternative");
                return e
            }
        }

        var kM = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.463 5.187a.888.888 0 1 1 1.254 1.255L9.16 10l3.557 3.557a.888.888 0 1 1-1.254 1.255L7.26 10.61a.888.888 0 0 1 .16-1.382l4.043-4.042z"/></svg>';
        var wM = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.537 14.813a.888.888 0 1 1-1.254-1.255L10.84 10 7.283 6.442a.888.888 0 1 1 1.254-1.255L12.74 9.39a.888.888 0 0 1-.16 1.382l-4.043 4.042z"/></svg>';
        var AM = n(45);
        var _M = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        _M.insert = "head";
        _M.singleton = true;
        var CM = ob()(AM["a"], _M);
        var vM = AM["a"].locals || {};
        var yM = n(46);
        var xM = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        xM.insert = "head";
        xM.singleton = true;
        var EM = ob()(yM["a"], xM);
        var DM = yM["a"].locals || {};
        const TM = kk("px");

        class MM extends tA {
            static get pluginName() {
                return "ContextualBalloon"
            }

            constructor(t) {
                super(t);
                this.positionLimiter = () => {
                    const t = this.editor.editing.view;
                    const e = t.document;
                    const n = e.selection.editableElement;
                    if (n) {
                        return t.domConverter.mapViewToDom(n.root)
                    }
                    return null
                };
                this.set("visibleView", null);
                this.view = new ZE(t.locale);
                t.ui.view.body.add(this.view);
                t.ui.focusTracker.add(this.view.element);
                this._viewToStack = new Map;
                this._idToStack = new Map;
                this.set("_numberOfStacks", 0);
                this.set("_singleViewMode", false);
                this._rotatorView = this._createRotatorView();
                this._fakePanelsView = this._createFakePanelsView()
            }

            hasView(t) {
                return Array.from(this._viewToStack.keys()).includes(t)
            }

            add(t) {
                if (this.hasView(t.view)) {
                    throw new ss["a"]("contextualballoon-add-view-exist", [this, t])
                }
                const e = t.stackId || "main";
                if (!this._idToStack.has(e)) {
                    this._idToStack.set(e, new Map([[t.view, t]]));
                    this._viewToStack.set(t.view, this._idToStack.get(e));
                    this._numberOfStacks = this._idToStack.size;
                    if (!this._visibleStack || t.singleViewMode) {
                        this.showStack(e)
                    }
                    return
                }
                const n = this._idToStack.get(e);
                if (t.singleViewMode) {
                    this.showStack(e)
                }
                n.set(t.view, t);
                this._viewToStack.set(t.view, n);
                if (n === this._visibleStack) {
                    this._showView(t)
                }
            }

            remove(t) {
                if (!this.hasView(t)) {
                    throw new ss["a"]("contextualballoon-remove-view-not-exist", [this, t])
                }
                const e = this._viewToStack.get(t);
                if (this._singleViewMode && this.visibleView === t) {
                    this._singleViewMode = false
                }
                if (this.visibleView === t) {
                    if (e.size === 1) {
                        if (this._idToStack.size > 1) {
                            this._showNextStack()
                        } else {
                            this.view.hide();
                            this.visibleView = null;
                            this._rotatorView.hideView()
                        }
                    } else {
                        this._showView(Array.from(e.values())[e.size - 2])
                    }
                }
                if (e.size === 1) {
                    this._idToStack.delete(this._getStackId(e));
                    this._numberOfStacks = this._idToStack.size
                } else {
                    e.delete(t)
                }
                this._viewToStack.delete(t)
            }

            updatePosition(t) {
                if (t) {
                    this._visibleStack.get(this.visibleView).position = t
                }
                this.view.pin(this._getBalloonPosition());
                this._fakePanelsView.updatePosition()
            }

            showStack(t) {
                this.visibleStack = t;
                const e = this._idToStack.get(t);
                if (!e) {
                    throw new ss["a"]("contextualballoon-showstack-stack-not-exist", this)
                }
                if (this._visibleStack === e) {
                    return
                }
                this._showView(Array.from(e.values()).pop())
            }

            get _visibleStack() {
                return this._viewToStack.get(this.visibleView)
            }

            _getStackId(t) {
                const e = Array.from(this._idToStack.entries()).find((e => e[1] === t));
                return e[0]
            }

            _showNextStack() {
                const t = Array.from(this._idToStack.values());
                let e = t.indexOf(this._visibleStack) + 1;
                if (!t[e]) {
                    e = 0
                }
                this.showStack(this._getStackId(t[e]))
            }

            _showPrevStack() {
                const t = Array.from(this._idToStack.values());
                let e = t.indexOf(this._visibleStack) - 1;
                if (!t[e]) {
                    e = t.length - 1
                }
                this.showStack(this._getStackId(t[e]))
            }

            _createRotatorView() {
                const t = new SM(this.editor.locale);
                const e = this.editor.locale.t;
                this.view.content.add(t);
                t.bind("isNavigationVisible").to(this, "_numberOfStacks", this, "_singleViewMode", ((t, e) => !e && t > 1));
                t.on("change:isNavigationVisible", (() => this.updatePosition()), {priority: "low"});
                t.bind("counter").to(this, "visibleView", this, "_numberOfStacks", ((t, n) => {
                    if (n < 2) {
                        return ""
                    }
                    const i = Array.from(this._idToStack.values()).indexOf(this._visibleStack) + 1;
                    return e("%0 of %1", [i, n])
                }));
                t.buttonNextView.on("execute", (() => {
                    if (t.focusTracker.isFocused) {
                        this.editor.editing.view.focus()
                    }
                    this._showNextStack()
                }));
                t.buttonPrevView.on("execute", (() => {
                    if (t.focusTracker.isFocused) {
                        this.editor.editing.view.focus()
                    }
                    this._showPrevStack()
                }));
                return t
            }

            _createFakePanelsView() {
                const t = new IM(this.editor.locale, this.view);
                t.bind("numberOfPanels").to(this, "_numberOfStacks", this, "_singleViewMode", ((t, e) => {
                    const n = !e && t >= 2;
                    return n ? Math.min(t - 1, 2) : 0
                }));
                t.listenTo(this.view, "change:top", (() => t.updatePosition()));
                t.listenTo(this.view, "change:left", (() => t.updatePosition()));
                this.editor.ui.view.body.add(t);
                return t
            }

            _showView({view: t, balloonClassName: e = "", withArrow: n = true, singleViewMode: i = false}) {
                this.view.class = e;
                this.view.withArrow = n;
                this._rotatorView.showView(t);
                this.visibleView = t;
                this.view.pin(this._getBalloonPosition());
                this._fakePanelsView.updatePosition();
                if (i) {
                    this._singleViewMode = true
                }
            }

            _getBalloonPosition() {
                let t = Array.from(this._visibleStack.values()).pop().position;
                if (t && !t.limiter) {
                    t = Object.assign({}, t, {limiter: this.positionLimiter})
                }
                return t
            }
        }

        class SM extends Zb {
            constructor(t) {
                super(t);
                const e = t.t;
                const n = this.bindTemplate;
                this.set("isNavigationVisible", true);
                this.focusTracker = new Zp;
                this.buttonPrevView = this._createButtonView(e("Previous"), kM);
                this.buttonNextView = this._createButtonView(e("Next"), wM);
                this.content = this.createCollection();
                this.setTemplate({
                    tag: "div",
                    attributes: {class: ["ck", "ck-balloon-rotator"], "z-index": "-1"},
                    children: [{
                        tag: "div",
                        attributes: {class: ["ck-balloon-rotator__navigation", n.to("isNavigationVisible", (t => t ? "" : "ck-hidden"))]},
                        children: [this.buttonPrevView, {
                            tag: "span",
                            attributes: {class: ["ck-balloon-rotator__counter"]},
                            children: [{text: n.to("counter")}]
                        }, this.buttonNextView]
                    }, {tag: "div", attributes: {class: "ck-balloon-rotator__content"}, children: this.content}]
                })
            }

            render() {
                super.render();
                this.focusTracker.add(this.element)
            }

            showView(t) {
                this.hideView();
                this.content.add(t)
            }

            hideView() {
                this.content.clear()
            }

            _createButtonView(t, e) {
                const n = new sw(this.locale);
                n.set({label: t, icon: e, tooltip: true});
                return n
            }
        }

        class IM extends Zb {
            constructor(t, e) {
                super(t);
                const n = this.bindTemplate;
                this.set("top", 0);
                this.set("left", 0);
                this.set("height", 0);
                this.set("width", 0);
                this.set("numberOfPanels", 0);
                this.content = this.createCollection();
                this._balloonPanelView = e;
                this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck-fake-panel", n.to("numberOfPanels", (t => t ? "" : "ck-hidden"))],
                        style: {
                            top: n.to("top", TM),
                            left: n.to("left", TM),
                            width: n.to("width", TM),
                            height: n.to("height", TM)
                        }
                    },
                    children: this.content
                });
                this.on("change:numberOfPanels", ((t, e, n, i) => {
                    if (n > i) {
                        this._addPanels(n - i)
                    } else {
                        this._removePanels(i - n)
                    }
                    this.updatePosition()
                }))
            }

            _addPanels(t) {
                while (t--) {
                    const t = new Zb;
                    t.setTemplate({tag: "div"});
                    this.content.add(t);
                    this.registerChild(t)
                }
            }

            _removePanels(t) {
                while (t--) {
                    const t = this.content.last;
                    this.content.remove(t);
                    this.deregisterChild(t);
                    t.destroy()
                }
            }

            updatePosition() {
                if (this.numberOfPanels) {
                    const {top: t, left: e} = this._balloonPanelView;
                    const {width: n, height: i} = new Eh(this._balloonPanelView.element);
                    Object.assign(this, {top: t, left: e, width: n, height: i})
                }
            }
        }

        var BM = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5.085 6.22L2.943 4.078a.75.75 0 1 1 1.06-1.06l2.592 2.59A11.094 11.094 0 0 1 10 5.068c4.738 0 8.578 3.101 8.578 5.083 0 1.197-1.401 2.803-3.555 3.887l1.714 1.713a.75.75 0 0 1-.09 1.138.488.488 0 0 1-.15.084.75.75 0 0 1-.821-.16L6.17 7.304c-.258.11-.51.233-.757.365l6.239 6.24-.006.005.78.78c-.388.094-.78.166-1.174.215l-1.11-1.11h.011L4.55 8.197a7.2 7.2 0 0 0-.665.514l-.112.098 4.897 4.897-.005.006 1.276 1.276a10.164 10.164 0 0 1-1.477-.117l-.479-.479-.009.009-4.863-4.863-.022.031a2.563 2.563 0 0 0-.124.2c-.043.077-.08.158-.108.241a.534.534 0 0 0-.028.133.29.29 0 0 0 .008.072.927.927 0 0 0 .082.226c.067.133.145.26.234.379l3.242 3.365.025.01.59.623c-3.265-.918-5.59-3.155-5.59-4.668 0-1.194 1.448-2.838 3.663-3.93zm7.07.531a4.632 4.632 0 0 1 1.108 5.992l.345.344.046-.018a9.313 9.313 0 0 0 2-1.112c.256-.187.5-.392.727-.613.137-.134.27-.277.392-.431.072-.091.141-.185.203-.286.057-.093.107-.19.148-.292a.72.72 0 0 0 .036-.12.29.29 0 0 0 .008-.072.492.492 0 0 0-.028-.133.999.999 0 0 0-.036-.096 2.165 2.165 0 0 0-.071-.145 2.917 2.917 0 0 0-.125-.2 3.592 3.592 0 0 0-.263-.335 5.444 5.444 0 0 0-.53-.523 7.955 7.955 0 0 0-1.054-.768 9.766 9.766 0 0 0-1.879-.891c-.337-.118-.68-.219-1.027-.301zm-2.85.21l-.069.002a.508.508 0 0 0-.254.097.496.496 0 0 0-.104.679.498.498 0 0 0 .326.199l.045.005c.091.003.181.003.272.012a2.45 2.45 0 0 1 2.017 1.513c.024.061.043.125.069.185a.494.494 0 0 0 .45.287h.008a.496.496 0 0 0 .35-.158.482.482 0 0 0 .13-.335.638.638 0 0 0-.048-.219 3.379 3.379 0 0 0-.36-.723 3.438 3.438 0 0 0-2.791-1.543l-.028-.001h-.013z"/></svg>';

        function LM(t) {
            const e = t.plugins.get("ContextualBalloon");
            if (sT(t.editing.view.document.selection)) {
                const n = zM(t);
                e.updatePosition(n)
            }
        }

        function zM(t) {
            const e = t.editing.view;
            const n = ZE.defaultPositions;
            return {
                target: e.domConverter.viewToDom(e.document.selection.getSelectedElement()),
                positions: [n.northArrowSouth, n.northArrowSouthWest, n.northArrowSouthEast, n.southArrowNorth, n.southArrowNorthWest, n.southArrowNorthEast]
            }
        }

        class NM extends tA {
            static get requires() {
                return [MM]
            }

            static get pluginName() {
                return "ImageTextAlternativeUI"
            }

            init() {
                this._createButton();
                this._createForm()
            }

            destroy() {
                super.destroy();
                this._form.destroy()
            }

            _createButton() {
                const t = this.editor;
                const e = t.t;
                t.ui.componentFactory.add("imageTextAlternative", (n => {
                    const i = t.commands.get("imageTextAlternative");
                    const o = new sw(n);
                    o.set({label: e("Change image text alternative"), icon: BM, tooltip: true});
                    o.bind("isEnabled").to(i, "isEnabled");
                    this.listenTo(o, "execute", (() => {
                        this._showForm()
                    }));
                    return o
                }))
            }

            _createForm() {
                const t = this.editor;
                const e = t.editing.view;
                const n = e.document;
                this._balloon = this.editor.plugins.get("ContextualBalloon");
                this._form = new bM(t.locale);
                this._form.render();
                this.listenTo(this._form, "submit", (() => {
                    t.execute("imageTextAlternative", {newValue: this._form.labeledInput.fieldView.element.value});
                    this._hideForm(true)
                }));
                this.listenTo(this._form, "cancel", (() => {
                    this._hideForm(true)
                }));
                this._form.keystrokes.set("Esc", ((t, e) => {
                    this._hideForm(true);
                    e()
                }));
                this.listenTo(t.ui, "update", (() => {
                    if (!sT(n.selection)) {
                        this._hideForm(true)
                    } else if (this._isVisible) {
                        LM(t)
                    }
                }));
                _w({
                    emitter: this._form,
                    activator: () => this._isVisible,
                    contextElements: [this._balloon.view.element],
                    callback: () => this._hideForm()
                })
            }

            _showForm() {
                if (this._isVisible) {
                    return
                }
                const t = this.editor;
                const e = t.commands.get("imageTextAlternative");
                const n = this._form.labeledInput;
                if (!this._isInBalloon) {
                    this._balloon.add({view: this._form, position: zM(t)})
                }
                n.fieldView.value = n.fieldView.element.value = e.value || "";
                this._form.labeledInput.fieldView.select()
            }

            _hideForm(t) {
                if (!this._isInBalloon) {
                    return
                }
                if (this._form.focusTracker.isFocused) {
                    this._form.saveButtonView.focus()
                }
                this._balloon.remove(this._form);
                if (t) {
                    this.editor.editing.view.focus()
                }
            }

            get _isVisible() {
                return this._balloon.visibleView === this._form
            }

            get _isInBalloon() {
                return this._balloon.hasView(this._form)
            }
        }

        class PM extends tA {
            static get requires() {
                return [YT, NM]
            }

            static get pluginName() {
                return "ImageTextAlternative"
            }
        }

        var OM = n(47);
        var jM = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        jM.insert = "head";
        jM.singleton = true;
        var RM = ob()(OM["a"], jM);
        var FM = OM["a"].locals || {};

        class VM extends tA {
            static get requires() {
                return [wT, qT, PM]
            }

            static get pluginName() {
                return "Image"
            }
        }

        function HM(t, e) {
            return n => {
                const i = n.createEditableElement("figcaption");
                n.setCustomProperty("imageCaption", true, i);
                db({view: t, element: i, text: e});
                return bD(i, n)
            }
        }

        function UM(t) {
            return !!t.getCustomProperty("imageCaption")
        }

        function WM(t) {
            for (const e of t.getChildren()) {
                if (!!e && e.is("element", "caption")) {
                    return e
                }
            }
            return null
        }

        function qM(t) {
            const e = t.parent;
            if (t.name == "figcaption" && e && e.name == "figure" && e.hasClass("image")) {
                return {name: true}
            }
            return null
        }

        class KM extends tA {
            static get pluginName() {
                return "ImageCaptionEditing"
            }

            init() {
                const t = this.editor;
                const e = t.editing.view;
                const n = t.model.schema;
                const i = t.data;
                const o = t.editing;
                const r = t.t;
                n.register("caption", {allowIn: "image", allowContentOf: "$block", isLimit: true});
                t.model.document.registerPostFixer((t => this._insertMissingModelCaptionElement(t)));
                t.conversion.for("upcast").elementToElement({view: qM, model: "caption"});
                const s = t => t.createContainerElement("figcaption");
                i.downcastDispatcher.on("insert:caption", GM(s, false));
                const a = HM(e, r("Enter image caption"));
                o.downcastDispatcher.on("insert:caption", GM(a));
                o.downcastDispatcher.on("insert", this._fixCaptionVisibility((t => t.item)), {priority: "high"});
                o.downcastDispatcher.on("remove", this._fixCaptionVisibility((t => t.position.parent)), {priority: "high"});
                e.document.registerPostFixer((t => this._updateCaptionVisibility(t)))
            }

            _updateCaptionVisibility(t) {
                const e = this.editor.editing.mapper;
                const n = this._lastSelectedCaption;
                let i;
                const o = this.editor.model.document.selection;
                const r = o.getSelectedElement();
                if (r && r.is("element", "image")) {
                    const t = WM(r);
                    i = e.toViewElement(t)
                }
                const s = o.getFirstPosition();
                const a = YM(s.parent);
                if (a) {
                    i = e.toViewElement(a)
                }
                if (i) {
                    if (n) {
                        if (n === i) {
                            return JM(i, t)
                        } else {
                            QM(n, t);
                            this._lastSelectedCaption = i;
                            return JM(i, t)
                        }
                    } else {
                        this._lastSelectedCaption = i;
                        return JM(i, t)
                    }
                } else {
                    if (n) {
                        const e = QM(n, t);
                        this._lastSelectedCaption = null;
                        return e
                    } else {
                        return false
                    }
                }
            }

            _fixCaptionVisibility(t) {
                return (e, n, i) => {
                    const o = t(n);
                    const r = YM(o);
                    const s = this.editor.editing.mapper;
                    const a = i.writer;
                    if (r) {
                        const t = s.toViewElement(r);
                        if (t) {
                            if (r.childCount) {
                                a.removeClass("ck-hidden", t)
                            } else {
                                a.addClass("ck-hidden", t)
                            }
                        }
                    }
                }
            }

            _insertMissingModelCaptionElement(t) {
                const e = this.editor.model;
                const n = e.document.differ.getChanges();
                const i = [];
                for (const t of n) {
                    if (t.type == "insert" && t.name != "$text") {
                        const n = t.position.nodeAfter;
                        if (n.is("element", "image") && !WM(n)) {
                            i.push(n)
                        }
                        if (!n.is("element", "image") && n.childCount) {
                            for (const t of e.createRangeIn(n).getItems()) {
                                if (t.is("element", "image") && !WM(t)) {
                                    i.push(t)
                                }
                            }
                        }
                    }
                }
                for (const e of i) {
                    t.appendElement("caption", e)
                }
                return !!i.length
            }
        }

        function GM(t, e = true) {
            return (n, i, o) => {
                const r = i.item;
                if (!r.childCount && !e) {
                    return
                }
                if (aT(r.parent)) {
                    if (!o.consumable.consume(i.item, "insert")) {
                        return
                    }
                    const e = o.mapper.toViewElement(i.range.start.parent);
                    const n = t(o.writer);
                    const s = o.writer;
                    if (!r.childCount) {
                        s.addClass("ck-hidden", n)
                    }
                    $M(n, i.item, e, o)
                }
            }
        }

        function $M(t, e, n, i) {
            const o = i.writer.createPositionAt(n, "end");
            i.writer.insert(o, t);
            i.mapper.bindElements(e, t)
        }

        function YM(t) {
            const e = t.getAncestors({includeSelf: true});
            const n = e.find((t => t.name == "caption"));
            if (n && n.parent && n.parent.name == "image") {
                return n
            }
            return null
        }

        function QM(t, e) {
            if (!t.childCount && !t.hasClass("ck-hidden")) {
                e.addClass("ck-hidden", t);
                return true
            }
            return false
        }

        function JM(t, e) {
            if (t.hasClass("ck-hidden")) {
                e.removeClass("ck-hidden", t);
                return true
            }
            return false
        }

        var XM = n(48);
        var ZM = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        ZM.insert = "head";
        ZM.singleton = true;
        var tS = ob()(XM["a"], ZM);
        var eS = XM["a"].locals || {};

        class nS extends tA {
            static get requires() {
                return [KM]
            }

            static get pluginName() {
                return "ImageCaption"
            }
        }

        class iS extends Zb {
            constructor(t) {
                super(t);
                this.buttonView = new sw(t);
                this._fileInputView = new oS(t);
                this._fileInputView.bind("acceptedType").to(this);
                this._fileInputView.bind("allowMultipleFiles").to(this);
                this._fileInputView.delegate("done").to(this);
                this.setTemplate({
                    tag: "span",
                    attributes: {class: "ck-file-dialog-button"},
                    children: [this.buttonView, this._fileInputView]
                });
                this.buttonView.on("execute", (() => {
                    this._fileInputView.open()
                }))
            }

            focus() {
                this.buttonView.focus()
            }
        }

        class oS extends Zb {
            constructor(t) {
                super(t);
                this.set("acceptedType");
                this.set("allowMultipleFiles", false);
                const e = this.bindTemplate;
                this.setTemplate({
                    tag: "input",
                    attributes: {
                        class: ["ck-hidden"],
                        type: "file",
                        tabindex: "-1",
                        accept: e.to("acceptedType"),
                        multiple: e.to("allowMultipleFiles")
                    },
                    on: {
                        change: e.to((() => {
                            if (this.element && this.element.files && this.element.files.length) {
                                this.fire("done", this.element.files)
                            }
                            this.element.value = ""
                        }))
                    }
                })
            }

            open() {
                this.element.click()
            }
        }

        function rS(t) {
            const e = t.map((t => t.replace("+", "\\+")));
            return new RegExp(`^image\\/(${e.join("|")})$`)
        }

        function sS(t) {
            return new Promise(((e, n) => {
                const i = t.getAttribute("src");
                fetch(i).then((t => t.blob())).then((t => {
                    const n = cS(t, i);
                    const o = n.replace("image/", "");
                    const r = `image.${o}`;
                    const s = new File([t], r, {type: n});
                    e(s)
                })).catch(n)
            }))
        }

        function aS(t) {
            if (!t.is("element", "img") || !t.getAttribute("src")) {
                return false
            }
            return t.getAttribute("src").match(/^data:image\/\w+;base64,/g) || t.getAttribute("src").match(/^blob:/g)
        }

        function cS(t, e) {
            if (t.type) {
                return t.type
            } else if (e.match(/data:(image\/\w+);base64/)) {
                return e.match(/data:(image\/\w+);base64/)[1].toLowerCase()
            } else {
                return "image/jpeg"
            }
        }

        var lS = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.91 10.54c.26-.23.64-.21.88.03l3.36 3.14 2.23-2.06a.64.64 0 0 1 .87 0l2.52 2.97V4.5H3.2v10.12l3.71-4.08zm10.27-7.51c.6 0 1.09.47 1.09 1.05v11.84c0 .59-.49 1.06-1.09 1.06H2.79c-.6 0-1.09-.47-1.09-1.06V4.08c0-.58.49-1.05 1.1-1.05h14.38zm-5.22 5.56a1.96 1.96 0 1 1 3.4-1.96 1.96 1.96 0 0 1-3.4 1.96z"/></svg>';

        class dS extends tA {
            static get pluginName() {
                return "ImageUploadUI"
            }

            init() {
                const t = this.editor;
                const e = t.t;
                t.ui.componentFactory.add("imageUpload", (n => {
                    const i = new iS(n);
                    const o = t.commands.get("imageUpload");
                    const r = t.config.get("image.upload.types");
                    const s = rS(r);
                    i.set({acceptedType: r.map((t => `image/${t}`)).join(","), allowMultipleFiles: true});
                    i.buttonView.set({label: e("Insert image"), icon: lS, tooltip: true});
                    i.buttonView.bind("isEnabled").to(o);
                    i.on("done", ((e, n) => {
                        const i = Array.from(n).filter((t => s.test(t.type)));
                        if (i.length) {
                            t.execute("imageUpload", {file: i})
                        }
                    }));
                    return i
                }))
            }
        }

        var uS = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 700 250"><rect rx="4"/></svg>';
        var hS = n(49);
        var mS = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        mS.insert = "head";
        mS.singleton = true;
        var gS = ob()(hS["a"], mS);
        var fS = hS["a"].locals || {};
        var pS = n(50);
        var bS = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        bS.insert = "head";
        bS.singleton = true;
        var kS = ob()(pS["a"], bS);
        var wS = pS["a"].locals || {};
        var AS = n(51);
        var _S = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        _S.insert = "head";
        _S.singleton = true;
        var CS = ob()(AS["a"], _S);
        var vS = AS["a"].locals || {};

        class yS extends tA {
            constructor(t) {
                super(t);
                this.placeholder = "data:image/svg+xml;utf8," + encodeURIComponent(uS)
            }

            init() {
                const t = this.editor;
                t.editing.downcastDispatcher.on("attribute:uploadStatus:image", ((...t) => this.uploadStatusChange(...t)))
            }

            uploadStatusChange(t, e, n) {
                const i = this.editor;
                const o = e.item;
                const r = o.getAttribute("uploadId");
                if (!n.consumable.consume(e.item, t.name)) {
                    return
                }
                const s = i.plugins.get(H_);
                const a = r ? e.attributeNewValue : null;
                const c = this.placeholder;
                const l = i.editing.mapper.toViewElement(o);
                const d = n.writer;
                if (a == "reading") {
                    xS(l, d);
                    DS(c, l, d);
                    return
                }
                if (a == "uploading") {
                    const t = s.loaders.get(r);
                    xS(l, d);
                    if (!t) {
                        DS(c, l, d)
                    } else {
                        TS(l, d);
                        MS(l, d, t, i.editing.view);
                        PS(l, d, t)
                    }
                    return
                }
                if (a == "complete" && s.loaders.get(r)) {
                    IS(l, d, i.editing.view)
                }
                SS(l, d);
                TS(l, d);
                ES(l, d)
            }
        }

        function xS(t, e) {
            if (!t.hasClass("ck-appear")) {
                e.addClass("ck-appear", t)
            }
        }

        function ES(t, e) {
            e.removeClass("ck-appear", t)
        }

        function DS(t, e, n) {
            if (!e.hasClass("ck-image-upload-placeholder")) {
                n.addClass("ck-image-upload-placeholder", e)
            }
            const i = dT(e);
            if (i.getAttribute("src") !== t) {
                n.setAttribute("src", t, i)
            }
            if (!zS(e, "placeholder")) {
                n.insert(n.createPositionAfter(i), LS(n))
            }
        }

        function TS(t, e) {
            if (t.hasClass("ck-image-upload-placeholder")) {
                e.removeClass("ck-image-upload-placeholder", t)
            }
            NS(t, e, "placeholder")
        }

        function MS(t, e, n, i) {
            const o = BS(e);
            e.insert(e.createPositionAt(t, "end"), o);
            n.on("change:uploadedPercent", ((t, e, n) => {
                i.change((t => {
                    t.setStyle("width", n + "%", o)
                }))
            }))
        }

        function SS(t, e) {
            NS(t, e, "progressBar")
        }

        function IS(t, e, n) {
            const i = e.createUIElement("div", {class: "ck-image-upload-complete-icon"});
            e.insert(e.createPositionAt(t, "end"), i);
            setTimeout((() => {
                n.change((t => t.remove(t.createRangeOn(i))))
            }), 3e3)
        }

        function BS(t) {
            const e = t.createUIElement("div", {class: "ck-progress-bar"});
            t.setCustomProperty("progressBar", true, e);
            return e
        }

        function LS(t) {
            const e = t.createUIElement("div", {class: "ck-upload-placeholder-loader"});
            t.setCustomProperty("placeholder", true, e);
            return e
        }

        function zS(t, e) {
            for (const n of t.getChildren()) {
                if (n.getCustomProperty(e)) {
                    return n
                }
            }
        }

        function NS(t, e, n) {
            const i = zS(t, n);
            if (i) {
                e.remove(e.createRangeOn(i))
            }
        }

        function PS(t, e, n) {
            if (n.data) {
                const i = dT(t);
                e.setAttribute("src", n.data, i)
            }
        }

        class OS extends j_ {
            static get pluginName() {
                return "Notification"
            }

            init() {
                this.on("show:warning", ((t, e) => {
                    window.alert(e.message)
                }), {priority: "lowest"})
            }

            showSuccess(t, e = {}) {
                this._showNotification({message: t, type: "success", namespace: e.namespace, title: e.title})
            }

            showInfo(t, e = {}) {
                this._showNotification({message: t, type: "info", namespace: e.namespace, title: e.title})
            }

            showWarning(t, e = {}) {
                this._showNotification({message: t, type: "warning", namespace: e.namespace, title: e.title})
            }

            _showNotification(t) {
                const e = `show:${t.type}` + (t.namespace ? `:${t.namespace}` : "");
                this.fire(e, {message: t.message, type: t.type, title: t.title || ""})
            }
        }

        class jS extends nA {
            refresh() {
                const t = this.editor.model.document.selection.getSelectedElement();
                const e = t && t.name === "image" || false;
                this.isEnabled = lT(this.editor.model) || e
            }

            execute(t) {
                const e = this.editor;
                const n = e.model;
                const i = e.plugins.get(H_);
                n.change((e => {
                    const o = Array.isArray(t.file) ? t.file : [t.file];
                    for (const t of o) {
                        RS(e, n, i, t)
                    }
                }))
            }
        }

        function RS(t, e, n, i) {
            const o = n.createLoader(i);
            if (!o) {
                return
            }
            cT(t, e, {uploadId: o.id})
        }

        class FS extends tA {
            static get requires() {
                return [H_, OS, Dv]
            }

            static get pluginName() {
                return "ImageUploadEditing"
            }

            constructor(t) {
                super(t);
                t.config.define("image", {upload: {types: ["jpeg", "png", "gif", "bmp", "webp", "tiff"]}})
            }

            init() {
                const t = this.editor;
                const e = t.model.document;
                const n = t.model.schema;
                const i = t.conversion;
                const o = t.plugins.get(H_);
                const r = rS(t.config.get("image.upload.types"));
                n.extend("image", {allowAttributes: ["uploadId", "uploadStatus"]});
                t.commands.add("imageUpload", new jS(t));
                i.for("upcast").attributeToAttribute({view: {name: "img", key: "uploadId"}, model: "uploadId"});
                this.listenTo(t.editing.view.document, "clipboardInput", ((e, n) => {
                    if (VS(n.dataTransfer)) {
                        return
                    }
                    const i = Array.from(n.dataTransfer.files).filter((t => {
                        if (!t) {
                            return false
                        }
                        return r.test(t.type)
                    }));
                    const o = n.targetRanges.map((e => t.editing.mapper.toModelRange(e)));
                    t.model.change((n => {
                        n.setSelection(o);
                        if (i.length) {
                            e.stop();
                            t.model.enqueueChange("default", (() => {
                                t.execute("imageUpload", {file: i})
                            }))
                        }
                    }))
                }));
                this.listenTo(t.plugins.get(Dv), "inputTransformation", ((e, n) => {
                    const i = Array.from(t.editing.view.createRangeIn(n.content)).filter((t => aS(t.item) && !t.item.getAttribute("uploadProcessed"))).map((t => ({
                        promise: sS(t.item),
                        imageElement: t.item
                    })));
                    if (!i.length) {
                        return
                    }
                    const r = new OD(t.editing.view.document);
                    for (const t of i) {
                        r.setAttribute("uploadProcessed", true, t.imageElement);
                        const e = o.createLoader(t.promise);
                        if (e) {
                            r.setAttribute("src", "", t.imageElement);
                            r.setAttribute("uploadId", e.id, t.imageElement)
                        }
                    }
                }));
                t.editing.view.document.on("dragover", ((t, e) => {
                    e.preventDefault()
                }));
                e.on("change", (() => {
                    const n = e.differ.getChanges({includeChangesInGraveyard: true});
                    for (const e of n) {
                        if (e.type == "insert" && e.name != "$text") {
                            const n = e.position.nodeAfter;
                            const i = e.position.root.rootName == "$graveyard";
                            for (const e of HS(t, n)) {
                                const t = e.getAttribute("uploadId");
                                if (!t) {
                                    continue
                                }
                                const n = o.loaders.get(t);
                                if (!n) {
                                    continue
                                }
                                if (i) {
                                    n.abort()
                                } else if (n.status == "idle") {
                                    this._readAndUpload(n, e)
                                }
                            }
                        }
                    }
                }))
            }

            _readAndUpload(t, e) {
                const n = this.editor;
                const i = n.model;
                const o = n.locale.t;
                const r = n.plugins.get(H_);
                const s = n.plugins.get(OS);
                i.enqueueChange("transparent", (t => {
                    t.setAttribute("uploadStatus", "reading", e)
                }));
                return t.read().then((() => {
                    const o = t.upload();
                    if (El.isSafari) {
                        const t = n.editing.mapper.toViewElement(e);
                        const i = dT(t);
                        n.editing.view.once("render", (() => {
                            if (!i.parent) {
                                return
                            }
                            const t = n.editing.view.domConverter.mapViewToDom(i.parent);
                            if (!t) {
                                return
                            }
                            const e = t.style.display;
                            t.style.display = "none";
                            t._ckHack = t.offsetHeight;
                            t.style.display = e
                        }))
                    }
                    i.enqueueChange("transparent", (t => {
                        t.setAttribute("uploadStatus", "uploading", e)
                    }));
                    return o
                })).then((t => {
                    i.enqueueChange("transparent", (n => {
                        n.setAttributes({uploadStatus: "complete", src: t.default}, e);
                        this._parseAndSetSrcsetAttributeOnImage(t, e, n)
                    }));
                    a()
                })).catch((n => {
                    if (t.status !== "error" && t.status !== "aborted") {
                        throw n
                    }
                    if (t.status == "error" && n) {
                        s.showWarning(n, {title: o("Upload failed"), namespace: "upload"})
                    }
                    a();
                    i.enqueueChange("transparent", (t => {
                        t.remove(e)
                    }))
                }));

                function a() {
                    i.enqueueChange("transparent", (t => {
                        t.removeAttribute("uploadId", e);
                        t.removeAttribute("uploadStatus", e)
                    }));
                    r.destroyLoader(t)
                }
            }

            _parseAndSetSrcsetAttributeOnImage(t, e, n) {
                let i = 0;
                const o = Object.keys(t).filter((t => {
                    const e = parseInt(t, 10);
                    if (!isNaN(e)) {
                        i = Math.max(i, e);
                        return true
                    }
                })).map((e => `${t[e]} ${e}w`)).join(", ");
                if (o != "") {
                    n.setAttribute("srcset", {data: o, width: i}, e)
                }
            }
        }

        function VS(t) {
            return Array.from(t.types).includes("text/html") && t.getData("text/html") !== ""
        }

        function HS(t, e) {
            return Array.from(t.model.createRangeOn(e)).filter((t => t.item.is("element", "image"))).map((t => t.item))
        }

        class US extends tA {
            static get pluginName() {
                return "ImageUpload"
            }

            static get requires() {
                return [FS, dS, yS]
            }
        }

        var WS = n(52);
        var qS = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        qS.insert = "head";
        qS.singleton = true;
        var KS = ob()(WS["a"], qS);
        var GS = WS["a"].locals || {};

        class $S extends Zb {
            constructor(t, e = {}) {
                super(t);
                const n = this.bindTemplate;
                this.set("class", e.class || null);
                this.children = this.createCollection();
                if (e.children) {
                    e.children.forEach((t => this.children.add(t)))
                }
                this.set("_role", null);
                this.set("_ariaLabelledBy", null);
                if (e.labelView) {
                    this.set({_role: "group", _ariaLabelledBy: e.labelView.id})
                }
                this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-form__row", n.to("class")],
                        role: n.to("_role"),
                        "aria-labelledby": n.to("_ariaLabelledBy")
                    },
                    children: this.children
                })
            }
        }

        var YS = n(53);
        var QS = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        QS.insert = "head";
        QS.singleton = true;
        var JS = ob()(YS["a"], QS);
        var XS = YS["a"].locals || {};

        class ZS extends Zb {
            constructor(t, e) {
                super(t);
                const {insertButtonView: n, cancelButtonView: i} = this._createActionButtons(t);
                this.insertButtonView = n;
                this.cancelButtonView = i;
                this.dropdownView = this._createDropdownView(t);
                this.set("imageURLInputValue", "");
                this.focusTracker = new Zp;
                this.keystrokes = new Fp;
                this._focusables = new Ab;
                this._focusCycler = new xk({
                    focusables: this._focusables,
                    focusTracker: this.focusTracker,
                    keystrokeHandler: this.keystrokes,
                    actions: {focusPrevious: "shift + tab", focusNext: "tab"}
                });
                this.set("_integrations", new vs);
                if (e) {
                    for (const [t, n] of Object.entries(e)) {
                        if (t === "insertImageViaUrl") {
                            n.fieldView.bind("value").to(this, "imageURLInputValue", (t => t || ""));
                            n.fieldView.on("input", (() => {
                                this.imageURLInputValue = n.fieldView.element.value.trim()
                            }))
                        }
                        n.name = t;
                        this._integrations.add(n)
                    }
                }
                this.setTemplate({
                    tag: "form",
                    attributes: {class: ["ck", "ck-image-insert-form"], tabindex: "-1"},
                    children: [...this._integrations, new $S(t, {
                        children: [this.insertButtonView, this.cancelButtonView],
                        class: "ck-image-insert-form__action-row"
                    })]
                })
            }

            render() {
                super.render();
                cM({view: this});
                const t = [...this._integrations, this.insertButtonView, this.cancelButtonView];
                t.forEach((t => {
                    this._focusables.add(t);
                    this.focusTracker.add(t.element)
                }));
                this.keystrokes.listenTo(this.element);
                const e = t => t.stopPropagation();
                this.keystrokes.set("arrowright", e);
                this.keystrokes.set("arrowleft", e);
                this.keystrokes.set("arrowup", e);
                this.keystrokes.set("arrowdown", e);
                this.listenTo(t[0].element, "selectstart", ((t, e) => {
                    e.stopPropagation()
                }), {priority: "high"})
            }

            getIntegration(t) {
                return this._integrations.find((e => e.name === t))
            }

            _createDropdownView(t) {
                const e = t.t;
                const n = Sw(t, dv);
                const i = n.buttonView;
                const o = n.panelView;
                i.set({label: e("Insert image"), icon: lS, tooltip: true});
                o.extendTemplate({attributes: {class: "ck-image-insert__panel"}});
                return n
            }

            _createActionButtons(t) {
                const e = t.t;
                const n = new sw(t);
                const i = new sw(t);
                n.set({
                    label: e("Insert"),
                    icon: KD,
                    class: "ck-button-save",
                    type: "submit",
                    withText: true,
                    isEnabled: this.imageURLInputValue
                });
                i.set({label: e("Cancel"), icon: GD, class: "ck-button-cancel", withText: true});
                n.bind("isEnabled").to(this, "imageURLInputValue", (t => !!t));
                n.delegate("execute").to(this, "submit");
                i.delegate("execute").to(this, "cancel");
                return {insertButtonView: n, cancelButtonView: i}
            }

            focus() {
                this._focusCycler.focusFirst()
            }
        }

        function tI(t) {
            const e = t.config.get("image.insert.integrations");
            const n = t.plugins.get("ImageInsertUI");
            const i = {insertImageViaUrl: eI(t.locale)};
            if (!e) {
                return i
            }
            if (e.find((t => t === "openCKFinder")) && t.ui.componentFactory.has("ckfinder")) {
                const e = t.ui.componentFactory.create("ckfinder");
                e.set({withText: true, class: "ck-image-insert__ck-finder-button"});
                e.delegate("execute").to(n, "cancel");
                i.openCKFinder = e
            }
            return e.reduce(((e, n) => {
                if (i[n]) {
                    e[n] = i[n]
                } else if (t.ui.componentFactory.has(n)) {
                    e[n] = t.ui.componentFactory.create(n)
                }
                return e
            }), {})
        }

        function eI(t) {
            const e = t.t;
            const n = new tM(t, sM);
            n.set({label: e("Insert image via URL")});
            n.fieldView.placeholder = "https://example.com/src/image.png";
            n.infoText = e("Paste the image source URL.");
            return n
        }

        class nI extends tA {
            static get pluginName() {
                return "ImageInsertUI"
            }

            init() {
                const t = this.editor;
                t.ui.componentFactory.add("imageInsert", (t => this._createDropdownView(t)))
            }

            _createDropdownView(t) {
                const e = this.editor;
                const n = new ZS(t, tI(e));
                const i = e.commands.get("imageUpload");
                const o = n.dropdownView;
                const r = o.buttonView;
                r.actionView = e.ui.componentFactory.create("imageUpload");
                r.actionView.extendTemplate({attributes: {class: "ck ck-button ck-splitbutton__action"}});
                return this._setUpDropdown(o, n, i)
            }

            _setUpDropdown(t, e, n) {
                const i = this.editor;
                const o = i.t;
                const r = e.insertButtonView;
                const s = e.getIntegration("insertImageViaUrl");
                const a = t.panelView;
                t.bind("isEnabled").to(n);
                t.buttonView.once("open", (() => {
                    a.children.add(e)
                }));
                t.on("change:isOpen", (() => {
                    const n = i.model.document.selection.getSelectedElement();
                    if (t.isOpen) {
                        e.focus();
                        if (aT(n)) {
                            e.imageURLInputValue = n.getAttribute("src");
                            r.label = o("Update");
                            s.label = o("Update image URL")
                        } else {
                            e.imageURLInputValue = "";
                            r.label = o("Insert");
                            s.label = o("Insert image via URL")
                        }
                    }
                }), {priority: "low"});
                e.delegate("submit", "cancel").to(t);
                this.delegate("cancel").to(t);
                t.on("submit", (() => {
                    l();
                    c()
                }));
                t.on("cancel", (() => {
                    l()
                }));

                function c() {
                    const t = i.model.document.selection.getSelectedElement();
                    if (aT(t)) {
                        i.model.change((n => {
                            n.setAttribute("src", e.imageURLInputValue, t);
                            n.removeAttribute("srcset", t);
                            n.removeAttribute("sizes", t)
                        }))
                    } else {
                        i.execute("imageInsert", {source: e.imageURLInputValue})
                    }
                }

                function l() {
                    i.editing.view.focus();
                    t.isOpen = false
                }

                return t
            }
        }

        class iI extends tA {
            static get pluginName() {
                return "ImageInsert"
            }

            static get requires() {
                return [US, nI]
            }
        }

        class oI extends nA {
            refresh() {
                const t = this.editor.model.document.selection.getSelectedElement();
                this.isEnabled = aT(t);
                if (!t || !t.hasAttribute("width")) {
                    this.value = null
                } else {
                    this.value = {width: t.getAttribute("width"), height: null}
                }
            }

            execute(t) {
                const e = this.editor.model;
                const n = e.document.selection.getSelectedElement();
                this.value = {width: t.width, height: null};
                if (n) {
                    e.change((e => {
                        e.setAttribute("width", t.width, n)
                    }))
                }
            }
        }

        class rI extends tA {
            static get pluginName() {
                return "ImageResizeEditing"
            }

            constructor(t) {
                super(t);
                t.config.define("image", {
                    resizeUnit: "%",
                    resizeOptions: [{
                        name: "imageResize:original",
                        value: null,
                        icon: "original"
                    }, {name: "imageResize:25", value: "25", icon: "small"}, {
                        name: "imageResize:50",
                        value: "50",
                        icon: "medium"
                    }, {name: "imageResize:75", value: "75", icon: "large"}]
                })
            }

            init() {
                const t = this.editor;
                const e = new oI(t);
                this._registerSchema();
                this._registerConverters();
                t.commands.add("imageResize", e)
            }

            _registerSchema() {
                this.editor.model.schema.extend("image", {allowAttributes: "width"});
                this.editor.model.schema.setAttributeProperties("width", {isFormatting: true})
            }

            _registerConverters() {
                const t = this.editor;
                t.conversion.for("downcast").add((t => t.on("attribute:width:image", ((t, e, n) => {
                    if (!n.consumable.consume(e.item, t.name)) {
                        return
                    }
                    const i = n.writer;
                    const o = n.mapper.toViewElement(e.item);
                    if (e.attributeNewValue !== null) {
                        i.setStyle("width", e.attributeNewValue, o);
                        i.addClass("image_resized", o)
                    } else {
                        i.removeStyle("width", o);
                        i.removeClass("image_resized", o)
                    }
                }))));
                t.conversion.for("upcast").attributeToAttribute({
                    view: {name: "figure", styles: {width: /.+/}},
                    model: {key: "width", value: t => t.getStyle("width")}
                })
            }
        }

        var sI = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M7 10H2a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h5a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-4a.5.5 0 0 1 .5-.5h5z"/></svg>';
        var aI = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M10 8H2a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2v-6a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-6a.5.5 0 0 1 .5-.5h8z"/></svg>';
        var cI = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M13 6H2a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5V8a.5.5 0 0 1 .5-.5h11z"/></svg>';
        var lI = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M18.095 2H1.905C.853 2 0 2.895 0 4v12c0 1.105.853 2 1.905 2h16.19C19.147 18 20 17.105 20 16V4c0-1.105-.853-2-1.905-2zm0 1.5c.263 0 .476.224.476.5v12c0 .276-.213.5-.476.5H1.905a.489.489 0 0 1-.476-.5V4c0-.276.213-.5.476-.5h16.19z"/></svg>';
        const dI = {small: sI, medium: aI, large: cI, original: lI};

        class uI extends tA {
            static get requires() {
                return [rI]
            }

            static get pluginName() {
                return "ImageResizeButtons"
            }

            constructor(t) {
                super(t);
                this._resizeUnit = t.config.get("image.resizeUnit")
            }

            init() {
                const t = this.editor;
                const e = t.config.get("image.resizeOptions");
                const n = t.commands.get("imageResize");
                this.bind("isEnabled").to(n);
                for (const t of e) {
                    this._registerImageResizeButton(t)
                }
                this._registerImageResizeDropdown(e)
            }

            _registerImageResizeButton(t) {
                const e = this.editor;
                const {name: n, value: i, icon: o} = t;
                const r = i ? i + this._resizeUnit : null;
                e.ui.componentFactory.add(n, (n => {
                    const i = new sw(n);
                    const s = e.commands.get("imageResize");
                    const a = this._getOptionLabelValue(t, true);
                    if (!dI[o]) {
                        throw new ss["a"]("imageresizebuttons-missing-icon", e, t)
                    }
                    i.set({label: a, icon: dI[o], tooltip: a, isToggleable: true});
                    i.bind("isEnabled").to(this);
                    i.bind("isOn").to(s, "value", hI(r));
                    this.listenTo(i, "execute", (() => {
                        e.execute("imageResize", {width: r})
                    }));
                    return i
                }))
            }

            _registerImageResizeDropdown(t) {
                const e = this.editor;
                const n = e.t;
                const i = t.find((t => !t.value));
                e.ui.componentFactory.add("imageResize", (o => {
                    const r = e.commands.get("imageResize");
                    const s = Sw(o, cw);
                    const a = s.buttonView;
                    a.set({
                        tooltip: n("Resize image"),
                        commandValue: i.value,
                        icon: aI,
                        isToggleable: true,
                        label: this._getOptionLabelValue(i),
                        withText: true,
                        class: "ck-resize-image-button"
                    });
                    a.bind("label").to(r, "value", (t => {
                        if (t && t.width) {
                            return t.width
                        } else {
                            return this._getOptionLabelValue(i)
                        }
                    }));
                    s.bind("isOn").to(r);
                    s.bind("isEnabled").to(this);
                    Bw(s, this._getResizeDropdownListItemDefinitions(t, r));
                    s.listView.ariaLabel = n("Image resize list");
                    this.listenTo(s, "execute", (t => {
                        e.execute(t.source.commandName, {width: t.source.commandValue});
                        e.editing.view.focus()
                    }));
                    return s
                }))
            }

            _getOptionLabelValue(t, e) {
                const n = this.editor.t;
                if (t.label) {
                    return t.label
                } else if (e) {
                    if (t.value) {
                        return n("Resize image to %0", t.value + this._resizeUnit)
                    } else {
                        return n("Resize image to the original size")
                    }
                } else {
                    if (t.value) {
                        return t.value + this._resizeUnit
                    } else {
                        return n("Original")
                    }
                }
            }

            _getResizeDropdownListItemDefinitions(t, e) {
                const n = new vs;
                t.map((t => {
                    const i = t.value ? t.value + this._resizeUnit : null;
                    const o = {
                        type: "button",
                        model: new rv({
                            commandName: "imageResize",
                            commandValue: i,
                            label: this._getOptionLabelValue(t),
                            withText: true,
                            icon: null
                        })
                    };
                    o.model.bind("isOn").to(e, "value", hI(i));
                    n.add(o)
                }));
                return n
            }
        }

        function hI(t) {
            return e => {
                if (t === null && e === t) {
                    return true
                }
                return e && e.width === t
            }
        }

        class mI {
            constructor(t) {
                this.set("activeHandlePosition", null);
                this.set("proposedWidthPercents", null);
                this.set("proposedWidth", null);
                this.set("proposedHeight", null);
                this.set("proposedHandleHostWidth", null);
                this.set("proposedHandleHostHeight", null);
                this._options = t;
                this._referenceCoordinates = null
            }

            begin(t, e, n) {
                const i = new Eh(e);
                this.activeHandlePosition = bI(t);
                this._referenceCoordinates = fI(e, kI(this.activeHandlePosition));
                this.originalWidth = i.width;
                this.originalHeight = i.height;
                this.aspectRatio = i.width / i.height;
                const o = n.style.width;
                if (o && o.match(/^\d+\.?\d*%$/)) {
                    this.originalWidthPercents = parseFloat(o)
                } else {
                    this.originalWidthPercents = gI(n, i)
                }
            }

            update(t) {
                this.proposedWidth = t.width;
                this.proposedHeight = t.height;
                this.proposedWidthPercents = t.widthPercents;
                this.proposedHandleHostWidth = t.handleHostWidth;
                this.proposedHandleHostHeight = t.handleHostHeight
            }
        }

        Cs(mI, Qc);

        function gI(t, e) {
            const n = t.parentElement;
            const i = parseFloat(n.ownerDocument.defaultView.getComputedStyle(n).width);
            return e.width / i * 100
        }

        function fI(t, e) {
            const n = new Eh(t);
            const i = e.split("-");
            const o = {x: i[1] == "right" ? n.right : n.left, y: i[0] == "bottom" ? n.bottom : n.top};
            o.x += t.ownerDocument.defaultView.scrollX;
            o.y += t.ownerDocument.defaultView.scrollY;
            return o
        }

        function pI(t) {
            return `ck-widget__resizer__handle-${t}`
        }

        function bI(t) {
            const e = ["top-left", "top-right", "bottom-right", "bottom-left"];
            for (const n of e) {
                if (t.classList.contains(pI(n))) {
                    return n
                }
            }
        }

        function kI(t) {
            const e = t.split("-");
            const n = {top: "bottom", bottom: "top", left: "right", right: "left"};
            return `${n[e[0]]}-${n[e[1]]}`
        }

        class wI {
            constructor(t) {
                this._options = t;
                this._domResizerWrapper = null;
                this._viewResizerWrapper = null;
                this.set("isEnabled", true);
                this.decorate("begin");
                this.decorate("cancel");
                this.decorate("commit");
                this.decorate("updateSize");
                this.on("commit", (t => {
                    if (!this.state.proposedWidth && !this.state.proposedWidthPercents) {
                        this._cleanup();
                        t.stop()
                    }
                }), {priority: "high"});
                this.on("change:isEnabled", (() => {
                    if (this.isEnabled) {
                        this.redraw()
                    }
                }))
            }

            attach() {
                const t = this;
                const e = this._options.viewElement;
                const n = this._options.editor.editing.view;
                n.change((n => {
                    const i = n.createUIElement("div", {class: "ck ck-reset_all ck-widget__resizer"}, (function (e) {
                        const n = this.toDomElement(e);
                        t._appendHandles(n);
                        t._appendSizeUI(n);
                        t._domResizerWrapper = n;
                        t.on("change:isEnabled", ((t, e, i) => {
                            n.style.display = i ? "" : "none"
                        }));
                        n.style.display = t.isEnabled ? "" : "none";
                        return n
                    }));
                    n.insert(n.createPositionAt(e, "end"), i);
                    n.addClass("ck-widget_with-resizer", e);
                    this._viewResizerWrapper = i
                }))
            }

            begin(t) {
                this.state = new mI(this._options);
                this._sizeUI.bindToState(this._options, this.state);
                this._initialViewWidth = this._options.viewElement.getStyle("width");
                this.state.begin(t, this._getHandleHost(), this._getResizeHost())
            }

            updateSize(t) {
                const e = this._proposeNewSize(t);
                const n = this._options.editor.editing.view;
                n.change((t => {
                    const n = this._options.unit || "%";
                    const i = (n === "%" ? e.widthPercents : e.width) + n;
                    t.setStyle("width", i, this._options.viewElement)
                }));
                const i = this._getHandleHost();
                const o = new Eh(i);
                e.handleHostWidth = Math.round(o.width);
                e.handleHostHeight = Math.round(o.height);
                const r = new Eh(i);
                e.width = Math.round(r.width);
                e.height = Math.round(r.height);
                this.redraw(o);
                this.state.update(e)
            }

            commit() {
                const t = this._options.unit || "%";
                const e = (t === "%" ? this.state.proposedWidthPercents : this.state.proposedWidth) + t;
                this._options.editor.editing.view.change((() => {
                    this._cleanup();
                    this._options.onCommit(e)
                }))
            }

            cancel() {
                this._cleanup()
            }

            destroy() {
                this.cancel()
            }

            redraw(t) {
                const e = this._domResizerWrapper;
                if (!vI(e)) {
                    return
                }
                const n = e.parentElement;
                const i = this._getHandleHost();
                const o = this._viewResizerWrapper;
                const r = [o.getStyle("width"), o.getStyle("height"), o.getStyle("left"), o.getStyle("top")];
                let s;
                if (n.isSameNode(i)) {
                    const e = t || new Eh(i);
                    s = [e.width + "px", e.height + "px", undefined, undefined]
                } else {
                    s = [i.offsetWidth + "px", i.offsetHeight + "px", i.offsetLeft + "px", i.offsetTop + "px"]
                }
                if (Ns(r, s) !== "same") {
                    this._options.editor.editing.view.change((t => {
                        t.setStyle({width: s[0], height: s[1], left: s[2], top: s[3]}, o)
                    }))
                }
            }

            containsHandle(t) {
                return this._domResizerWrapper.contains(t)
            }

            static isResizeHandle(t) {
                return t.classList.contains("ck-widget__resizer__handle")
            }

            _cleanup() {
                this._sizeUI.dismiss();
                this._sizeUI.isVisible = false;
                const t = this._options.editor.editing.view;
                t.change((t => {
                    t.setStyle("width", this._initialViewWidth, this._options.viewElement)
                }))
            }

            _proposeNewSize(t) {
                const e = this.state;
                const n = CI(t);
                const i = this._options.isCentered ? this._options.isCentered(this) : true;
                const o = {
                    x: e._referenceCoordinates.x - (n.x + e.originalWidth),
                    y: n.y - e.originalHeight - e._referenceCoordinates.y
                };
                if (i && e.activeHandlePosition.endsWith("-right")) {
                    o.x = n.x - (e._referenceCoordinates.x + e.originalWidth)
                }
                if (i) {
                    o.x *= 2
                }
                const r = {width: Math.abs(e.originalWidth + o.x), height: Math.abs(e.originalHeight + o.y)};
                r.dominant = r.width / e.aspectRatio > r.height ? "width" : "height";
                r.max = r[r.dominant];
                const s = {width: r.width, height: r.height};
                if (r.dominant == "width") {
                    s.height = s.width / e.aspectRatio
                } else {
                    s.width = s.height * e.aspectRatio
                }
                return {
                    width: Math.round(s.width),
                    height: Math.round(s.height),
                    widthPercents: Math.min(Math.round(e.originalWidthPercents / e.originalWidth * s.width * 100) / 100, 100)
                }
            }

            _getResizeHost() {
                const t = this._domResizerWrapper.parentElement;
                return this._options.getResizeHost(t)
            }

            _getHandleHost() {
                const t = this._domResizerWrapper.parentElement;
                return this._options.getHandleHost(t)
            }

            _appendHandles(t) {
                const e = ["top-left", "top-right", "bottom-right", "bottom-left"];
                for (const n of e) {
                    t.appendChild(new vb({
                        tag: "div",
                        attributes: {class: `ck-widget__resizer__handle ${_I(n)}`}
                    }).render())
                }
            }

            _appendSizeUI(t) {
                const e = new AI;
                e.render();
                this._sizeUI = e;
                t.appendChild(e.element)
            }
        }

        Cs(wI, Qc);

        class AI extends Zb {
            constructor() {
                super();
                const t = this.bindTemplate;
                this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-size-view", t.to("activeHandlePosition", (t => t ? `ck-orientation-${t}` : ""))],
                        style: {display: t.if("isVisible", "none", (t => !t))}
                    },
                    children: [{text: t.to("label")}]
                })
            }

            bindToState(t, e) {
                this.bind("isVisible").to(e, "proposedWidth", e, "proposedHeight", ((t, e) => t !== null && e !== null));
                this.bind("label").to(e, "proposedHandleHostWidth", e, "proposedHandleHostHeight", e, "proposedWidthPercents", ((e, n, i) => {
                    if (t.unit === "px") {
                        return `${e}×${n}`
                    } else {
                        return `${i}%`
                    }
                }));
                this.bind("activeHandlePosition").to(e)
            }

            dismiss() {
                this.unbind();
                this.isVisible = false
            }
        }

        function _I(t) {
            return `ck-widget__resizer__handle-${t}`
        }

        function CI(t) {
            return {x: t.pageX, y: t.pageY}
        }

        function vI(t) {
            return t && t.ownerDocument && t.ownerDocument.contains(t)
        }

        var yI = "Expected a function";

        function xI(t, e, n) {
            var i = true, o = true;
            if (typeof t != "function") {
                throw new TypeError(yI)
            }
            if (ct(n)) {
                i = "leading" in n ? !!n.leading : i;
                o = "trailing" in n ? !!n.trailing : o
            }
            return bh(t, e, {leading: i, maxWait: e, trailing: o})
        }

        var EI = xI;
        var DI = n(54);
        var TI = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        TI.insert = "head";
        TI.singleton = true;
        var MI = ob()(DI["a"], TI);
        var SI = DI["a"].locals || {};

        class II extends tA {
            static get pluginName() {
                return "WidgetResize"
            }

            init() {
                this.set("_visibleResizer", null);
                this.set("_activeResizer", null);
                this._resizers = new Map;
                const t = jd.window.document;
                this.editor.model.schema.setAttributeProperties("width", {isFormatting: true});
                this.editor.editing.view.addObserver(_T);
                this._observer = Object.create(Qd);
                this.listenTo(this.editor.editing.view.document, "mousedown", this._mouseDownListener.bind(this), {priority: "high"});
                this._observer.listenTo(t, "mousemove", this._mouseMoveListener.bind(this));
                this._observer.listenTo(t, "mouseup", this._mouseUpListener.bind(this));
                const e = () => {
                    if (this._visibleResizer) {
                        this._visibleResizer.redraw()
                    }
                };
                const n = EI(e, 200);
                this.on("change:_visibleResizer", e);
                this.editor.ui.on("update", n);
                this._observer.listenTo(jd.window, "resize", n);
                const i = this.editor.editing.view.document.selection;
                i.on("change", (() => {
                    const t = i.getSelectedElement();
                    this._visibleResizer = this._getResizerByViewElement(t) || null
                }))
            }

            destroy() {
                this._observer.stopListening();
                for (const t of this._resizers.values()) {
                    t.destroy()
                }
            }

            attachTo(t) {
                const e = new wI(t);
                const n = this.editor.plugins;
                e.attach();
                if (n.has("WidgetToolbarRepository")) {
                    const t = n.get("WidgetToolbarRepository");
                    e.on("begin", (() => {
                        t.forceDisabled("resize")
                    }), {priority: "lowest"});
                    e.on("cancel", (() => {
                        t.clearForceDisabled("resize")
                    }), {priority: "highest"});
                    e.on("commit", (() => {
                        t.clearForceDisabled("resize")
                    }), {priority: "highest"})
                }
                this._resizers.set(t.viewElement, e);
                return e
            }

            _getResizerByHandle(t) {
                for (const e of this._resizers.values()) {
                    if (e.containsHandle(t)) {
                        return e
                    }
                }
            }

            _getResizerByViewElement(t) {
                return this._resizers.get(t)
            }

            _mouseDownListener(t, e) {
                const n = e.domTarget;
                if (!wI.isResizeHandle(n)) {
                    return
                }
                this._activeResizer = this._getResizerByHandle(n);
                if (this._activeResizer) {
                    this._activeResizer.begin(n);
                    t.stop();
                    e.preventDefault()
                }
            }

            _mouseMoveListener(t, e) {
                if (this._activeResizer) {
                    this._activeResizer.updateSize(e)
                }
            }

            _mouseUpListener() {
                if (this._activeResizer) {
                    this._activeResizer.commit();
                    this._activeResizer = null
                }
            }
        }

        Cs(II, Qc);

        class BI extends tA {
            static get requires() {
                return [II]
            }

            static get pluginName() {
                return "ImageResizeHandles"
            }

            init() {
                const t = this.editor;
                const e = t.commands.get("imageResize");
                this.bind("isEnabled").to(e);
                t.editing.downcastDispatcher.on("insert:image", ((e, n, i) => {
                    const o = i.mapper.toViewElement(n.item);
                    const r = t.plugins.get(II).attachTo({
                        unit: t.config.get("image.resizeUnit"),
                        modelElement: n.item,
                        viewElement: o,
                        editor: t,
                        getHandleHost(t) {
                            return t.querySelector("img")
                        },
                        getResizeHost(t) {
                            return t
                        },
                        isCentered() {
                            const t = n.item.getAttribute("imageStyle");
                            return !t || t == "full" || t == "alignCenter"
                        },
                        onCommit(e) {
                            t.execute("imageResize", {width: e})
                        }
                    });
                    r.on("updateSize", (() => {
                        if (!o.hasClass("image_resized")) {
                            t.editing.view.change((t => {
                                t.addClass("image_resized", o)
                            }))
                        }
                    }));
                    r.bind("isEnabled").to(this)
                }), {priority: "low"})
            }
        }

        var LI = n(55);
        var zI = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        zI.insert = "head";
        zI.singleton = true;
        var NI = ob()(LI["a"], zI);
        var PI = LI["a"].locals || {};

        class OI extends tA {
            static get requires() {
                return [rI, BI, uI]
            }

            static get pluginName() {
                return "ImageResize"
            }
        }

        class jI extends nA {
            constructor(t, e) {
                super(t);
                this.defaultStyle = false;
                this.styles = e.reduce(((t, e) => {
                    t[e.name] = e;
                    if (e.isDefault) {
                        this.defaultStyle = e.name
                    }
                    return t
                }), {})
            }

            refresh() {
                const t = this.editor.model.document.selection.getSelectedElement();
                this.isEnabled = aT(t);
                if (!t) {
                    this.value = false
                } else if (t.hasAttribute("imageStyle")) {
                    const e = t.getAttribute("imageStyle");
                    this.value = this.styles[e] ? e : false
                } else {
                    this.value = this.defaultStyle
                }
            }

            execute(t) {
                const e = t.value;
                const n = this.editor.model;
                const i = n.document.selection.getSelectedElement();
                n.change((t => {
                    if (this.styles[e].isDefault) {
                        t.removeAttribute("imageStyle", i)
                    } else {
                        t.setAttribute("imageStyle", e, i)
                    }
                }))
            }
        }

        function RI(t) {
            return (e, n, i) => {
                if (!i.consumable.consume(n.item, e.name)) {
                    return
                }
                const o = VI(n.attributeNewValue, t);
                const r = VI(n.attributeOldValue, t);
                const s = i.mapper.toViewElement(n.item);
                const a = i.writer;
                if (r) {
                    a.removeClass(r.className, s)
                }
                if (o) {
                    a.addClass(o.className, s)
                }
            }
        }

        function FI(t) {
            const e = t.filter((t => !t.isDefault));
            return (t, n, i) => {
                if (!n.modelRange) {
                    return
                }
                const o = n.viewItem;
                const r = oA(n.modelRange.getItems());
                if (!i.schema.checkAttribute(r, "imageStyle")) {
                    return
                }
                for (const t of e) {
                    if (i.consumable.consume(o, {classes: t.className})) {
                        i.writer.setAttribute("imageStyle", t.name, r)
                    }
                }
            }
        }

        function VI(t, e) {
            for (const n of e) {
                if (n.name === t) {
                    return n
                }
            }
        }

        var HI = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 4.5V3h16v1.5zm2.5 3V12h11V7.5h-11zM4.061 6H15.94c.586 0 1.061.407 1.061.91v5.68c0 .503-.475.91-1.061.91H4.06c-.585 0-1.06-.407-1.06-.91V6.91C3 6.406 3.475 6 4.061 6zM2 16.5V15h16v1.5z"/></svg>';
        var UI = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg" clip-rule="evenodd" stroke-linejoin="round" stroke-miterlimit="1.414"><path d="M18 4.5V3H2v1.5h16zm0 3V6h-5.674v1.5H18zm0 3V9h-5.674v1.5H18zm0 3V12h-5.674v1.5H18zm-8.5-6V12h-6V7.5h6zm.818-1.5H2.682C2.305 6 2 6.407 2 6.91v5.68c0 .503.305.91.682.91h7.636c.377 0 .682-.407.682-.91V6.91c0-.503-.305-.91-.682-.91zM18 16.5V15H2v1.5h16z"/></svg>';
        var WI = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 4.5V3h16v1.5zm4.5 3V12h7V7.5h-7zM5.758 6h8.484c.419 0 .758.407.758.91v5.681c0 .502-.34.909-.758.909H5.758c-.419 0-.758-.407-.758-.91V6.91c0-.503.34-.91.758-.91zM2 16.5V15h16v1.5z"/></svg>';
        var qI = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 4.5V3h16v1.5zm0 3V6h5.674v1.5zm0 3V9h5.674v1.5zm0 3V12h5.674v1.5zm8.5-6V12h6V7.5h-6zM9.682 6h7.636c.377 0 .682.407.682.91v5.68c0 .503-.305.91-.682.91H9.682c-.377 0-.682-.407-.682-.91V6.91c0-.503.305-.91.682-.91zM2 16.5V15h16v1.5z"/></svg>';
        const KI = {
            full: {name: "full", title: "Full size image", icon: HI, isDefault: true},
            side: {name: "side", title: "Side image", icon: qI, className: "image-style-side"},
            alignLeft: {name: "alignLeft", title: "Left aligned image", icon: UI, className: "image-style-align-left"},
            alignCenter: {
                name: "alignCenter",
                title: "Centered image",
                icon: WI,
                className: "image-style-align-center"
            },
            alignRight: {
                name: "alignRight",
                title: "Right aligned image",
                icon: qI,
                className: "image-style-align-right"
            }
        };
        const GI = {full: HI, left: UI, right: qI, center: WI};

        function $I(t = []) {
            return t.map(YI)
        }

        function YI(t) {
            if (typeof t == "string") {
                const e = t;
                if (KI[e]) {
                    t = Object.assign({}, KI[e])
                } else {
                    Object(ss["c"])("image-style-not-found", {name: e});
                    t = {name: e}
                }
            } else if (KI[t.name]) {
                const e = KI[t.name];
                const n = Object.assign({}, t);
                for (const i in e) {
                    if (!Object.prototype.hasOwnProperty.call(t, i)) {
                        n[i] = e[i]
                    }
                }
                t = n
            }
            if (typeof t.icon == "string" && GI[t.icon]) {
                t.icon = GI[t.icon]
            }
            return t
        }

        class QI extends tA {
            static get pluginName() {
                return "ImageStyleEditing"
            }

            init() {
                const t = this.editor;
                const e = t.model.schema;
                const n = t.data;
                const i = t.editing;
                t.config.define("image.styles", ["full", "side"]);
                const o = $I(t.config.get("image.styles"));
                e.extend("image", {allowAttributes: "imageStyle"});
                const r = RI(o);
                i.downcastDispatcher.on("attribute:imageStyle:image", r);
                n.downcastDispatcher.on("attribute:imageStyle:image", r);
                n.upcastDispatcher.on("element:figure", FI(o), {priority: "low"});
                t.commands.add("imageStyle", new jI(t, o))
            }
        }

        var JI = n(56);
        var XI = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        XI.insert = "head";
        XI.singleton = true;
        var ZI = ob()(JI["a"], XI);
        var tB = JI["a"].locals || {};

        class eB extends tA {
            static get pluginName() {
                return "ImageStyleUI"
            }

            get localizedDefaultStylesTitles() {
                const t = this.editor.t;
                return {
                    "Full size image": t("Full size image"),
                    "Side image": t("Side image"),
                    "Left aligned image": t("Left aligned image"),
                    "Centered image": t("Centered image"),
                    "Right aligned image": t("Right aligned image")
                }
            }

            init() {
                const t = this.editor;
                const e = t.config.get("image.styles");
                const n = nB($I(e), this.localizedDefaultStylesTitles);
                for (const t of n) {
                    this._createButton(t)
                }
            }

            _createButton(t) {
                const e = this.editor;
                const n = `imageStyle:${t.name}`;
                e.ui.componentFactory.add(n, (n => {
                    const i = e.commands.get("imageStyle");
                    const o = new sw(n);
                    o.set({label: t.title, icon: t.icon, tooltip: true, isToggleable: true});
                    o.bind("isEnabled").to(i, "isEnabled");
                    o.bind("isOn").to(i, "value", (e => e === t.name));
                    this.listenTo(o, "execute", (() => {
                        e.execute("imageStyle", {value: t.name});
                        e.editing.view.focus()
                    }));
                    return o
                }))
            }
        }

        function nB(t, e) {
            for (const n of t) {
                if (e[n.title]) {
                    n.title = e[n.title]
                }
            }
            return t
        }

        class iB extends tA {
            static get requires() {
                return [QI, eB]
            }

            static get pluginName() {
                return "ImageStyle"
            }
        }

        class oB extends tA {
            static get requires() {
                return [MM]
            }

            static get pluginName() {
                return "WidgetToolbarRepository"
            }

            init() {
                const t = this.editor;
                if (t.plugins.has("BalloonToolbar")) {
                    const e = t.plugins.get("BalloonToolbar");
                    this.listenTo(e, "show", (e => {
                        if (aB(t.editing.view.document.selection)) {
                            e.stop()
                        }
                    }), {priority: "high"})
                }
                this._toolbarDefinitions = new Map;
                this._balloon = this.editor.plugins.get("ContextualBalloon");
                this.on("change:isEnabled", (() => {
                    this._updateToolbarsVisibility()
                }));
                this.listenTo(t.ui, "update", (() => {
                    this._updateToolbarsVisibility()
                }));
                this.listenTo(t.ui.focusTracker, "change:isFocused", (() => {
                    this._updateToolbarsVisibility()
                }), {priority: "low"})
            }

            destroy() {
                super.destroy();
                for (const t of this._toolbarDefinitions.values()) {
                    t.view.destroy()
                }
            }

            register(t, {ariaLabel: e, items: n, getRelatedElement: i, balloonClassName: o = "ck-toolbar-container"}) {
                if (!n.length) {
                    Object(ss["c"])("widget-toolbar-no-items", {toolbarId: t});
                    return
                }
                const r = this.editor;
                const s = r.t;
                const a = new Hw(r.locale);
                a.ariaLabel = e || s("Widget toolbar");
                if (this._toolbarDefinitions.has(t)) {
                    throw new ss["a"]("widget-toolbar-duplicated", this, {toolbarId: t})
                }
                a.fillFromConfig(n, r.ui.componentFactory);
                this._toolbarDefinitions.set(t, {view: a, getRelatedElement: i, balloonClassName: o})
            }

            _updateToolbarsVisibility() {
                let t = 0;
                let e = null;
                let n = null;
                for (const i of this._toolbarDefinitions.values()) {
                    const o = i.getRelatedElement(this.editor.editing.view.document.selection);
                    if (!this.isEnabled || !o) {
                        if (this._isToolbarInBalloon(i)) {
                            this._hideToolbar(i)
                        }
                    } else if (!this.editor.ui.focusTracker.isFocused) {
                        if (this._isToolbarVisible(i)) {
                            this._hideToolbar(i)
                        }
                    } else {
                        const r = o.getAncestors().length;
                        if (r > t) {
                            t = r;
                            e = o;
                            n = i
                        }
                    }
                }
                if (n) {
                    this._showToolbar(n, e)
                }
            }

            _hideToolbar(t) {
                this._balloon.remove(t.view);
                this.stopListening(this._balloon, "change:visibleView")
            }

            _showToolbar(t, e) {
                if (this._isToolbarVisible(t)) {
                    rB(this.editor, e)
                } else if (!this._isToolbarInBalloon(t)) {
                    this._balloon.add({
                        view: t.view,
                        position: sB(this.editor, e),
                        balloonClassName: t.balloonClassName
                    });
                    this.listenTo(this._balloon, "change:visibleView", (() => {
                        for (const t of this._toolbarDefinitions.values()) {
                            if (this._isToolbarVisible(t)) {
                                const e = t.getRelatedElement(this.editor.editing.view.document.selection);
                                rB(this.editor, e)
                            }
                        }
                    }))
                }
            }

            _isToolbarVisible(t) {
                return this._balloon.visibleView === t.view
            }

            _isToolbarInBalloon(t) {
                return this._balloon.hasView(t.view)
            }
        }

        function rB(t, e) {
            const n = t.plugins.get("ContextualBalloon");
            const i = sB(t, e);
            n.updatePosition(i)
        }

        function sB(t, e) {
            const n = t.editing.view;
            const i = ZE.defaultPositions;
            return {
                target: n.domConverter.mapViewToDom(e),
                positions: [i.northArrowSouth, i.northArrowSouthWest, i.northArrowSouthEast, i.southArrowNorth, i.southArrowNorthWest, i.southArrowNorthEast, AD]
            }
        }

        function aB(t) {
            const e = t.getSelectedElement();
            return !!(e && hD(e))
        }

        class cB extends tA {
            static get requires() {
                return [oB]
            }

            static get pluginName() {
                return "ImageToolbar"
            }

            afterInit() {
                const t = this.editor;
                const e = t.t;
                const n = t.plugins.get(oB);
                n.register("image", {
                    ariaLabel: e("Image toolbar"),
                    items: t.config.get("image.toolbar") || [],
                    getRelatedElement: sT
                })
            }
        }

        class lB extends nA {
            constructor(t) {
                super(t);
                this._childCommands = []
            }

            refresh() {
            }

            execute(...t) {
                const e = this._getFirstEnabledCommand();
                return e.execute(t)
            }

            registerChildCommand(t) {
                this._childCommands.push(t);
                t.on("change:isEnabled", (() => this._checkEnabled()));
                this._checkEnabled()
            }

            _checkEnabled() {
                this.isEnabled = !!this._getFirstEnabledCommand()
            }

            _getFirstEnabledCommand() {
                return this._childCommands.find((t => t.isEnabled))
            }
        }

        class dB extends tA {
            static get pluginName() {
                return "IndentEditing"
            }

            init() {
                const t = this.editor;
                t.commands.add("indent", new lB(t));
                t.commands.add("outdent", new lB(t))
            }
        }

        var uB = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zM1.632 6.95L5.02 9.358a.4.4 0 0 1-.013.661l-3.39 2.207A.4.4 0 0 1 1 11.892V7.275a.4.4 0 0 1 .632-.326z"/></svg>';
        var hB = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zm1.618-9.55L.98 9.358a.4.4 0 0 0 .013.661l3.39 2.207A.4.4 0 0 0 5 11.892V7.275a.4.4 0 0 0-.632-.326z"/></svg>';

        class mB extends tA {
            static get pluginName() {
                return "IndentUI"
            }

            init() {
                const t = this.editor;
                const e = t.locale;
                const n = t.t;
                const i = e.uiLanguageDirection == "ltr" ? uB : hB;
                const o = e.uiLanguageDirection == "ltr" ? hB : uB;
                this._defineButton("indent", n("Increase indent"), i);
                this._defineButton("outdent", n("Decrease indent"), o)
            }

            _defineButton(t, e, n) {
                const i = this.editor;
                i.ui.componentFactory.add(t, (o => {
                    const r = i.commands.get(t);
                    const s = new sw(o);
                    s.set({label: e, icon: n, tooltip: true});
                    s.bind("isOn", "isEnabled").to(r, "value", "isEnabled");
                    this.listenTo(s, "execute", (() => {
                        i.execute(t);
                        i.editing.view.focus()
                    }));
                    return s
                }))
            }
        }

        class gB extends tA {
            static get pluginName() {
                return "Indent"
            }

            static get requires() {
                return [dB, mB]
            }
        }

        class fB extends nA {
            constructor(t, e) {
                super(t);
                this._indentBehavior = e
            }

            refresh() {
                const t = this.editor;
                const e = t.model;
                const n = oA(e.document.selection.getSelectedBlocks());
                if (!n || !e.schema.checkAttribute(n, "blockIndent")) {
                    this.isEnabled = false;
                    return
                }
                this.isEnabled = this._indentBehavior.checkEnabled(n.getAttribute("blockIndent"))
            }

            execute() {
                const t = this.editor.model;
                const e = pB(t);
                t.change((t => {
                    for (const n of e) {
                        const e = n.getAttribute("blockIndent");
                        const i = this._indentBehavior.getNextIndent(e);
                        if (i) {
                            t.setAttribute("blockIndent", i, n)
                        } else {
                            t.removeAttribute("blockIndent", n)
                        }
                    }
                }))
            }
        }

        function pB(t) {
            const e = t.document.selection;
            const n = t.schema;
            const i = Array.from(e.getSelectedBlocks());
            return i.filter((t => n.checkAttribute(t, "blockIndent")))
        }

        class bB {
            constructor(t) {
                this.isForward = t.direction === "forward";
                this.offset = t.offset;
                this.unit = t.unit
            }

            checkEnabled(t) {
                const e = parseFloat(t || 0);
                return this.isForward || e > 0
            }

            getNextIndent(t) {
                const e = parseFloat(t || 0);
                const n = !t || t.endsWith(this.unit);
                if (!n) {
                    return this.isForward ? this.offset + this.unit : undefined
                }
                const i = this.isForward ? this.offset : -this.offset;
                const o = e + i;
                return o > 0 ? o + this.unit : undefined
            }
        }

        class kB {
            constructor(t) {
                this.isForward = t.direction === "forward";
                this.classes = t.classes
            }

            checkEnabled(t) {
                const e = this.classes.indexOf(t);
                if (this.isForward) {
                    return e < this.classes.length - 1
                } else {
                    return e >= 0
                }
            }

            getNextIndent(t) {
                const e = this.classes.indexOf(t);
                const n = this.isForward ? 1 : -1;
                return this.classes[e + n]
            }
        }

        function wB(t) {
            t.setNormalizer("margin", yx("margin"));
            t.setNormalizer("margin-top", (t => ({path: "margin.top", value: t})));
            t.setNormalizer("margin-right", (t => ({path: "margin.right", value: t})));
            t.setNormalizer("margin-bottom", (t => ({path: "margin.bottom", value: t})));
            t.setNormalizer("margin-left", (t => ({path: "margin.left", value: t})));
            t.setReducer("margin", Cx("margin"));
            t.setStyleRelation("margin", ["margin-top", "margin-right", "margin-bottom", "margin-left"])
        }

        class AB extends tA {
            constructor(t) {
                super(t);
                t.config.define("indentBlock", {offset: 40, unit: "px"})
            }

            static get pluginName() {
                return "IndentBlock"
            }

            init() {
                const t = this.editor;
                const e = t.config.get("indentBlock");
                const n = !e.classes || !e.classes.length;
                const i = Object.assign({direction: "forward"}, e);
                const o = Object.assign({direction: "backward"}, e);
                if (n) {
                    t.data.addStyleProcessorRules(wB);
                    this._setupConversionUsingOffset(t.conversion);
                    t.commands.add("indentBlock", new fB(t, new bB(i)));
                    t.commands.add("outdentBlock", new fB(t, new bB(o)))
                } else {
                    this._setupConversionUsingClasses(e.classes);
                    t.commands.add("indentBlock", new fB(t, new kB(i)));
                    t.commands.add("outdentBlock", new fB(t, new kB(o)))
                }
            }

            afterInit() {
                const t = this.editor;
                const e = t.model.schema;
                const n = t.commands.get("indent");
                const i = t.commands.get("outdent");
                const o = ["paragraph", "heading1", "heading2", "heading3", "heading4", "heading5", "heading6"];
                o.forEach((t => {
                    if (e.isRegistered(t)) {
                        e.extend(t, {allowAttributes: "blockIndent"})
                    }
                }));
                e.setAttributeProperties("blockIndent", {isFormatting: true});
                n.registerChildCommand(t.commands.get("indentBlock"));
                i.registerChildCommand(t.commands.get("outdentBlock"))
            }

            _setupConversionUsingOffset() {
                const t = this.editor.conversion;
                const e = this.editor.locale;
                const n = e.contentLanguageDirection === "rtl" ? "margin-right" : "margin-left";
                t.for("upcast").attributeToAttribute({
                    view: {styles: {[n]: /[\s\S]+/}},
                    model: {key: "blockIndent", value: t => t.getStyle(n)}
                });
                t.for("downcast").attributeToAttribute({
                    model: "blockIndent",
                    view: t => ({key: "style", value: {[n]: t}})
                })
            }

            _setupConversionUsingClasses(t) {
                const e = {model: {key: "blockIndent", values: []}, view: {}};
                for (const n of t) {
                    e.model.values.push(n);
                    e.view[n] = {key: "class", value: [n]}
                }
                this.editor.conversion.attributeToAttribute(e)
            }
        }

        const _B = "italic";

        class CB extends tA {
            static get pluginName() {
                return "ItalicEditing"
            }

            init() {
                const t = this.editor;
                t.model.schema.extend("$text", {allowAttributes: _B});
                t.model.schema.setAttributeProperties(_B, {isFormatting: true, copyOnEnter: true});
                t.conversion.attributeToElement({
                    model: _B,
                    view: "i",
                    upcastAlso: ["em", {styles: {"font-style": "italic"}}]
                });
                t.commands.add(_B, new oC(t, _B));
                t.keystrokes.set("CTRL+I", _B)
            }
        }

        var vB = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.586 14.633l.021.004c-.036.335.095.655.393.962.082.083.173.15.274.201h1.474a.6.6 0 1 1 0 1.2H5.304a.6.6 0 0 1 0-1.2h1.15c.474-.07.809-.182 1.005-.334.157-.122.291-.32.404-.597l2.416-9.55a1.053 1.053 0 0 0-.281-.823 1.12 1.12 0 0 0-.442-.296H8.15a.6.6 0 0 1 0-1.2h6.443a.6.6 0 1 1 0 1.2h-1.195c-.376.056-.65.155-.823.296-.215.175-.423.439-.623.79l-2.366 9.347z"/></svg>';
        const yB = "italic";

        class xB extends tA {
            init() {
                const t = this.editor;
                const e = t.t;
                t.ui.componentFactory.add(yB, (n => {
                    const i = t.commands.get(yB);
                    const o = new sw(n);
                    o.set({label: e("Italic"), icon: vB, keystroke: "CTRL+I", tooltip: true, isToggleable: true});
                    o.bind("isOn", "isEnabled").to(i, "value", "isEnabled");
                    this.listenTo(o, "execute", (() => {
                        t.execute(yB);
                        t.editing.view.focus()
                    }));
                    return o
                }))
            }
        }

        class EB extends tA {
            static get requires() {
                return [CB, xB]
            }

            static get pluginName() {
                return "Italic"
            }
        }

        class DB {
            constructor() {
                this._definitions = new Set
            }

            get length() {
                return this._definitions.size
            }

            add(t) {
                if (Array.isArray(t)) {
                    t.forEach((t => this._definitions.add(t)))
                } else {
                    this._definitions.add(t)
                }
            }

            getDispatcher() {
                return t => {
                    t.on("attribute:linkHref", ((t, e, n) => {
                        if (!n.consumable.test(e.item, "attribute:linkHref")) {
                            return
                        }
                        const i = n.writer;
                        const o = i.document.selection;
                        for (const t of this._definitions) {
                            const r = i.createAttributeElement("a", t.attributes, {priority: 5});
                            i.setCustomProperty("link", true, r);
                            if (t.callback(e.attributeNewValue)) {
                                if (e.item.is("selection")) {
                                    i.wrap(o.getFirstRange(), r)
                                } else {
                                    i.wrap(n.mapper.toViewRange(e.range), r)
                                }
                            } else {
                                i.unwrap(n.mapper.toViewRange(e.range), r)
                            }
                        }
                    }), {priority: "high"})
                }
            }

            getDispatcherForLinkedImage() {
                return t => {
                    t.on("attribute:linkHref:image", ((t, e, n) => {
                        const i = n.mapper.toViewElement(e.item);
                        const o = Array.from(i.getChildren()).find((t => t.name === "a"));
                        for (const t of this._definitions) {
                            const i = Us(t.attributes);
                            if (t.callback(e.attributeNewValue)) {
                                for (const [t, e] of i) {
                                    if (t === "class") {
                                        n.writer.addClass(e, o)
                                    } else {
                                        n.writer.setAttribute(t, e, o)
                                    }
                                }
                            } else {
                                for (const [t, e] of i) {
                                    if (t === "class") {
                                        n.writer.removeClass(e, o)
                                    } else {
                                        n.writer.removeAttribute(t, o)
                                    }
                                }
                            }
                        }
                    }))
                }
            }
        }

        class TB extends nA {
            constructor(t) {
                super(t);
                this.manualDecorators = new vs;
                this.automaticDecorators = new DB
            }

            restoreManualDecoratorStates() {
                for (const t of this.manualDecorators) {
                    t.value = this._getDecoratorStateFromModel(t.id)
                }
            }

            refresh() {
                const t = this.editor.model;
                const e = t.document;
                const n = oA(e.selection.getSelectedBlocks());
                if (T_(n, t.schema)) {
                    this.value = n.getAttribute("linkHref");
                    this.isEnabled = t.schema.checkAttribute(n, "linkHref")
                } else {
                    this.value = e.selection.getAttribute("linkHref");
                    this.isEnabled = t.schema.checkAttributeInSelection(e.selection, "linkHref")
                }
                for (const t of this.manualDecorators) {
                    t.value = this._getDecoratorStateFromModel(t.id)
                }
            }

            execute(t, e = {}) {
                const n = this.editor.model;
                const i = n.document.selection;
                const o = [];
                const r = [];
                for (const t in e) {
                    if (e[t]) {
                        o.push(t)
                    } else {
                        r.push(t)
                    }
                }
                n.change((e => {
                    if (i.isCollapsed) {
                        const s = i.getFirstPosition();
                        if (i.hasAttribute("linkHref")) {
                            const a = bC(s, "linkHref", i.getAttribute("linkHref"), n);
                            e.setAttribute("linkHref", t, a);
                            o.forEach((t => {
                                e.setAttribute(t, true, a)
                            }));
                            r.forEach((t => {
                                e.removeAttribute(t, a)
                            }));
                            e.setSelection(e.createPositionAfter(a.end.nodeBefore))
                        } else if (t !== "") {
                            const r = Us(i.getAttributes());
                            r.set("linkHref", t);
                            o.forEach((t => {
                                r.set(t, true)
                            }));
                            const a = e.createText(t, r);
                            n.insertContent(a, s);
                            e.setSelection(e.createPositionAfter(a))
                        }
                        ["linkHref", ...o, ...r].forEach((t => {
                            e.removeSelectionAttribute(t)
                        }))
                    } else {
                        const s = n.schema.getValidRanges(i.getRanges(), "linkHref");
                        const a = [];
                        for (const t of i.getSelectedBlocks()) {
                            if (n.schema.checkAttribute(t, "linkHref")) {
                                a.push(e.createRangeOn(t))
                            }
                        }
                        const c = a.slice();
                        for (const t of s) {
                            if (this._isRangeToUpdate(t, a)) {
                                c.push(t)
                            }
                        }
                        for (const n of c) {
                            e.setAttribute("linkHref", t, n);
                            o.forEach((t => {
                                e.setAttribute(t, true, n)
                            }));
                            r.forEach((t => {
                                e.removeAttribute(t, n)
                            }))
                        }
                    }
                }))
            }

            _getDecoratorStateFromModel(t) {
                const e = this.editor.model;
                const n = e.document;
                const i = oA(n.selection.getSelectedBlocks());
                if (T_(i, e.schema)) {
                    return i.getAttribute(t)
                }
                return n.selection.getAttribute(t)
            }

            _isRangeToUpdate(t, e) {
                for (const n of e) {
                    if (n.containsRange(t)) {
                        return false
                    }
                }
                return true
            }
        }

        class MB extends nA {
            refresh() {
                const t = this.editor.model;
                const e = t.document;
                const n = oA(e.selection.getSelectedBlocks());
                if (T_(n, t.schema)) {
                    this.isEnabled = t.schema.checkAttribute(n, "linkHref")
                } else {
                    this.isEnabled = t.schema.checkAttributeInSelection(e.selection, "linkHref")
                }
            }

            execute() {
                const t = this.editor;
                const e = this.editor.model;
                const n = e.document.selection;
                const i = t.commands.get("link");
                e.change((t => {
                    const o = n.isCollapsed ? [bC(n.getFirstPosition(), "linkHref", n.getAttribute("linkHref"), e)] : n.getRanges();
                    for (const e of o) {
                        t.removeAttribute("linkHref", e);
                        if (i) {
                            for (const n of i.manualDecorators) {
                                t.removeAttribute(n.id, e)
                            }
                        }
                    }
                }))
            }
        }

        class SB {
            constructor({id: t, label: e, attributes: n, defaultValue: i}) {
                this.id = t;
                this.set("value");
                this.defaultValue = i;
                this.label = e;
                this.attributes = n
            }
        }

        Cs(SB, Qc);
        var IB = n(57);
        var BB = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        BB.insert = "head";
        BB.singleton = true;
        var LB = ob()(IB["a"], BB);
        var zB = IB["a"].locals || {};
        const NB = "ck-link_selected";
        const PB = "automatic";
        const OB = "manual";
        const jB = /^(https?:)?\/\//;

        class RB extends tA {
            static get pluginName() {
                return "LinkEditing"
            }

            static get requires() {
                return [uC, ty, Dv]
            }

            constructor(t) {
                super(t);
                t.config.define("link", {addTargetToExternalLinks: false})
            }

            init() {
                const t = this.editor;
                t.model.schema.extend("$text", {allowAttributes: "linkHref"});
                t.conversion.for("dataDowncast").attributeToElement({model: "linkHref", view: v_});
                t.conversion.for("editingDowncast").attributeToElement({
                    model: "linkHref",
                    view: (t, e) => v_(y_(t), e)
                });
                t.conversion.for("upcast").elementToAttribute({
                    view: {name: "a", attributes: {href: true}},
                    model: {key: "linkHref", value: t => t.getAttribute("href")}
                });
                t.commands.add("link", new TB(t));
                t.commands.add("unlink", new MB(t));
                const e = E_(t.t, D_(t.config.get("link.decorators")));
                this._enableAutomaticDecorators(e.filter((t => t.mode === PB)));
                this._enableManualDecorators(e.filter((t => t.mode === OB)));
                const n = t.plugins.get(uC);
                n.registerAttribute("linkHref");
                wC(t, "linkHref", "a", NB);
                this._enableInsertContentSelectionAttributesFixer();
                this._enableClickingAfterLink();
                this._enableTypingOverLink();
                this._handleDeleteContentAfterLink()
            }

            _enableAutomaticDecorators(t) {
                const e = this.editor;
                const n = e.commands.get("link");
                const i = n.automaticDecorators;
                if (e.config.get("link.addTargetToExternalLinks")) {
                    i.add({
                        id: "linkIsExternal",
                        mode: PB,
                        callback: t => jB.test(t),
                        attributes: {target: "_blank", rel: "noopener noreferrer"}
                    })
                }
                i.add(t);
                if (i.length) {
                    e.conversion.for("downcast").add(i.getDispatcher())
                }
            }

            _enableManualDecorators(t) {
                if (!t.length) {
                    return
                }
                const e = this.editor;
                const n = e.commands.get("link");
                const i = n.manualDecorators;
                t.forEach((t => {
                    e.model.schema.extend("$text", {allowAttributes: t.id});
                    i.add(new SB(t));
                    e.conversion.for("downcast").attributeToElement({
                        model: t.id, view: (e, {writer: n}) => {
                            if (e) {
                                const e = i.get(t.id).attributes;
                                const o = n.createAttributeElement("a", e, {priority: 5});
                                n.setCustomProperty("link", true, o);
                                return o
                            }
                        }
                    });
                    e.conversion.for("upcast").elementToAttribute({
                        view: {
                            name: "a",
                            attributes: i.get(t.id).attributes
                        }, model: {key: t.id}
                    })
                }))
            }

            _enableInsertContentSelectionAttributesFixer() {
                const t = this.editor;
                const e = t.model;
                const n = e.document.selection;
                const i = t.commands.get("link");
                this.listenTo(e, "insertContent", (() => {
                    const t = n.anchor.nodeBefore;
                    const o = n.anchor.nodeAfter;
                    if (!n.hasAttribute("linkHref")) {
                        return
                    }
                    if (!t) {
                        return
                    }
                    if (!t.hasAttribute("linkHref")) {
                        return
                    }
                    if (o && o.hasAttribute("linkHref")) {
                        return
                    }
                    e.change((t => {
                        FB(t, i.manualDecorators)
                    }))
                }), {priority: "low"})
            }

            _enableClickingAfterLink() {
                const t = this.editor;
                const e = t.commands.get("link");
                t.editing.view.addObserver(_T);
                let n = false;
                this.listenTo(t.editing.view.document, "mousedown", (() => {
                    n = true
                }));
                this.listenTo(t.editing.view.document, "selectionChange", (() => {
                    if (!n) {
                        return
                    }
                    n = false;
                    const i = t.model.document.selection;
                    if (!i.isCollapsed) {
                        return
                    }
                    if (!i.hasAttribute("linkHref")) {
                        return
                    }
                    const o = i.getFirstPosition();
                    const r = bC(o, "linkHref", i.getAttribute("linkHref"), t.model);
                    if (o.isTouching(r.start) || o.isTouching(r.end)) {
                        t.model.change((t => {
                            FB(t, e.manualDecorators)
                        }))
                    }
                }))
            }

            _enableTypingOverLink() {
                const t = this.editor;
                const e = t.editing.view;
                let n;
                let i;
                this.listenTo(e.document, "delete", (() => {
                    i = true
                }), {priority: "high"});
                this.listenTo(t.model, "deleteContent", (() => {
                    const e = t.model.document.selection;
                    if (e.isCollapsed) {
                        return
                    }
                    if (i) {
                        i = false;
                        return
                    }
                    if (!HB(t)) {
                        return
                    }
                    if (VB(t.model)) {
                        n = e.getAttributes()
                    }
                }), {priority: "high"});
                this.listenTo(t.model, "insertContent", ((e, [o]) => {
                    i = false;
                    if (!HB(t)) {
                        return
                    }
                    if (!n) {
                        return
                    }
                    t.model.change((t => {
                        for (const [e, i] of n) {
                            t.setAttribute(e, i, o)
                        }
                    }));
                    n = null
                }), {priority: "high"})
            }

            _handleDeleteContentAfterLink() {
                const t = this.editor;
                const e = t.model;
                const n = e.document.selection;
                const i = t.editing.view;
                const o = t.commands.get("link");
                let r = false;
                let s = false;
                this.listenTo(i.document, "delete", ((t, e) => {
                    s = e.domEvent.keyCode === Nl.backspace
                }), {priority: "high"});
                this.listenTo(e, "deleteContent", (() => {
                    r = false;
                    const t = n.getFirstPosition();
                    const i = n.getAttribute("linkHref");
                    if (!i) {
                        return
                    }
                    const o = bC(t, "linkHref", i, e);
                    r = o.containsPosition(t) || o.end.isEqual(t)
                }), {priority: "high"});
                this.listenTo(e, "deleteContent", (() => {
                    if (!s) {
                        return
                    }
                    s = false;
                    if (r) {
                        return
                    }
                    t.model.enqueueChange((t => {
                        FB(t, o.manualDecorators)
                    }))
                }), {priority: "low"})
            }
        }

        function FB(t, e) {
            t.removeSelectionAttribute("linkHref");
            for (const n of e) {
                t.removeSelectionAttribute(n.id)
            }
        }

        function VB(t) {
            const e = t.document.selection;
            const n = e.getFirstPosition();
            const i = e.getLastPosition();
            const o = n.nodeAfter;
            if (!o) {
                return false
            }
            if (!o.is("$text")) {
                return false
            }
            if (!o.hasAttribute("linkHref")) {
                return false
            }
            const r = i.textNode || i.nodeBefore;
            if (o === r) {
                return true
            }
            const s = bC(n, "linkHref", o.getAttribute("linkHref"), t);
            return s.containsRange(t.createRange(n, i), true)
        }

        function HB(t) {
            const e = t.plugins.get("Input");
            return e.isInput(t.model.change((t => t.batch)))
        }

        class UB extends eh {
            constructor(t) {
                super(t);
                this.domEventType = "click"
            }

            onDomEvent(t) {
                this.fire(t.type, t)
            }
        }

        var WB = n(58);
        var qB = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        qB.insert = "head";
        qB.singleton = true;
        var KB = ob()(WB["a"], qB);
        var GB = WB["a"].locals || {};

        class $B extends Zb {
            constructor(t, e, n) {
                super(t);
                const i = t.t;
                this.focusTracker = new Zp;
                this.keystrokes = new Fp;
                this.urlInputView = this._createUrlInput(n);
                this.saveButtonView = this._createButton(i("Save"), KD, "ck-button-save");
                this.saveButtonView.type = "submit";
                this.cancelButtonView = this._createButton(i("Cancel"), GD, "ck-button-cancel", "cancel");
                this._manualDecoratorSwitches = this._createManualDecoratorSwitches(e);
                this.children = this._createFormChildren(e.manualDecorators);
                this._focusables = new Ab;
                this._focusCycler = new xk({
                    focusables: this._focusables,
                    focusTracker: this.focusTracker,
                    keystrokeHandler: this.keystrokes,
                    actions: {focusPrevious: "shift + tab", focusNext: "tab"}
                });
                const o = ["ck", "ck-link-form", "ck-responsive-form"];
                if (e.manualDecorators.length) {
                    o.push("ck-link-form_layout-vertical", "ck-vertical-form")
                }
                this.setTemplate({tag: "form", attributes: {class: o, tabindex: "-1"}, children: this.children})
            }

            getDecoratorSwitchesState() {
                return Array.from(this._manualDecoratorSwitches).reduce(((t, e) => {
                    t[e.name] = e.isOn;
                    return t
                }), {})
            }

            render() {
                super.render();
                cM({view: this});
                const t = [this.urlInputView, ...this._manualDecoratorSwitches, this.saveButtonView, this.cancelButtonView];
                t.forEach((t => {
                    this._focusables.add(t);
                    this.focusTracker.add(t.element)
                }));
                this.keystrokes.listenTo(this.element)
            }

            focus() {
                this._focusCycler.focusFirst()
            }

            _createUrlInput(t = "https://") {
                const e = this.locale.t;
                const n = new tM(this.locale, sM);
                n.label = e("Link URL");
                n.fieldView.placeholder = t + "example.com";
                return n
            }

            _createButton(t, e, n, i) {
                const o = new sw(this.locale);
                o.set({label: t, icon: e, tooltip: true});
                o.extendTemplate({attributes: {class: n}});
                if (i) {
                    o.delegate("execute").to(this, i)
                }
                return o
            }

            _createManualDecoratorSwitches(t) {
                const e = this.createCollection();
                for (const n of t.manualDecorators) {
                    const i = new Aw(this.locale);
                    i.set({name: n.id, label: n.label, withText: true});
                    i.bind("isOn").toMany([n, t], "value", ((t, e) => e === undefined && t === undefined ? n.defaultValue : t));
                    i.on("execute", (() => {
                        n.set("value", !i.isOn)
                    }));
                    e.add(i)
                }
                return e
            }

            _createFormChildren(t) {
                const e = this.createCollection();
                e.add(this.urlInputView);
                if (t.length) {
                    const t = new Zb;
                    t.setTemplate({
                        tag: "ul",
                        children: this._manualDecoratorSwitches.map((t => ({
                            tag: "li",
                            children: [t],
                            attributes: {class: ["ck", "ck-list__item"]}
                        }))),
                        attributes: {class: ["ck", "ck-reset", "ck-list"]}
                    });
                    e.add(t)
                }
                e.add(this.saveButtonView);
                e.add(this.cancelButtonView);
                return e
            }
        }

        var YB = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.077 15l.991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184zm4.919 10.562l-1.414 1.414a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.061-1.06l1.414 1.414 1.414-1.415a.75.75 0 0 1 1.061 1.061l-1.414 1.414 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414z"/></svg>';
        var QB = n(59);
        var JB = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        JB.insert = "head";
        JB.singleton = true;
        var XB = ob()(QB["a"], JB);
        var ZB = QB["a"].locals || {};

        class tL extends Zb {
            constructor(t) {
                super(t);
                const e = t.t;
                this.focusTracker = new Zp;
                this.keystrokes = new Fp;
                this.previewButtonView = this._createPreviewButton();
                this.unlinkButtonView = this._createButton(e("Unlink"), YB, "unlink");
                this.editButtonView = this._createButton(e("Edit link"), qD, "edit");
                this.set("href");
                this._focusables = new Ab;
                this._focusCycler = new xk({
                    focusables: this._focusables,
                    focusTracker: this.focusTracker,
                    keystrokeHandler: this.keystrokes,
                    actions: {focusPrevious: "shift + tab", focusNext: "tab"}
                });
                this.setTemplate({
                    tag: "div",
                    attributes: {class: ["ck", "ck-link-actions", "ck-responsive-form"], tabindex: "-1"},
                    children: [this.previewButtonView, this.editButtonView, this.unlinkButtonView]
                })
            }

            render() {
                super.render();
                const t = [this.previewButtonView, this.editButtonView, this.unlinkButtonView];
                t.forEach((t => {
                    this._focusables.add(t);
                    this.focusTracker.add(t.element)
                }));
                this.keystrokes.listenTo(this.element)
            }

            focus() {
                this._focusCycler.focusFirst()
            }

            _createButton(t, e, n) {
                const i = new sw(this.locale);
                i.set({label: t, icon: e, tooltip: true});
                i.delegate("execute").to(this, n);
                return i
            }

            _createPreviewButton() {
                const t = new sw(this.locale);
                const e = this.bindTemplate;
                const n = this.t;
                t.set({withText: true, tooltip: n("Open link in new tab")});
                t.extendTemplate({
                    attributes: {
                        class: ["ck", "ck-link-actions__preview"],
                        href: e.to("href", (t => t && y_(t))),
                        target: "_blank",
                        rel: "noopener noreferrer"
                    }
                });
                t.bind("label").to(this, "href", (t => t || n("This link has no URL")));
                t.bind("isEnabled").to(this, "href", (t => !!t));
                t.template.tag = "a";
                t.template.eventListeners = {};
                return t
            }
        }

        var eL = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.077 15l.991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184z"/></svg>';
        const nL = "link-ui";

        class iL extends tA {
            static get requires() {
                return [MM]
            }

            static get pluginName() {
                return "LinkUI"
            }

            init() {
                const t = this.editor;
                t.editing.view.addObserver(UB);
                this.actionsView = this._createActionsView();
                this.formView = this._createFormView();
                this._balloon = t.plugins.get(MM);
                this._createToolbarLinkButton();
                this._enableUserBalloonInteractions();
                t.conversion.for("editingDowncast").markerToHighlight({
                    model: nL,
                    view: {classes: ["ck-fake-link-selection"]}
                });
                t.conversion.for("editingDowncast").markerToElement({
                    model: nL,
                    view: {name: "span", classes: ["ck-fake-link-selection", "ck-fake-link-selection_collapsed"]}
                })
            }

            destroy() {
                super.destroy();
                this.formView.destroy()
            }

            _createActionsView() {
                const t = this.editor;
                const e = new tL(t.locale);
                const n = t.commands.get("link");
                const i = t.commands.get("unlink");
                e.bind("href").to(n, "value");
                e.editButtonView.bind("isEnabled").to(n);
                e.unlinkButtonView.bind("isEnabled").to(i);
                this.listenTo(e, "edit", (() => {
                    this._addFormView()
                }));
                this.listenTo(e, "unlink", (() => {
                    t.execute("unlink");
                    this._hideUI()
                }));
                e.keystrokes.set("Esc", ((t, e) => {
                    this._hideUI();
                    e()
                }));
                e.keystrokes.set(__, ((t, e) => {
                    this._addFormView();
                    e()
                }));
                return e
            }

            _createFormView() {
                const t = this.editor;
                const e = t.commands.get("link");
                const n = t.config.get("link.defaultProtocol");
                const i = new $B(t.locale, e, n);
                i.urlInputView.fieldView.bind("value").to(e, "value");
                i.urlInputView.bind("isReadOnly").to(e, "isEnabled", (t => !t));
                i.saveButtonView.bind("isEnabled").to(e);
                this.listenTo(i, "submit", (() => {
                    const {value: e} = i.urlInputView.fieldView.element;
                    const o = S_(e, n);
                    t.execute("link", o, i.getDecoratorSwitchesState());
                    this._closeFormView()
                }));
                this.listenTo(i, "cancel", (() => {
                    this._closeFormView()
                }));
                i.keystrokes.set("Esc", ((t, e) => {
                    this._closeFormView();
                    e()
                }));
                return i
            }

            _createToolbarLinkButton() {
                const t = this.editor;
                const e = t.commands.get("link");
                const n = t.t;
                t.keystrokes.set(__, ((t, n) => {
                    n();
                    if (e.isEnabled) {
                        this._showUI(true)
                    }
                }));
                t.ui.componentFactory.add("link", (t => {
                    const i = new sw(t);
                    i.isEnabled = true;
                    i.label = n("Link");
                    i.icon = eL;
                    i.keystroke = __;
                    i.tooltip = true;
                    i.isToggleable = true;
                    i.bind("isEnabled").to(e, "isEnabled");
                    i.bind("isOn").to(e, "value", (t => !!t));
                    this.listenTo(i, "execute", (() => this._showUI(true)));
                    return i
                }))
            }

            _enableUserBalloonInteractions() {
                const t = this.editor.editing.view.document;
                this.listenTo(t, "click", (() => {
                    const t = this._getSelectedLinkElement();
                    if (t) {
                        this._showUI()
                    }
                }));
                this.editor.keystrokes.set("Tab", ((t, e) => {
                    if (this._areActionsVisible && !this.actionsView.focusTracker.isFocused) {
                        this.actionsView.focus();
                        e()
                    }
                }), {priority: "high"});
                this.editor.keystrokes.set("Esc", ((t, e) => {
                    if (this._isUIVisible) {
                        this._hideUI();
                        e()
                    }
                }));
                _w({
                    emitter: this.formView,
                    activator: () => this._isUIInPanel,
                    contextElements: [this._balloon.view.element],
                    callback: () => this._hideUI()
                })
            }

            _addActionsView() {
                if (this._areActionsInPanel) {
                    return
                }
                this._balloon.add({view: this.actionsView, position: this._getBalloonPositionData()})
            }

            _addFormView() {
                if (this._isFormInPanel) {
                    return
                }
                const t = this.editor;
                const e = t.commands.get("link");
                this._balloon.add({view: this.formView, position: this._getBalloonPositionData()});
                if (this._balloon.visibleView === this.formView) {
                    this.formView.urlInputView.fieldView.select()
                }
                this.formView.urlInputView.fieldView.element.value = e.value || ""
            }

            _closeFormView() {
                const t = this.editor.commands.get("link");
                t.restoreManualDecoratorStates();
                if (t.value !== undefined) {
                    this._removeFormView()
                } else {
                    this._hideUI()
                }
            }

            _removeFormView() {
                if (this._isFormInPanel) {
                    this.formView.saveButtonView.focus();
                    this._balloon.remove(this.formView);
                    this.editor.editing.view.focus();
                    this._hideFakeVisualSelection()
                }
            }

            _showUI(t = false) {
                if (!this._getSelectedLinkElement()) {
                    this._showFakeVisualSelection();
                    this._addActionsView();
                    if (t) {
                        this._balloon.showStack("main")
                    }
                    this._addFormView()
                } else {
                    if (this._areActionsVisible) {
                        this._addFormView()
                    } else {
                        this._addActionsView()
                    }
                    if (t) {
                        this._balloon.showStack("main")
                    }
                }
                this._startUpdatingUI()
            }

            _hideUI() {
                if (!this._isUIInPanel) {
                    return
                }
                const t = this.editor;
                this.stopListening(t.ui, "update");
                this.stopListening(this._balloon, "change:visibleView");
                t.editing.view.focus();
                this._removeFormView();
                this._balloon.remove(this.actionsView);
                this._hideFakeVisualSelection()
            }

            _startUpdatingUI() {
                const t = this.editor;
                const e = t.editing.view.document;
                let n = this._getSelectedLinkElement();
                let i = r();
                const o = () => {
                    const t = this._getSelectedLinkElement();
                    const e = r();
                    if (n && !t || !n && e !== i) {
                        this._hideUI()
                    } else if (this._isUIVisible) {
                        this._balloon.updatePosition(this._getBalloonPositionData())
                    }
                    n = t;
                    i = e
                };

                function r() {
                    return e.selection.focus.getAncestors().reverse().find((t => t.is("element")))
                }

                this.listenTo(t.ui, "update", o);
                this.listenTo(this._balloon, "change:visibleView", o)
            }

            get _isFormInPanel() {
                return this._balloon.hasView(this.formView)
            }

            get _areActionsInPanel() {
                return this._balloon.hasView(this.actionsView)
            }

            get _areActionsVisible() {
                return this._balloon.visibleView === this.actionsView
            }

            get _isUIInPanel() {
                return this._isFormInPanel || this._areActionsInPanel
            }

            get _isUIVisible() {
                const t = this._balloon.visibleView;
                return t == this.formView || this._areActionsVisible
            }

            _getBalloonPositionData() {
                const t = this.editor.editing.view;
                const e = this.editor.model;
                const n = t.document;
                let i = null;
                if (e.markers.has(nL)) {
                    const e = Array.from(this.editor.editing.mapper.markerNameToElements(nL));
                    const n = t.createRange(t.createPositionBefore(e[0]), t.createPositionAfter(e[e.length - 1]));
                    i = t.domConverter.viewRangeToDom(n)
                } else {
                    const e = this._getSelectedLinkElement();
                    const o = n.selection.getFirstRange();
                    i = e ? t.domConverter.mapViewToDom(e) : t.domConverter.viewRangeToDom(o)
                }
                return {target: i}
            }

            _getSelectedLinkElement() {
                const t = this.editor.editing.view;
                const e = t.document.selection;
                if (e.isCollapsed) {
                    return oL(e.getFirstPosition())
                } else {
                    const n = e.getFirstRange().getTrimmed();
                    const i = oL(n.start);
                    const o = oL(n.end);
                    if (!i || i != o) {
                        return null
                    }
                    if (t.createRangeIn(i).getTrimmed().isEqual(n)) {
                        return i
                    } else {
                        return null
                    }
                }
            }

            _showFakeVisualSelection() {
                const t = this.editor.model;
                t.change((e => {
                    const n = t.document.selection.getFirstRange();
                    if (t.markers.has(nL)) {
                        e.updateMarker(nL, {range: n})
                    } else {
                        if (n.start.isAtEnd) {
                            const i = t.document.selection.focus;
                            const o = rL(n, i, e);
                            e.addMarker(nL, {usingOperation: false, affectsData: false, range: o})
                        } else {
                            e.addMarker(nL, {usingOperation: false, affectsData: false, range: n})
                        }
                    }
                }))
            }

            _hideFakeVisualSelection() {
                const t = this.editor.model;
                if (t.markers.has(nL)) {
                    t.change((t => {
                        t.removeMarker(nL)
                    }))
                }
            }
        }

        function oL(t) {
            return t.getAncestors().find((t => C_(t)))
        }

        function rL(t, e, n) {
            const i = [t.start.path[0] + 1, 0];
            const o = n.createPositionFromPath(t.start.root, i, "toNext");
            const r = n.createRange(o, t.end);
            if (r.start.path[0] > t.end.path[0]) {
                return n.createRange(e)
            }
            if (o.isAtStart && o.isAtEnd) {
                return rL(r, e, n)
            }
            return r
        }

        class sL extends tA {
            static get requires() {
                return [RB, iL, z_]
            }

            static get pluginName() {
                return "Link"
            }
        }

        class aL extends tA {
            static get requires() {
                return [wT, RB]
            }

            static get pluginName() {
                return "LinkImageEditing"
            }

            init() {
                const t = this.editor;
                t.model.schema.extend("image", {allowAttributes: ["linkHref"]});
                t.conversion.for("upcast").add(cL());
                t.conversion.for("editingDowncast").add(lL({attachIconIndicator: true}));
                t.conversion.for("dataDowncast").add(lL({attachIconIndicator: false}));
                this._enableAutomaticDecorators();
                this._enableManualDecorators()
            }

            _enableAutomaticDecorators() {
                const t = this.editor;
                const e = t.commands.get("link");
                const n = e.automaticDecorators;
                if (n.length) {
                    t.conversion.for("downcast").add(n.getDispatcherForLinkedImage())
                }
            }

            _enableManualDecorators() {
                const t = this.editor;
                const e = t.commands.get("link");
                const n = e.manualDecorators;
                for (const i of e.manualDecorators) {
                    t.model.schema.extend("image", {allowAttributes: i.id});
                    t.conversion.for("downcast").add(dL(n, i));
                    t.conversion.for("upcast").add(uL(n, i))
                }
            }
        }

        function cL() {
            return t => {
                t.on("element:a", ((t, e, n) => {
                    const i = e.viewItem;
                    const o = hL(i);
                    if (!o) {
                        return
                    }
                    const r = {attributes: ["href"]};
                    if (!n.consumable.consume(i, r)) {
                        return
                    }
                    const s = i.getAttribute("href");
                    if (!s) {
                        return
                    }
                    let a = e.modelCursor.parent;
                    if (!a.is("element", "image")) {
                        const t = n.convertItem(o, e.modelCursor);
                        e.modelRange = t.modelRange;
                        e.modelCursor = t.modelCursor;
                        a = e.modelCursor.nodeBefore
                    }
                    if (a && a.is("element", "image")) {
                        n.writer.setAttribute("linkHref", s, a)
                    }
                }), {priority: "high"})
            }
        }

        function lL(t) {
            return e => {
                e.on("attribute:linkHref:image", ((e, n, i) => {
                    const o = i.mapper.toViewElement(n.item);
                    const r = i.writer;
                    const s = Array.from(o.getChildren()).find((t => t.name === "a"));
                    let a;
                    if (t.attachIconIndicator) {
                        a = r.createUIElement("span", {class: "ck ck-link-image_icon"}, (function (t) {
                            const e = this.toDomElement(t);
                            e.innerHTML = eL;
                            return e
                        }))
                    }
                    if (s) {
                        if (n.attributeNewValue) {
                            r.setAttribute("href", n.attributeNewValue, s)
                        } else {
                            const t = Array.from(s.getChildren()).find((t => t.name === "img"));
                            r.move(r.createRangeOn(t), r.createPositionAt(o, 0));
                            r.remove(s)
                        }
                    } else {
                        const t = r.createContainerElement("a", {href: n.attributeNewValue});
                        r.insert(r.createPositionAt(o, 0), t);
                        r.move(r.createRangeOn(o.getChild(1)), r.createPositionAt(t, 0));
                        if (a) {
                            r.insert(r.createPositionAt(t, "end"), a)
                        }
                    }
                }))
            }
        }

        function dL(t, e) {
            return n => {
                n.on(`attribute:${e.id}:image`, ((n, i, o) => {
                    const r = t.get(e.id).attributes;
                    const s = o.mapper.toViewElement(i.item);
                    const a = Array.from(s.getChildren()).find((t => t.name === "a"));
                    for (const [t, e] of Us(r)) {
                        o.writer.setAttribute(t, e, a)
                    }
                }))
            }
        }

        function uL(t, e) {
            return n => {
                n.on("element:a", ((n, i, o) => {
                    const r = i.viewItem;
                    const s = hL(r);
                    if (!s) {
                        return
                    }
                    const a = {attributes: t.get(e.id).attributes};
                    const c = new Ws(a);
                    const l = c.match(r);
                    if (!l) {
                        return
                    }
                    if (!o.consumable.consume(r, l.match)) {
                        return
                    }
                    const d = i.modelCursor.nodeBefore || i.modelCursor.parent;
                    o.writer.setAttribute(e.id, true, d)
                }), {priority: "high"})
            }
        }

        function hL(t) {
            return Array.from(t.getChildren()).find((t => t.name === "img"))
        }

        class mL extends tA {
            static get requires() {
                return [VM, RB, iL]
            }

            static get pluginName() {
                return "LinkImageUI"
            }

            init() {
                const t = this.editor;
                const e = t.editing.view.document;
                this.listenTo(e, "click", ((t, n) => {
                    const i = gL(e.selection.getSelectedElement());
                    if (i) {
                        n.preventDefault()
                    }
                }));
                this._createToolbarLinkImageButton()
            }

            _createToolbarLinkImageButton() {
                const t = this.editor;
                const e = t.t;
                t.ui.componentFactory.add("linkImage", (n => {
                    const i = new sw(n);
                    const o = t.plugins.get("LinkUI");
                    const r = t.commands.get("link");
                    i.set({
                        isEnabled: true,
                        label: e("Link image"),
                        icon: eL,
                        keystroke: __,
                        tooltip: true,
                        isToggleable: true
                    });
                    i.bind("isEnabled").to(r, "isEnabled");
                    i.bind("isOn").to(r, "value", (t => !!t));
                    this.listenTo(i, "execute", (() => {
                        const e = gL(t.editing.view.document.selection.getSelectedElement());
                        if (e) {
                            o._addActionsView()
                        } else {
                            o._showUI(true)
                        }
                    }));
                    return i
                }))
            }
        }

        function gL(t) {
            const e = t && rT(t);
            if (!e) {
                return false
            }
            return t.getChild(0).is("element", "a")
        }

        var fL = n(60);
        var pL = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        pL.insert = "head";
        pL.singleton = true;
        var bL = ob()(fL["a"], pL);
        var kL = fL["a"].locals || {};

        class wL extends tA {
            static get requires() {
                return [aL, mL]
            }

            static get pluginName() {
                return "LinkImage"
            }
        }

        class AL extends nA {
            constructor(t, e) {
                super(t);
                this.type = e
            }

            refresh() {
                this.value = this._getValue();
                this.isEnabled = this._checkEnabled()
            }

            execute() {
                const t = this.editor.model;
                const e = t.document;
                const n = Array.from(e.selection.getSelectedBlocks()).filter((e => CL(e, t.schema)));
                const i = this.value === true;
                t.change((t => {
                    if (i) {
                        let e = n[n.length - 1].nextSibling;
                        let i = Number.POSITIVE_INFINITY;
                        let o = [];
                        while (e && e.name == "listItem" && e.getAttribute("listIndent") !== 0) {
                            const t = e.getAttribute("listIndent");
                            if (t < i) {
                                i = t
                            }
                            const n = t - i;
                            o.push({element: e, listIndent: n});
                            e = e.nextSibling
                        }
                        o = o.reverse();
                        for (const e of o) {
                            t.setAttribute("listIndent", e.listIndent, e.element)
                        }
                    }
                    if (!i) {
                        let t = Number.POSITIVE_INFINITY;
                        for (const e of n) {
                            if (e.is("element", "listItem") && e.getAttribute("listIndent") < t) {
                                t = e.getAttribute("listIndent")
                            }
                        }
                        t = t === 0 ? 1 : t;
                        _L(n, true, t);
                        _L(n, false, t)
                    }
                    for (const e of n.reverse()) {
                        if (i && e.name == "listItem") {
                            t.rename(e, "paragraph")
                        } else if (!i && e.name != "listItem") {
                            t.setAttributes({listType: this.type, listIndent: 0}, e);
                            t.rename(e, "listItem")
                        } else if (!i && e.name == "listItem" && e.getAttribute("listType") != this.type) {
                            t.setAttribute("listType", this.type, e)
                        }
                    }
                    this.fire("_executeCleanup", n)
                }))
            }

            _getValue() {
                const t = oA(this.editor.model.document.selection.getSelectedBlocks());
                return !!t && t.is("element", "listItem") && t.getAttribute("listType") == this.type
            }

            _checkEnabled() {
                if (this.value) {
                    return true
                }
                const t = this.editor.model.document.selection;
                const e = this.editor.model.schema;
                const n = oA(t.getSelectedBlocks());
                if (!n) {
                    return false
                }
                return CL(n, e)
            }
        }

        function _L(t, e, n) {
            const i = e ? t[0] : t[t.length - 1];
            if (i.is("element", "listItem")) {
                let o = i[e ? "previousSibling" : "nextSibling"];
                let r = i.getAttribute("listIndent");
                while (o && o.is("element", "listItem") && o.getAttribute("listIndent") >= n) {
                    if (r > o.getAttribute("listIndent")) {
                        r = o.getAttribute("listIndent")
                    }
                    if (o.getAttribute("listIndent") == r) {
                        t[e ? "unshift" : "push"](o)
                    }
                    o = o[e ? "previousSibling" : "nextSibling"]
                }
            }
        }

        function CL(t, e) {
            return e.checkChild(t.parent, "listItem") && !e.isObject(t)
        }

        class vL extends nA {
            constructor(t, e) {
                super(t);
                this._indentBy = e == "forward" ? 1 : -1
            }

            refresh() {
                this.isEnabled = this._checkEnabled()
            }

            execute() {
                const t = this.editor.model;
                const e = t.document;
                let n = Array.from(e.selection.getSelectedBlocks());
                t.change((t => {
                    const e = n[n.length - 1];
                    let i = e.nextSibling;
                    while (i && i.name == "listItem" && i.getAttribute("listIndent") > e.getAttribute("listIndent")) {
                        n.push(i);
                        i = i.nextSibling
                    }
                    if (this._indentBy < 0) {
                        n = n.reverse()
                    }
                    for (const e of n) {
                        const n = e.getAttribute("listIndent") + this._indentBy;
                        if (n < 0) {
                            t.rename(e, "paragraph")
                        } else {
                            t.setAttribute("listIndent", n, e)
                        }
                    }
                    this.fire("_executeCleanup", n)
                }))
            }

            _checkEnabled() {
                const t = oA(this.editor.model.document.selection.getSelectedBlocks());
                if (!t || !t.is("element", "listItem")) {
                    return false
                }
                if (this._indentBy > 0) {
                    const e = t.getAttribute("listIndent");
                    const n = t.getAttribute("listType");
                    let i = t.previousSibling;
                    while (i && i.is("element", "listItem") && i.getAttribute("listIndent") >= e) {
                        if (i.getAttribute("listIndent") == e) {
                            return i.getAttribute("listType") == n
                        }
                        i = i.previousSibling
                    }
                    return false
                }
                return true
            }
        }

        function yL(t) {
            const e = t.createContainerElement("li");
            e.getFillerOffset = LL;
            return e
        }

        function xL(t, e) {
            const n = e.mapper;
            const i = e.writer;
            const o = t.getAttribute("listType") == "numbered" ? "ol" : "ul";
            const r = yL(i);
            const s = i.createContainerElement(o, null);
            i.insert(i.createPositionAt(s, 0), r);
            n.bindElements(t, r);
            return r
        }

        function EL(t, e, n, i) {
            const o = e.parent;
            const r = n.mapper;
            const s = n.writer;
            let a = r.toViewPosition(i.createPositionBefore(t));
            const c = ML(t.previousSibling, {
                sameIndent: true,
                smallerIndent: true,
                listIndent: t.getAttribute("listIndent")
            });
            const l = t.previousSibling;
            if (c && c.getAttribute("listIndent") == t.getAttribute("listIndent")) {
                const t = r.toViewElement(c);
                a = s.breakContainer(s.createPositionAfter(t))
            } else {
                if (l && l.name == "listItem") {
                    a = r.toViewPosition(i.createPositionAt(l, "end"));
                    const t = r.findMappedViewAncestor(a);
                    const e = IL(t);
                    if (e) {
                        a = s.createPositionBefore(e)
                    } else {
                        a = s.createPositionAt(t, "end")
                    }
                } else {
                    a = r.toViewPosition(i.createPositionBefore(t))
                }
            }
            a = TL(a);
            s.insert(a, o);
            if (l && l.name == "listItem") {
                const t = r.toViewElement(l);
                const n = s.createRange(s.createPositionAt(t, 0), a);
                const i = n.getWalker({ignoreElementEnd: true});
                for (const t of i) {
                    if (t.item.is("element", "li")) {
                        const n = s.breakContainer(s.createPositionBefore(t.item));
                        const o = t.item.parent;
                        const r = s.createPositionAt(e, "end");
                        DL(s, r.nodeBefore, r.nodeAfter);
                        s.move(s.createRangeOn(o), r);
                        i.position = n
                    }
                }
            } else {
                const n = o.nextSibling;
                if (n && (n.is("element", "ul") || n.is("element", "ol"))) {
                    let i = null;
                    for (const e of n.getChildren()) {
                        const n = r.toModelElement(e);
                        if (n && n.getAttribute("listIndent") > t.getAttribute("listIndent")) {
                            i = e
                        } else {
                            break
                        }
                    }
                    if (i) {
                        s.breakContainer(s.createPositionAfter(i));
                        s.move(s.createRangeOn(i.parent), s.createPositionAt(e, "end"))
                    }
                }
            }
            DL(s, o, o.nextSibling);
            DL(s, o.previousSibling, o)
        }

        function DL(t, e, n) {
            if (!e || !n || e.name != "ul" && e.name != "ol") {
                return null
            }
            if (e.name != n.name || e.getAttribute("class") !== n.getAttribute("class")) {
                return null
            }
            return t.mergeContainers(t.createPositionAfter(e))
        }

        function TL(t) {
            return t.getLastMatchingPosition((t => t.item.is("uiElement")))
        }

        function ML(t, e) {
            const n = !!e.sameIndent;
            const i = !!e.smallerIndent;
            const o = e.listIndent;
            let r = t;
            while (r && r.name == "listItem") {
                const t = r.getAttribute("listIndent");
                if (n && o == t || i && o > t) {
                    return r
                }
                if (e.direction === "forward") {
                    r = r.nextSibling
                } else {
                    r = r.previousSibling
                }
            }
            return null
        }

        function SL(t, e, n, i) {
            t.ui.componentFactory.add(e, (o => {
                const r = t.commands.get(e);
                const s = new sw(o);
                s.set({label: n, icon: i, tooltip: true, isToggleable: true});
                s.bind("isOn", "isEnabled").to(r, "value", "isEnabled");
                s.on("execute", (() => {
                    t.execute(e);
                    t.editing.view.focus()
                }));
                return s
            }))
        }

        function IL(t) {
            for (const e of t.getChildren()) {
                if (e.name == "ul" || e.name == "ol") {
                    return e
                }
            }
            return null
        }

        function BL(t, e) {
            const n = [];
            const i = t.parent;
            const o = {ignoreElementEnd: true, startPosition: t, shallow: true, direction: e};
            const r = i.getAttribute("listIndent");
            const s = [...new $h(o)].filter((t => t.item.is("element"))).map((t => t.item));
            for (const t of s) {
                if (!t.is("element", "listItem")) {
                    break
                }
                if (t.getAttribute("listIndent") < r) {
                    break
                }
                if (t.getAttribute("listIndent") > r) {
                    continue
                }
                if (t.getAttribute("listType") !== i.getAttribute("listType")) {
                    break
                }
                if (t.getAttribute("listStyle") !== i.getAttribute("listStyle")) {
                    break
                }
                if (e === "backward") {
                    n.unshift(t)
                } else {
                    n.push(t)
                }
            }
            return n
        }

        function LL() {
            const t = !this.isEmpty && (this.getChild(0).name == "ul" || this.getChild(0).name == "ol");
            if (this.isEmpty || t) {
                return 0
            }
            return Uc.call(this)
        }

        function zL(t) {
            return (e, n, i) => {
                const o = i.consumable;
                if (!o.test(n.item, "insert") || !o.test(n.item, "attribute:listType") || !o.test(n.item, "attribute:listIndent")) {
                    return
                }
                o.consume(n.item, "insert");
                o.consume(n.item, "attribute:listType");
                o.consume(n.item, "attribute:listIndent");
                const r = n.item;
                const s = xL(r, i);
                EL(r, s, i, t)
            }
        }

        function NL(t) {
            return (e, n, i) => {
                const o = i.mapper.toViewPosition(n.position);
                const r = o.getLastMatchingPosition((t => !t.item.is("element", "li")));
                const s = r.nodeAfter;
                const a = i.writer;
                a.breakContainer(a.createPositionBefore(s));
                a.breakContainer(a.createPositionAfter(s));
                const c = s.parent;
                const l = c.previousSibling;
                const d = a.createRangeOn(c);
                const u = a.remove(d);
                if (l && l.nextSibling) {
                    DL(a, l, l.nextSibling)
                }
                const h = i.mapper.toModelElement(s);
                QL(h.getAttribute("listIndent") + 1, n.position, d.start, s, i, t);
                for (const t of a.createRangeIn(u).getItems()) {
                    i.mapper.unbindViewElement(t)
                }
                e.stop()
            }
        }

        function PL(t, e, n) {
            if (!n.consumable.consume(e.item, "attribute:listType")) {
                return
            }
            const i = n.mapper.toViewElement(e.item);
            const o = n.writer;
            o.breakContainer(o.createPositionBefore(i));
            o.breakContainer(o.createPositionAfter(i));
            const r = i.parent;
            const s = e.attributeNewValue == "numbered" ? "ol" : "ul";
            o.rename(s, r)
        }

        function OL(t, e, n) {
            const i = n.mapper.toViewElement(e.item);
            const o = i.parent;
            const r = n.writer;
            DL(r, o, o.nextSibling);
            DL(r, o.previousSibling, o);
            for (const t of e.item.getChildren()) {
                n.consumable.consume(t, "insert")
            }
        }

        function jL(t) {
            return (e, n, i) => {
                if (!i.consumable.consume(n.item, "attribute:listIndent")) {
                    return
                }
                const o = i.mapper.toViewElement(n.item);
                const r = i.writer;
                r.breakContainer(r.createPositionBefore(o));
                r.breakContainer(r.createPositionAfter(o));
                const s = o.parent;
                const a = s.previousSibling;
                const c = r.createRangeOn(s);
                r.remove(c);
                if (a && a.nextSibling) {
                    DL(r, a, a.nextSibling)
                }
                QL(n.attributeOldValue + 1, n.range.start, c.start, o, i, t);
                EL(n.item, o, i, t);
                for (const t of n.item.getChildren()) {
                    i.consumable.consume(t, "insert")
                }
            }
        }

        function RL(t, e, n) {
            if (e.item.name != "listItem") {
                let t = n.mapper.toViewPosition(e.range.start);
                const i = n.writer;
                const o = [];
                while (t.parent.name == "ul" || t.parent.name == "ol") {
                    t = i.breakContainer(t);
                    if (t.parent.name != "li") {
                        break
                    }
                    const e = t;
                    const n = i.createPositionAt(t.parent, "end");
                    if (!e.isEqual(n)) {
                        const t = i.remove(i.createRange(e, n));
                        o.push(t)
                    }
                    t = i.createPositionAfter(t.parent)
                }
                if (o.length > 0) {
                    for (let e = 0; e < o.length; e++) {
                        const n = t.nodeBefore;
                        const r = i.insert(t, o[e]);
                        t = r.end;
                        if (e > 0) {
                            const e = DL(i, n, n.nextSibling);
                            if (e && e.parent == n) {
                                t.offset--
                            }
                        }
                    }
                    DL(i, t.nodeBefore, t.nodeAfter)
                }
            }
        }

        function FL(t, e, n) {
            const i = n.mapper.toViewPosition(e.position);
            const o = i.nodeBefore;
            const r = i.nodeAfter;
            DL(n.writer, o, r)
        }

        function VL(t, e, n) {
            if (n.consumable.consume(e.viewItem, {name: true})) {
                const t = n.writer;
                const i = t.createElement("listItem");
                const o = XL(e.viewItem);
                t.setAttribute("listIndent", o, i);
                const r = e.viewItem.parent && e.viewItem.parent.name == "ol" ? "numbered" : "bulleted";
                t.setAttribute("listType", r, i);
                if (!n.safeInsert(i, e.modelCursor)) {
                    return
                }
                const s = $L(i, e.viewItem.getChildren(), n);
                e.modelRange = t.createRange(e.modelCursor, s);
                n.updateConversionResult(i, e)
            }
        }

        function HL(t, e, n) {
            if (n.consumable.test(e.viewItem, {name: true})) {
                const t = Array.from(e.viewItem.getChildren());
                for (const e of t) {
                    const t = !(e.is("element", "li") || JL(e));
                    if (t) {
                        e._remove()
                    }
                }
            }
        }

        function UL(t, e, n) {
            if (n.consumable.test(e.viewItem, {name: true})) {
                if (e.viewItem.childCount === 0) {
                    return
                }
                const t = [...e.viewItem.getChildren()];
                let n = false;
                let i = true;
                for (const e of t) {
                    if (n && !JL(e)) {
                        e._remove()
                    }
                    if (e.is("$text")) {
                        if (i) {
                            e._data = e.data.replace(/^\s+/, "")
                        }
                        if (!e.nextSibling || JL(e.nextSibling)) {
                            e._data = e.data.replace(/\s+$/, "")
                        }
                    } else if (JL(e)) {
                        n = true
                    }
                    i = false
                }
            }
        }

        function WL(t) {
            return (e, n) => {
                if (n.isPhantom) {
                    return
                }
                const i = n.modelPosition.nodeBefore;
                if (i && i.is("element", "listItem")) {
                    const e = n.mapper.toViewElement(i);
                    const o = e.getAncestors().find(JL);
                    const r = t.createPositionAt(e, 0).getWalker();
                    for (const t of r) {
                        if (t.type == "elementStart" && t.item.is("element", "li")) {
                            n.viewPosition = t.previousPosition;
                            break
                        } else if (t.type == "elementEnd" && t.item == o) {
                            n.viewPosition = t.nextPosition;
                            break
                        }
                    }
                }
            }
        }

        function qL(t) {
            return (e, n) => {
                const i = n.viewPosition;
                const o = i.parent;
                const r = n.mapper;
                if (o.name == "ul" || o.name == "ol") {
                    if (!i.isAtEnd) {
                        const e = r.toModelElement(i.nodeAfter);
                        n.modelPosition = t.createPositionBefore(e)
                    } else {
                        const e = r.toModelElement(i.nodeBefore);
                        const o = r.getModelLength(i.nodeBefore);
                        n.modelPosition = t.createPositionBefore(e).getShiftedBy(o)
                    }
                    e.stop()
                } else if (o.name == "li" && i.nodeBefore && (i.nodeBefore.name == "ul" || i.nodeBefore.name == "ol")) {
                    const s = r.toModelElement(o);
                    let a = 1;
                    let c = i.nodeBefore;
                    while (c && JL(c)) {
                        a += r.getModelLength(c);
                        c = c.previousSibling
                    }
                    n.modelPosition = t.createPositionBefore(s).getShiftedBy(a);
                    e.stop()
                }
            }
        }

        function KL(t, e) {
            const n = t.document.differ.getChanges();
            const i = new Map;
            let o = false;
            for (const i of n) {
                if (i.type == "insert" && i.name == "listItem") {
                    r(i.position)
                } else if (i.type == "insert" && i.name != "listItem") {
                    if (i.name != "$text") {
                        const n = i.position.nodeAfter;
                        if (n.hasAttribute("listIndent")) {
                            e.removeAttribute("listIndent", n);
                            o = true
                        }
                        if (n.hasAttribute("listType")) {
                            e.removeAttribute("listType", n);
                            o = true
                        }
                        if (n.hasAttribute("listStyle")) {
                            e.removeAttribute("listStyle", n);
                            o = true
                        }
                        for (const e of Array.from(t.createRangeIn(n)).filter((t => t.item.is("element", "listItem")))) {
                            r(e.previousPosition)
                        }
                    }
                    const n = i.position.getShiftedBy(i.length);
                    r(n)
                } else if (i.type == "remove" && i.name == "listItem") {
                    r(i.position)
                } else if (i.type == "attribute" && i.attributeKey == "listIndent") {
                    r(i.range.start)
                } else if (i.type == "attribute" && i.attributeKey == "listType") {
                    r(i.range.start)
                }
            }
            for (const t of i.values()) {
                s(t);
                a(t)
            }
            return o;

            function r(t) {
                const e = t.nodeBefore;
                if (!e || !e.is("element", "listItem")) {
                    const e = t.nodeAfter;
                    if (e && e.is("element", "listItem")) {
                        i.set(e, e)
                    }
                } else {
                    let t = e;
                    if (i.has(t)) {
                        return
                    }
                    for (let e = t.previousSibling; e && e.is("element", "listItem"); e = t.previousSibling) {
                        t = e;
                        if (i.has(t)) {
                            return
                        }
                    }
                    i.set(e, t)
                }
            }

            function s(t) {
                let n = 0;
                let i = null;
                while (t && t.is("element", "listItem")) {
                    const r = t.getAttribute("listIndent");
                    if (r > n) {
                        let s;
                        if (i === null) {
                            i = r - n;
                            s = n
                        } else {
                            if (i > r) {
                                i = r
                            }
                            s = r - i
                        }
                        e.setAttribute("listIndent", s, t);
                        o = true
                    } else {
                        i = null;
                        n = t.getAttribute("listIndent") + 1
                    }
                    t = t.nextSibling
                }
            }

            function a(t) {
                let n = [];
                let i = null;
                while (t && t.is("element", "listItem")) {
                    const r = t.getAttribute("listIndent");
                    if (i && i.getAttribute("listIndent") > r) {
                        n = n.slice(0, r + 1)
                    }
                    if (r != 0) {
                        if (n[r]) {
                            const i = n[r];
                            if (t.getAttribute("listType") != i) {
                                e.setAttribute("listType", i, t);
                                o = true
                            }
                        } else {
                            n[r] = t.getAttribute("listType")
                        }
                    }
                    i = t;
                    t = t.nextSibling
                }
            }
        }

        function GL(t, [e, n]) {
            let i = e.is("documentFragment") ? e.getChild(0) : e;
            let o;
            if (!n) {
                o = this.document.selection
            } else {
                o = this.createSelection(n)
            }
            if (i && i.is("element", "listItem")) {
                const t = o.getFirstPosition();
                let e = null;
                if (t.parent.is("element", "listItem")) {
                    e = t.parent
                } else if (t.nodeBefore && t.nodeBefore.is("element", "listItem")) {
                    e = t.nodeBefore
                }
                if (e) {
                    const t = e.getAttribute("listIndent");
                    if (t > 0) {
                        while (i && i.is("element", "listItem")) {
                            i._setAttribute("listIndent", i.getAttribute("listIndent") + t);
                            i = i.nextSibling
                        }
                    }
                }
            }
        }

        function $L(t, e, n) {
            const {writer: i, schema: o} = n;
            let r = i.createPositionAfter(t);
            for (const s of e) {
                if (s.name == "ul" || s.name == "ol") {
                    r = n.convertItem(s, r).modelCursor
                } else {
                    const e = n.convertItem(s, i.createPositionAt(t, "end"));
                    const a = e.modelRange.start.nodeAfter;
                    const c = a && a.is("element") && !o.checkChild(t, a.name);
                    if (c) {
                        if (e.modelCursor.parent.is("element", "listItem")) {
                            t = e.modelCursor.parent
                        } else {
                            t = YL(e.modelCursor)
                        }
                        r = i.createPositionAfter(t)
                    }
                }
            }
            return r
        }

        function YL(t) {
            const e = new $h({startPosition: t});
            let n;
            do {
                n = e.next()
            } while (!n.value.item.is("element", "listItem"));
            return n.value.item
        }

        function QL(t, e, n, i, o, r) {
            const s = ML(e.nodeBefore, {sameIndent: true, smallerIndent: true, listIndent: t, foo: "b"});
            const a = o.mapper;
            const c = o.writer;
            const l = s ? s.getAttribute("listIndent") : null;
            let d;
            if (!s) {
                d = n
            } else if (l == t) {
                const t = a.toViewElement(s).parent;
                d = c.createPositionAfter(t)
            } else {
                const t = r.createPositionAt(s, "end");
                d = a.toViewPosition(t)
            }
            d = TL(d);
            for (const t of [...i.getChildren()]) {
                if (JL(t)) {
                    d = c.move(c.createRangeOn(t), d).end;
                    DL(c, t, t.nextSibling);
                    DL(c, t.previousSibling, t)
                }
            }
        }

        function JL(t) {
            return t.is("element", "ol") || t.is("element", "ul")
        }

        function XL(t) {
            let e = 0;
            let n = t.parent;
            while (n) {
                if (n.is("element", "li")) {
                    e++
                } else {
                    const t = n.previousSibling;
                    if (t && t.is("element", "li")) {
                        e++
                    }
                }
                n = n.parent
            }
            return e
        }

        class ZL extends tA {
            static get pluginName() {
                return "ListEditing"
            }

            static get requires() {
                return [kE]
            }

            init() {
                const t = this.editor;
                t.model.schema.register("listItem", {
                    inheritAllFrom: "$block",
                    allowAttributes: ["listType", "listIndent"]
                });
                const e = t.data;
                const n = t.editing;
                t.model.document.registerPostFixer((e => KL(t.model, e)));
                n.mapper.registerViewToModelLength("li", tz);
                e.mapper.registerViewToModelLength("li", tz);
                n.mapper.on("modelToViewPosition", WL(n.view));
                n.mapper.on("viewToModelPosition", qL(t.model));
                e.mapper.on("modelToViewPosition", WL(n.view));
                t.conversion.for("editingDowncast").add((e => {
                    e.on("insert", RL, {priority: "high"});
                    e.on("insert:listItem", zL(t.model));
                    e.on("attribute:listType:listItem", PL, {priority: "high"});
                    e.on("attribute:listType:listItem", OL, {priority: "low"});
                    e.on("attribute:listIndent:listItem", jL(t.model));
                    e.on("remove:listItem", NL(t.model));
                    e.on("remove", FL, {priority: "low"})
                }));
                t.conversion.for("dataDowncast").add((e => {
                    e.on("insert", RL, {priority: "high"});
                    e.on("insert:listItem", zL(t.model))
                }));
                t.conversion.for("upcast").add((t => {
                    t.on("element:ul", HL, {priority: "high"});
                    t.on("element:ol", HL, {priority: "high"});
                    t.on("element:li", UL, {priority: "high"});
                    t.on("element:li", VL)
                }));
                t.model.on("insertContent", GL, {priority: "high"});
                t.commands.add("numberedList", new AL(t, "numbered"));
                t.commands.add("bulletedList", new AL(t, "bulleted"));
                t.commands.add("indentList", new vL(t, "forward"));
                t.commands.add("outdentList", new vL(t, "backward"));
                const i = n.view.document;
                this.listenTo(i, "enter", ((t, e) => {
                    const n = this.editor.model.document;
                    const i = n.selection.getLastPosition().parent;
                    if (n.selection.isCollapsed && i.name == "listItem" && i.isEmpty) {
                        this.editor.execute("outdentList");
                        e.preventDefault();
                        t.stop()
                    }
                }));
                this.listenTo(i, "delete", ((t, e) => {
                    if (e.direction !== "backward") {
                        return
                    }
                    const n = this.editor.model.document.selection;
                    if (!n.isCollapsed) {
                        return
                    }
                    const i = n.getFirstPosition();
                    if (!i.isAtStart) {
                        return
                    }
                    const o = i.parent;
                    if (o.name !== "listItem") {
                        return
                    }
                    const r = o.previousSibling && o.previousSibling.name === "listItem";
                    if (r) {
                        return
                    }
                    this.editor.execute("outdentList");
                    e.preventDefault();
                    t.stop()
                }), {priority: "high"});
                const o = t => (e, n) => {
                    const i = this.editor.commands.get(t);
                    if (i.isEnabled) {
                        this.editor.execute(t);
                        n()
                    }
                };
                t.keystrokes.set("Tab", o("indentList"));
                t.keystrokes.set("Shift+Tab", o("outdentList"))
            }

            afterInit() {
                const t = this.editor.commands;
                const e = t.get("indent");
                const n = t.get("outdent");
                if (e) {
                    e.registerChildCommand(t.get("indentList"))
                }
                if (n) {
                    n.registerChildCommand(t.get("outdentList"))
                }
            }
        }

        function tz(t) {
            let e = 1;
            for (const n of t.getChildren()) {
                if (n.name == "ul" || n.name == "ol") {
                    for (const t of n.getChildren()) {
                        e += tz(t)
                    }
                }
            }
            return e
        }

        var ez = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM3.5 3v5H2V3.7H1v-1h2.5V3zM.343 17.857l2.59-3.257H2.92a.6.6 0 1 0-1.04 0H.302a2 2 0 1 1 3.995 0h-.001c-.048.405-.16.734-.333.988-.175.254-.59.692-1.244 1.312H4.3v1h-4l.043-.043zM7 14.75a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z"/></svg>';
        var nz = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0C1 4.784 1.777 4 2.75 4c.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75C1.784 7.5 1 6.723 1 5.75zm6 9c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0c0-.966.777-1.75 1.75-1.75.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75-.966 0-1.75-.777-1.75-1.75z"/></svg>';

        class iz extends tA {
            init() {
                const t = this.editor.t;
                SL(this.editor, "numberedList", t("Numbered List"), ez);
                SL(this.editor, "bulletedList", t("Bulleted List"), nz)
            }
        }

        class oz extends tA {
            static get requires() {
                return [ZL, iz]
            }

            static get pluginName() {
                return "List"
            }
        }

        class rz extends nA {
            constructor(t, e) {
                super(t);
                this._defaultType = e
            }

            refresh() {
                this.value = this._getValue();
                this.isEnabled = this._checkEnabled()
            }

            execute(t = {}) {
                const e = this.editor.model;
                const n = e.document;
                let i = [...n.selection.getSelectedBlocks()].filter((t => t.is("element", "listItem"))).map((t => {
                    const n = e.change((e => e.createPositionAt(t, 0)));
                    return [...BL(n, "backward"), ...BL(n, "forward")]
                })).flat();
                i = [...new Set(i)];
                if (!i.length) {
                    return
                }
                e.change((e => {
                    for (const n of i) {
                        e.setAttribute("listStyle", t.type || this._defaultType, n)
                    }
                }))
            }

            _getValue() {
                const t = this.editor.model.document.selection.getFirstPosition().parent;
                if (t && t.is("element", "listItem")) {
                    return t.getAttribute("listStyle")
                }
                return null
            }

            _checkEnabled() {
                const t = this.editor;
                const e = t.commands.get("numberedList");
                const n = t.commands.get("bulletedList");
                return e.isEnabled || n.isEnabled
            }
        }

        const sz = "default";

        class az extends tA {
            static get requires() {
                return [ZL]
            }

            static get pluginName() {
                return "ListStyleEditing"
            }

            init() {
                const t = this.editor;
                const e = t.model;
                e.schema.extend("listItem", {allowAttributes: ["listStyle"]});
                t.commands.add("listStyle", new rz(t, sz));
                this.listenTo(t.commands.get("indentList"), "_executeCleanup", dz(t));
                this.listenTo(t.commands.get("outdentList"), "_executeCleanup", uz(t));
                this.listenTo(t.commands.get("bulletedList"), "_executeCleanup", gz(t));
                this.listenTo(t.commands.get("numberedList"), "_executeCleanup", gz(t));
                e.document.registerPostFixer(hz(t));
                t.conversion.for("upcast").add(cz());
                t.conversion.for("downcast").add(lz());
                this._mergeListStyleAttributeWhileMergingLists()
            }

            afterInit() {
                const t = this.editor;
                if (t.commands.get("todoList")) {
                    t.model.document.registerPostFixer(mz(t))
                }
            }

            _mergeListStyleAttributeWhileMergingLists() {
                const t = this.editor;
                const e = t.model;
                let n;
                this.listenTo(e, "deleteContent", ((t, [e]) => {
                    const i = e.getFirstPosition();
                    const o = e.getLastPosition();
                    if (i.parent === o.parent) {
                        return
                    }
                    if (!i.parent.is("element", "listItem")) {
                        return
                    }
                    const r = o.parent.nextSibling;
                    if (!r || !r.is("element", "listItem")) {
                        return
                    }
                    const s = ML(i.parent, {sameIndent: true, listIndent: r.getAttribute("listIndent")});
                    if (!s) {
                        return
                    }
                    if (s.getAttribute("listType") === r.getAttribute("listType")) {
                        n = s
                    }
                }), {priority: "high"});
                this.listenTo(e, "deleteContent", (() => {
                    if (!n) {
                        return
                    }
                    e.change((t => {
                        const e = ML(n.nextSibling, {
                            sameIndent: true,
                            listIndent: n.getAttribute("listIndent"),
                            direction: "forward"
                        });
                        const i = [e, ...BL(t.createPositionAt(e, 0), "forward")];
                        for (const e of i) {
                            t.setAttribute("listStyle", n.getAttribute("listStyle"), e)
                        }
                    }));
                    n = null
                }), {priority: "low"})
            }
        }

        function cz() {
            return t => {
                t.on("element:li", ((t, e, n) => {
                    const i = e.viewItem.parent;
                    const o = i.getStyle("list-style-type") || sz;
                    const r = e.modelRange.start.nodeAfter || e.modelRange.end.nodeBefore;
                    n.writer.setAttribute("listStyle", o, r)
                }), {priority: "low"})
            }
        }

        function lz() {
            return n => {
                n.on("attribute:listStyle:listItem", ((n, i, o) => {
                    const r = o.writer;
                    const s = i.item;
                    const a = ML(s.previousSibling, {
                        sameIndent: true,
                        listIndent: s.getAttribute("listIndent"),
                        direction: "backward"
                    });
                    const c = o.mapper.toViewElement(s);
                    if (!t(s, a)) {
                        r.breakContainer(r.createPositionBefore(c))
                    }
                    e(r, i.attributeNewValue, c.parent)
                }), {priority: "low"})
            };

            function t(t, e) {
                return e && t.getAttribute("listType") === e.getAttribute("listType") && t.getAttribute("listIndent") === e.getAttribute("listIndent") && t.getAttribute("listStyle") === e.getAttribute("listStyle")
            }

            function e(t, e, n) {
                if (e && e !== sz) {
                    t.setStyle("list-style-type", e, n)
                } else {
                    t.removeStyle("list-style-type", n)
                }
            }
        }

        function dz(t) {
            return (e, n) => {
                let i;
                const o = n[0];
                const r = o.getAttribute("listIndent");
                const s = n.filter((t => t.getAttribute("listIndent") === r));
                if (o.previousSibling.getAttribute("listIndent") + 1 === r) {
                    i = sz
                } else {
                    const t = ML(o.previousSibling, {sameIndent: true, direction: "backward", listIndent: r});
                    i = t.getAttribute("listStyle")
                }
                t.model.change((t => {
                    for (const e of s) {
                        t.setAttribute("listStyle", i, e)
                    }
                }))
            }
        }

        function uz(t) {
            return (e, n) => {
                n = n.reverse().filter((t => t.is("element", "listItem")));
                if (!n.length) {
                    return
                }
                const i = n[0].getAttribute("listIndent");
                const o = n[0].getAttribute("listType");
                let r = n[0].previousSibling;
                if (r.is("element", "listItem")) {
                    while (r.getAttribute("listIndent") !== i) {
                        r = r.previousSibling
                    }
                } else {
                    r = null
                }
                if (!r) {
                    r = n[n.length - 1].nextSibling
                }
                if (!r || !r.is("element", "listItem")) {
                    return
                }
                if (r.getAttribute("listType") !== o) {
                    return
                }
                t.model.change((t => {
                    const e = n.filter((t => t.getAttribute("listIndent") === i));
                    for (const n of e) {
                        t.setAttribute("listStyle", r.getAttribute("listStyle"), n)
                    }
                }))
            }
        }

        function hz(t) {
            return n => {
                let i = false;
                const o = fz(t.model.document.differ.getChanges()).filter((t => t.getAttribute("listType") !== "todo"));
                if (!o.length) {
                    return i
                }
                let r = o[o.length - 1].nextSibling;
                if (!r || !r.is("element", "listItem")) {
                    r = o[o.length - 1].previousSibling;
                    if (r) {
                        const t = o[0].getAttribute("listIndent");
                        while (r.is("element", "listItem") && r.getAttribute("listIndent") !== t) {
                            r = r.previousSibling;
                            if (!r) {
                                break
                            }
                        }
                    }
                }
                for (const t of o) {
                    if (!t.hasAttribute("listStyle")) {
                        if (e(r, t)) {
                            n.setAttribute("listStyle", r.getAttribute("listStyle"), t)
                        } else {
                            n.setAttribute("listStyle", sz, t)
                        }
                        i = true
                    }
                }
                return i
            };

            function e(t, e) {
                if (!t) {
                    return false
                }
                const n = t.getAttribute("listStyle");
                if (!n) {
                    return false
                }
                if (n === sz) {
                    return false
                }
                if (t.getAttribute("listType") !== e.getAttribute("listType")) {
                    return false
                }
                return true
            }
        }

        function mz(t) {
            return e => {
                const n = fz(t.model.document.differ.getChanges()).filter((t => t.getAttribute("listType") === "todo" && t.hasAttribute("listStyle")));
                if (!n.length) {
                    return false
                }
                for (const t of n) {
                    e.removeAttribute("listStyle", t)
                }
                return true
            }
        }

        function gz(t) {
            return (e, n) => {
                n = n.filter((t => t.is("element", "listItem")));
                t.model.change((t => {
                    for (const e of n) {
                        t.removeAttribute("listStyle", e)
                    }
                }))
            }
        }

        function fz(t) {
            const e = [];
            for (const n of t) {
                const t = pz(n);
                if (t && t.is("element", "listItem")) {
                    e.push(t)
                }
            }
            return e
        }

        function pz(t) {
            if (t.type === "attribute") {
                return t.range.start.nodeAfter
            }
            if (t.type === "insert") {
                return t.position.nodeAfter
            }
            return null
        }

        var bz = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M11 27a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0-9a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0-9a3 3 0 1 1 0 6 3 3 0 0 1 0-6z"/></svg>';
        var kz = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M11 27a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0 1a2 2 0 1 0 0 4 2 2 0 0 0 0-4zm0-10a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0 1a2 2 0 1 0 0 4 2 2 0 0 0 0-4zm0-10a3 3 0 1 1 0 6 3 3 0 0 1 0-6zm0 1a2 2 0 1 0 0 4 2 2 0 0 0 0-4z"/></svg>';
        var wz = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M14 27v6H8v-6h6zm0-9v6H8v-6h6zm0-9v6H8V9h6z"/></svg>';
        var Az = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M10.29 15V8.531H9.286c-.14.393-.4.736-.778 1.03-.378.295-.728.495-1.05.6v1.121a4.257 4.257 0 0 0 1.595-.936V15h1.235zm3.343 0v-1.235h-1.235V15h1.235zM11.3 24v-1.147H8.848c.064-.111.148-.226.252-.343.104-.117.351-.354.74-.712.39-.357.66-.631.81-.821.225-.288.39-.562.494-.824.104-.263.156-.539.156-.829 0-.51-.182-.936-.545-1.279-.363-.342-.863-.514-1.499-.514-.58 0-1.063.148-1.45.444-.387.296-.617.784-.69 1.463l1.23.124c.024-.36.112-.619.264-.774.153-.155.358-.233.616-.233.26 0 .465.074.613.222.148.148.222.36.222.635 0 .25-.085.501-.255.756-.126.185-.468.536-1.024 1.055-.692.641-1.155 1.156-1.389 1.544-.234.389-.375.8-.422 1.233H11.3zm2.333 0v-1.235h-1.235V24h1.235zM9.204 34.11c.615 0 1.129-.2 1.542-.598.413-.398.62-.88.62-1.446 0-.39-.11-.722-.332-.997a1.5 1.5 0 0 0-.886-.532c.619-.337.928-.788.928-1.353 0-.399-.151-.756-.453-1.073-.366-.386-.852-.58-1.459-.58a2.25 2.25 0 0 0-.96.2 1.617 1.617 0 0 0-.668.55c-.16.232-.28.544-.358.933l1.138.194c.032-.282.123-.495.272-.642.15-.146.33-.22.54-.22.215 0 .386.065.515.194s.193.302.193.518c0 .255-.087.46-.263.613-.176.154-.43.227-.765.218l-.136 1.006c.22-.061.409-.092.567-.092.24 0 .444.09.61.272.168.182.251.428.251.739 0 .328-.087.589-.261.782a.833.833 0 0 1-.644.29.841.841 0 0 1-.607-.242c-.167-.16-.27-.394-.307-.698l-1.196.145c.062.542.285.98.668 1.316.384.335.868.503 1.45.503zm4.43-.11v-1.235h-1.236V34h1.235z"/></svg>';
        var _z = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M5.714 15.11c.624 0 1.11-.22 1.46-.66.421-.533.632-1.408.632-2.627 0-1.222-.21-2.096-.629-2.624-.351-.445-.839-.668-1.463-.668-.624 0-1.11.22-1.459.66-.422.533-.633 1.406-.633 2.619 0 1.236.192 2.095.576 2.577.384.482.89.723 1.516.723zm0-1.024a.614.614 0 0 1-.398-.14c-.115-.094-.211-.283-.287-.565-.077-.283-.115-.802-.115-1.558s.043-1.294.128-1.613c.064-.246.155-.417.272-.512a.617.617 0 0 1 .4-.143.61.61 0 0 1 .398.143c.116.095.211.284.288.567.076.283.114.802.114 1.558s-.043 1.292-.128 1.608c-.064.246-.155.417-.272.512a.617.617 0 0 1-.4.143zm6.078.914V8.531H10.79c-.14.393-.4.736-.778 1.03-.378.295-.728.495-1.05.6v1.121a4.257 4.257 0 0 0 1.595-.936V15h1.235zm3.344 0v-1.235h-1.235V15h1.235zm-9.422 9.11c.624 0 1.11-.22 1.46-.66.421-.533.632-1.408.632-2.627 0-1.222-.21-2.096-.629-2.624-.351-.445-.839-.668-1.463-.668-.624 0-1.11.22-1.459.66-.422.533-.633 1.406-.633 2.619 0 1.236.192 2.095.576 2.577.384.482.89.723 1.516.723zm0-1.024a.614.614 0 0 1-.398-.14c-.115-.094-.211-.283-.287-.565-.077-.283-.115-.802-.115-1.558s.043-1.294.128-1.613c.064-.246.155-.417.272-.512a.617.617 0 0 1 .4-.143.61.61 0 0 1 .398.143c.116.095.211.284.288.567.076.283.114.802.114 1.558s-.043 1.292-.128 1.608c-.064.246-.155.417-.272.512a.617.617 0 0 1-.4.143zm7.088.914v-1.147H10.35c.065-.111.149-.226.253-.343.104-.117.35-.354.74-.712.39-.357.66-.631.81-.821.225-.288.39-.562.493-.824.104-.263.156-.539.156-.829 0-.51-.181-.936-.544-1.279-.364-.342-.863-.514-1.499-.514-.58 0-1.063.148-1.45.444-.387.296-.617.784-.69 1.463l1.23.124c.024-.36.112-.619.264-.774.152-.155.357-.233.615-.233.261 0 .465.074.613.222.148.148.222.36.222.635 0 .25-.085.501-.255.756-.126.185-.467.536-1.024 1.055-.691.641-1.154 1.156-1.388 1.544-.235.389-.375.8-.422 1.233h4.328zm2.334 0v-1.235h-1.235V24h1.235zM5.714 34.11c.624 0 1.11-.22 1.46-.66.421-.533.632-1.408.632-2.627 0-1.222-.21-2.096-.629-2.624-.351-.445-.839-.668-1.463-.668-.624 0-1.11.22-1.459.66-.422.533-.633 1.406-.633 2.619 0 1.236.192 2.095.576 2.577.384.482.89.723 1.516.723zm0-1.024a.614.614 0 0 1-.398-.14c-.115-.094-.211-.283-.287-.565-.077-.283-.115-.802-.115-1.558s.043-1.294.128-1.613c.064-.246.155-.417.272-.512a.617.617 0 0 1 .4-.143.61.61 0 0 1 .398.143c.116.095.211.284.288.567.076.283.114.802.114 1.558s-.043 1.292-.128 1.608c-.064.246-.155.417-.272.512a.617.617 0 0 1-.4.143zm4.992 1.024c.616 0 1.13-.2 1.543-.598.413-.398.62-.88.62-1.446 0-.39-.111-.722-.332-.997a1.5 1.5 0 0 0-.886-.532c.618-.337.927-.788.927-1.353 0-.399-.15-.756-.452-1.073-.366-.386-.853-.58-1.46-.58a2.25 2.25 0 0 0-.96.2 1.617 1.617 0 0 0-.667.55c-.16.232-.28.544-.359.933l1.139.194c.032-.282.123-.495.272-.642.15-.146.33-.22.54-.22.214 0 .386.065.515.194s.193.302.193.518c0 .255-.088.46-.264.613-.175.154-.43.227-.764.218l-.136 1.006c.22-.061.408-.092.566-.092.24 0 .444.09.611.272.167.182.25.428.25.739 0 .328-.086.589-.26.782a.833.833 0 0 1-.644.29.841.841 0 0 1-.607-.242c-.167-.16-.27-.394-.308-.698l-1.195.145c.062.542.284.98.668 1.316.384.335.867.503 1.45.503zm4.43-.11v-1.235h-1.235V34h1.235z"/></svg>';
        var Cz = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M11.88 8.7V7.558h-1.234V8.7h1.234zm0 5.3V9.333h-1.234V14h1.234zm2.5 0v-1.235h-1.234V14h1.235zm-4.75 4.7v-1.142H8.395V18.7H9.63zm0 5.3v-4.667H8.395V24H9.63zm2.5-5.3v-1.142h-1.234V18.7h1.235zm0 5.3v-4.667h-1.234V24h1.235zm2.501 0v-1.235h-1.235V24h1.235zM7.38 28.7v-1.142H6.145V28.7H7.38zm0 5.3v-4.667H6.145V34H7.38zm2.5-5.3v-1.142H8.646V28.7H9.88zm0 5.3v-4.667H8.646V34H9.88zm2.5-5.3v-1.142h-1.234V28.7h1.235zm0 5.3v-4.667h-1.234V34h1.235zm2.501 0v-1.235h-1.235V34h1.235z"/></svg>';
        var vz = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M11.916 15V8.558h-1.301V15h1.3zm2.465 0v-1.235h-1.235V15h1.235zM9.665 25v-6.442h-1.3V25h1.3zm2.5 0v-6.442h-1.3V25h1.3zm2.466 0v-1.235h-1.235V25h1.235zm-7.216 9v-6.442h-1.3V34h1.3zm2.5 0v-6.442h-1.3V34h1.3zm2.501 0v-6.442h-1.3V34h1.3zm2.465 0v-1.235h-1.235V34h1.235z"/></svg>';
        var yz = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M9.62 14.105c.272 0 .528-.05.768-.153s.466-.257.677-.462c.009.024.023.072.044.145.047.161.086.283.119.365h1.221a2.649 2.649 0 0 1-.222-.626c-.04-.195-.059-.498-.059-.908l.013-1.441c0-.536-.055-.905-.165-1.105-.11-.201-.3-.367-.569-.497-.27-.13-.68-.195-1.23-.195-.607 0-1.064.108-1.371.325-.308.217-.525.55-.65 1.002l1.12.202c.076-.217.176-.369.299-.455.123-.086.294-.13.514-.13.325 0 .546.05.663.152.118.101.176.27.176.508v.123c-.222.093-.622.194-1.2.303-.427.082-.755.178-.982.288-.227.11-.403.268-.53.474a1.327 1.327 0 0 0-.188.706c0 .398.138.728.415.988.277.261.656.391 1.136.391zm.368-.87a.675.675 0 0 1-.492-.189.606.606 0 0 1-.193-.448c0-.176.08-.32.241-.435.106-.07.33-.142.673-.215a7.19 7.19 0 0 0 .751-.19v.247c0 .296-.016.496-.048.602a.773.773 0 0 1-.295.409 1.07 1.07 0 0 1-.637.22zm4.645.765v-1.235h-1.235V14h1.235zM10.2 25.105c.542 0 1.003-.215 1.382-.646.38-.43.57-1.044.57-1.84 0-.771-.187-1.362-.559-1.774a1.82 1.82 0 0 0-1.41-.617c-.522 0-.973.216-1.354.65v-2.32H7.594V25h1.147v-.686a1.9 1.9 0 0 0 .67.592c.26.133.523.2.79.2zm-.299-.975c-.354 0-.638-.164-.852-.492-.153-.232-.229-.59-.229-1.073 0-.468.098-.818.295-1.048a.93.93 0 0 1 .738-.345c.302 0 .55.118.743.354.193.236.29.62.29 1.154 0 .5-.096.868-.288 1.1-.192.233-.424.35-.697.35zm4.478.87v-1.235h-1.234V25h1.234zm-4.017 9.105c.6 0 1.08-.142 1.437-.426.357-.284.599-.704.725-1.261l-1.213-.207c-.061.326-.167.555-.316.688a.832.832 0 0 1-.576.2.916.916 0 0 1-.75-.343c-.185-.228-.278-.62-.278-1.173 0-.498.091-.853.274-1.066.183-.212.429-.318.736-.318.232 0 .42.061.565.184.145.123.238.306.28.55l1.216-.22c-.146-.501-.387-.874-.722-1.119-.336-.244-.788-.366-1.356-.366-.695 0-1.245.214-1.653.643-.407.43-.61 1.03-.61 1.8 0 .762.202 1.358.608 1.788.406.431.95.646 1.633.646zM14.633 34v-1.235h-1.235V34h1.235z"/></svg>';
        var xz = '<svg viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg"><path d="M35 29a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17zm0-9a1 1 0 0 1 1 1v1a1 1 0 0 1-1 1H18a1 1 0 0 1-1-1v-1a1 1 0 0 1 1-1h17z" fill-opacity=".163"/><path d="M7.88 15l.532-1.463h2.575L11.549 15h1.415l-2.58-6.442H9.01L6.5 15h1.38zm2.69-2.549H8.811l.87-2.39.887 2.39zM14.88 15v-1.235h-1.234V15h1.234zM9.352 25c.83-.006 1.352-.02 1.569-.044.346-.038.636-.14.872-.305.236-.166.422-.387.558-.664.137-.277.205-.562.205-.855 0-.372-.106-.695-.317-.97-.21-.276-.512-.471-.905-.585a1.51 1.51 0 0 0 .661-.567 1.5 1.5 0 0 0 .244-.83c0-.28-.066-.53-.197-.754a1.654 1.654 0 0 0-.495-.539 1.676 1.676 0 0 0-.672-.266c-.25-.042-.63-.063-1.14-.063H7.158V25h2.193zm.142-3.88H8.46v-1.49h.747c.612 0 .983.007 1.112.022.217.026.38.102.49.226.11.125.165.287.165.486a.68.68 0 0 1-.192.503.86.86 0 0 1-.525.23 11.47 11.47 0 0 1-.944.023h.18zm.17 2.795H8.46v-1.723h1.05c.592 0 .977.03 1.154.092.177.062.313.16.406.295a.84.84 0 0 1 .14.492c0 .228-.06.41-.181.547a.806.806 0 0 1-.473.257c-.126.026-.423.04-.892.04zM14.88 25v-1.235h-1.234V25h1.234zm-5.018 9.11c.691 0 1.262-.17 1.711-.512.45-.341.772-.864.965-1.567l-1.261-.4c-.109.472-.287.818-.536 1.037-.25.22-.547.33-.892.33-.47 0-.85-.173-1.143-.519-.293-.345-.44-.925-.44-1.74 0-.767.15-1.322.447-1.665.297-.343.684-.514 1.162-.514.346 0 .64.096.881.29.242.193.4.457.477.79l1.288-.307c-.147-.516-.367-.911-.66-1.187-.492-.465-1.132-.698-1.92-.698-.902 0-1.63.296-2.184.89-.554.593-.83 1.426-.83 2.498 0 1.014.275 1.813.825 2.397.551.585 1.254.877 2.11.877zM14.88 34v-1.235h-1.234V34h1.234z"/></svg>';
        var Ez = n(61);
        var Dz = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        Dz.insert = "head";
        Dz.singleton = true;
        var Tz = ob()(Ez["a"], Dz);
        var Mz = Ez["a"].locals || {};

        class Sz extends tA {
            static get pluginName() {
                return "ListStyleUI"
            }

            init() {
                const t = this.editor;
                const e = t.locale.t;
                t.ui.componentFactory.add("bulletedList", Iz({
                    editor: t,
                    parentCommandName: "bulletedList",
                    buttonLabel: e("Bulleted List"),
                    buttonIcon: nz,
                    toolbarAriaLabel: e("Bulleted list styles toolbar"),
                    styleDefinitions: [{
                        label: e("Toggle the disc list style"),
                        tooltip: e("Disc"),
                        type: "disc",
                        icon: bz
                    }, {
                        label: e("Toggle the circle list style"),
                        tooltip: e("Circle"),
                        type: "circle",
                        icon: kz
                    }, {label: e("Toggle the square list style"), tooltip: e("Square"), type: "square", icon: wz}]
                }));
                t.ui.componentFactory.add("numberedList", Iz({
                    editor: t,
                    parentCommandName: "numberedList",
                    buttonLabel: e("Numbered List"),
                    buttonIcon: ez,
                    toolbarAriaLabel: e("Numbered list styles toolbar"),
                    styleDefinitions: [{
                        label: e("Toggle the decimal list style"),
                        tooltip: e("Decimal"),
                        type: "decimal",
                        icon: Az
                    }, {
                        label: e("Toggle the decimal with leading zero list style"),
                        tooltip: e("Decimal with leading zero"),
                        type: "decimal-leading-zero",
                        icon: _z
                    }, {
                        label: e("Toggle the lower–roman list style"),
                        tooltip: e("Lower–roman"),
                        type: "lower-roman",
                        icon: Cz
                    }, {
                        label: e("Toggle the upper–roman list style"),
                        tooltip: e("Upper-roman"),
                        type: "upper-roman",
                        icon: vz
                    }, {
                        label: e("Toggle the lower–latin list style"),
                        tooltip: e("Lower-latin"),
                        type: "lower-latin",
                        icon: yz
                    }, {
                        label: e("Toggle the upper–latin list style"),
                        tooltip: e("Upper-latin"),
                        type: "upper-latin",
                        icon: xz
                    }]
                }))
            }
        }

        function Iz({editor: t, parentCommandName: e, buttonLabel: n, buttonIcon: i, toolbarAriaLabel: o, styleDefinitions: r}) {
            const s = t.commands.get(e);
            const a = t.commands.get("listStyle");
            return c => {
                const l = Sw(c, dv);
                const d = l.buttonView;
                const u = Bz({editor: t, parentCommandName: e, listStyleCommand: a});
                Iw(l, r.map(u));
                l.bind("isEnabled").to(s);
                l.toolbarView.ariaLabel = o;
                l.class = "ck-list-styles-dropdown";
                d.on("execute", (() => {
                    t.execute(e);
                    t.editing.view.focus()
                }));
                d.set({label: n, icon: i, tooltip: true, isToggleable: true});
                d.bind("isOn").to(s, "value", (t => !!t));
                return l
            }
        }

        function Bz({editor: t, listStyleCommand: e, parentCommandName: n}) {
            const i = t.locale;
            const o = t.commands.get(n);
            return ({label: r, type: s, icon: a, tooltip: c}) => {
                const l = new sw(i);
                l.set({label: r, icon: a, tooltip: c});
                e.on("change:value", (() => {
                    l.isOn = e.value === s
                }));
                l.on("execute", (() => {
                    if (o.value) {
                        if (e.value !== s) {
                            t.execute("listStyle", {type: s})
                        } else {
                            t.execute("listStyle", {type: e._defaultType})
                        }
                    } else {
                        t.model.change((() => {
                            t.execute(n);
                            t.execute("listStyle", {type: s})
                        }))
                    }
                    t.editing.view.focus()
                }));
                return l
            }
        }

        class Lz extends tA {
            static get requires() {
                return [az, Sz]
            }

            static get pluginName() {
                return "ListStyle"
            }
        }

        class zz {
            constructor(t, e = {}) {
                this.namespaces = e.namespaces || [];
                this._domParser = new DOMParser;
                this._domConverter = new Ud(t, {blockFillerMode: "nbsp"});
                this._htmlWriter = new Yp
            }

            toData(t) {
                const e = this._domConverter.viewToDom(t, document);
                return this._htmlWriter.getHtml(e)
            }

            toView(t) {
                const e = this._toDom(t);
                return this._domConverter.domToView(e, {keepOriginalCase: true})
            }

            _toDom(t) {
                const e = this.namespaces.map((t => `xmlns:${t}="nsp"`)).join(" ");
                t = `<xml ${e}>${t}</xml>`;
                const n = this._domParser.parseFromString(t, "text/xml");
                const i = n.querySelector("parsererror");
                if (i) {
                    throw new Error("Parse error - " + i.textContent)
                }
                const o = n.createDocumentFragment();
                const r = n.documentElement.childNodes;
                while (r.length > 0) {
                    o.appendChild(r[0])
                }
                return o
            }
        }

        class Nz {
            static get safeXmlCharactersEntities() {
                return {tagOpener: "&laquo;", tagCloser: "&raquo;", doubleQuote: "&uml;", realDoubleQuote: "&quot;"}
            }

            static get safeBadBlackboardCharacters() {
                return {ltElement: "«mo»<«/mo»", gtElement: "«mo»>«/mo»", ampElement: "«mo»&«/mo»"}
            }

            static get safeGoodBlackboardCharacters() {
                return {ltElement: "«mo»§lt;«/mo»", gtElement: "«mo»§gt;«/mo»", ampElement: "«mo»§amp;«/mo»"}
            }

            static get xmlCharacters() {
                return {
                    id: "xmlCharacters",
                    tagOpener: "<",
                    tagCloser: ">",
                    doubleQuote: '"',
                    ampersand: "&",
                    quote: "'"
                }
            }

            static get safeXmlCharacters() {
                return {
                    id: "safeXmlCharacters",
                    tagOpener: "«",
                    tagCloser: "»",
                    doubleQuote: "¨",
                    ampersand: "§",
                    quote: "`",
                    realDoubleQuote: "¨"
                }
            }
        }

        class Pz {
            static isMathmlInAttribute(t, e) {
                const n = "['\"][\\s]*=[\\s]*[\\w-]+";
                const i = "\"[^\"]*\"|'[^']*'";
                const o = `[\\s]*(${i})[\\s]*=[\\s]*[\\w-]+[\\s]*`;
                const r = `('${o}')*`;
                const s = `^${n}${r}[\\s]+gmi<`;
                const a = new RegExp(s);
                const c = t.substring(0, e);
                const l = c.split("").reverse().join("");
                const d = a.test(l);
                return d
            }

            static safeXmlDecode(t) {
                let {tagOpener: e} = Nz.safeXmlCharactersEntities;
                let {tagCloser: n} = Nz.safeXmlCharactersEntities;
                let {doubleQuote: i} = Nz.safeXmlCharactersEntities;
                let {realDoubleQuote: o} = Nz.safeXmlCharactersEntities;
                t = t.split(e).join(Nz.safeXmlCharacters.tagOpener);
                t = t.split(n).join(Nz.safeXmlCharacters.tagCloser);
                t = t.split(i).join(Nz.safeXmlCharacters.doubleQuote);
                t = t.split(o).join(Nz.safeXmlCharacters.realDoubleQuote);
                const {ltElement: r} = Nz.safeBadBlackboardCharacters;
                const {gtElement: s} = Nz.safeBadBlackboardCharacters;
                const {ampElement: a} = Nz.safeBadBlackboardCharacters;
                if ("_wrs_blackboard" in window && window._wrs_blackboard) {
                    t = t.split(r).join(Nz.safeGoodBlackboardCharacters.ltElement);
                    t = t.split(s).join(Nz.safeGoodBlackboardCharacters.gtElement);
                    t = t.split(a).join(Nz.safeGoodBlackboardCharacters.ampElement)
                }
                ({tagOpener: e} = Nz.safeXmlCharacters);
                ({tagCloser: n} = Nz.safeXmlCharacters);
                ({doubleQuote: i} = Nz.safeXmlCharacters);
                ({realDoubleQuote: o} = Nz.safeXmlCharacters);
                const {ampersand: c} = Nz.safeXmlCharacters;
                const {quote: l} = Nz.safeXmlCharacters;
                t = t.split(e).join(Nz.xmlCharacters.tagOpener);
                t = t.split(n).join(Nz.xmlCharacters.tagCloser);
                t = t.split(i).join(Nz.xmlCharacters.doubleQuote);
                t = t.split(c).join(Nz.xmlCharacters.ampersand);
                t = t.split(l).join(Nz.xmlCharacters.quote);
                let d = "";
                let u = null;
                for (let e = 0; e < t.length; e += 1) {
                    const n = t.charAt(e);
                    if (u == null) {
                        if (n === "$") {
                            u = ""
                        } else {
                            d += n
                        }
                    } else if (n === ";") {
                        d += `&${u}`;
                        u = null
                    } else if (n.match(/([a-zA-Z0-9#._-] | '-')/)) {
                        u += n
                    } else {
                        d += `$${u}`;
                        u = null;
                        e -= 1
                    }
                }
                return d
            }

            static safeXmlEncode(t) {
                const {tagOpener: e} = Nz.xmlCharacters;
                const {tagCloser: n} = Nz.xmlCharacters;
                const {doubleQuote: i} = Nz.xmlCharacters;
                const {ampersand: o} = Nz.xmlCharacters;
                const {quote: r} = Nz.xmlCharacters;
                t = t.split(e).join(Nz.safeXmlCharacters.tagOpener);
                t = t.split(n).join(Nz.safeXmlCharacters.tagCloser);
                t = t.split(i).join(Nz.safeXmlCharacters.doubleQuote);
                t = t.split(o).join(Nz.safeXmlCharacters.ampersand);
                t = t.split(r).join(Nz.safeXmlCharacters.quote);
                return t
            }

            static mathMLEntities(t) {
                let e = "";
                for (let n = 0; n < t.length; n += 1) {
                    const i = t.charAt(n);
                    if (t.codePointAt(n) > 128) {
                        e += `&#${t.codePointAt(n)};`;
                        if (t.codePointAt(n) > 65535) {
                            n += 1
                        }
                    } else if (i === "&") {
                        const o = t.indexOf(";", n + 1);
                        if (o >= 0) {
                            const i = document.createElement("span");
                            i.innerHTML = t.substring(n, o + 1);
                            e += `&#${Wz.fixedCharCodeAt(i.textContent || i.innerText, 0)};`;
                            n = o
                        } else {
                            e += i
                        }
                    } else {
                        e += i
                    }
                }
                return e
            }

            static addCustomEditorClassAttribute(t, e) {
                let n = "";
                const i = t.indexOf("<math");
                if (i === 0) {
                    const o = t.indexOf(">");
                    if (t.indexOf("class") === -1) {
                        n = `${t.substr(i, o)} class="wrs_${e}">`;
                        n += t.substr(o + 1, t.length);
                        return n
                    }
                }
                return t
            }

            static removeCustomEditorClassAttribute(t, e) {
                if (t.indexOf("class") === -1 || t.indexOf(`wrs_${e}`) === -1) {
                    return t
                }
                if (t.indexOf(`class="wrs_${e}"`) !== -1) {
                    return t.replace(`class="wrs_${e}"`, "")
                }
                return t.replace(`wrs_${e}`, "")
            }

            static addAnnotation(t, e, n) {
                const i = t.indexOf("<annotation");
                let o = "";
                if (i !== -1) {
                    const i = t.indexOf("</semantics>");
                    o = `${t.substring(0, i)}<annotation encoding="${n}">${e}</annotation>${t.substring(i)}`
                } else if (Pz.isEmpty(t)) {
                    const i = t.indexOf("/>");
                    const r = t.indexOf(">");
                    const s = r === i ? i : r;
                    o = `${t.substring(0, s)}><semantics><annotation encoding="${n}">${e}</annotation></semantics></math>`
                } else {
                    const i = t.indexOf(">") + 1;
                    const r = t.lastIndexOf("</math>");
                    const s = t.substring(i, r);
                    o = `${t.substring(0, i)}<semantics>${s}<annotation encoding="${n}">${e}</annotation></semantics></math>`
                }
                return o
            }

            static removeAnnotation(t, e) {
                let n = t;
                const i = `<annotation encoding="${e}">`;
                const o = "</annotation>";
                const r = t.indexOf(i);
                if (r !== -1) {
                    let e = false;
                    let i = t.indexOf("<annotation");
                    while (i !== -1) {
                        if (i !== r) {
                            e = true
                        }
                        i = t.indexOf("<annotation", i + 1)
                    }
                    if (e) {
                        const e = t.indexOf(o, r);
                        const i = e + o.length;
                        const s = t.substring(0, r);
                        n = s + t.substring(i)
                    } else {
                        n = Pz.removeSemantics(t)
                    }
                }
                return n
            }

            static removeSemantics(t) {
                const e = "</math>";
                const n = "<semantics>";
                const i = "<annotation";
                let o = t;
                const r = t.indexOf(n);
                if (r !== -1) {
                    const s = t.indexOf(i, r + n.length);
                    if (s !== -1) {
                        o = t.substring(0, r) + t.substring(r + n.length, s) + e
                    }
                }
                return o
            }

            static removeSemanticsOcurrences(t, e = Nz.xmlCharacters) {
                const n = `${e.tagOpener}math`;
                const i = `${e.tagOpener}/math${e.tagCloser}`;
                const o = `/${e.tagCloser}`;
                const {tagCloser: r} = e;
                const s = `${e.tagOpener}semantics${e.tagCloser}`;
                const a = `${e.tagOpener}annotation encoding=`;
                let c = "";
                let l = t.indexOf(n);
                let d = 0;
                while (l !== -1) {
                    c += t.substring(d, l);
                    const e = t.indexOf(i, l);
                    const u = t.indexOf(o, l);
                    const h = t.indexOf(r, l);
                    if (e !== -1) {
                        d = e
                    } else if (u === h - 1) {
                        d = u
                    }
                    const m = t.indexOf(s, l);
                    if (m !== -1) {
                        const e = t.substring(l, m);
                        const o = t.indexOf(a, l);
                        if (o !== -1) {
                            const r = m + s.length;
                            const a = t.substring(r, o);
                            c += e + a + i;
                            l = t.indexOf(n, l + n.length);
                            d += i.length
                        } else {
                            d = l;
                            l = t.indexOf(n, l + n.length)
                        }
                    } else {
                        d = l;
                        l = t.indexOf(n, l + n.length)
                    }
                }
                c += t.substring(d, t.length);
                return c
            }

            static containClass(t, e) {
                const n = t.indexOf("class");
                if (n === -1) {
                    return false
                }
                const i = t.indexOf(">", n);
                const o = t.substring(n, i);
                if (o.indexOf(e) !== -1) {
                    return true
                }
                return false
            }

            static isEmpty(t) {
                const e = ">";
                const n = "/>";
                const i = t.indexOf(e);
                const o = t.indexOf(n);
                let r = false;
                if (o !== -1) {
                    if (o === i - 1) {
                        r = true
                    }
                }
                if (!r) {
                    const e = new RegExp("</(.+:)?math>");
                    const n = e.exec(t);
                    if (n) {
                        r = i + 1 === n.index
                    }
                }
                return r
            }

            static encodeProperties(t) {
                const e = /\w+=".*?"/g;
                const n = t => {
                    const e = t.indexOf('"');
                    const n = t.substring(e + 1, t.length - 1);
                    const i = Wz.htmlEntities(n);
                    const o = `${t.substring(0, e + 1)}${i}"`;
                    return o
                };
                const i = t.replace(e, n);
                return i
            }
        }

        class Oz {
            static addConfiguration(t) {
                Object.assign(Oz.properties, t)
            }

            static get properties() {
                return Oz._properties
            }

            static set properties(t) {
                Oz._properties = t
            }

            static get(t) {
                if (!Object.prototype.hasOwnProperty.call(Oz.properties, t)) {
                    if (Object.prototype.hasOwnProperty.call(Oz.properties, "_wrs_conf_")) {
                        return Oz.properties[`_wrs_conf_${t}`]
                    }
                    return false
                }
                return Oz.properties[t]
            }

            static set(t, e) {
                Oz.properties[t] = e
            }

            static update(t, e) {
                if (!Oz.get(t)) {
                    Oz.set(t, e)
                } else {
                    const n = Object.assign(Oz.get(t), e);
                    Oz.set(t, n)
                }
            }
        }

        Oz._properties = {};

        class jz {
            constructor() {
                this.cache = []
            }

            populate(t, e) {
                this.cache[t] = e
            }

            get(t) {
                if (Object.prototype.hasOwnProperty.call(this.cache, t)) {
                    return this.cache[t]
                }
                return false
            }
        }

        class Rz {
            constructor() {
                this.listeners = []
            }

            add(t) {
                this.listeners.push(t)
            }

            fire(t, e) {
                for (let n = 0; n < this.listeners.length && !e.cancelled; n += 1) {
                    if (this.listeners[n].eventName === t) {
                        this.listeners[n].callback(e)
                    }
                }
                return e.defaultPrevented
            }

            static newListener(t, e) {
                const n = {};
                n.eventName = t;
                n.callback = e;
                return n
            }
        }

        class Fz {
            static get listeners() {
                return Fz._listeners
            }

            static addListener(t) {
                Fz.listeners.add(t)
            }

            static fireEvent(t, e) {
                Fz.listeners.fire(t, e)
            }

            static get parameters() {
                return Fz._parameters
            }

            static set parameters(t) {
                Fz._parameters = t
            }

            static get servicePaths() {
                return Fz._servicePaths
            }

            static set servicePaths(t) {
                Fz._servicePaths = t
            }

            static setServicePath(t, e) {
                Fz.servicePaths[t] = e
            }

            static getServicePath(t) {
                return Fz.servicePaths[t]
            }

            static get integrationPath() {
                return Fz._integrationPath
            }

            static set integrationPath(t) {
                Fz._integrationPath = t
            }

            static getServerURL() {
                const t = window.location.href;
                const e = t.split("/");
                const n = `${e[0]}//${e[2]}`;
                return n
            }

            static init(t) {
                Fz.parameters = t;
                let e = Fz.createServiceURI("configurationjs");
                let n = Fz.createServiceURI("createimage");
                let i = Fz.createServiceURI("showimage");
                let o = Fz.createServiceURI("getmathml");
                let r = Fz.createServiceURI("service");
                if (Fz.parameters.URI.indexOf("/") === 0) {
                    const t = Fz.getServerURL();
                    e = t + e;
                    i = t + i;
                    n = t + n;
                    o = t + o;
                    r = t + r
                }
                Fz.setServicePath("configurationjs", e);
                Fz.setServicePath("showimage", i);
                Fz.setServicePath("createimage", n);
                Fz.setServicePath("service", r);
                Fz.setServicePath("getmathml", o);
                Fz.setServicePath("configurationjs", e);
                Fz.listeners.fire("onInit", {})
            }

            static getUrl(t, e) {
                const n = window.location.toString().substr(0, window.location.toString().lastIndexOf("/") + 1);
                const i = Wz.createHttpRequest();
                if (i) {
                    if (typeof e === "undefined" || typeof e === "undefined") {
                        i.open("GET", t, false)
                    } else if (t.substr(0, 1) === "/" || t.substr(0, 7) === "http://" || t.substr(0, 8) === "https://") {
                        i.open("POST", t, false)
                    } else {
                        i.open("POST", n + t, false)
                    }
                    if (typeof e !== "undefined" && e) {
                        i.setRequestHeader("Content-type", "application/x-www-form-urlencoded; charset=UTF-8");
                        i.send(Wz.httpBuildQuery(e))
                    } else {
                        i.send(null)
                    }
                    return i.responseText
                }
                return ""
            }

            static getService(t, e, n) {
                let i;
                if (n === true) {
                    const n = `${Fz.getServicePath(t)}?${e}`;
                    i = Fz.getUrl(n)
                } else {
                    const n = Fz.getServicePath(t);
                    i = Fz.getUrl(n, e)
                }
                return i
            }

            static getServerLanguageFromService(t) {
                if (t.indexOf(".php") !== -1) {
                    return "php"
                }
                if (t.indexOf(".aspx") !== -1) {
                    return "aspx"
                }
                if (t.indexOf("wirispluginengine") !== -1) {
                    return "ruby"
                }
                return "java"
            }

            static createServiceURI(t) {
                const e = Fz.serverExtension();
                return Wz.concatenateUrl(Fz.parameters.URI, t) + e
            }

            static serverExtension() {
                if (Fz.parameters.server.indexOf("php") !== -1) {
                    return ".php"
                }
                if (Fz.parameters.server.indexOf("aspx") !== -1) {
                    return ".aspx"
                }
                return ""
            }
        }

        Fz._servicePaths = {};
        Fz._integrationPath = "";
        Fz._listeners = new Rz;
        Fz._parameters = {};

        class Vz {
            static get cache() {
                return Vz._cache
            }

            static set cache(t) {
                Vz._cache = t
            }

            static getLatexFromMathML(t) {
                const e = Pz.removeSemantics(t);
                const {cache: n} = Vz;
                const i = {service: "mathml2latex", mml: e};
                const o = JSON.parse(Fz.getService("service", i));
                let r = "";
                if (o.status === "ok") {
                    r = o.result.text;
                    const e = Wz.htmlEntities(r);
                    const i = Pz.addAnnotation(t, e, "LaTeX");
                    n.populate(r, i)
                }
                return r
            }

            static getMathMLFromLatex(t, e) {
                const n = Vz.cache;
                if (Vz.cache.get(t)) {
                    return Vz.cache.get(t)
                }
                const i = {service: "latex2mathml", latex: t};
                if (e) {
                    i.saveLatex = ""
                }
                const o = JSON.parse(Fz.getService("service", i));
                let r;
                if (o.status === "ok") {
                    let e = o.result.text;
                    e = e.split("\r").join("").split("\n").join(" ");
                    if (e.indexOf("semantics") === -1 && e.indexOf("annotation") === -1) {
                        e = Pz.addAnnotation(e, t, "LaTeX");
                        r = e
                    } else {
                        r = e
                    }
                    if (!n.get(t)) {
                        n.populate(t, e)
                    }
                } else {
                    r = `$$${t}$$`
                }
                return r
            }

            static parseMathmlToLatex(t, e) {
                let n = "";
                const i = `${e.tagOpener}math`;
                const o = `${e.tagOpener}/math${e.tagCloser}`;
                const r = `${e.tagOpener}annotation encoding=${e.doubleQuote}LaTeX${e.doubleQuote}${e.tagCloser}`;
                const s = `${e.tagOpener}/annotation${e.tagCloser}`;
                let a = t.indexOf(i);
                let c = 0;
                let l;
                let d;
                let u;
                while (a !== -1) {
                    n += t.substring(c, a);
                    c = t.indexOf(o, a);
                    if (c === -1) {
                        c = t.length - 1
                    } else {
                        c += o.length
                    }
                    l = t.substring(a, c);
                    d = l.indexOf(r);
                    if (d !== -1) {
                        d += r.length;
                        u = l.indexOf(s);
                        let t = l.substring(d, u);
                        if (e === Nz.safeXmlCharacters) {
                            t = Pz.safeXmlDecode(t)
                        }
                        n += `$$${t}$$`;
                        Vz.cache.populate(t, l)
                    } else {
                        n += l
                    }
                    a = t.indexOf(i, c)
                }
                n += t.substring(c, t.length);
                return n
            }

            static getLatexFromTextNode(t, e, n) {
                const i = {open: "$$", close: "$$"};
                if (typeof n === "undefined" || n == null) {
                    n = i
                }
                let o = t;
                while (o.previousSibling && o.previousSibling.nodeType === 3) {
                    o = o.previousSibling
                }

                function r(t, e, i) {
                    let o = t.nodeValue.indexOf(i, e);
                    while (o === -1) {
                        t = t.nextSibling;
                        if (!t) {
                            return null
                        }
                        o = t.nodeValue ? t.nodeValue.indexOf(n.close) : -1
                    }
                    return {node: t, position: o}
                }

                function s(t, e, n, i) {
                    if (t === n) {
                        return e <= i
                    }
                    while (t && t !== n) {
                        t = t.nextSibling
                    }
                    return t === n
                }

                let a;
                let c = {node: o, position: 0};
                const l = n.open.length;
                do {
                    a = r(c.node, c.position, n.open);
                    if (a == null || s(t, e, a.node, a.position)) {
                        return null
                    }
                    c = r(a.node, a.position + l, n.close);
                    if (c == null) {
                        return null
                    }
                    c.position += l
                } while (s(c.node, c.position, t, e));
                let d;
                if (a.node === c.node) {
                    d = a.node.nodeValue.substring(a.position + l, c.position - l)
                } else {
                    const t = a.position + l;
                    d = a.node.nodeValue.substring(t, a.node.nodeValue.length);
                    let e = a.node;
                    do {
                        e = e.nextSibling;
                        if (e === c.node) {
                            d += c.node.nodeValue.substring(0, c.position - l)
                        } else {
                            d += e.nodeValue ? e.nodeValue : ""
                        }
                    } while (e !== c.node)
                }
                return {
                    latex: d,
                    startNode: a.node,
                    startPosition: a.position,
                    endNode: c.node,
                    endPosition: c.position
                }
            }
        }

        Vz._cache = new jz;
        var Hz = n(85);

        class Uz {
            constructor() {
                throw new Error("Static class StringManager can not be instantiated.")
            }

            static get(t) {
                let {language: e} = this;
                if (e && e.length > 2) {
                    e = e.slice(0, 2)
                }
                if (!this.strings.hasOwnProperty(e)) {
                    console.warn(`Unknown language ${e} set in StringManager.`);
                    e = "en"
                }
                if (!this.strings[e].hasOwnProperty(t)) {
                    console.warn(`Unknown key ${t} for language ${e} in StringManager.`);
                    return t
                }
                return this.strings[e][t]
            }
        }

        Uz.strings = Hz;
        Uz.language = "en";

        class Wz {
            static fireEvent(t, e) {
                if (document.createEvent) {
                    const n = document.createEvent("HTMLEvents");
                    n.initEvent(e, true, true);
                    return !t.dispatchEvent(n)
                }
                const n = document.createEventObject();
                return t.fireEvent(`on${e}`, n)
            }

            static addEvent(t, e, n) {
                if (t.addEventListener) {
                    t.addEventListener(e, n, true)
                } else if (t.attachEvent) {
                    t.attachEvent(`on${e}`, n)
                }
            }

            static removeEvent(t, e, n) {
                if (t.removeEventListener) {
                    t.removeEventListener(e, n, true)
                } else if (t.detachEvent) {
                    t.detachEvent(`on${e}`, n)
                }
            }

            static addElementEvents(t, e, n, i) {
                if (e) {
                    Wz.addEvent(t, "dblclick", (t => {
                        const n = t || window.event;
                        const i = n.srcElement ? n.srcElement : n.target;
                        e(i, n)
                    }))
                }
                if (n) {
                    Wz.addEvent(t, "mousedown", (t => {
                        const e = t || window.event;
                        const i = e.srcElement ? e.srcElement : e.target;
                        n(i, e)
                    }))
                }
                if (i) {
                    Wz.addEvent(t, "mouseup", (t => {
                        const e = t || window.event;
                        const n = e.srcElement ? e.srcElement : e.target;
                        i(n, e)
                    }))
                }
            }

            static addClass(t, e) {
                if (!Wz.containsClass(t, e)) {
                    t.className += ` ${e}`
                }
            }

            static containsClass(t, e) {
                if (t == null || !("className" in t)) {
                    return false
                }
                const n = t.className.split(" ");
                for (let t = n.length - 1; t >= 0; t -= 1) {
                    if (n[t] === e) {
                        return true
                    }
                }
                return false
            }

            static removeClass(t, e) {
                let n = "";
                const i = t.className.split(" ");
                for (let t = 0; t < i.length; t += 1) {
                    if (i[t] !== e) {
                        n += `${i[t]} `
                    }
                }
                t.className = n.trim()
            }

            static convertOldXmlinitialtextAttribute(t) {
                const e = "value=";
                const n = t.indexOf("xmlinitialtext");
                const i = t.indexOf(e, n);
                const o = t.charAt(i + e.length);
                const r = i + e.length + 1;
                const s = t.indexOf(o, r);
                const a = t.substring(r, s);
                let c = a.split("«").join("§lt;");
                c = c.split("»").join("§gt;");
                c = c.split("&").join("§");
                c = c.split("¨").join("§quot;");
                t = t.split(a).join(c);
                return t
            }

            static createElement(t, e, n) {
                if (e === undefined) {
                    e = {}
                }
                if (n === undefined) {
                    n = document
                }
                let i;
                try {
                    let o = `<${t}`;
                    Object.keys(e).forEach((t => {
                        o += ` ${t}="${Wz.htmlEntities(e[t])}"`
                    }));
                    o += ">";
                    i = n.createElement(o)
                } catch (o) {
                    i = n.createElement(t);
                    Object.keys(e).forEach((t => {
                        i.setAttribute(t, e[t])
                    }))
                }
                return i
            }

            static createObject(t, e) {
                if (e === undefined) {
                    e = document
                }
                t = t.split("<applet ").join('<span wirisObject="WirisApplet" ').split("<APPLET ").join('<span wirisObject="WirisApplet" ');
                t = t.split("</applet>").join("</span>").split("</APPLET>").join("</span>");
                t = t.split("<param ").join('<br wirisObject="WirisParam" ').split("<PARAM ").join('<br wirisObject="WirisParam" ');
                t = t.split("</param>").join("</br>").split("</PARAM>").join("</br>");
                const n = Wz.createElement("div", {}, e);
                n.innerHTML = t;

                function i(t) {
                    if (t.getAttribute && t.getAttribute("wirisObject") === "WirisParam") {
                        const n = {};
                        for (let e = 0; e < t.attributes.length; e += 1) {
                            if (t.attributes[e].nodeValue !== null) {
                                n[t.attributes[e].nodeName] = t.attributes[e].nodeValue
                            }
                        }
                        const i = Wz.createElement("param", n, e);
                        if (i.NAME) {
                            i.name = i.NAME;
                            i.value = i.VALUE
                        }
                        i.removeAttribute("wirisObject");
                        t.parentNode.replaceChild(i, t)
                    } else if (t.getAttribute && t.getAttribute("wirisObject") === "WirisApplet") {
                        const n = {};
                        for (let e = 0; e < t.attributes.length; e += 1) {
                            if (t.attributes[e].nodeValue !== null) {
                                n[t.attributes[e].nodeName] = t.attributes[e].nodeValue
                            }
                        }
                        const o = Wz.createElement("applet", n, e);
                        o.removeAttribute("wirisObject");
                        for (let e = 0; e < t.childNodes.length; e += 1) {
                            i(t.childNodes[e]);
                            if (t.childNodes[e].nodeName.toLowerCase() === "param") {
                                o.appendChild(t.childNodes[e]);
                                e -= 1
                            }
                        }
                        t.parentNode.replaceChild(o, t)
                    } else {
                        for (let e = 0; e < t.childNodes.length; e += 1) {
                            i(t.childNodes[e])
                        }
                    }
                }

                i(n);
                return n.firstChild
            }

            static createObjectCode(t) {
                if (typeof t === "undefined" || t === null) {
                    return null
                }
                if (t.nodeType === 1) {
                    let e = `<${t.tagName}`;
                    for (let n = 0; n < t.attributes.length; n += 1) {
                        if (t.attributes[n].specified) {
                            e += ` ${t.attributes[n].name}="${Wz.htmlEntities(t.attributes[n].value)}"`
                        }
                    }
                    if (t.childNodes.length > 0) {
                        e += ">";
                        for (let n = 0; n < t.childNodes.length; n += 1) {
                            e += Wz.createObject(t.childNodes[n])
                        }
                        e += `</${t.tagName}>`
                    } else if (t.nodeName === "DIV" || t.nodeName === "SCRIPT") {
                        e += `></${t.tagName}>`
                    } else {
                        e += "/>"
                    }
                    return e
                }
                if (t.nodeType === 3) {
                    return Wz.htmlEntities(t.nodeValue)
                }
                return ""
            }

            static concatenateUrl(t, e) {
                let n = "";
                if (t.indexOf("/") !== t.length && e.indexOf("/") !== 0) {
                    n = "/"
                }
                return (t + n + e).replace(/([^:]\/)\/+/g, "$1")
            }

            static htmlEntities(t) {
                return t.split("&").join("&amp;").split("<").join("&lt;").split(">").join("&gt;").split('"').join("&quot;")
            }

            static htmlEntitiesDecode(t) {
                const e = document.createElement("textarea");
                e.innerHTML = t;
                return e.value
            }

            static createHttpRequest() {
                const t = window.location.toString().substr(0, window.location.toString().lastIndexOf("/") + 1);
                if (t.substr(0, 7) === "file://") {
                    throw Uz.get("exception_cross_site")
                }
                if (typeof XMLHttpRequest !== "undefined") {
                    return new XMLHttpRequest
                }
                try {
                    return new ActiveXObject("Msxml2.XMLHTTP")
                } catch (t) {
                    try {
                        return new ActiveXObject("Microsoft.XMLHTTP")
                    } catch (t) {
                        return null
                    }
                }
            }

            static httpBuildQuery(t) {
                let e = "";
                Object.keys(t).forEach((n => {
                    if (t[n] != null) {
                        e += `${Wz.urlEncode(n)}=${Wz.urlEncode(t[n])}&`
                    }
                }));
                if (e.substring(e.length - 1) === "&") {
                    e = e.substring(0, e.length - 1)
                }
                return e
            }

            static propertiesToString(t) {
                const e = [];
                Object.keys(t).forEach((n => {
                    if (Object.prototype.hasOwnProperty.call(t, n)) {
                        e.push(n)
                    }
                }));
                const n = e.length;
                for (let t = 0; t < n; t += 1) {
                    for (let i = t + 1; i < n; i += 1) {
                        const n = e[t];
                        const o = e[i];
                        if (Wz.compareStrings(n, o) > 0) {
                            e[t] = o;
                            e[i] = n
                        }
                    }
                }
                let i = "";
                for (let o = 0; o < n; o += 1) {
                    const n = e[o];
                    i += n;
                    i += "=";
                    let r = t[n];
                    r = r.replace("\\", "\\\\");
                    r = r.replace("\n", "\\n");
                    r = r.replace("\r", "\\r");
                    r = r.replace("\t", "\\t");
                    i += r;
                    i += "\n"
                }
                return i
            }

            static compareStrings(t, e) {
                let n;
                const i = t.length;
                const o = e.length;
                const r = i > o ? o : i;
                for (n = 0; n < r; n += 1) {
                    const i = Wz.fixedCharCodeAt(t, n) - Wz.fixedCharCodeAt(e, n);
                    if (i !== 0) {
                        return i
                    }
                }
                return t.length - e.length
            }

            static fixedCharCodeAt(t, e) {
                e = e || 0;
                const n = t.charCodeAt(e);
                let i;
                let o;
                if (n >= 55296 && n <= 56319) {
                    i = n;
                    o = t.charCodeAt(e + 1);
                    if (Number.isNaN(o)) {
                        throw Uz.get("exception_high_surrogate")
                    }
                    return (i - 55296) * 1024 + (o - 56320) + 65536
                }
                if (n >= 56320 && n <= 57343) {
                    return false
                }
                return n
            }

            static urlToAssArray(t) {
                let e;
                e = t.indexOf("?");
                if (e > 0) {
                    const n = t.substring(e + 1);
                    const i = n.split("&");
                    const o = {};
                    for (e = 0; e < i.length; e += 1) {
                        const t = i[e];
                        const n = t.split("=");
                        if (n.length > 1) {
                            o[n[0]] = decodeURIComponent(n[1].replace(/\+/g, " "))
                        }
                    }
                    return o
                }
                return {}
            }

            static urlEncode(t) {
                let e = "";
                e = encodeURIComponent(t);
                return e
            }

            static getWIRISImageOutput(t, e, n) {
                const i = Wz.createObject(t);
                if (i) {
                    if (i.className === Oz.get("imageClassName") || i.getAttribute(Oz.get("imageMathmlAttribute"))) {
                        if (!e) {
                            return t
                        }
                        const o = i.getAttribute(Oz.get("imageMathmlAttribute"));
                        let r = Pz.safeXmlDecode(o);
                        if (!Oz.get("saveHandTraces")) {
                            r = Pz.removeAnnotation(r, "application/json")
                        }
                        if (r == null) {
                            r = i.getAttribute("alt")
                        }
                        if (n) {
                            const t = Pz.safeXmlEncode(r);
                            return t
                        }
                        return r
                    }
                }
                return t
            }

            static getNodeLength(t) {
                const e = {IMG: 1, BR: 1};
                if (t.nodeType === 3) {
                    return t.nodeValue.length
                }
                if (t.nodeType === 1) {
                    let n = e[t.nodeName.toUpperCase()];
                    if (n === undefined) {
                        n = 0
                    }
                    for (let e = 0; e < t.childNodes.length; e += 1) {
                        n += Wz.getNodeLength(t.childNodes[e])
                    }
                    return n
                }
                return 0
            }

            static getSelectedItem(t, e, n) {
                let i;
                if (e) {
                    i = t.contentWindow;
                    i.focus()
                } else {
                    i = window;
                    t.focus()
                }
                if (document.selection && !n) {
                    const n = i.document.selection.createRange();
                    if (n.parentElement) {
                        if (n.htmlText.length > 0) {
                            if (n.text.length === 0) {
                                return Wz.getSelectedItem(t, e, true)
                            }
                            return null
                        }
                        i.document.execCommand("InsertImage", false, "#");
                        let o = n.parentElement();
                        if (o.nodeName.toUpperCase() !== "IMG") {
                            n.pasteHTML('<span id="wrs_openEditorWindow_temporalObject"></span>');
                            o = i.document.getElementById("wrs_openEditorWindow_temporalObject")
                        }
                        let r;
                        let s;
                        if (o.nextSibling && o.nextSibling.nodeType === 3) {
                            r = o.nextSibling;
                            s = 0
                        } else if (o.previousSibling && o.previousSibling.nodeType === 3) {
                            r = o.previousSibling;
                            s = r.nodeValue.length
                        } else {
                            r = i.document.createTextNode("");
                            o.parentNode.insertBefore(r, o);
                            s = 0
                        }
                        o.parentNode.removeChild(o);
                        return {node: r, caretPosition: s}
                    }
                    if (n.length > 1) {
                        return null
                    }
                    return {node: n.item(0)}
                }
                if (i.getSelection) {
                    let t;
                    const e = i.getSelection();
                    try {
                        t = e.getRangeAt(0)
                    } catch (e) {
                        t = i.document.createRange()
                    }
                    const n = t.startContainer;
                    if (n.nodeType === 3) {
                        return {node: n, caretPosition: t.startOffset}
                    }
                    if (n !== t.endContainer) {
                        return null
                    }
                    if (n.nodeType === 1) {
                        const e = t.startOffset;
                        if (n.childNodes[e]) {
                            return {node: n.childNodes[e]}
                        }
                    }
                }
                return null
            }

            static getSelectedItemOnTextarea(t) {
                const e = document.createTextNode(t.value);
                const n = Vz.getLatexFromTextNode(e, t.selectionStart);
                if (n === null) {
                    return null
                }
                return {
                    node: e,
                    caretPosition: t.selectionStart,
                    startPosition: n.startPosition,
                    endPosition: n.endPosition
                }
            }

            static getElementsByNameFromString(t, e, n) {
                const i = [];
                t = t.toLowerCase();
                e = e.toLowerCase();
                let o = t.indexOf(`<${e} `);
                while (o !== -1) {
                    let r;
                    if (n) {
                        r = ">"
                    } else {
                        r = `</${e}>`
                    }
                    let s = t.indexOf(r, o);
                    if (s !== -1) {
                        s += r.length;
                        i.push({start: o, end: s})
                    } else {
                        s = o + 1
                    }
                    o = t.indexOf(`<${e} `, s)
                }
                return i
            }

            static decode64(t) {
                const e = "+".charCodeAt(0);
                const n = "/".charCodeAt(0);
                const i = "0".charCodeAt(0);
                const o = "a".charCodeAt(0);
                const r = "A".charCodeAt(0);
                const s = "-".charCodeAt(0);
                const a = "_".charCodeAt(0);
                const c = t.charCodeAt(0);
                if (c === e || c === s) {
                    return 62
                }
                if (c === n || c === a) {
                    return 63
                }
                if (c < i) {
                    return -1
                }
                if (c < i + 10) {
                    return c - i + 26 + 26
                }
                if (c < r + 26) {
                    return c - r
                }
                if (c < o + 26) {
                    return c - o + 26
                }
                return null
            }

            static b64ToByteArray(t, e) {
                let n;
                if (t.length % 4 > 0) {
                    throw new Error("Invalid string. Length must be a multiple of 4")
                }
                const i = [];
                let o;
                let r;
                if (!e) {
                    if (t.charAt(t.length - 2) === "=") {
                        r = 2
                    } else if (t.charAt(t.length - 1) === "=") {
                        r = 1
                    } else {
                        r = 0
                    }
                    o = r > 0 ? t.length - 4 : t.length
                } else {
                    o = e
                }
                let s;
                for (s = 0; s < o; s += 4) {
                    n = Wz.decode64(t.charAt(s)) << 18 | Wz.decode64(t.charAt(s + 1)) << 12 | Wz.decode64(t.charAt(s + 2)) << 6 | Wz.decode64(t.charAt(s + 3));
                    i.push(n >> 16 & 255);
                    i.push(n >> 8 & 255);
                    i.push(n & 255)
                }
                if (r) {
                    if (r === 2) {
                        n = Wz.decode64(t.charAt(s)) << 2 | Wz.decode64(t.charAt(s + 1)) >> 4;
                        i.push(n & 255)
                    } else if (r === 1) {
                        n = Wz.decode64(t.charAt(s)) << 10 | Wz.decode64(t.charAt(s + 1)) << 4 | Wz.decode64(t.charAt(s + 2)) >> 2;
                        i.push(n >> 8 & 255);
                        i.push(n & 255)
                    }
                }
                return i
            }

            static readInt32(t) {
                if (t.length < 4) {
                    return false
                }
                const e = t.splice(0, 4);
                return e[0] << 24 | e[1] << 16 | e[2] << 8 | e[3] << 0
            }

            static readByte(t) {
                return t.shift() << 0
            }

            static readBytes(t, e, n) {
                return t.splice(e, n)
            }

            static updateTextArea(t, e) {
                if (t && e) {
                    t.focus();
                    if (t.selectionStart != null) {
                        const {selectionEnd: n} = t;
                        const i = t.value.substring(0, t.selectionStart);
                        const o = t.value.substring(n, t.value.length);
                        t.value = i + e + o;
                        t.selectionEnd = n + e.length
                    } else {
                        const t = document.selection.createRange();
                        t.text = e
                    }
                }
            }

            static updateExistingTextOnTextarea(t, e, n, i) {
                t.focus();
                const o = t.value.substring(0, n);
                t.value = o + e + t.value.substring(i, t.value.length);
                t.selectionEnd = n + e.length
            }

            static addArgument(t, e, n) {
                let i;
                if (t.indexOf("?") > 0) {
                    i = "&"
                } else {
                    i = "?"
                }
                return `${t + i + e}=${n}`
            }
        }

        class qz {
            static removeImgDataAttributes(t) {
                const e = [];
                const {attributes: n} = t;
                Object.keys(n).forEach((t => {
                    const i = n[t];
                    if (i.name.indexOf("data-") === 0) {
                        e.push(i.name)
                    }
                }));
                e.forEach((e => {
                    t.removeAttribute(e)
                }))
            }

            static clone(t, e) {
                const n = Oz.get("imageCustomEditorName");
                if (!t.hasAttribute(n)) {
                    e.removeAttribute(n)
                }
                const i = Oz.get("imageMathmlAttribute");
                const o = [i, n, "alt", "height", "width", "style", "src", "role"];
                o.forEach((n => {
                    const i = t.getAttribute(n);
                    if (i) {
                        e.setAttribute(n, i)
                    }
                }))
            }

            static setImgSize(t, e, n) {
                let i;
                let o;
                let r;
                let s;
                if (n) {
                    if (Oz.get("imageFormat") === "svg") {
                        if (Oz.get("saveMode") !== "base64") {
                            i = qz.getMetricsFromSvgString(e)
                        } else {
                            o = t.src.substr(t.src.indexOf("base64,") + 7, t.src.length);
                            s = "";
                            r = Wz.b64ToByteArray(o, o.length);
                            for (let t = 0; t < r.length; t += 1) {
                                s += String.fromCharCode(r[t])
                            }
                            i = qz.getMetricsFromSvgString(s)
                        }
                    } else {
                        o = t.src.substr(t.src.indexOf("base64,") + 7, t.src.length);
                        r = Wz.b64ToByteArray(o, 88);
                        i = qz.getMetricsFromBytes(r)
                    }
                } else {
                    i = Wz.urlToAssArray(e)
                }
                let a = i.cw;
                if (!a) {
                    return
                }
                let c = i.ch;
                let l = i.cb;
                const {dpi: d} = i;
                if (d) {
                    a = a * 96 / d;
                    c = c * 96 / d;
                    l = l * 96 / d
                }
                t.width = a;
                t.height = c;
                t.style.verticalAlign = `-${c - l}px`
            }

            static fixAfterResize(t) {
                t.removeAttribute("style");
                t.removeAttribute("width");
                t.removeAttribute("height");
                t.style.maxWidth = "none";
                if (t.src.indexOf("data:image") !== -1) {
                    if (Oz.get("imageFormat") === "svg") {
                        const e = decodeURIComponent(t.src.substring(32, t.src.length));
                        qz.setImgSize(t, e, true)
                    } else {
                        const e = t.src.substring(22, t.src.length);
                        qz.setImgSize(t, e, true)
                    }
                } else {
                    qz.setImgSize(t, t.src)
                }
            }

            static getMetricsFromSvgString(t) {
                let e = t.indexOf('height="');
                let n = t.indexOf('"', e + 8, t.length);
                const i = t.substring(e + 8, n);
                e = t.indexOf('width="');
                n = t.indexOf('"', e + 7, t.length);
                const o = t.substring(e + 7, n);
                e = t.indexOf('wrs:baseline="');
                n = t.indexOf('"', e + 14, t.length);
                const r = t.substring(e + 14, n);
                if (typeof o !== "undefined") {
                    const t = [];
                    t.cw = o;
                    t.ch = i;
                    if (typeof r !== "undefined") {
                        t.cb = r
                    }
                    return t
                }
                return []
            }

            static getMetricsFromBytes(t) {
                Wz.readBytes(t, 0, 8);
                let e;
                let n;
                let i;
                let o;
                let r;
                while (t.length >= 4) {
                    i = Wz.readInt32(t);
                    if (i === 1229472850) {
                        e = Wz.readInt32(t);
                        n = Wz.readInt32(t);
                        Wz.readInt32(t);
                        Wz.readByte(t)
                    } else if (i === 1650545477) {
                        o = Wz.readInt32(t)
                    } else if (i === 1883789683) {
                        r = Wz.readInt32(t);
                        r = Math.round(r / 39.37);
                        Wz.readInt32(t);
                        Wz.readByte(t)
                    }
                    Wz.readInt32(t)
                }
                if (typeof e !== "undefined") {
                    const t = [];
                    t.cw = e;
                    t.ch = n;
                    t.dpi = r;
                    if (o) {
                        t.cb = o
                    }
                    return t
                }
                return []
            }
        }

        class Kz {
            static get cache() {
                return Kz._cache
            }

            static set cache(t) {
                Kz._cache = t
            }

            static mathMLToAccessible(t, e, n) {
                if (typeof e === "undefined") {
                    e = "en"
                }
                if (Pz.containClass(t, "wrs_chemistry")) {
                    n.mode = "chemistry"
                }
                let i = "";
                if (Kz.cache.get(t)) {
                    i = Kz.cache.get(t)
                } else {
                    n.service = "mathml2accessible";
                    n.lang = e;
                    const o = JSON.parse(Fz.getService("service", n));
                    if (o.status !== "error") {
                        i = o.result.text;
                        Kz.cache.populate(t, i)
                    } else {
                        i = Uz.get("error_convert_accessibility")
                    }
                }
                return i
            }
        }

        Kz._cache = new jz;
        var Gz = n(86);

        class $z {
            static mathmlToImgObject(t, e, n, i) {
                const o = t.createElement("img");
                o.align = "middle";
                o.style.maxWidth = "none";
                const r = n || {};
                r.mml = e;
                r.lang = i;
                r.metrics = "true";
                r.centerbaseline = "false";
                if (Oz.get("saveMode") === "base64" && Oz.get("base64savemode") === "default") {
                    r.base64 = true
                }
                o.className = Oz.get("imageClassName");
                if (e.indexOf('class="') !== -1) {
                    let t = e.substring(e.indexOf('class="') + 'class="'.length, e.length);
                    t = t.substring(0, t.indexOf('"'));
                    t = t.substring(4, t.length);
                    o.setAttribute(Oz.get("imageCustomEditorName"), t)
                }
                if (Oz.get("wirisPluginPerformance") && (Oz.get("saveMode") === "xml" || Oz.get("saveMode") === "safeXml")) {
                    let t = JSON.parse($z.createShowImageSrc(r, i));
                    if (t.status === "warning") {
                        try {
                            t = JSON.parse(Fz.getService("showimage", r))
                        } catch (t) {
                            return null
                        }
                    }
                    ({result: t} = t);
                    if (t.format === "png") {
                        o.src = `data:image/png;base64,${t.content}`
                    } else {
                        o.src = `data:image/svg+xml;charset=utf8,${Wz.urlEncode(t.content)}`
                    }
                    o.setAttribute(Oz.get("imageMathmlAttribute"), Pz.safeXmlEncode(e));
                    qz.setImgSize(o, t.content, true);
                    if (Oz.get("enableAccessibility")) {
                        if (typeof t.alt === "undefined") {
                            o.alt = Kz.mathMLToAccessible(e, i, r)
                        } else {
                            o.alt = t.alt
                        }
                    }
                } else {
                    const t = $z.createImageSrc(e, r);
                    o.setAttribute(Oz.get("imageMathmlAttribute"), Pz.safeXmlEncode(e));
                    o.src = t;
                    qz.setImgSize(o, t, Oz.get("saveMode") === "base64" && Oz.get("base64savemode") === "default");
                    if (Oz.get("enableAccessibility")) {
                        o.alt = Kz.mathMLToAccessible(e, i, r)
                    }
                }
                if (typeof $z.observer !== "undefined") {
                    $z.observer.observe(o)
                }
                o.setAttribute("role", "math");
                return o
            }

            static createImageSrc(t, e) {
                if (Oz.get("saveMode") === "base64" && Oz.get("base64savemode") === "default") {
                    e.base64 = true
                }
                let n = Fz.getService("createimage", e);
                if (n.indexOf("@BASE@") !== -1) {
                    const t = Fz.getServicePath("createimage").split("/");
                    t.pop();
                    n = n.split("@BASE@").join(t.join("/"))
                }
                return n
            }

            static initParse(t, e) {
                t = $z.initParseSaveMode(t, e);
                return $z.initParseEditMode(t)
            }

            static initParseSaveMode(t, e) {
                if (Oz.get("saveMode")) {
                    t = Vz.parseMathmlToLatex(t, Nz.safeXmlCharacters);
                    t = Vz.parseMathmlToLatex(t, Nz.xmlCharacters);
                    t = $z.parseMathmlToImg(t, Nz.safeXmlCharacters, e);
                    t = $z.parseMathmlToImg(t, Nz.xmlCharacters, e);
                    if (Oz.get("saveMode") === "base64" && Oz.get("base64savemode") === "image") {
                        t = $z.codeImgTransform(t, "base642showimage")
                    }
                }
                return t
            }

            static initParseEditMode(t) {
                if (Oz.get("parseModes").indexOf("latex") !== -1) {
                    const e = Wz.getElementsByNameFromString(t, "img", true);
                    const n = 'encoding="LaTeX">';
                    let i = 0;
                    for (let o = 0; o < e.length; o += 1) {
                        const r = t.substring(e[o].start + i, e[o].end + i);
                        if (r.indexOf(` class="${Oz.get("imageClassName")}"`) !== -1) {
                            let s = ` ${Oz.get("imageMathmlAttribute")}="`;
                            let a = r.indexOf(s);
                            if (a === -1) {
                                s = ' alt="';
                                a = r.indexOf(s)
                            }
                            if (a !== -1) {
                                a += s.length;
                                const c = r.indexOf('"', a);
                                const l = Pz.safeXmlDecode(r.substring(a, c));
                                let d = l.indexOf(n);
                                if (d !== -1) {
                                    d += n.length;
                                    const r = l.indexOf("</annotation>", d);
                                    const s = l.substring(d, r);
                                    const a = `$$${Wz.htmlEntitiesDecode(s)}$$`;
                                    const c = t.substring(0, e[o].start + i);
                                    const u = t.substring(e[o].end + i);
                                    t = c + a + u;
                                    i += a.length - (e[o].end - e[o].start)
                                }
                            }
                        }
                    }
                }
                return t
            }

            static endParse(t) {
                const e = $z.endParseEditMode(t);
                const n = $z.endParseSaveMode(e);
                return n
            }

            static endParseEditMode(t) {
                if (Oz.get("parseModes").indexOf("latex") !== -1) {
                    let e = "";
                    let n = 0;
                    let i = t.indexOf("$$");
                    while (i !== -1) {
                        e += t.substring(n, i);
                        n = t.indexOf("$$", i + 2);
                        if (n !== -1) {
                            const o = t.substring(i + 2, n);
                            const r = Wz.htmlEntitiesDecode(o);
                            let s = Vz.getMathMLFromLatex(r, true);
                            if (!Oz.get("saveHandTraces")) {
                                s = Pz.removeAnnotation(s, "application/json")
                            }
                            e += s;
                            n += 2
                        } else {
                            e += "$$";
                            n = i + 2
                        }
                        i = t.indexOf("$$", n)
                    }
                    e += t.substring(n, t.length);
                    t = e
                }
                return t
            }

            static endParseSaveMode(t) {
                if (Oz.get("saveMode")) {
                    if (Oz.get("saveMode") === "safeXml") {
                        t = $z.codeImgTransform(t, "img2mathml")
                    } else if (Oz.get("saveMode") === "xml") {
                        t = $z.codeImgTransform(t, "img2mathml")
                    } else if (Oz.get("saveMode") === "base64" && Oz.get("base64savemode") === "image") {
                        t = $z.codeImgTransform(t, "img264")
                    }
                }
                return t
            }

            static createShowImageSrc(t, e) {
                const n = [];
                const i = ["mml", "color", "centerbaseline", "zoom", "dpi", "fontSize", "fontFamily", "defaultStretchy", "backgroundColor", "format"];
                i.forEach((e => {
                    const o = i[e];
                    if (typeof t[o] !== "undefined") {
                        n[o] = t[o]
                    }
                }));
                const o = {};
                Object.keys(t).forEach((e => {
                    if (e !== "mml") {
                        o[e] = t[e]
                    }
                }));
                o.formula = com.wiris.js.JsPluginTools.md5encode(Wz.propertiesToString(n));
                o.lang = typeof e === "undefined" ? "en" : e;
                o.version = Oz.get("version");
                const r = Fz.getService("showimage", Wz.httpBuildQuery(o), true);
                return r
            }

            static codeImgTransform(t, e) {
                let n = "";
                let i = 0;
                const o = /<img/gi;
                const r = o.source.length;
                while (o.test(t)) {
                    const s = o.lastIndex - r;
                    n += t.substring(i, s);
                    let a = s + 1;
                    while (a < t.length && i <= s) {
                        const e = t.charAt(a);
                        if (e === '"' || e === "'") {
                            const n = t.indexOf(e, a + 1);
                            if (n === -1) {
                                a = t.length
                            } else {
                                a = n
                            }
                        } else if (e === ">") {
                            i = a + 1
                        }
                        a += 1
                    }
                    if (i < s) {
                        n += t.substring(s, t.length);
                        return n
                    }
                    let c = t.substring(s, i);
                    const l = Wz.createObject(c);
                    let d = l.getAttribute(Oz.get("imageMathmlAttribute"));
                    let u;
                    let h;
                    if (e === "base642showimage") {
                        if (d == null) {
                            d = l.getAttribute("alt")
                        }
                        d = Pz.safeXmlDecode(d);
                        c = $z.mathmlToImgObject(document, d, null, null);
                        n += Wz.createObjectCode(c)
                    } else if (e === "img2mathml") {
                        if (Oz.get("saveMode")) {
                            if (Oz.get("saveMode") === "safeXml") {
                                u = true;
                                h = true
                            } else if (Oz.get("saveMode") === "xml") {
                                u = true;
                                h = false
                            }
                        }
                        n += Wz.getWIRISImageOutput(c, u, h)
                    } else if (e === "img264") {
                        if (d === null) {
                            d = l.getAttribute("alt")
                        }
                        d = Pz.safeXmlDecode(d);
                        const t = {};
                        t.base64 = "true";
                        c = $z.mathmlToImgObject(document, d, t, null);
                        qz.setImgSize(c, c.src, true);
                        n += Wz.createObjectCode(c)
                    }
                }
                n += t.substring(i, t.length);
                return n
            }

            static parseMathmlToImg(t, e, n) {
                let i = "";
                const o = `${e.tagOpener}math`;
                const r = `${e.tagOpener}/math${e.tagCloser}`;
                let s = t.indexOf(o);
                let a = 0;
                while (s !== -1) {
                    i += t.substring(a, s);
                    const c = t.indexOf(Oz.get("imageMathmlAttribute"));
                    a = t.indexOf(r, s);
                    if (a === -1) {
                        a = t.length - 1
                    } else if (c !== -1) {
                        a += t.indexOf("/>", s)
                    } else {
                        a += r.length
                    }
                    if (!Pz.isMathmlInAttribute(t, s) && c === -1) {
                        let o = t.substring(s, a);
                        o = e.id === Nz.safeXmlCharacters.id ? Pz.safeXmlDecode(o) : Pz.mathMLEntities(o);
                        i += Wz.createObjectCode($z.mathmlToImgObject(document, o, null, n))
                    } else {
                        i += t.substring(s, a)
                    }
                    s = t.indexOf(o, a)
                }
                i += t.substring(a, t.length);
                return i
            }
        }

        if (typeof MutationObserver !== "undefined") {
            const t = new MutationObserver((t => {
                t.forEach((t => {
                    if (t.oldValue === Oz.get("imageClassName") && t.attributeName === "class" && t.target.className.indexOf(Oz.get("imageClassName")) === -1) {
                        t.target.className = Oz.get("imageClassName")
                    }
                }))
            }));
            $z.observer = Object.create(t);
            $z.observer.Config = {attributes: true, attributeOldValue: true};
            $z.observer.observe = function t(e) {
                Object.getPrototypeOf(this).observe(e, this.Config)
            }
        }

        class Yz {
            constructor() {
                this.isContentChanged = false;
                this.waitingForChanges = false
            }

            setIsContentChanged(t) {
                this.isContentChanged = t
            }

            getIsContentChanged() {
                return this.isContentChanged
            }

            setWaitingForChanges(t) {
                this.waitingForChanges = t
            }

            caretPositionChanged(t) {
            }

            clipboardChanged(t) {
            }

            contentChanged(t) {
                if (this.waitingForChanges === true && this.isContentChanged === false) {
                    this.isContentChanged = true
                }
            }

            styleChanged(t) {
            }

            transformationReceived(t) {
            }
        }

        class Qz {
            constructor(t) {
                this.editorAttributes = {};
                if ("editorAttributes" in t) {
                    this.editorAttributes = t.editorAttributes
                } else {
                    throw new Error("ContentManager constructor error: editorAttributes property missed.")
                }
                this.customEditors = null;
                if ("customEditors" in t) {
                    this.customEditors = t.customEditors
                }
                this.environment = {};
                if ("environment" in t) {
                    this.environment = t.environment
                } else {
                    throw new Error("ContentManager constructor error: environment property missed")
                }
                this.language = "";
                if ("language" in t) {
                    this.language = t.language
                } else {
                    throw new Error("ContentManager constructor error: language property missed")
                }
                this.editorListener = new Yz;
                this.editor = null;
                this.ua = navigator.userAgent.toLowerCase();
                this.deviceProperties = {};
                this.deviceProperties.isAndroid = this.ua.indexOf("android") > -1;
                this.deviceProperties.isIOS = Qz.isIOS();
                this.toolbar = null;
                this.modalDialogInstance = null;
                this.listeners = new Rz;
                this.mathML = null;
                this.isNewElement = true;
                this.integrationModel = null
            }

            addListener(t) {
                this.listeners.add(t)
            }

            setIntegrationModel(t) {
                this.integrationModel = t
            }

            setModalDialogInstance(t) {
                this.modalDialogInstance = t
            }

            insert() {
                this.updateTitle(this.modalDialogInstance);
                this.insertEditor(this.modalDialogInstance)
            }

            insertEditor() {
                if (Qz.isEditorLoaded()) {
                    this.editor = window.com.wiris.jsEditor.JsEditor.newInstance(this.editorAttributes);
                    this.editor.insertInto(this.modalDialogInstance.contentContainer);
                    this.editor.focus();
                    if (this.modalDialogInstance.rtl) {
                        this.editor.action("rtl")
                    }
                    if (this.editor.getEditorModel().isRTL()) {
                        this.editor.element.style.direction = "rtl"
                    }
                    this.editor.getEditorModel().addEditorListener(this.editorListener);
                    if (this.modalDialogInstance.deviceProperties.isIOS) {
                        setTimeout((function t() {
                            if (this.hasOwnProperty("modalDialogInstance")) this.modalDialogInstance.hideKeyboard()
                        }), 400);
                        const t = document.getElementsByClassName("wrs_formulaDisplay")[0];
                        Wz.addEvent(t, "focus", this.modalDialogInstance.handleOpenedIosSoftkeyboard);
                        Wz.addEvent(t, "blur", this.modalDialogInstance.handleClosedIosSoftkeyboard)
                    }
                    this.listeners.fire("onLoad", {})
                } else {
                    setTimeout(Qz.prototype.insertEditor.bind(this), 100)
                }
            }

            init() {
                if (!Qz.isEditorLoaded()) {
                    this.addEditorAsExternalDependency()
                }
            }

            addEditorAsExternalDependency() {
                const t = document.createElement("script");
                t.type = "text/javascript";
                let e = Oz.get("editorUrl");
                const n = document.createElement("a");
                Qz.setHrefToAnchorElement(n, e);
                Qz.setProtocolToAnchorElement(n);
                e = Qz.getURLFromAnchorElement(n);
                const i = this.getEditorStats();
                t.src = `${e}?lang=${this.language}&stats-editor=${i.editor}&stats-mode=${i.mode}&stats-version=${i.version}`;
                document.getElementsByTagName("head")[0].appendChild(t)
            }

            static setHrefToAnchorElement(t, e) {
                t.href = e
            }

            static setProtocolToAnchorElement(t) {
                if (window.location.href.indexOf("https://") === 0) {
                    if (t.protocol === "http:") {
                        t.protocol = "https:"
                    }
                }
            }

            static getURLFromAnchorElement(t) {
                if (t.port === "80" || t.port === "443" || t.port === "") {
                    return `${t.protocol}//${t.hostname}/${t.pathname}`
                }
            }

            getEditorStats() {
                const t = {};
                if ("editor" in this.environment) {
                    t.editor = this.environment.editor
                } else {
                    t.editor = "unknown"
                }
                if ("mode" in this.environment) {
                    t.mode = this.environment.mode
                } else {
                    t.mode = Oz.get("saveMode")
                }
                if ("version" in this.environment) {
                    t.version = this.environment.version
                } else {
                    t.version = Oz.get("version")
                }
                return t
            }

            static isIOS() {
                return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document
            }

            static isEditorLoaded() {
                return window.com && window.com.wiris && window.com.wiris.jsEditor && window.com.wiris.jsEditor.JsEditor && window.com.wiris.jsEditor.JsEditor.newInstance
            }

            setInitialContent() {
                if (!this.isNewElement) {
                    this.setMathML(this.mathML)
                }
            }

            setMathML(t, e) {
                if (typeof e === "undefined") {
                    e = false
                }
                this.editor.setMathMLWithCallback(t, (() => {
                    this.editorListener.setWaitingForChanges(true)
                }));
                setTimeout((() => {
                    this.editorListener.setIsContentChanged(false)
                }), 500);
                if (!e) {
                    this.onFocus()
                }
            }

            onFocus() {
                if (typeof this.editor !== "undefined" && this.editor != null) {
                    this.editor.focus()
                }
            }

            submitAction() {
                if (!this.editor.isFormulaEmpty()) {
                    let t = this.editor.getMathMLWithSemantics();
                    if (this.customEditors.getActiveEditor() !== null) {
                        const {toolbar: e} = this.customEditors.getActiveEditor();
                        t = Pz.addCustomEditorClassAttribute(t, e)
                    } else {
                        Object.keys(this.customEditors.editors).forEach((e => {
                            t = Pz.removeCustomEditorClassAttribute(t, e)
                        }))
                    }
                    const e = Pz.mathMLEntities(t);
                    this.integrationModel.updateFormula(e)
                } else {
                    this.integrationModel.updateFormula(null)
                }
                this.customEditors.disable();
                this.integrationModel.notifyWindowClosed();
                this.setEmptyMathML();
                this.customEditors.disable()
            }

            setEmptyMathML() {
                if (this.deviceProperties.isAndroid || this.deviceProperties.isIOS) {
                    if (this.editor.getEditorModel().isRTL()) {
                        this.setMathML('<math dir="rtl"><semantics><annotation encoding="application/json">[]</annotation></semantics></math>', true)
                    } else {
                        this.setMathML('<math><semantics><annotation encoding="application/json">[]</annotation></semantics></math>', true)
                    }
                } else if (this.editor.getEditorModel().isRTL()) {
                    this.setMathML('<math dir="rtl"/>', true)
                } else {
                    this.setMathML("<math/>", true)
                }
            }

            onOpen() {
                if (this.isNewElement) {
                    this.setEmptyMathML()
                } else {
                    this.setMathML(this.mathML)
                }
                this.updateToolbar();
                this.onFocus()
            }

            updateToolbar() {
                this.updateTitle(this.modalDialogInstance);
                const t = this.customEditors.getActiveEditor();
                if (t) {
                    const e = t.toolbar ? t.toolbar : _wrs_int_wirisProperties.toolbar;
                    if (this.toolbar == null || this.toolbar !== e) {
                        this.setToolbar(e)
                    }
                } else {
                    const t = this.getToolbar();
                    if (this.toolbar == null || this.toolbar !== t) {
                        this.setToolbar(t);
                        this.customEditors.disable()
                    }
                }
            }

            updateTitle() {
                const t = this.customEditors.getActiveEditor();
                if (t) {
                    this.modalDialogInstance.setTitle(t.title)
                } else {
                    this.modalDialogInstance.setTitle("MathType")
                }
            }

            getToolbar() {
                let t = "general";
                if ("toolbar" in this.editorAttributes) {
                    ({toolbar: t} = this.editorAttributes)
                }
                if (t === "general") {
                    t = typeof _wrs_int_wirisProperties === "undefined" || typeof _wrs_int_wirisProperties.toolbar === "undefined" ? "general" : _wrs_int_wirisProperties.toolbar
                }
                return t
            }

            setToolbar(t) {
                this.toolbar = t;
                this.editor.setParams({toolbar: this.toolbar})
            }

            hasChanges() {
                return !this.editor.isFormulaEmpty() && this.editorListener.getIsContentChanged()
            }

            onKeyDown(t) {
                if (t.key !== undefined && t.repeat === false) {
                    if (t.key === "Escape" || t.key === "Esc") {
                        let e = document.getElementsByClassName("wrs_expandButton wrs_expandButtonFor3RowsLayout wrs_pressed");
                        if (e.length === 0) {
                            e = document.getElementsByClassName("wrs_expandButton wrs_expandButtonFor2RowsLayout wrs_pressed");
                            if (e.length === 0) {
                                e = document.getElementsByClassName("wrs_select wrs_pressed");
                                if (e.length === 0) {
                                    this.modalDialogInstance.cancelAction();
                                    t.stopPropagation();
                                    t.preventDefault()
                                }
                            }
                        }
                    } else if (t.shiftKey && t.key === "Tab") {
                        if (document.activeElement === this.modalDialogInstance.submitButton) {
                            this.editor.focus();
                            t.stopPropagation();
                            t.preventDefault()
                        } else {
                            const e = document.querySelector('[title="Manual"]');
                            if (document.activeElement === e) {
                                this.modalDialogInstance.cancelButton.focus();
                                t.stopPropagation();
                                t.preventDefault()
                            }
                        }
                    } else if (t.key === "Tab") {
                        if (document.activeElement === this.modalDialogInstance.cancelButton) {
                            const e = document.querySelector('[title="Manual"]');
                            e.focus();
                            t.stopPropagation();
                            t.preventDefault()
                        } else {
                            const e = document.getElementsByClassName("wrs_formulaDisplay")[0];
                            if (e.getAttribute("class") === "wrs_formulaDisplay wrs_focused") {
                                this.modalDialogInstance.submitButton.focus();
                                t.stopPropagation();
                                t.preventDefault()
                            }
                        }
                    }
                }
            }
        }

        class Jz {
            constructor() {
                this.editors = [];
                this.activeEditor = "default"
            }

            addEditor(t, e) {
                const n = {};
                n.name = e.name;
                n.toolbar = e.toolbar;
                n.icon = e.icon;
                n.confVariable = e.confVariable;
                n.title = e.title;
                n.tooltip = e.tooltip;
                this.editors[t] = n
            }

            enable(t) {
                this.activeEditor = t
            }

            disable() {
                this.activeEditor = "default"
            }

            getActiveEditor() {
                if (this.activeEditor !== "default") {
                    return this.editors[this.activeEditor]
                }
                return null
            }
        }

        const Xz = {
            imageCustomEditorName: "data-custom-editor",
            imageClassName: "Wirisformula",
            CASClassName: "Wiriscas"
        };
        var Zz = Xz;

        class tN {
            constructor() {
                this.cancelled = false;
                this.defaultPrevented = false
            }

            cancel() {
                this.cancelled = true
            }

            preventDefault() {
                this.defaultPrevented = true
            }
        }

        class eN {
            constructor(t) {
                this.overlayElement = t.overlayElement;
                this.callbacks = t.callbacks;
                this.overlayWrapper = this.overlayElement.appendChild(document.createElement("div"));
                this.overlayWrapper.setAttribute("class", "wrs_popupmessage_overlay_envolture");
                this.message = this.overlayWrapper.appendChild(document.createElement("div"));
                this.message.id = "wrs_popupmessage";
                this.message.setAttribute("class", "wrs_popupmessage_panel");
                this.message.setAttribute("role", "dialog");
                this.message.setAttribute("aria-describedby", "description_txt");
                const e = document.createElement("p");
                const n = document.createTextNode(t.strings.message);
                e.appendChild(n);
                e.id = "description_txt";
                this.message.appendChild(e);
                const i = this.overlayWrapper.appendChild(document.createElement("div"));
                i.setAttribute("class", "wrs_popupmessage_overlay");
                i.addEventListener("click", this.cancelAction.bind(this));
                this.buttonArea = this.message.appendChild(document.createElement("div"));
                this.buttonArea.setAttribute("class", "wrs_popupmessage_button_area");
                this.buttonArea.id = "wrs_popup_button_area";
                const o = {
                    class: "wrs_button_accept",
                    innerHTML: t.strings.submitString,
                    id: "wrs_popup_accept_button"
                };
                this.closeButton = this.createButton(o, this.closeAction.bind(this));
                this.buttonArea.appendChild(this.closeButton);
                const r = {
                    class: "wrs_button_cancel",
                    innerHTML: t.strings.cancelString,
                    id: "wrs_popup_cancel_button"
                };
                this.cancelButton = this.createButton(r, this.cancelAction.bind(this));
                this.buttonArea.appendChild(this.cancelButton)
            }

            createButton(t, e) {
                let n = {};
                n = document.createElement("button");
                n.setAttribute("id", t.id);
                n.setAttribute("class", t.class);
                n.innerHTML = t.innerHTML;
                n.addEventListener("click", e);
                return n
            }

            show() {
                if (this.overlayWrapper.style.display !== "block") {
                    document.activeElement.blur();
                    this.overlayWrapper.style.display = "block";
                    this.closeButton.focus()
                } else {
                    this.overlayWrapper.style.display = "none"
                }
            }

            cancelAction() {
                this.overlayWrapper.style.display = "none";
                if (typeof this.callbacks.cancelCallback !== "undefined") {
                    this.callbacks.cancelCallback()
                }
            }

            closeAction() {
                this.cancelAction();
                if (typeof this.callbacks.closeCallback !== "undefined") {
                    this.callbacks.closeCallback()
                }
            }

            onKeyDown(t) {
                if (t.key !== undefined) {
                    if (t.key === "Escape" || t.key === "Esc") {
                        this.cancelAction();
                        t.stopPropagation();
                        t.preventDefault()
                    } else if (t.key === "Tab") {
                        if (document.activeElement === this.closeButton) {
                            this.cancelButton.focus()
                        } else {
                            this.closeButton.focus()
                        }
                        t.stopPropagation();
                        t.preventDefault()
                    }
                }
            }
        }

        var nN = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<svg\n   xmlns:dc="http://purl.org/dc/elements/1.1/"\n   xmlns:cc="http://creativecommons.org/ns#"\n   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"\n   xmlns:svg="http://www.w3.org/2000/svg"\n   xmlns="http://www.w3.org/2000/svg"\n   xmlns:xlink="http://www.w3.org/1999/xlink"\n   viewBox="0 0 13.76 13.76"\n   height="13.76"\n   width="13.76"\n   id="svg3783"\n   version="1.1">\n  <metadata\n     id="metadata3789">\n    <rdf:RDF>\n      <cc:Work\n         rdf:about="">\n        <dc:format>image/svg+xml</dc:format>\n        <dc:type\n           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />\n        <dc:title></dc:title>\n      </cc:Work>\n    </rdf:RDF>\n  </metadata>\n  <defs\n     id="defs3787" />\n  <image\n     y="0"\n     x="0"\n     id="image3791"\n     xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACsAAAArCAYAAADhXXHAAAAACXBIWXMAAC4jAAAuIwF4pT92AAAB\nvklEQVRYw83Z23GDMBAF0AsNhBIowSVQgjuISnAJKSEdZNOBS6CDOBUkqSC4gs2PyGhAQg92se4M\n4w8bccYW2hVumBmRdAB6ADfopQcw2SOYNoIkAL8APgB8AzgLI0/2S/iy1xkt3B9m9h0dM9/YHxM4\nJ/c4MfPkGX+y763OyYVKgUPQTXAJdC84Bg2CS6Gl4FSoF7wHmgvOhbrgzsW+8L4YJegccrEj749R\ngs7ZXGdz8wbAeNbREcDTzrHvblEgBbAUFACuy6JALJeL0E/P9sbvmBnNojcgAM+oJ58AhrlnWM5Z\nA+C9RmiokakBvIJuNTLSc7hojqY0Mo8EB6Ep2CPBm9BU7BHgKDQHqwlOguZiNcDJ0JLe4FV4iaLY\nJjF16dLqnoob+EdDs8A1QJPBtUCTwDVBo+DaoJvgNvBIR6rDl9wirbA1QIPgVgl6VwHb+dAr7Jkk\nS/Pg3mCkVOslxxV9yBFqSqTA/3N2Utkzye3pftw5OxzQ5tHeddcdzGj3o4VgClUwowgtAVOs3BpF\naA6YUnsDowhNAVNu12UUoVtgCn2+ifxp1wO42Ner4KPR5dJ2tsse2ZLvTQxbVf4AmC2z7WnSvpIA\nAAAASUVORK5CYII=\n"\n     style="image-rendering:optimizeQuality"\n     preserveAspectRatio="none"\n     height="13.76"\n     width="13.76" />\n</svg>\n';
        var iN = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<svg\n   xmlns:dc="http://purl.org/dc/elements/1.1/"\n   xmlns:cc="http://creativecommons.org/ns#"\n   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"\n   xmlns:svg="http://www.w3.org/2000/svg"\n   xmlns="http://www.w3.org/2000/svg"\n   xmlns:xlink="http://www.w3.org/1999/xlink"\n   viewBox="0 0 13.76 13.76"\n   height="13.76"\n   width="13.76"\n   id="svg2"\n   version="1.1">\n  <metadata\n     id="metadata8">\n    <rdf:RDF>\n      <cc:Work\n         rdf:about="">\n        <dc:format>image/svg+xml</dc:format>\n        <dc:type\n           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />\n        <dc:title></dc:title>\n      </cc:Work>\n    </rdf:RDF>\n  </metadata>\n  <defs\n     id="defs6" />\n  <image\n     y="0"\n     x="0"\n     id="image10"\n     xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACsAAAArCAYAAADhXXHAAAAACXBIWXMAAC4jAAAuIwF4pT92AAAB\n2ElEQVRYw9XZoXPCMBTH8S+5KfDzQ29606CH3/SmQTO96aGHHn/F0Himh8eDZSblQknSJH2F0DtE\nQw8+12vyfulr7XY7LuW4qvj+DugD18AC+AE2woa+/mz07y9cF7Y8d7YPDEtjK2AsCB4BvdLYHPi0\nXawioAA3wAfQaQiKHhuFYl1QSbAL6gWrSKgEuArqBKsEaB1wKNQKVsasHybcpRhwLNQED0zsoMbz\nFwJOhWL6Cmzd2e0D14Wi1/k9di2wFNnAEtBifd9jv4GtIPgaeBOCAkzLFayr/6idWSSY6DJ8sHT9\n6VK6zRFqKwo5gQ+grnKbA/gI6gsy5wRboT7sucBOaBX21GAvNAR7KnAlNBTbNDgIGoMtwO/C0Gko\nNBZbN525tk+dJrAj4F4YGxXgVQS019DkCgarM0OjwCoDaDBYZQINAquMoJVglRnUC1YZQp1g1RB0\nJryn65jYJ0HoRGPHguDX8hsZ6VAiGX4eUrJBbHqSArdN7LLBmCcBnpvYWfHWo6E8Wge8Ar7Kj8E4\nARwcnBPBB20BE7uJBMdAU8BH/YvyBAsFp0BjwNZGi201qALXgYaAnR0hX2upAzwDj/p8raFL5I4u\n8ALc6vNfvc+ztq5al9Rh/AfwZZ/LmlMllAAAAABJRU5ErkJggg==\n"\n     style="image-rendering:optimizeQuality"\n     preserveAspectRatio="none"\n     height="13.76"\n     width="13.76" />\n</svg>\n';
        var oN = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<svg\n   xmlns:dc="http://purl.org/dc/elements/1.1/"\n   xmlns:cc="http://creativecommons.org/ns#"\n   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"\n   xmlns:svg="http://www.w3.org/2000/svg"\n   xmlns="http://www.w3.org/2000/svg"\n   xmlns:xlink="http://www.w3.org/1999/xlink"\n   viewBox="0 0 13.76 13.76"\n   height="13.76"\n   width="13.76"\n   id="svg3793"\n   version="1.1">\n  <metadata\n     id="metadata3799">\n    <rdf:RDF>\n      <cc:Work\n         rdf:about="">\n        <dc:format>image/svg+xml</dc:format>\n        <dc:type\n           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />\n        <dc:title></dc:title>\n      </cc:Work>\n    </rdf:RDF>\n  </metadata>\n  <defs\n     id="defs3797" />\n  <image\n     y="0"\n     x="0"\n     id="image3801"\n     xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACsAAAArCAYAAADhXXHAAAAAAXNSR0IArs4c6QAAAARnQU1BAACx\njwv8YQUAAAAJcEhZcwAALiMAAC4jAXilP3YAAAG4SURBVFhHvZnhUYNAEEbRBkwH2oGUkA40FWgJ\nKSEdaAmxA0vQDmIHKSFWgPuAHZkEAnd8y5v5kuNHMm+WY1mSm6qqCiGlZdUspXzxopY9Wu6bpZQf\nSxlRWapwVx9p2dy2CxUHy9ryWx9pKdWyECYcIQshwlGyIBeOlAWpcLQsyISXkAWEX5tlPkvJwnP7\nns1SsnvLS7PMZwlZiShEy8pEIVJWKgpRsnJRiJBNFf2wbCzjfZgRUZi9JYWDxT9bWk6WIXbKym4t\nKRVloObO5oze6ZClWX9a5jyOcOrfmuUkXPRUH/1zVRhZpvsnCxN+jnDqHh0SdQaFu9vg0ZIqrBZ1\neoXP92yKcJSocyHcd4FNEY4WdbrCR1rGrukMF9BWVhZvLZ7U9rS2nH9HVvoq63iFu+RUlOpIuCYL\nCCPIqVjq1A9j5R3aBnMY2kKzMlbZHPQVbVHLhomCUjZUFFSy35ZQUVDIMo+Gi4JCltFwERSy75Y5\n4+VkFLLcKHLHyyRUF1jOeJmMShbChZWy0Df8yFDLgg8/cpCN6I9cdHJhZHmy7X2anAnCtDUZ/j/Y\ng2X2j709MHhTDAFF8QdK9SRpUl2yFgAAAABJRU5ErkJggg==\n"\n     style="image-rendering:optimizeQuality"\n     preserveAspectRatio="none"\n     height="13.76"\n     width="13.76" />\n</svg>\n';
        var rN = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<svg\n   xmlns:dc="http://purl.org/dc/elements/1.1/"\n   xmlns:cc="http://creativecommons.org/ns#"\n   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"\n   xmlns:svg="http://www.w3.org/2000/svg"\n   xmlns="http://www.w3.org/2000/svg"\n   xmlns:xlink="http://www.w3.org/1999/xlink"\n   viewBox="0 0 13.76 13.76"\n   height="13.76"\n   width="13.76"\n   id="svg12"\n   version="1.1">\n  <metadata\n     id="metadata18">\n    <rdf:RDF>\n      <cc:Work\n         rdf:about="">\n        <dc:format>image/svg+xml</dc:format>\n        <dc:type\n           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />\n        <dc:title></dc:title>\n      </cc:Work>\n    </rdf:RDF>\n  </metadata>\n  <defs\n     id="defs16" />\n  <image\n     y="0"\n     x="0"\n     id="image20"\n     xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACsAAAArCAYAAADhXXHAAAAAAXNSR0IArs4c6QAAAARnQU1BAACx\njwv8YQUAAAAJcEhZcwAALiMAAC4jAXilP3YAAAGMSURBVFhHvdk7TsNAFIVhQ0l6elLDJqCGngXQ\nU7MA6rALahZATQ81C6APrXP/jEaKHD/i8TnzS1eaICF/2I4f4qxt20bYOmaVlrK2Mb8s1Nj3mIu0\nlPYZszlPa1kvMf9pKe02Zq3Gcrhc4JUaSzawA0sWsAtLcrATS1KwG0sycA0sAd6kZXm1sNzVHtOy\nvBpYoK8xV/tPC3JjZVByYqVQcmHlUHJgLVBSY0ugPP7xO5PXYSW2FMr19ytm8sahxD7ElEBzk3c6\nsFysn/afymKPvsXMueh3oblRMNibmPuYZ34wsyWHfqhB8OFpwKvDHLADmusFd8/ZU8FOaO4I3PcF\nmwLXgOYOwVtexdnwdUy3vg2UQPnD2eji+vZsrruHS/eoBEpjWMpgrhi1Dv1gY6fBkuRQmtqzJVmg\npMbaoKTEWqGkwtqhpMBWgZICWwVKCuwpzxKSFNi5T2vFqb5gVcAqLNnBSixZwWos2cBg/9JSmgUM\n9iMt5QFe8tZ8VP6n3WXMHQtxPzHfabm0ptkBwWhpthzMp7YAAAAASUVORK5CYII=\n"\n     style="image-rendering:optimizeQuality"\n     preserveAspectRatio="none"\n     height="13.76"\n     width="13.76" />\n</svg>\n';
        var sN = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<svg\n   xmlns:dc="http://purl.org/dc/elements/1.1/"\n   xmlns:cc="http://creativecommons.org/ns#"\n   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"\n   xmlns:svg="http://www.w3.org/2000/svg"\n   xmlns="http://www.w3.org/2000/svg"\n   xmlns:xlink="http://www.w3.org/1999/xlink"\n   viewBox="0 0 13.76 13.76"\n   height="13.76"\n   width="13.76"\n   id="svg3813"\n   version="1.1">\n  <metadata\n     id="metadata3819">\n    <rdf:RDF>\n      <cc:Work\n         rdf:about="">\n        <dc:format>image/svg+xml</dc:format>\n        <dc:type\n           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />\n        <dc:title></dc:title>\n      </cc:Work>\n    </rdf:RDF>\n  </metadata>\n  <defs\n     id="defs3817" />\n  <image\n     y="0"\n     x="0"\n     id="image3821"\n     xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACsAAAArCAYAAADhXXHAAAAACXBIWXMAAC4jAAAuIwF4pT92AAAA\nnUlEQVRYw+3Z0QnCMBSF4T/FATqCG1g3cISO0NE6iiPoCE5gneD40ohPvgkJ/AcC9/EjHELgliT0\nkoGOIlasWLFixYoVK1asWLFixYoVK1bsjxy+5hlYgLEx47ofSEKSJW1nTUJJMgLPDlpwHoCpk8rO\nvgZixf4Zu3Vi3cq+WroBp4ahL+BYa3AB7o1CH7vvc7M1U4N/g2sdSk8bxjfDaMNdr+hmAQAAAABJ\nRU5ErkJggg==\n"\n     style="image-rendering:optimizeQuality"\n     preserveAspectRatio="none"\n     height="13.76"\n     width="13.76" />\n</svg>\n';
        var aN = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<svg\n   xmlns:dc="http://purl.org/dc/elements/1.1/"\n   xmlns:cc="http://creativecommons.org/ns#"\n   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"\n   xmlns:svg="http://www.w3.org/2000/svg"\n   xmlns="http://www.w3.org/2000/svg"\n   xmlns:xlink="http://www.w3.org/1999/xlink"\n   viewBox="0 0 13.76 13.76"\n   height="13.76"\n   width="13.76"\n   id="svg32"\n   version="1.1">\n  <metadata\n     id="metadata38">\n    <rdf:RDF>\n      <cc:Work\n         rdf:about="">\n        <dc:format>image/svg+xml</dc:format>\n        <dc:type\n           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />\n        <dc:title></dc:title>\n      </cc:Work>\n    </rdf:RDF>\n  </metadata>\n  <defs\n     id="defs36" />\n  <image\n     y="0"\n     x="0"\n     id="image40"\n     xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACsAAAArCAYAAADhXXHAAAAACXBIWXMAAC4jAAAuIwF4pT92AAAA\npklEQVRYw+3ZLQ4CMRCG4bcbFOvXg99T7FG4BafAw1VALx7dWyy2mIoGgSOZJu/n6p70ZybppFIK\nvWSgo4gVK1asWLFixYoVK1asWLFixYoV+yO7r/UMHIAxiO8FZGBrsUfgDEwBN/QNXIA11S/PW1Bo\nCz4N9ein4Nd1Dyw9PbDR0iVW7J+xudax6HkOtZVdg0MfQE7N0G4GlmANYgNW4A6QepowfgDMXB26\nb1V6LAAAAABJRU5ErkJggg==\n"\n     style="image-rendering:optimizeQuality"\n     preserveAspectRatio="none"\n     height="13.76"\n     width="13.76" />\n</svg>\n';
        var cN = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<svg\n   xmlns:dc="http://purl.org/dc/elements/1.1/"\n   xmlns:cc="http://creativecommons.org/ns#"\n   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"\n   xmlns:svg="http://www.w3.org/2000/svg"\n   xmlns="http://www.w3.org/2000/svg"\n   xmlns:xlink="http://www.w3.org/1999/xlink"\n   viewBox="0 0 13.76 13.76"\n   height="13.76"\n   width="13.76"\n   id="svg3823"\n   version="1.1">\n  <metadata\n     id="metadata3829">\n    <rdf:RDF>\n      <cc:Work\n         rdf:about="">\n        <dc:format>image/svg+xml</dc:format>\n        <dc:type\n           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />\n        <dc:title></dc:title>\n      </cc:Work>\n    </rdf:RDF>\n  </metadata>\n  <defs\n     id="defs3827" />\n  <image\n     y="0"\n     x="0"\n     id="image3831"\n     xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACsAAAArCAYAAADhXXHAAAAAAXNSR0IArs4c6QAAAARnQU1BAACx\njwv8YQUAAAAJcEhZcwAALiMAAC4jAXilP3YAAAHOSURBVFhH1ZiLUcMwEEQNDcQl0AEuISVABZhO\nUkroICVAB6ECoINQgdmVfR5FlmQrkZzjzezEzsc8NPqcdNd1XfVfuB9ec3NAmv4yiRo5ImzBlm+c\nwZYtEHJCGsT3eSgHxKZFxs/tL+aMkCK8R3yMwu4PcsVmiXBIVDDCvh/miEtMeE5UaEsNMJcN8o64\ng26PvPSXs9S+/zRHQtgtvLRFCb9blZpnYw/9Rb6RR3M3zxtiprFbyKYwipK1+uwlnIkSrbITUaJR\n1itKtMkGRYk2WRZAQbTNBpzWtggrrwnaWja00hk0DrCgsEZZ4hXWKksmwjLAHobkgOv+V3+ZhXHQ\niWxKqXYLKNyILDdqbPKlldASPhA+Mxc7uwatkSOSix1iP//q2APshLBvfJo7hbizgQj/mDtl+KYu\nCj8h7NSqCM2zXJvZwqqEY4uCOuGYLKEwJ3kVzMlyscg5915FTFbdqhaSVbn8+mTV1gmurOqCxpZN\nEeUu9BlZd1obioTkQ7IhPGTjYZuPIoUMK/GUFrX39asuHJTlH3w1d3FCBxCrCUufZX+NCUdPSsAq\nwu4A8wnPiQrFhW1Z4govFRWKCoeOjzjoZF92CdwpZy6AquoPvJRHJxB8bJ8AAAAASUVORK5CYII=\n"\n     style="image-rendering:optimizeQuality"\n     preserveAspectRatio="none"\n     height="13.76"\n     width="13.76" />\n</svg>\n';
        var lN = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<svg\n   xmlns:dc="http://purl.org/dc/elements/1.1/"\n   xmlns:cc="http://creativecommons.org/ns#"\n   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"\n   xmlns:svg="http://www.w3.org/2000/svg"\n   xmlns="http://www.w3.org/2000/svg"\n   xmlns:xlink="http://www.w3.org/1999/xlink"\n   viewBox="0 0 13.76 13.76"\n   height="13.76"\n   width="13.76"\n   id="svg42"\n   version="1.1">\n  <metadata\n     id="metadata48">\n    <rdf:RDF>\n      <cc:Work\n         rdf:about="">\n        <dc:format>image/svg+xml</dc:format>\n        <dc:type\n           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />\n        <dc:title></dc:title>\n      </cc:Work>\n    </rdf:RDF>\n  </metadata>\n  <defs\n     id="defs46" />\n  <image\n     y="0"\n     x="0"\n     id="image50"\n     xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACsAAAArCAYAAADhXXHAAAAAAXNSR0IArs4c6QAAAARnQU1BAACx\njwv8YQUAAAAJcEhZcwAALiMAAC4jAXilP3YAAAG/SURBVFhH1ZgxUsMwEEUNJRyAGmp6qKGn5xRQ\nQ08NNfRQQw11DpAaanIAWrMv8WaELSlexhLLm/mRnImiF48jr7zVtm3zX9ju2ik5llxLdpdHNg4k\nT5I7yWB8Cdl9yZHkRmIRRpQxOxK+YzC+hKwSnTBBKKoMxpeUBSbkksgRE1V+CJeWhUPJ5ao7ICeq\nrIVryMKJpC88RlTZk1SThVDYIvoluZIsSqyz511SfEg4UxbRdw5qnlmFa9AsCn8hO4aBKHiUjYqC\nN9mkKHiSzYqCJ9lPSVIUPMmySqTudEu8XbOxO90ab7KQFPYoC1Fhr7IwENbagMLCUtXnoCTM1QZW\n3iS3dFT2mRfHvEjuVfZUckFnQh67dgqo1GYqC1MLn3XtZIR/sFcJW2C39FcD18KxpcutcGqddSmc\nuykg/LDq+iAnC/OudUFOVrfLbkjJWvb11YjJuhSFvqxbUQhlXYuCylpE2YXy2SkLlVEgaxVluzyT\nIEutWQ1kKZYtouF2maK4mjCyFN6bJsw9gKgmrNdsbsKNT0qEKsIqC7EJx4gqxYVDWQgntIgqRYXD\nbY3CLpcVgmdPC974BYy3/MgRNM03hR9ubFTHT48AAAAASUVORK5CYII=\n"\n     style="image-rendering:optimizeQuality"\n     preserveAspectRatio="none"\n     height="13.76"\n     width="13.76" />\n</svg>\n';
        var dN = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<svg\n   xmlns:dc="http://purl.org/dc/elements/1.1/"\n   xmlns:cc="http://creativecommons.org/ns#"\n   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"\n   xmlns:svg="http://www.w3.org/2000/svg"\n   xmlns="http://www.w3.org/2000/svg"\n   xmlns:xlink="http://www.w3.org/1999/xlink"\n   viewBox="0 0 13.44 13.76"\n   height="13.76"\n   width="13.44"\n   id="svg3803"\n   version="1.1">\n  <metadata\n     id="metadata3809">\n    <rdf:RDF>\n      <cc:Work\n         rdf:about="">\n        <dc:format>image/svg+xml</dc:format>\n        <dc:type\n           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />\n        <dc:title></dc:title>\n      </cc:Work>\n    </rdf:RDF>\n  </metadata>\n  <defs\n     id="defs3807" />\n  <image\n     y="0"\n     x="0"\n     id="image3811"\n     xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAArCAYAAAAOnxr+AAAACXBIWXMAAC4jAAAuIwF4pT92AAAA\nvElEQVRYw+3ZSw0CMRSF4b8T9iAFB4wDkDAWcICEkTA4GAeAA3AADurgsCkbAgsSMrmFczZNd1/a\n3vSVJFFDGipJNdBZaRdAB2wC2TIwAgNAkrQEjsA86GBegDZJGoF18JnfJtVR9idXvaGGGmrod/b6\nV9kD14k9LbD6FDqUM8CU2b2Deo0aaqihhhpqqKGGGhr1hH/wiP469FaBMzflEhc9PZKQ1CtmsqRO\nEunpHbeNNN3A+dFJ/mf6V+gduGPIoUgKLbAAAAAASUVORK5CYII=\n"\n     style="image-rendering:optimizeQuality"\n     preserveAspectRatio="none"\n     height="13.76"\n     width="13.44" />\n</svg>\n';
        var uN = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<svg\n   xmlns:dc="http://purl.org/dc/elements/1.1/"\n   xmlns:cc="http://creativecommons.org/ns#"\n   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"\n   xmlns:svg="http://www.w3.org/2000/svg"\n   xmlns="http://www.w3.org/2000/svg"\n   xmlns:xlink="http://www.w3.org/1999/xlink"\n   viewBox="0 0 13.44 13.76"\n   height="13.76"\n   width="13.44"\n   id="svg22"\n   version="1.1">\n  <metadata\n     id="metadata28">\n    <rdf:RDF>\n      <cc:Work\n         rdf:about="">\n        <dc:format>image/svg+xml</dc:format>\n        <dc:type\n           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />\n        <dc:title></dc:title>\n      </cc:Work>\n    </rdf:RDF>\n  </metadata>\n  <defs\n     id="defs26" />\n  <image\n     y="0"\n     x="0"\n     id="image30"\n     xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACoAAAArCAYAAAAOnxr+AAAACXBIWXMAAC4jAAAuIwF4pT92AAAA\nvUlEQVRYw+3ZsQ3CMBCF4d8WFekZgBqWIDUDZACmYBQWYIn0pGYAegZIexROERHRIBTdhXeVy08+\nyT4/JzMjQmWCVBjoarSugK0z3/0degKODjeyBy5Am8ysARrnnT8nM7sCa+fQLgdAAlQ6ngQVVFBB\nfzeUTK6t8VAwU328ztV6QQUVVFBBBRVUUEG9Ds41sJvZs/8GelDrlw7tAjhvmZLo9o6RD4bEGUp+\nX1My/I0T4HN4rrcASf9M/wp9ASNzIKYYz2hAAAAAAElFTkSuQmCC\n"\n     style="image-rendering:optimizeQuality"\n     preserveAspectRatio="none"\n     height="13.76"\n     width="13.44" />\n</svg>\n';

        class hN {
            constructor(t) {
                this.attributes = t;
                const e = navigator.userAgent.toLowerCase();
                const n = e.indexOf("android") > -1;
                const i = Qz.isIOS();
                this.iosSoftkeyboardOpened = false;
                this.iosMeasureUnit = e.indexOf("crios") === -1 ? "%" : "vh";
                this.iosDivHeight = `100%${this.iosMeasureUnit}`;
                const o = window.outerWidth;
                const r = window.outerHeight;
                const s = o > r;
                const a = o < r;
                const c = s && this.attributes.height > r;
                const l = a && this.attributes.width > o;
                const d = c || l;
                this.instanceId = document.getElementsByClassName("wrs_modal_dialogContainer").length;
                this.deviceProperties = {
                    orientation: s ? "landscape" : "portait",
                    isAndroid: n,
                    isIOS: i,
                    isMobile: d,
                    isDesktop: !d && !i && !n
                };
                this.properties = {
                    created: false,
                    state: "",
                    previousState: "",
                    position: {bottom: 0, right: 10},
                    size: {height: 338, width: 580}
                };
                this.websiteBeforeLockParameters = null;
                let u = {};
                u.class = "wrs_modal_overlay";
                u.id = this.getElementId(u.class);
                this.overlay = Wz.createElement("div", u);
                u = {};
                u.class = "wrs_modal_title_bar";
                u.id = this.getElementId(u.class);
                this.titleBar = Wz.createElement("div", u);
                u = {};
                u.class = "wrs_modal_title";
                u.id = this.getElementId(u.class);
                this.title = Wz.createElement("div", u);
                this.title.innerHTML = "";
                u = {};
                u.class = "wrs_modal_close_button";
                u.id = this.getElementId(u.class);
                u.title = Uz.get("close");
                u.style = {};
                this.closeDiv = Wz.createElement("a", u);
                this.closeDiv.setAttribute("role", "button");
                let h = `background-size: 10px; background-image: url(data:image/svg+xml;base64,${window.btoa(nN)})`;
                let m = `background-size: 10px; background-image: url(data:image/svg+xml;base64,${window.btoa(iN)})`;
                this.closeDiv.setAttribute("style", h);
                this.closeDiv.setAttribute("onmouseover", `this.style = "${m}";`);
                this.closeDiv.setAttribute("onmouseout", `this.style = "${h}";`);
                u = {};
                u.class = "wrs_modal_stack_button";
                u.id = this.getElementId(u.class);
                u.title = Uz.get("exit_fullscreen");
                this.stackDiv = Wz.createElement("a", u);
                this.stackDiv.setAttribute("role", "button");
                h = `background-size: 10px; background-image: url(data:image/svg+xml;base64,${window.btoa(cN)})`;
                m = `background-size: 10px; background-image: url(data:image/svg+xml;base64,${window.btoa(lN)})`;
                this.stackDiv.setAttribute("style", h);
                this.stackDiv.setAttribute("onmouseover", `this.style = "${m}";`);
                this.stackDiv.setAttribute("onmouseout", `this.style = "${h}";`);
                u = {};
                u.class = "wrs_modal_maximize_button";
                u.id = this.getElementId(u.class);
                u.title = Uz.get("fullscreen");
                this.maximizeDiv = Wz.createElement("a", u);
                this.maximizeDiv.setAttribute("role", "button");
                h = `background-size: 10px; background-repeat: no-repeat; background-image: url(data:image/svg+xml;base64,${window.btoa(oN)})`;
                m = `background-size: 10px; background-repeat: no-repeat; background-image: url(data:image/svg+xml;base64,${window.btoa(rN)})`;
                this.maximizeDiv.setAttribute("style", h);
                this.maximizeDiv.setAttribute("onmouseover", `this.style = "${m}";`);
                this.maximizeDiv.setAttribute("onmouseout", `this.style = "${h}";`);
                u = {};
                u.class = "wrs_modal_minimize_button";
                u.id = this.getElementId(u.class);
                u.title = Uz.get("minimize");
                this.minimizeDiv = Wz.createElement("a", u);
                this.minimizeDiv.setAttribute("role", "button");
                h = `background-size: 10px; background-repeat: no-repeat; background-image: url(data:image/svg+xml;base64,${window.btoa(sN)})`;
                m = `background-size: 10px; background-repeat: no-repeat; background-image: url(data:image/svg+xml;base64,${window.btoa(aN)})`;
                this.minimizeDiv.setAttribute("style", h);
                this.minimizeDiv.setAttribute("onmouseover", `this.style = "${m}";`);
                this.minimizeDiv.setAttribute("onmouseout", `this.style = "${h}";`);
                u = {};
                u.class = "wrs_modal_dialogContainer";
                u.id = this.getElementId(u.class);
                u.role = "dialog";
                this.container = Wz.createElement("div", u);
                this.container.setAttribute("aria-labeledby", "wrs_modal_title[0]");
                u = {};
                u.class = "wrs_modal_wrapper";
                u.id = this.getElementId(u.class);
                this.wrapper = Wz.createElement("div", u);
                u = {};
                u.class = "wrs_content_container";
                u.id = this.getElementId(u.class);
                this.contentContainer = Wz.createElement("div", u);
                u = {};
                u.class = "wrs_modal_controls";
                u.id = this.getElementId(u.class);
                this.controls = Wz.createElement("div", u);
                u = {};
                u.class = "wrs_modal_buttons_container";
                u.id = this.getElementId(u.class);
                this.buttonContainer = Wz.createElement("div", u);
                this.submitButton = this.createSubmitButton({
                    id: this.getElementId("wrs_modal_button_accept"),
                    class: "wrs_modal_button_accept",
                    innerHTML: Uz.get("accept")
                }, this.submitAction.bind(this));
                this.cancelButton = this.createSubmitButton({
                    id: this.getElementId("wrs_modal_button_cancel"),
                    class: "wrs_modal_button_cancel",
                    innerHTML: Uz.get("cancel")
                }, this.cancelAction.bind(this));
                this.contentManager = null;
                const g = {
                    cancelString: Uz.get("cancel"),
                    submitString: Uz.get("close"),
                    message: Uz.get("close_modal_warning")
                };
                const f = {
                    closeCallback: () => {
                        this.close()
                    }, cancelCallback: () => {
                        this.focus()
                    }
                };
                const p = {overlayElement: this.container, callbacks: f, strings: g};
                this.popup = new eN(p);
                this.rtl = false;
                if ("rtl" in this.attributes) {
                    this.rtl = this.attributes.rtl
                }
                this.handleOpenedIosSoftkeyboard = this.handleOpenedIosSoftkeyboard.bind(this);
                this.handleClosedIosSoftkeyboard = this.handleClosedIosSoftkeyboard.bind(this)
            }

            setContentManager(t) {
                this.contentManager = t
            }

            getContentManager() {
                return this.contentManager
            }

            submitAction() {
                if (typeof this.contentManager.submitAction !== "undefined") {
                    this.contentManager.submitAction()
                }
                this.close()
            }

            cancelAction() {
                if (typeof this.contentManager.hasChanges === "undefined") {
                    this.close()
                } else if (!this.contentManager.hasChanges()) {
                    this.close()
                } else {
                    this.showPopUpMessage()
                }
            }

            createSubmitButton(t, e) {
                class n {
                    constructor() {
                        this.element = document.createElement("button");
                        this.element.id = t.id;
                        this.element.className = t.class;
                        this.element.innerHTML = t.innerHTML;
                        Wz.addEvent(this.element, "click", e)
                    }

                    getElement() {
                        return this.element
                    }
                }

                return new n(t, e).getElement()
            }

            create() {
                this.titleBar.appendChild(this.closeDiv);
                this.titleBar.appendChild(this.stackDiv);
                this.titleBar.appendChild(this.maximizeDiv);
                this.titleBar.appendChild(this.minimizeDiv);
                this.titleBar.appendChild(this.title);
                if (this.deviceProperties.isDesktop) {
                    this.container.appendChild(this.titleBar)
                }
                this.wrapper.appendChild(this.contentContainer);
                this.wrapper.appendChild(this.controls);
                this.controls.appendChild(this.buttonContainer);
                this.buttonContainer.appendChild(this.submitButton);
                this.buttonContainer.appendChild(this.cancelButton);
                this.container.appendChild(this.wrapper);
                this.recalculateScrollBar();
                document.body.appendChild(this.container);
                document.body.appendChild(this.overlay);
                if (this.deviceProperties.isDesktop) {
                    this.createModalWindowDesktop();
                    this.createResizeButtons();
                    this.addListeners();
                    if (Oz.get("modalWindowFullScreen")) {
                        this.maximize()
                    }
                } else if (this.deviceProperties.isAndroid) {
                    this.createModalWindowAndroid()
                } else if (this.deviceProperties.isIOS) {
                    this.createModalWindowIos()
                }
                if (this.contentManager != null) {
                    this.contentManager.insert(this)
                }
                this.properties.open = true;
                this.properties.created = true;
                if (this.isRTL()) {
                    this.container.style.right = `${window.innerWidth - this.scrollbarWidth - this.container.offsetWidth}px`;
                    this.container.className += " wrs_modal_rtl"
                }
            }

            createResizeButtons() {
                this.resizerBR = document.createElement("div");
                this.resizerBR.className = "wrs_bottom_right_resizer";
                this.resizerBR.innerHTML = "◢";
                this.resizerTL = document.createElement("div");
                this.resizerTL.className = "wrs_bottom_left_resizer";
                this.container.appendChild(this.resizerBR);
                this.titleBar.appendChild(this.resizerTL);
                Wz.addEvent(this.resizerBR, "mousedown", this.activateResizeStateBR.bind(this));
                Wz.addEvent(this.resizerTL, "mousedown", this.activateResizeStateTL.bind(this))
            }

            activateResizeStateBR(t) {
                this.initializeResizeProperties(t, false)
            }

            activateResizeStateTL(t) {
                this.initializeResizeProperties(t, true)
            }

            initializeResizeProperties(t, e) {
                Wz.addClass(document.body, "wrs_noselect");
                Wz.addClass(this.overlay, "wrs_overlay_active");
                this.resizeDataObject = {x: this.eventClient(t).X, y: this.eventClient(t).Y};
                this.initialWidth = parseInt(this.container.style.width, 10);
                this.initialHeight = parseInt(this.container.style.height, 10);
                if (!e) {
                    this.initialRight = parseInt(this.container.style.right, 10);
                    this.initialBottom = parseInt(this.container.style.bottom, 10)
                } else {
                    this.leftScale = true
                }
                if (!this.initialRight) {
                    this.initialRight = 0
                }
                if (!this.initialBottom) {
                    this.initialBottom = 0
                }
                document.body.style["user-select"] = "none"
            }

            open() {
                try {
                    TelemetryService.send([{
                        timestamp: (new Date).toJSON(),
                        topic: "0",
                        level: "info",
                        message: "HELO telemetry.wiris.net"
                    }]).then((t => {
                    }))
                } catch (t) {
                }
                this.removeClass("wrs_closed");
                const {isIOS: t} = this.deviceProperties;
                const {isAndroid: e} = this.deviceProperties;
                const {isMobile: n} = this.deviceProperties;
                if (t || e || n) {
                    this.restoreWebsiteScale();
                    this.lockWebsiteScroll();
                    setTimeout((() => {
                        this.hideKeyboard()
                    }), 400)
                }
                if (!this.properties.created) {
                    this.create()
                } else {
                    if (!this.properties.open) {
                        this.properties.open = true;
                        if (!this.deviceProperties.isAndroid && !this.deviceProperties.isIOS) {
                            this.restoreState()
                        }
                    }
                    if (this.deviceProperties.isDesktop && Oz.get("modalWindowFullScreen")) {
                        this.maximize()
                    }
                    if (this.deviceProperties.isIOS) {
                        this.iosSoftkeyboardOpened = false;
                        this.setContainerHeight(`${100 + this.iosMeasureUnit}`)
                    }
                }
                if (!Qz.isEditorLoaded()) {
                    const t = Rz.newListener("onLoad", (() => {
                        this.contentManager.onOpen(this)
                    }));
                    this.contentManager.addListener(t)
                } else {
                    this.contentManager.onOpen(this)
                }
            }

            close() {
                this.removeClass("wrs_maximized");
                this.removeClass("wrs_minimized");
                this.removeClass("wrs_stack");
                this.addClass("wrs_closed");
                this.saveModalProperties();
                this.unlockWebsiteScroll();
                this.properties.open = false
            }

            restoreWebsiteScale() {
                let t = document.querySelector("meta[name=viewport]");
                const e = ["initial-scale=", "minimum-scale=", "maximum-scale="];
                const n = ["1.0", "1.0", "1.0"];
                const i = (t, e) => {
                    const i = t.getAttribute("content");
                    if (i) {
                        const o = i.split(",");
                        let r = "";
                        const s = [];
                        for (let t = 0; t < o.length; t += 1) {
                            let n = false;
                            let i = 0;
                            while (!n && i < e.length) {
                                if (o[t].indexOf(e[i])) {
                                    n = true
                                }
                                i += 1
                            }
                            if (!n) {
                                s.push(o[t])
                            }
                        }
                        for (let t = 0; t < e.length; t += 1) {
                            const i = e[t] + n[t];
                            r += t === 0 ? i : `,${i}`
                        }
                        for (let t = 0; t < s.length; t += 1) {
                            r += `,${s[t]}`
                        }
                        t.setAttribute("content", r);
                        t.setAttribute("content", "");
                        t.setAttribute("content", i)
                    } else {
                        t.setAttribute("content", "initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0");
                        t.removeAttribute("content")
                    }
                };
                if (!t) {
                    t = document.createElement("meta");
                    document.getElementsByTagName("head")[0].appendChild(t);
                    i(t, e, n);
                    t.remove()
                } else {
                    i(t, e, n)
                }
            }

            lockWebsiteScroll() {
                this.websiteBeforeLockParameters = {
                    bodyStylePosition: document.body.style.position ? document.body.style.position : "",
                    bodyStyleOverflow: document.body.style.overflow ? document.body.style.overflow : "",
                    htmlStyleOverflow: document.documentElement.style.overflow ? document.documentElement.style.overflow : "",
                    windowScrollX: window.scrollX,
                    windowScrollY: window.scrollY
                }
            }

            unlockWebsiteScroll() {
                if (this.websiteBeforeLockParameters) {
                    document.body.style.position = this.websiteBeforeLockParameters.bodyStylePosition;
                    document.body.style.overflow = this.websiteBeforeLockParameters.bodyStyleOverflow;
                    document.documentElement.style.overflow = this.websiteBeforeLockParameters.htmlStyleOverflow;
                    const {windowScrollX: t} = this.websiteBeforeLockParameters;
                    const {windowScrollY: e} = this.websiteBeforeLockParameters;
                    window.scrollTo(t, e);
                    this.websiteBeforeLockParameters = null
                }
            }

            isIE11() {
                if (navigator.userAgent.search("Msie/") >= 0 || navigator.userAgent.search("Trident/") >= 0 || navigator.userAgent.search("Edge/") >= 0) {
                    return true
                }
                return false
            }

            isRTL() {
                if (this.attributes.language === "ar" || this.attributes.language === "he") {
                    return true
                }
                return this.rtl
            }

            addClass(t) {
                Wz.addClass(this.overlay, t);
                Wz.addClass(this.titleBar, t);
                Wz.addClass(this.overlay, t);
                Wz.addClass(this.container, t);
                Wz.addClass(this.contentContainer, t);
                Wz.addClass(this.stackDiv, t);
                Wz.addClass(this.minimizeDiv, t);
                Wz.addClass(this.maximizeDiv, t);
                Wz.addClass(this.wrapper, t)
            }

            removeClass(t) {
                Wz.removeClass(this.overlay, t);
                Wz.removeClass(this.titleBar, t);
                Wz.removeClass(this.overlay, t);
                Wz.removeClass(this.container, t);
                Wz.removeClass(this.contentContainer, t);
                Wz.removeClass(this.stackDiv, t);
                Wz.removeClass(this.minimizeDiv, t);
                Wz.removeClass(this.maximizeDiv, t);
                Wz.removeClass(this.wrapper, t)
            }

            createModalWindowDesktop() {
                this.addClass("wrs_modal_desktop");
                this.stack()
            }

            createModalWindowAndroid() {
                this.addClass("wrs_modal_android");
                window.addEventListener("resize", this.orientationChangeAndroidSoftkeyboard.bind(this))
            }

            createModalWindowIos() {
                this.addClass("wrs_modal_ios");
                window.addEventListener("resize", this.orientationChangeIosSoftkeyboard.bind(this))
            }

            restoreState() {
                if (this.properties.state === "maximized") {
                    this.maximize()
                } else if (this.properties.state === "minimized") {
                    this.properties.state = this.properties.previousState;
                    this.properties.previousState = "";
                    this.minimize()
                } else {
                    this.stack()
                }
            }

            stack() {
                this.properties.previousState = this.properties.state;
                this.properties.state = "stack";
                this.removeClass("wrs_maximized");
                this.minimizeDiv.title = Uz.get("minimize");
                this.removeClass("wrs_minimized");
                this.addClass("wrs_stack");
                const t = `background-size: 10px; background-repeat: no-repeat; background-image: url(data:image/svg+xml;base64,${window.btoa(sN)})`;
                const e = `background-size: 10px; background-repeat: no-repeat; background-image: url(data:image/svg+xml;base64,${window.btoa(aN)})`;
                this.minimizeDiv.setAttribute("style", t);
                this.minimizeDiv.setAttribute("onmouseover", `this.style = "${e}";`);
                this.minimizeDiv.setAttribute("onmouseout", `this.style = "${t}";`);
                this.restoreModalProperties();
                if (typeof this.resizerBR !== "undefined" && typeof this.resizerTL !== "undefined") {
                    this.setResizeButtonsVisibility()
                }
                this.recalculateScrollBar();
                this.recalculatePosition();
                this.recalculateScale();
                this.focus()
            }

            minimize() {
                this.saveModalProperties();
                this.title.style.cursor = "pointer";
                if (this.properties.state === "minimized" && this.properties.previousState === "stack") {
                    this.stack()
                } else if (this.properties.state === "minimized" && this.properties.previousState === "maximized") {
                    this.maximize()
                } else {
                    this.container.style.height = "30px";
                    this.container.style.width = "250px";
                    this.container.style.bottom = "0px";
                    this.container.style.right = "10px";
                    this.removeListeners();
                    this.properties.previousState = this.properties.state;
                    this.properties.state = "minimized";
                    this.setResizeButtonsVisibility();
                    this.minimizeDiv.title = Uz.get("maximize");
                    if (Wz.containsClass(this.overlay, "wrs_stack")) {
                        this.removeClass("wrs_stack")
                    } else {
                        this.removeClass("wrs_maximized")
                    }
                    this.addClass("wrs_minimized");
                    const t = `background-size: 10px; background-repeat: no-repeat; background-image: url(data:image/svg+xml;base64,${window.btoa(dN)})`;
                    const e = `background-size: 10px; background-repeat: no-repeat; background-image: url(data:image/svg+xml;base64,${window.btoa(uN)})`;
                    this.minimizeDiv.setAttribute("style", t);
                    this.minimizeDiv.setAttribute("onmouseover", `this.style = "${e}";`);
                    this.minimizeDiv.setAttribute("onmouseout", `this.style = "${t}";`)
                }
            }

            maximize() {
                this.saveModalProperties();
                if (this.properties.state !== "maximized") {
                    this.properties.previousState = this.properties.state;
                    this.properties.state = "maximized"
                }
                this.setResizeButtonsVisibility();
                if (Wz.containsClass(this.overlay, "wrs_minimized")) {
                    this.minimizeDiv.title = Uz.get("minimize");
                    this.removeClass("wrs_minimized")
                } else if (Wz.containsClass(this.overlay, "wrs_stack")) {
                    this.container.style.left = null;
                    this.container.style.top = null;
                    this.removeClass("wrs_stack")
                }
                this.addClass("wrs_maximized");
                const t = `background-size: 10px; background-repeat: no-repeat; background-image: url(data:image/svg+xml;base64,${window.btoa(sN)})`;
                const e = `background-size: 10px; background-repeat: no-repeat; background-image: url(data:image/svg+xml;base64,${window.btoa(aN)})`;
                this.minimizeDiv.setAttribute("style", t);
                this.minimizeDiv.setAttribute("onmouseover", `this.style = "${e}";`);
                this.minimizeDiv.setAttribute("onmouseout", `this.style = "${t}";`);
                this.setSize(parseInt(window.innerHeight * .8, 10), parseInt(window.innerWidth * .8, 10));
                if (this.container.clientHeight > 700) {
                    this.container.style.height = "700px"
                }
                if (this.container.clientWidth > 1200) {
                    this.container.style.width = "1200px"
                }
                const {innerHeight: n} = window;
                const {innerWidth: i} = window;
                const {offsetHeight: o} = this.container;
                const {offsetWidth: r} = this.container;
                const s = n / 2 - o / 2;
                const a = i / 2 - r / 2;
                this.setPosition(s, a);
                this.recalculateScale();
                this.recalculatePosition();
                this.recalculateSize();
                this.focus()
            }

            reExpand() {
                if (this.properties.state === "minimized") {
                    if (this.properties.previousState === "maximized") {
                        this.maximize()
                    } else {
                        this.stack()
                    }
                    this.title.style.cursor = ""
                }
            }

            setSize(t, e) {
                this.container.style.height = `${t}px`;
                this.container.style.width = `${e}px`;
                this.recalculateSize()
            }

            setPosition(t, e) {
                this.container.style.bottom = `${t}px`;
                this.container.style.right = `${e}px`
            }

            saveModalProperties() {
                if (this.properties.state === "stack") {
                    this.properties.position.bottom = parseInt(this.container.style.bottom, 10);
                    this.properties.position.right = parseInt(this.container.style.right, 10);
                    this.properties.size.width = parseInt(this.container.style.width, 10);
                    this.properties.size.height = parseInt(this.container.style.height, 10)
                }
            }

            restoreModalProperties() {
                if (this.properties.state === "stack") {
                    this.setPosition(this.properties.position.bottom, this.properties.position.right);
                    this.setSize(this.properties.size.height, this.properties.size.width)
                }
            }

            recalculateSize() {
                this.wrapper.style.width = `${this.container.clientWidth - 12}px`;
                this.wrapper.style.height = `${this.container.clientHeight - 38}px`;
                this.contentContainer.style.height = `${parseInt(this.wrapper.offsetHeight - 50, 10)}px`
            }

            setResizeButtonsVisibility() {
                if (this.properties.state === "stack") {
                    this.resizerTL.style.visibility = "visible";
                    this.resizerBR.style.visibility = "visible"
                } else {
                    this.resizerTL.style.visibility = "hidden";
                    this.resizerBR.style.visibility = "hidden"
                }
            }

            addListeners() {
                this.maximizeDiv.addEventListener("click", this.maximize.bind(this), true);
                this.stackDiv.addEventListener("click", this.stack.bind(this), true);
                this.minimizeDiv.addEventListener("click", this.minimize.bind(this), true);
                this.closeDiv.addEventListener("click", this.cancelAction.bind(this));
                this.title.addEventListener("click", this.reExpand.bind(this));
                this.overlay.addEventListener("click", this.cancelAction.bind(this));
                Wz.addEvent(window, "mousedown", this.startDrag.bind(this));
                Wz.addEvent(window, "mouseup", this.stopDrag.bind(this));
                Wz.addEvent(window, "mousemove", this.drag.bind(this));
                Wz.addEvent(window, "resize", this.onWindowResize.bind(this));
                Wz.addEvent(this.container, "keydown", this.onKeyDown.bind(this))
            }

            removeListeners() {
                Wz.removeEvent(window, "mousedown", this.startDrag);
                Wz.removeEvent(window, "mouseup", this.stopDrag);
                Wz.removeEvent(window, "mousemove", this.drag);
                Wz.removeEvent(window, "resize", this.onWindowResize);
                Wz.removeEvent(this.container, "keydown", this.onKeyDown)
            }

            eventClient(t) {
                if (typeof t.clientX === "undefined" && t.changedTouches) {
                    const e = {X: t.changedTouches[0].clientX, Y: t.changedTouches[0].clientY};
                    return e
                }
                const e = {X: t.clientX, Y: t.clientY};
                return e
            }

            startDrag(t) {
                if (this.properties.state === "minimized") {
                    return
                }
                if (t.target === this.title) {
                    if (typeof this.dragDataObject === "undefined" || this.dragDataObject === null) {
                        this.dragDataObject = {x: this.eventClient(t).X, y: this.eventClient(t).Y};
                        this.lastDrag = {x: "0px", y: "0px"};
                        if (this.container.style.right === "") {
                            this.container.style.right = "0px"
                        }
                        if (this.container.style.bottom === "") {
                            this.container.style.bottom = "0px"
                        }
                        if (this.isIE11()) {
                        }
                        Wz.addClass(document.body, "wrs_noselect");
                        Wz.addClass(this.overlay, "wrs_overlay_active");
                        this.limitWindow = this.getLimitWindow()
                    }
                }
            }

            drag(t) {
                if (this.dragDataObject) {
                    t.preventDefault();
                    let e = Math.min(this.eventClient(t).Y, this.limitWindow.minPointer.y);
                    e = Math.max(this.limitWindow.maxPointer.y, e);
                    let n = Math.min(this.eventClient(t).X, this.limitWindow.minPointer.x);
                    n = Math.max(this.limitWindow.maxPointer.x, n);
                    const i = `${n - this.dragDataObject.x}px`;
                    const o = `${e - this.dragDataObject.y}px`;
                    this.lastDrag = {x: i, y: o};
                    this.container.style.transform = `translate3d(${i},${o},0)`
                }
                if (this.resizeDataObject) {
                    const {innerWidth: e} = window;
                    const {innerHeight: n} = window;
                    let i = Math.min(this.eventClient(t).X, e - this.scrollbarWidth - 7);
                    let o = Math.min(this.eventClient(t).Y, n - 7);
                    if (i < 0) {
                        i = 0
                    }
                    if (o < 0) {
                        o = 0
                    }
                    let r;
                    if (this.leftScale) {
                        r = -1
                    } else {
                        r = 1
                    }
                    this.container.style.width = `${this.initialWidth + r * (i - this.resizeDataObject.x)}px`;
                    this.container.style.height = `${this.initialHeight + r * (o - this.resizeDataObject.y)}px`;
                    if (!this.leftScale) {
                        if (this.resizeDataObject.x - i - this.initialWidth < -580) {
                            this.container.style.right = `${this.initialRight - (i - this.resizeDataObject.x)}px`
                        } else {
                            this.container.style.right = `${this.initialRight + this.initialWidth - 580}px`;
                            this.container.style.width = "580px"
                        }
                        if (this.resizeDataObject.y - o < this.initialHeight - 338) {
                            this.container.style.bottom = `${this.initialBottom - (o - this.resizeDataObject.y)}px`
                        } else {
                            this.container.style.bottom = `${this.initialBottom + this.initialHeight - 338}px`;
                            this.container.style.height = "338px"
                        }
                    }
                    this.recalculateScale();
                    this.recalculatePosition()
                }
            }

            getLimitWindow() {
                const t = window.innerWidth;
                const e = window.innerHeight;
                const {offsetHeight: n} = this.container;
                const i = parseInt(this.container.style.bottom, 10);
                const o = parseInt(this.container.style.right, 10);
                const {pageXOffset: r} = window;
                const s = this.dragDataObject.y;
                const a = this.dragDataObject.x;
                const c = n + i - (e - (s - r));
                const l = t - this.scrollbarWidth - (a - r) - o;
                const d = e - this.container.offsetHeight + c;
                const u = this.title.offsetHeight - (this.title.offsetHeight - c);
                const h = t - l - this.scrollbarWidth;
                const m = this.container.offsetWidth - l;
                const g = {x: h, y: d};
                const f = {x: m, y: u};
                return {minPointer: g, maxPointer: f}
            }

            getScrollBarWidth() {
                const t = document.createElement("p");
                t.style.width = "100%";
                t.style.height = "200px";
                const e = document.createElement("div");
                e.style.position = "absolute";
                e.style.top = "0px";
                e.style.left = "0px";
                e.style.visibility = "hidden";
                e.style.width = "200px";
                e.style.height = "150px";
                e.style.overflow = "hidden";
                e.appendChild(t);
                document.body.appendChild(e);
                const n = t.offsetWidth;
                e.style.overflow = "scroll";
                let i = t.offsetWidth;
                if (n === i) {
                    i = e.clientWidth
                }
                document.body.removeChild(e);
                return n - i
            }

            stopDrag() {
                if (this.dragDataObject || this.resizeDataObject) {
                    this.container.style.transform = "";
                    if (this.dragDataObject) {
                        this.container.style.right = `${parseInt(this.container.style.right, 10) - parseInt(this.lastDrag.x, 10)}px`;
                        this.container.style.bottom = `${parseInt(this.container.style.bottom, 10) - parseInt(this.lastDrag.y, 10)}px`
                    }
                    this.focus();
                    document.body.style["user-select"] = "";
                    if (this.isIE11()) {
                    }
                    Wz.removeClass(document.body, "wrs_noselect");
                    Wz.removeClass(this.overlay, "wrs_overlay_active")
                }
                this.dragDataObject = null;
                this.resizeDataObject = null;
                this.initialWidth = null;
                this.leftScale = null
            }

            onWindowResize() {
                this.recalculateScrollBar();
                this.recalculatePosition();
                this.recalculateScale()
            }

            onKeyDown(t) {
                if (t.key !== undefined) {
                    if (this.popup.overlayWrapper.style.display !== "block") {
                        if (t.key === "Escape" || t.key === "Esc") {
                            if (this.properties.open) {
                                this.contentManager.onKeyDown(t)
                            }
                        } else if (t.shiftKey && t.key === "Tab") {
                            if (document.activeElement === this.cancelButton) {
                                this.submitButton.focus();
                                t.stopPropagation();
                                t.preventDefault()
                            } else {
                                this.contentManager.onKeyDown(t)
                            }
                        } else if (t.key === "Tab") {
                            if (document.activeElement === this.submitButton) {
                                this.cancelButton.focus();
                                t.stopPropagation();
                                t.preventDefault()
                            } else {
                                this.contentManager.onKeyDown(t)
                            }
                        }
                    } else {
                        this.popup.onKeyDown(t)
                    }
                }
            }

            recalculatePosition() {
                this.container.style.right = `${Math.min(parseInt(this.container.style.right, 10), window.innerWidth - this.scrollbarWidth - this.container.offsetWidth)}px`;
                if (parseInt(this.container.style.right, 10) < 0) {
                    this.container.style.right = "0px"
                }
                this.container.style.bottom = `${Math.min(parseInt(this.container.style.bottom, 10), window.innerHeight - this.container.offsetHeight)}px`;
                if (parseInt(this.container.style.bottom, 10) < 0) {
                    this.container.style.bottom = "0px"
                }
            }

            recalculateScale() {
                let t = false;
                if (parseInt(this.container.style.width, 10) > 580) {
                    this.container.style.width = `${Math.min(parseInt(this.container.style.width, 10), window.innerWidth - this.scrollbarWidth)}px`;
                    t = true
                } else {
                    this.container.style.width = "580px";
                    t = true
                }
                if (parseInt(this.container.style.height, 10) > 338) {
                    this.container.style.height = `${Math.min(parseInt(this.container.style.height, 10), window.innerHeight)}px`;
                    t = true
                } else {
                    this.container.style.height = "338px";
                    t = true
                }
                if (t) {
                    this.recalculateSize()
                }
            }

            recalculateScrollBar() {
                this.hasScrollBar = window.innerWidth > document.documentElement.clientWidth;
                if (this.hasScrollBar) {
                    this.scrollbarWidth = this.getScrollBarWidth()
                } else {
                    this.scrollbarWidth = 0
                }
            }

            hideKeyboard() {
                const t = document.createElement("input");
                this.container.appendChild(t);
                t.focus();
                t.blur();
                t.remove()
            }

            focus() {
                if (this.contentManager != null && typeof this.contentManager.onFocus !== "undefined") {
                    this.contentManager.onFocus()
                }
            }

            portraitMode() {
                return window.innerHeight > window.innerWidth
            }

            handleOpenedIosSoftkeyboard() {
                if (!this.iosSoftkeyboardOpened && this.iosDivHeight != null && this.iosDivHeight === `100${this.iosMeasureUnit}`) {
                    if (this.portraitMode()) {
                        this.setContainerHeight(`63${this.iosMeasureUnit}`)
                    } else {
                        this.setContainerHeight(`40${this.iosMeasureUnit}`)
                    }
                }
                this.iosSoftkeyboardOpened = true
            }

            handleClosedIosSoftkeyboard() {
                this.iosSoftkeyboardOpened = false;
                this.setContainerHeight(`100${this.iosMeasureUnit}`)
            }

            orientationChangeIosSoftkeyboard() {
                if (this.iosSoftkeyboardOpened) {
                    if (this.portraitMode()) {
                        this.setContainerHeight(`63${this.iosMeasureUnit}`)
                    } else {
                        this.setContainerHeight(`40${this.iosMeasureUnit}`)
                    }
                } else {
                    this.setContainerHeight(`100${this.iosMeasureUnit}`)
                }
            }

            orientationChangeAndroidSoftkeyboard() {
                this.setContainerHeight("100%")
            }

            setContainerHeight(t) {
                this.iosDivHeight = t;
                this.wrapper.style.height = t
            }

            showPopUpMessage() {
                if (this.properties.state === "minimized") {
                    this.stack()
                }
                this.popup.show()
            }

            setTitle(t) {
                this.title.innerHTML = t
            }

            getElementId(t) {
                return `${t}[${this.instanceId}]`
            }
        }

        var mN;
        var gN = mN;
        /*! http://mths.be/codepointat v0.1.0 by @mathias */
        if (!String.prototype.codePointAt) {
            (function () {
                "use strict";
                var t = function (t) {
                    if (this == null) {
                        throw TypeError()
                    }
                    var e = String(this);
                    var n = e.length;
                    var i = t ? Number(t) : 0;
                    if (i != i) {
                        i = 0
                    }
                    if (i < 0 || i >= n) {
                        return undefined
                    }
                    var o = e.charCodeAt(i);
                    var r;
                    if (o >= 55296 && o <= 56319 && n > i + 1) {
                        r = e.charCodeAt(i + 1);
                        if (r >= 56320 && r <= 57343) {
                            return (o - 55296) * 1024 + r - 56320 + 65536
                        }
                    }
                    return o
                };
                if (Object.defineProperty) {
                    Object.defineProperty(String.prototype, "codePointAt", {
                        value: t,
                        configurable: true,
                        writable: true
                    })
                } else {
                    String.prototype.codePointAt = t
                }
            })()
        }
        if (typeof Object.assign != "function") {
            Object.defineProperty(Object, "assign", {
                value: function t(e, n) {
                    "use strict";
                    if (e == null) {
                        throw new TypeError("Cannot convert undefined or null to object")
                    }
                    var i = Object(e);
                    for (var o = 1; o < arguments.length; o++) {
                        var r = arguments[o];
                        if (r != null) {
                            for (var s in r) {
                                if (Object.prototype.hasOwnProperty.call(r, s)) {
                                    i[s] = r[s]
                                }
                            }
                        }
                    }
                    return i
                }, writable: true, configurable: true
            })
        }
        var fN = n(62);
        var pN = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        pN.insert = "head";
        pN.singleton = true;
        var bN = ob()(fN["a"], pN);
        var kN = fN["a"].locals || {};

        class wN {
            constructor(t) {
                this.language = "en";
                this.editMode = "images";
                this.modalDialog = null;
                this.customEditors = new Jz;
                const e = {
                    name: "Chemistry",
                    toolbar: "chemistry",
                    icon: "chem.png",
                    confVariable: "chemEnabled",
                    title: "ChemType",
                    tooltip: "Insert a chemistry formula - ChemType"
                };
                this.customEditors.addEditor("chemistry", e);
                this.environment = {};
                this.editionProperties = {};
                this.editionProperties.isNewElement = true;
                this.editionProperties.temporalImage = null;
                this.editionProperties.latexRange = null;
                this.editionProperties.range = null;
                this.integrationModel = null;
                this.contentManager = null;
                this.browser = (() => {
                    const t = navigator.userAgent;
                    let e = "none";
                    if (t.search("Edge/") >= 0) {
                        e = "EDGE"
                    } else if (t.search("Chrome/") >= 0) {
                        e = "CHROME"
                    } else if (t.search("Trident/") >= 0) {
                        e = "IE"
                    } else if (t.search("Firefox/") >= 0) {
                        e = "FIREFOX"
                    } else if (t.search("Safari/") >= 0) {
                        e = "SAFARI"
                    }
                    return e
                })();
                this.listeners = new Rz;
                this.serviceProviderProperties = {};
                if ("serviceProviderProperties" in t) {
                    this.serviceProviderProperties = t.serviceProviderProperties
                } else {
                    throw new Error("serviceProviderProperties property missing.")
                }
            }

            static get globalListeners() {
                return wN._globalListeners
            }

            static set globalListeners(t) {
                wN._globalListeners = t
            }

            static get initialized() {
                return wN._initialized
            }

            static set initialized(t) {
                wN._initialized = t
            }

            setIntegrationModel(t) {
                this.integrationModel = t
            }

            setEnvironment(t) {
                if ("editor" in t) {
                    this.environment.editor = t.editor
                }
                if ("mode" in t) {
                    this.environment.mode = t.mode
                }
                if ("version" in t) {
                    this.environment.version = t.version
                }
            }

            getModalDialog() {
                return this.modalDialog
            }

            init() {
                if (!wN.initialized) {
                    const t = Rz.newListener("onInit", (() => {
                        const t = Fz.getService("configurationjs", "", "get");
                        const e = JSON.parse(t);
                        Oz.addConfiguration(e);
                        Oz.addConfiguration(Zz);
                        Uz.language = this.language;
                        this.listeners.fire("onLoad", {})
                    }));
                    Fz.addListener(t);
                    Fz.init(this.serviceProviderProperties);
                    wN.initialized = true
                } else {
                    this.listeners.fire("onLoad", {})
                }
            }

            addListener(t) {
                this.listeners.add(t)
            }

            static addGlobalListener(t) {
                wN.globalListeners.add(t)
            }

            beforeUpdateFormula(t, e) {
                const n = new tN;
                n.mathml = t;
                n.wirisProperties = {};
                if (e != null) {
                    Object.keys(e).forEach((t => {
                        n.wirisProperties[t] = e[t]
                    }))
                }
                n.language = this.language;
                n.editMode = this.editMode;
                if (this.listeners.fire("onBeforeFormulaInsertion", n)) {
                    return {}
                }
                if (wN.globalListeners.fire("onBeforeFormulaInsertion", n)) {
                    return {}
                }
                return {mathml: n.mathml, wirisProperties: n.wirisProperties}
            }

            insertFormula(t, e, n, i) {
                const o = {};
                if (!n) {
                    this.insertElementOnSelection(null, t, e)
                } else if (this.editMode === "latex") {
                    o.latex = Vz.getLatexFromMathML(n);
                    if (!!this.integrationModel.fillNonLatexNode && !o.latex) {
                        const i = new tN;
                        i.editMode = this.editMode;
                        i.windowTarget = e;
                        i.focusElement = t;
                        i.latex = o.latex;
                        this.integrationModel.fillNonLatexNode(i, e, n)
                    } else {
                        o.node = e.document.createTextNode(`$$${o.latex}$$`)
                    }
                    this.insertElementOnSelection(o.node, t, e)
                } else {
                    o.node = $z.mathmlToImgObject(e.document, n, i, this.language);
                    this.insertElementOnSelection(o.node, t, e)
                }
                return o
            }

            afterUpdateFormula(t, e, n, i) {
                const o = new tN;
                o.editMode = this.editMode;
                o.windowTarget = e;
                o.focusElement = t;
                o.node = n;
                o.latex = i;
                if (this.listeners.fire("onAfterFormulaInsertion", o)) {
                    return {}
                }
                if (wN.globalListeners.fire("onAfterFormulaInsertion", o)) {
                    return {}
                }
                return {}
            }

            placeCaretAfterNode(t) {
                this.integrationModel.getSelection();
                const e = t.ownerDocument;
                if (typeof e.getSelection !== "undefined" && !!t.parentElement) {
                    const n = e.createRange();
                    n.setStartAfter(t);
                    n.collapse(true);
                    const i = e.getSelection();
                    i.removeAllRanges();
                    i.addRange(n);
                    e.body.focus()
                }
            }

            insertElementOnSelection(t, e, n) {
                if (this.editionProperties.isNewElement) {
                    if (t) {
                        if (e.type === "textarea") {
                            Wz.updateTextArea(e, t.textContent)
                        } else if (document.selection && document.getSelection === 0) {
                            let e = n.document.selection.createRange();
                            n.document.execCommand("InsertImage", false, t.src);
                            if (!("parentElement" in e)) {
                                n.document.execCommand("delete", false);
                                e = n.document.selection.createRange();
                                n.document.execCommand("InsertImage", false, t.src)
                            }
                            if ("parentElement" in e) {
                                const n = e.parentElement();
                                if (n.nodeName.toUpperCase() === "IMG") {
                                    n.parentNode.replaceChild(t, n)
                                } else {
                                    e.pasteHTML(Wz.createObjectCode(t))
                                }
                            }
                        } else {
                            const e = this.integrationModel.getSelection();
                            let n = null;
                            if (this.editionProperties.range) {
                                ({range: n} = this.editionProperties);
                                this.editionProperties.range = null
                            } else {
                                n = e.getRangeAt(0)
                            }
                            n.deleteContents();
                            let i = n.startContainer;
                            const o = n.startOffset;
                            if (i.nodeType === 3) {
                                i = i.splitText(o);
                                i.parentNode.insertBefore(t, i)
                            } else if (i.nodeType === 1) {
                                i.insertBefore(t, i.childNodes[o])
                            }
                            this.placeCaretAfterNode(t)
                        }
                    } else if (e.type === "textarea") {
                        e.focus()
                    } else {
                        const t = this.integrationModel.getSelection();
                        t.removeAllRanges();
                        if (this.editionProperties.range) {
                            const {range: e} = this.editionProperties;
                            this.editionProperties.range = null;
                            t.addRange(e)
                        }
                    }
                } else if (this.editionProperties.latexRange) {
                    if (document.selection && document.getSelection === 0) {
                        this.editionProperties.isNewElement = true;
                        this.editionProperties.latexRange.select();
                        this.insertElementOnSelection(t, e, n)
                    } else {
                        this.editionProperties.latexRange.deleteContents();
                        this.editionProperties.latexRange.insertNode(t);
                        this.placeCaretAfterNode(t)
                    }
                } else if (e.type === "textarea") {
                    let n;
                    if (typeof this.integrationModel.getSelectedItem !== "undefined") {
                        n = this.integrationModel.getSelectedItem(e, false)
                    } else {
                        n = Wz.getSelectedItemOnTextarea(e)
                    }
                    Wz.updateExistingTextOnTextarea(e, t.textContent, n.startPosition, n.endPosition)
                } else {
                    if (t && t.nodeName.toLowerCase() === "img") {
                        qz.removeImgDataAttributes(this.editionProperties.temporalImage);
                        qz.clone(t, this.editionProperties.temporalImage)
                    } else {
                        this.editionProperties.temporalImage.remove()
                    }
                    this.placeCaretAfterNode(this.editionProperties.temporalImage)
                }
            }

            openModalDialog(t, e) {
                this.editMode = "images";
                try {
                    if (e) {
                        t.contentWindow.focus();
                        const e = t.contentWindow.getSelection();
                        this.editionProperties.range = e.getRangeAt(0)
                    } else {
                        t.focus();
                        const e = getSelection();
                        this.editionProperties.range = e.getRangeAt(0)
                    }
                } catch (t) {
                    this.editionProperties.range = null
                }
                if (e === undefined) {
                    e = true
                }
                this.editionProperties.latexRange = null;
                if (t) {
                    let n;
                    if (typeof this.integrationModel.getSelectedItem !== "undefined") {
                        n = this.integrationModel.getSelectedItem(t, e)
                    } else {
                        n = Wz.getSelectedItem(t, e)
                    }
                    if (n) {
                        if (!n.caretPosition && Wz.containsClass(n.node, Oz.get("imageClassName"))) {
                            this.editionProperties.temporalImage = n.node;
                            this.editionProperties.isNewElement = false
                        } else if (n.node.nodeType === 3) {
                            if (this.integrationModel.getMathmlFromTextNode) {
                                const t = this.integrationModel.getMathmlFromTextNode(n.node, n.caretPosition);
                                if (t) {
                                    this.editMode = "latex";
                                    this.editionProperties.isNewElement = false;
                                    this.editionProperties.temporalImage = document.createElement("img");
                                    this.editionProperties.temporalImage.setAttribute(Oz.get("imageMathmlAttribute"), Pz.safeXmlEncode(t))
                                }
                            } else {
                                const i = Vz.getLatexFromTextNode(n.node, n.caretPosition);
                                if (i) {
                                    const n = Vz.getMathMLFromLatex(i.latex);
                                    this.editMode = "latex";
                                    this.editionProperties.isNewElement = false;
                                    this.editionProperties.temporalImage = document.createElement("img");
                                    this.editionProperties.temporalImage.setAttribute(Oz.get("imageMathmlAttribute"), Pz.safeXmlEncode(n));
                                    const o = e ? t.contentWindow : window;
                                    if (t.tagName.toLowerCase() !== "textarea") {
                                        if (document.selection) {
                                            let t = 0;
                                            let e = i.startNode.previousSibling;
                                            while (e) {
                                                t += Wz.getNodeLength(e);
                                                e = e.previousSibling
                                            }
                                            this.editionProperties.latexRange = o.document.selection.createRange();
                                            this.editionProperties.latexRange.moveToElementText(i.startNode.parentNode);
                                            this.editionProperties.latexRange.move("character", t + i.startPosition);
                                            this.editionProperties.latexRange.moveEnd("character", i.latex.length + 4)
                                        } else {
                                            this.editionProperties.latexRange = o.document.createRange();
                                            this.editionProperties.latexRange.setStart(i.startNode, i.startPosition);
                                            this.editionProperties.latexRange.setEnd(i.endNode, i.endPosition)
                                        }
                                    }
                                }
                            }
                        }
                    } else if (t.tagName.toLowerCase() === "textarea") {
                        this.editMode = "latex"
                    }
                }
                const n = Oz.get("editorAttributes").split(", ");
                const i = {};
                for (let t = 0, e = n.length; t < e; t += 1) {
                    const e = n[t].split("=");
                    const o = e[0];
                    const r = e[1];
                    i[o] = r
                }
                const o = {};
                const r = Oz.get("editorParameters");
                const s = this.integrationModel.editorParameters;
                Object.assign(o, i, r);
                Object.assign(o, i, s);
                o.language = this.language;
                o.rtl = this.integrationModel.rtl;
                const a = {};
                a.editorAttributes = o;
                a.language = this.language;
                a.customEditors = this.customEditors;
                a.environment = this.environment;
                if (this.modalDialog == null) {
                    this.modalDialog = new hN(o);
                    this.contentManager = new Qz(a);
                    const t = Rz.newListener("onLoad", (() => {
                        this.contentManager.isNewElement = this.editionProperties.isNewElement;
                        if (this.editionProperties.temporalImage != null) {
                            const t = Pz.safeXmlDecode(this.editionProperties.temporalImage.getAttribute(Oz.get("imageMathmlAttribute")));
                            this.contentManager.mathML = t
                        }
                    }));
                    this.contentManager.addListener(t);
                    this.contentManager.init();
                    this.modalDialog.setContentManager(this.contentManager);
                    this.contentManager.setModalDialogInstance(this.modalDialog)
                } else {
                    this.contentManager.isNewElement = this.editionProperties.isNewElement;
                    if (this.editionProperties.temporalImage != null) {
                        const t = Pz.safeXmlDecode(this.editionProperties.temporalImage.getAttribute(Oz.get("imageMathmlAttribute")));
                        this.contentManager.mathML = t
                    }
                }
                this.contentManager.setIntegrationModel(this.integrationModel);
                this.modalDialog.open()
            }

            getCustomEditors() {
                return this.customEditors
            }
        }

        wN._globalListeners = new Rz;
        wN._initialized = false;

        class AN {
            constructor(t) {
                this.language = "en";
                this.serviceProviderProperties = {};
                if ("serviceProviderProperties" in t) {
                    this.serviceProviderProperties = t.serviceProviderProperties
                }
                this.configurationService = "";
                if ("configurationService" in t) {
                    this.serviceProviderProperties.URI = t.configurationService;
                    console.warn("Deprecated property configurationService. Use serviceParameters on instead.", [t.configurationService])
                }
                this.version = "version" in t ? t.version : "";
                this.target = null;
                if ("target" in t) {
                    this.target = t.target
                } else {
                    throw new Error("IntegrationModel constructor error: target property missed.")
                }
                if ("scriptName" in t) {
                    this.scriptName = t.scriptName
                }
                this.callbackMethodArguments = {};
                if ("callbackMethodArguments" in t) {
                    this.callbackMethodArguments = t.callbackMethodArguments
                }
                this.environment = {};
                if ("environment" in t) {
                    this.environment = t.environment
                }
                this.isIframe = false;
                if (this.target != null) {
                    this.isIframe = this.target.tagName.toUpperCase() === "IFRAME"
                }
                this.editorObject = null;
                if ("editorObject" in t) {
                    this.editorObject = t.editorObject
                }
                this.rtl = false;
                if ("rtl" in t) {
                    this.rtl = t.rtl
                }
                this.managesLanguage = false;
                if ("managesLanguage" in t) {
                    this.managesLanguage = t.managesLanguage
                }
                this.temporalImageResizing = false;
                this.core = null;
                this.listeners = new Rz;
                if ("integrationParameters" in t) {
                    AN.integrationParameters.forEach((e => {
                        if (e in t.integrationParameters) {
                            const n = t.integrationParameters[e];
                            if (Object.keys(n).length !== 0) {
                                this[e] = n
                            }
                        }
                    }))
                }
            }

            init() {
                this.language = this.getLanguage();
                const t = Rz.newListener("onLoad", (() => {
                    this.callbackFunction(this.callbackMethodArguments)
                }));
                if (this.serviceProviderProperties.URI.indexOf("configuration") !== -1) {
                    const t = this.serviceProviderProperties.URI;
                    const e = Fz.getServerLanguageFromService(t);
                    this.serviceProviderProperties.server = e;
                    const n = this.serviceProviderProperties.URI.indexOf("configuration");
                    const i = this.serviceProviderProperties.URI.substring(0, n);
                    this.serviceProviderProperties.URI = i
                }
                let e = this.serviceProviderProperties.URI;
                e = e.indexOf("/") === 0 || e.indexOf("http") === 0 ? e : Wz.concatenateUrl(this.getPath(), e);
                this.serviceProviderProperties.URI = e;
                const n = {};
                n.serviceProviderProperties = this.serviceProviderProperties;
                this.setCore(new wN(n));
                this.core.addListener(t);
                this.core.language = this.language;
                this.core.init();
                this.core.setEnvironment(this.environment)
            }

            getPath() {
                if (typeof this.scriptName === "undefined") {
                    throw new Error("scriptName property needed for getPath.")
                }
                const t = document.getElementsByTagName("script");
                let e = "";
                for (let n = 0; n < t.length; n += 1) {
                    const i = t[n].src.lastIndexOf(this.scriptName);
                    if (i >= 0) {
                        e = t[n].src.substr(0, i - 1)
                    }
                }
                return e
            }

            getVersion() {
                return this.version
            }

            setLanguage(t) {
                this.language = t
            }

            setCore(t) {
                this.core = t;
                t.setIntegrationModel(this)
            }

            getCore() {
                return this.core
            }

            setTarget(t) {
                this.target = t;
                this.isIframe = this.target.tagName.toUpperCase() === "IFRAME"
            }

            setEditorObject(t) {
                this.editorObject = t
            }

            openNewFormulaEditor() {
                this.core.editionProperties.isNewElement = true;
                this.core.openModalDialog(this.target, this.isIframe)
            }

            openExistingFormulaEditor() {
                this.core.editionProperties.isNewElement = false;
                this.core.openModalDialog(this.target, this.isIframe)
            }

            updateFormula(t) {
                if (this.editorParameters) {
                    t = com.wiris.editor.util.EditorUtils.addAnnotation(t, "application/vnd.wiris.mtweb-params+json", JSON.stringify(this.editorParameters))
                }
                let e;
                let n;
                const i = null;
                if (this.isIframe) {
                    e = this.target.contentWindow;
                    n = this.target.contentWindow
                } else {
                    e = this.target;
                    n = window
                }
                let o = this.core.beforeUpdateFormula(t, i);
                if (!o) {
                    return ""
                }
                o = this.insertFormula(e, n, o.mathml, o.wirisProperties);
                if (!o) {
                    return ""
                }
                return this.core.afterUpdateFormula(o.focusElement, o.windowTarget, o.node, o.latex)
            }

            insertFormula(t, e, n, i) {
                return this.core.insertFormula(t, e, n, i)
            }

            getSelection() {
                if (this.isIframe) {
                    this.target.contentWindow.focus();
                    return this.target.contentWindow.getSelection()
                }
                this.target.focus();
                return window.getSelection()
            }

            addEvents() {
                const t = this.isIframe ? this.target.contentWindow.document : this.target;
                Wz.addElementEvents(t, ((t, e) => {
                    this.doubleClickHandler(t, e)
                }), ((t, e) => {
                    this.mousedownHandler(t, e)
                }), ((t, e) => {
                    this.mouseupHandler(t, e)
                }))
            }

            doubleClickHandler(t) {
                if (t.nodeName.toLowerCase() === "img") {
                    this.core.getCustomEditors().disable();
                    const e = Oz.get("imageCustomEditorName");
                    if (t.hasAttribute(e)) {
                        const n = t.getAttribute(e);
                        this.core.getCustomEditors().enable(n)
                    }
                    if (Wz.containsClass(t, Oz.get("imageClassName"))) {
                        this.core.editionProperties.temporalImage = t;
                        this.core.editionProperties.isNewElement = true;
                        this.openExistingFormulaEditor()
                    }
                }
            }

            mouseupHandler() {
                if (this.temporalImageResizing) {
                    setTimeout((() => {
                        qz.fixAfterResize(this.temporalImageResizing)
                    }), 10)
                }
            }

            mousedownHandler(t) {
                if (t.nodeName.toLowerCase() === "img") {
                    if (Wz.containsClass(t, Oz.get("imageClassName"))) {
                        this.temporalImageResizing = t
                    }
                }
            }

            getLanguage() {
                return this.getBrowserLanguage()
            }

            getBrowserLanguage() {
                let t = "en";
                if (navigator.userLanguage) {
                    t = navigator.userLanguage.substring(0, 2)
                } else if (navigator.language) {
                    t = navigator.language.substring(0, 2)
                } else {
                    t = "en"
                }
                return t
            }

            callbackFunction() {
                const t = Rz.newListener("onTargetReady", (() => {
                    this.addEvents(this.target)
                }));
                this.listeners.add(t)
            }

            notifyWindowClosed() {
            }

            getMathmlFromTextNode(t, e) {
            }

            fillNonLatexNode(t, e, n) {
            }

            getSelectedItem(t, e) {
            }
        }

        AN.prototype.getMathmlFromTextNode = undefined;
        AN.prototype.fillNonLatexNode = undefined;
        AN.prototype.getSelectedItem = undefined;
        AN.integrationParameters = ["serviceProviderProperties", "editorParameters"];

        class _N extends AN {
            constructor(t) {
                const e = t.editorObject;
                if (typeof e.config != "undefined" && typeof e.config.get("mathTypeParameters") != "undefined") {
                    t.integrationParameters = e.config.get("mathTypeParameters")
                }
                super(t);
                this.integrationFolderName = "ckeditor_wiris"
            }

            getLanguage() {
                const t = this.editorObject.config.get("language");
                if (typeof t === "object") {
                    if (t.hasOwnProperty("ui")) {
                        return t.ui
                    } else return "en"
                }
                return t
            }

            addEditorListeners() {
                const t = this.editorObject;
                if (typeof t.config.wirislistenersdisabled == "undefined" || !t.config.wirislistenersdisabled) {
                    this.checkElement()
                }
            }

            checkElement() {
                const t = this.editorObject;
                const e = t.sourceElement;
                if (!e.wirisActive) {
                    this.setTarget(e);
                    this.addEvents();
                    e.wirisActive = true
                }
            }

            doubleClickHandler(t, e) {
                if (t.nodeName.toLowerCase() == "img") {
                    if (Wz.containsClass(t, Oz.get("imageClassName"))) {
                        if (typeof e.stopPropagation != "undefined") {
                            e.stopPropagation()
                        } else {
                            e.returnValue = false
                        }
                        this.core.getCustomEditors().disable();
                        const n = t.getAttribute(Oz.get("imageCustomEditorName"));
                        if (n) {
                            this.core.getCustomEditors().enable(n)
                        }
                        this.core.editionProperties.temporalImage = t;
                        this.openExistingFormulaEditor()
                    }
                }
            }

            getCorePath() {
                return null
            }

            callbackFunction() {
                super.callbackFunction();
                this.addEditorListeners()
            }

            openNewFormulaEditor() {
                this.core.editionProperties.selection = this.editorObject.editing.view.document.selection;
                return super.openNewFormulaEditor()
            }

            insertMathml(t) {
                return this.editorObject.model.change((e => {
                    const n = this.getCore();
                    const i = e.createElement("mathml", {formula: t});
                    if (n.editionProperties.isNewElement) {
                        if (!t) return;
                        let n = this.core.editionProperties.selection || this.editorObject.editing.view.document.selection;
                        let o = this.editorObject.editing.mapper.toModelPosition(n.getLastPosition());
                        e.insert(i, o);
                        if (!n.isCollapsed) {
                            for (const t of n.getRanges()) {
                                e.remove(this.editorObject.editing.mapper.toModelRange(t))
                            }
                        }
                    } else {
                        const o = n.editionProperties.temporalImage;
                        const r = this.editorObject.editing.view.domConverter.domToView(o).parent;
                        const s = this.editorObject.editing.mapper.toModelElement(r);
                        const a = this.editorObject.model.createPositionBefore(s);
                        if (t) {
                            e.insert(i, a)
                        }
                        e.remove(s)
                    }
                    return i
                }))
            }

            findText(t) {
                let e = t;
                let n;
                while (!n) {
                    n = this.editorObject.editing.mapper.toModelElement(this.editorObject.editing.view.domConverter.domToView(e));
                    e = e.parentElement
                }
                const i = this.editorObject.model.createRangeIn(n);
                const o = Array.from(i.getItems());
                for (const e of o) {
                    if (e.is("textProxy") && e.data == t.data.replace(String.fromCharCode(160), " ")) {
                        return e.textNode
                    }
                }
            }

            insertFormula(t, e, n, i) {
                let o = {};
                if (!n) {
                    this.insertMathml("")
                } else if (this.core.editMode == "latex") {
                    o.latex = Vz.getLatexFromMathML(n);
                    o.node = e.document.createTextNode("$$" + o.latex + "$$");
                    this.editorObject.model.change((t => {
                        const e = this.core.editionProperties.latexRange;
                        const n = this.findText(e.startContainer);
                        const i = this.findText(e.endContainer);
                        const r = t.createPositionAt(n.parent, n.startOffset + e.startOffset);
                        const s = t.createPositionAt(i.parent, i.startOffset + e.endOffset);
                        const a = t.createRange(r, s);
                        t.remove(a);
                        t.insertText("$$" + o.latex + "$$", n.getAttributes(), r)
                    }))
                } else {
                    try {
                        o.node = this.editorObject.editing.view.domConverter.viewToDom(this.editorObject.editing.mapper.toViewElement(this.insertMathml(n)), e.document)
                    } catch (t) {
                        const e = t.toString();
                        if (e.includes("CKEditorError: Cannot read property 'parent' of undefined")) {
                            this.core.modalDialog.cancelAction()
                        }
                    }
                }
                return o
            }

            notifyWindowClosed() {
                this.editorObject.editing.view.focus()
            }
        }

        class CN extends nA {
            constructor(t) {
                super(t)
            }

            execute(t = {}) {
                if (!t.hasOwnProperty("integration") || !(t.integration instanceof _N)) {
                    throw'Must pass a valid CKEditor5Integration instance as attribute "integration" of options'
                }
                this.integration = t.integration;
                this.setEditor();
                this.openEditor()
            }

            setEditor() {
                this.integration.core.getCustomEditors().disable()
            }

            openEditor() {
                const t = this._getSelectedImage();
                if (typeof t !== "undefined" && t !== null && t.classList.contains(WirisPlugin.Configuration.get("imageClassName"))) {
                    this.integration.core.editionProperties.temporalImage = t;
                    this.integration.openExistingFormulaEditor()
                } else {
                    this.integration.openNewFormulaEditor()
                }
            }

            _getSelectedImage() {
                const t = this.editor.editing.view.document.selection;
                if (t.isCollapsed || t.rangeCount !== 1) {
                    return
                }
                const e = t.getFirstRange();
                let n;
                for (const t of e) {
                    if (t.item.name !== "span") {
                        return
                    }
                    n = t.item.getChild(0);
                    break
                }
                if (!n) {
                    return
                }
                return this.editor.editing.view.domConverter.mapViewToDom(n)
            }
        }

        class vN extends CN {
            setEditor() {
                this.integration.core.getCustomEditors().enable("chemistry")
            }
        }

        var yN = '<?xml version="1.0" encoding="utf-8"?>\n\x3c!-- Generator: Adobe Illustrator 22.0.1, SVG Export Plug-In . SVG Version: 6.00 Build 0)  --\x3e\n<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n\t viewBox="0 0 300 261.7" style="enable-background:new 0 0 300 261.7;" xml:space="preserve">\n<style type="text/css">\n\t.st0{fill:#FFFFFF;}\n\t.st1{fill:#EF4A5F;}\n\t.st2{fill:#C8202F;}\n</style>\n<path class="st0" d="M300,32.8c0-16.4-13.4-29.7-29.9-29.7c-2.9,0-7.2,0.8-7.2,0.8c-37.9,9.1-71.3,14-112,14c-0.3,0-0.6,0-1,0\n\tc-16.5,0-29.9,13.3-29.9,29.7c0,16.4,13.4,29.7,29.9,29.7l0,0c45.3,0,83.1-5.3,125.3-15.3h0C289.3,59.5,300,47.4,300,32.8"/>\n<path class="st0" d="M90.2,257.7c-11.4,0-21.9-6.4-27-16.7l-60-119.9c-7.5-14.9-1.4-33.1,13.5-40.5c14.9-7.5,33.1-1.4,40.5,13.5\n\tl27.3,54.7L121.1,39c5.3-15.8,22.4-24.4,38.2-19.1c15.8,5.3,24.4,22.4,19.1,38.2l-59.6,179c-3.9,11.6-14.3,19.7-26.5,20.6\n\tC91.6,257.7,90.9,257.7,90.2,257.7"/>\n<g>\n\t<g>\n\t\t<path class="st1" d="M90.2,257.7c-11.4,0-21.9-6.4-27-16.7l-60-119.9c-7.5-14.9-1.4-33.1,13.5-40.5c14.9-7.5,33.1-1.4,40.5,13.5\n\t\t\tl27.3,54.7L121.1,39c5.3-15.8,22.4-24.4,38.2-19.1c15.8,5.3,24.4,22.4,19.1,38.2l-59.6,179c-3.9,11.6-14.3,19.7-26.5,20.6\n\t\t\tC91.6,257.7,90.9,257.7,90.2,257.7"/>\n\t</g>\n</g>\n<g>\n\t<g>\n\t\t<path class="st2" d="M300,32.8c0-16.4-13.4-29.7-29.9-29.7c-2.9,0-7.2,0.8-7.2,0.8c-37.9,9.1-71.3,14-112,14c-0.3,0-0.6,0-1,0\n\t\t\tc-16.5,0-29.9,13.3-29.9,29.7c0,16.4,13.4,29.7,29.9,29.7l0,0c45.3,0,83.1-5.3,125.3-15.3h0C289.3,59.5,300,47.4,300,32.8"/>\n\t</g>\n</g>\n</svg>\n';
        var xN = '<?xml version="1.0" encoding="utf-8"?>\n\x3c!-- Generator: Adobe Illustrator 22.0.1, SVG Export Plug-In . SVG Version: 6.00 Build 0)  --\x3e\n<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n\t viewBox="0 0 40.3 49.5" style="enable-background:new 0 0 40.3 49.5;" xml:space="preserve">\n<style type="text/css">\n\t.st0{fill:#A4CF61;}\n</style>\n<path class="st0" d="M39.2,12.1c0-1.9-1.1-3.6-2.7-4.4L24.5,0.9l0,0c-0.7-0.4-1.5-0.6-2.4-0.6c-0.9,0-1.7,0.2-2.4,0.6l0,0L2.3,10.8\n\tl0,0C0.9,11.7,0,13.2,0,14.9h0v19.6h0c0,1.7,0.9,3.3,2.3,4.1l0,0l17.4,9.9l0,0c0.7,0.4,1.5,0.6,2.4,0.6c0.9,0,1.7-0.2,2.4-0.6l0,0\n\tl12.2-6.9h0c1.5-0.8,2.6-2.5,2.6-4.3c0-2.7-2.2-4.9-4.9-4.9c-0.9,0-1.8,0.3-2.5,0.7l0,0l-9.7,5.6l-12.3-7V17.8l12.3-7l9.9,5.7l0,0\n\tc0.7,0.4,1.5,0.6,2.4,0.6C37,17,39.2,14.8,39.2,12.1"/>\n</svg>\n';

        class EN extends tA {
            static get requires() {
                return [qT]
            }

            static get pluginName() {
                return "MathType"
            }

            init() {
                const t = this._addIntegration();
                this._addCommands();
                this._addViews(t);
                this._addSchema();
                this._addConverters();
                this._exposeWiris()
            }

            _addIntegration() {
                const t = this.editor;
                const e = {};
                e.environment = {};
                e.environment.editor = "CKEditor5";
                e.environment.editorVersion = "5" + ".x";
                e.editorObject = t;
                e.serviceProviderProperties = {};
                e.serviceProviderProperties.URI = "https://www.wiris.net/demo/plugins/app";
                e.serviceProviderProperties.server = "java";
                e.target = t.sourceElement;
                e.scriptName = "bundle.js";
                e.managesLanguage = true;
                let n;
                if (e.target) {
                    n = new _N(e);
                    n.init();
                    n.listeners.fire("onTargetReady", {});
                    n.checkElement();
                    this.listenTo(t.editing.view.document, "click", ((t, e) => {
                        if (e.domEvent.detail == 2) {
                            n.doubleClickHandler(e.domTarget, e.domEvent);
                            t.stop()
                        }
                    }), {priority: "highest"})
                }
                return n
            }

            _addCommands() {
                const t = this.editor;
                t.commands.add("MathType", new CN(t));
                t.commands.add("ChemType", new vN(t))
            }

            _addViews(t) {
                const e = this.editor;
                e.ui.componentFactory.add("MathType", (n => {
                    const i = new sw(n);
                    i.bind("isEnabled").to(e.commands.get("MathType"), "isEnabled");
                    i.set({label: "Insert a math equation - MathType", icon: yN, tooltip: true});
                    i.on("execute", (() => {
                        e.execute("MathType", {integration: t})
                    }));
                    return i
                }));
                e.ui.componentFactory.add("ChemType", (n => {
                    const i = new sw(n);
                    i.bind("isEnabled").to(e.commands.get("ChemType"), "isEnabled");
                    i.set({label: "Insert a chemistry formula - ChemType", icon: xN, tooltip: true});
                    i.on("execute", (() => {
                        e.execute("ChemType", {integration: t})
                    }));
                    return i
                }));
                e.editing.view.addObserver(UB)
            }

            _addSchema() {
                const t = this.editor.model.schema;
                t.register("mathml", {
                    allowWhere: "$text",
                    isObject: true,
                    isInline: true,
                    allowAttributes: ["formula"]
                })
            }

            _addConverters() {
                const t = this.editor;
                t.conversion.for("upcast").elementToElement({
                    view: {name: "span", classes: "ck-math-widget"},
                    model: (t, e) => {
                        const n = Pz.safeXmlDecode(t.getChild(0).getAttribute("data-mathml"));
                        return e.createElement("mathml", {formula: n})
                    }
                });
                t.data.upcastDispatcher.on("element:math", ((n, i, o) => {
                    const {consumable: r, writer: s} = o;
                    const a = i.viewItem;
                    if (!r.test(a, {name: true})) {
                        return
                    }
                    let c = e(a);
                    const l = new zz(t.editing.view.document);
                    const d = new OD(t.editing.view.document);
                    const u = d.createDocumentFragment(a.getChildren());
                    const h = [...a.getAttributes()].map((([t, e]) => ` ${t}="${e}"`)).join("");
                    let m = l.toData(u) || "";
                    m = `<math${h}>${m}</math>`;
                    const g = c ? s.createText($z.initParse(m, t.config.get("language"))) : s.createElement("mathml", {formula: m});
                    const f = o.splitToAllowedParent(g, i.modelCursor);
                    if (!f) {
                        return
                    }
                    o.writer.insert(g, f.position);
                    r.consume(a, {name: true});
                    const p = o.getSplitParts(g);
                    i.modelRange = s.createRange(o.writer.createPositionBefore(g), o.writer.createPositionAfter(p[p.length - 1]));
                    if (f.cursorParent) {
                        i.modelCursor = o.writer.createPositionAt(f.cursorParent, 0)
                    } else {
                        i.modelCursor = i.modelRange.end
                    }
                }));

                function e(t) {
                    const e = t.getChild(0);
                    if (!e || e.name !== "semantics") return false;
                    for (const t of e.getChildren()) {
                        if (t.name === "annotation" && t.getAttribute("encoding") === "LaTeX") {
                            return true
                        }
                    }
                    return false
                }

                t.conversion.for("editingDowncast").elementToElement({model: "mathml", view: o});
                t.conversion.for("dataDowncast").elementToElement({model: "mathml", view: i});

                function n(t, e) {
                    if (e.is("text")) {
                        return t.createText(e.data)
                    } else if (e.is("element")) {
                        if (e.is("emptyElement")) {
                            return t.createEmptyElement(e.name, e.getAttributes())
                        } else {
                            const i = t.createContainerElement(e.name, e.getAttributes());
                            for (const o of e.getChildren()) {
                                t.insert(t.createPositionAt(i, "end"), n(t, o))
                            }
                            return i
                        }
                    }
                    throw new Exception("Given node has unsupported type.")
                }

                function i(t, {writer: e}) {
                    const i = new Qp(e.document);
                    let o = $z.endParseSaveMode(t.getAttribute("formula"));
                    if (!Oz.get("saveHandTraces")) {
                        o = Pz.removeAnnotation(o, "application/json")
                    }
                    const r = i.toView(o).getChild(0);
                    return n(e, r)
                }

                function o(t, {writer: e}) {
                    const n = e.createContainerElement("span", {class: "ck-math-widget"});
                    const i = r(t, {writer: e});
                    e.insert(e.createPositionAt(n, 0), i);
                    return mD(n, e)
                }

                function r(e, {writer: n}) {
                    const i = new Qp(n.document);
                    const o = e.getAttribute("formula");
                    const r = $z.initParse(o, t.config.get("language"));
                    const s = i.toView(r).getChild(0);
                    return n.createEmptyElement("img", s.getAttributes())
                }

                t.editing.mapper.on("viewToModelPosition", wD(t.model, (t => t.hasClass("ck-math-widget"))))
            }

            _exposeWiris() {
                window.WirisPlugin = {
                    Core: wN,
                    Parser: $z,
                    Image: qz,
                    MathML: Pz,
                    Util: Wz,
                    Configuration: Oz,
                    Listeners: Rz,
                    IntegrationModel: AN,
                    Latex: Vz
                }
            }
        }

        function DN(t, e) {
            return t => {
                t.on("attribute:url:media", n)
            };

            function n(n, i, o) {
                if (!o.consumable.consume(i.item, n.name)) {
                    return
                }
                const r = i.attributeNewValue;
                const s = o.writer;
                const a = o.mapper.toViewElement(i.item);
                const c = [...a.getChildren()].find((t => t.getCustomProperty("media-content")));
                s.remove(c);
                const l = t.getMediaViewElement(s, r, e);
                s.insert(s.createPositionAt(a, 0), l)
            }
        }

        function TN(t, e, n) {
            e.setCustomProperty("media", true, t);
            return mD(t, e, {label: n})
        }

        function MN(t) {
            const e = t.getSelectedElement();
            if (e && SN(e)) {
                return e
            }
            return null
        }

        function SN(t) {
            return !!t.getCustomProperty("media") && hD(t)
        }

        function IN(t, e, n, i) {
            const o = t.createContainerElement("figure", {class: "media"});
            t.insert(t.createPositionAt(o, 0), e.getMediaViewElement(t, n, i));
            return o
        }

        function BN(t) {
            const e = t.getSelectedElement();
            if (e && e.is("element", "media")) {
                return e
            }
            return null
        }

        function LN(t, e, n) {
            t.change((i => {
                const o = i.createElement("media", {url: e});
                t.insertContent(o, n);
                i.setSelection(o, "on")
            }))
        }

        class zN extends nA {
            refresh() {
                const t = this.editor.model;
                const e = t.document.selection;
                const n = t.schema;
                const i = kD(e, t);
                const o = BN(e);
                let r = i.parent;
                if (r.isEmpty && !t.schema.isLimit(r)) {
                    r = r.parent
                }
                this.value = o ? o.getAttribute("url") : null;
                this.isEnabled = n.checkChild(r, "media")
            }

            execute(t) {
                const e = this.editor.model;
                const n = e.document.selection;
                const i = BN(n);
                if (i) {
                    e.change((e => {
                        e.setAttribute("url", t, i)
                    }))
                } else {
                    const i = kD(n, e);
                    LN(e, t, i)
                }
            }
        }

        var NN = '<svg viewBox="0 0 64 42" xmlns="http://www.w3.org/2000/svg"><path d="M47.426 17V3.713L63.102 0v19.389h-.001l.001.272c0 1.595-2.032 3.43-4.538 4.098-2.506.668-4.538-.083-4.538-1.678 0-1.594 2.032-3.43 4.538-4.098.914-.244 2.032-.565 2.888-.603V4.516L49.076 7.447v9.556A1.014 1.014 0 0 0 49 17h-1.574zM29.5 17h-8.343a7.073 7.073 0 1 0-4.657 4.06v3.781H3.3a2.803 2.803 0 0 1-2.8-2.804V8.63a2.803 2.803 0 0 1 2.8-2.805h4.082L8.58 2.768A1.994 1.994 0 0 1 10.435 1.5h8.985c.773 0 1.477.448 1.805 1.149l1.488 3.177H26.7c1.546 0 2.8 1.256 2.8 2.805V17zm-11.637 0H17.5a1 1 0 0 0-1 1v.05A4.244 4.244 0 1 1 17.863 17zm29.684 2c.97 0 .953-.048.953.889v20.743c0 .953.016.905-.953.905H19.453c-.97 0-.953.048-.953-.905V19.89c0-.937-.016-.889.97-.889h28.077zm-4.701 19.338V22.183H24.154v16.155h18.692zM20.6 21.375v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616V37.53H20.6zm24.233-16.155v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615V37.53h-1.615zM29.485 25.283a.4.4 0 0 1 .593-.35l9.05 4.977a.4.4 0 0 1 0 .701l-9.05 4.978a.4.4 0 0 1-.593-.35v-9.956z"/></svg>';
        const PN = "0 0 64 42";

        class ON {
            constructor(t, e) {
                const n = e.providers;
                const i = e.extraProviders || [];
                const o = new Set(e.removeProviders);
                const r = n.concat(i).filter((t => {
                    const e = t.name;
                    if (!e) {
                        Object(ss["c"])("media-embed-no-provider-name", {provider: t});
                        return false
                    }
                    return !o.has(e)
                }));
                this.locale = t;
                this.providerDefinitions = r
            }

            hasMedia(t) {
                return !!this._getMedia(t)
            }

            getMediaViewElement(t, e, n) {
                return this._getMedia(e).getViewElement(t, n)
            }

            _getMedia(t) {
                if (!t) {
                    return new jN(this.locale)
                }
                t = t.trim();
                for (const e of this.providerDefinitions) {
                    const n = e.html;
                    let i = e.url;
                    if (!Array.isArray(i)) {
                        i = [i]
                    }
                    for (const e of i) {
                        const i = this._getUrlMatches(t, e);
                        if (i) {
                            return new jN(this.locale, t, i, n)
                        }
                    }
                }
                return null
            }

            _getUrlMatches(t, e) {
                let n = t.match(e);
                if (n) {
                    return n
                }
                let i = t.replace(/^https?:\/\//, "");
                n = i.match(e);
                if (n) {
                    return n
                }
                i = i.replace(/^www\./, "");
                n = i.match(e);
                if (n) {
                    return n
                }
                return null
            }
        }

        class jN {
            constructor(t, e, n, i) {
                this.url = this._getValidUrl(e);
                this._t = t.t;
                this._match = n;
                this._previewRenderer = i
            }

            getViewElement(t, e) {
                const n = {};
                let i;
                if (e.renderForEditingView || e.renderMediaPreview && this.url && this._previewRenderer) {
                    if (this.url) {
                        n["data-oembed-url"] = this.url
                    }
                    if (e.renderForEditingView) {
                        n.class = "ck-media__wrapper"
                    }
                    const o = this._getPreviewHtml(e);
                    i = t.createRawElement("div", n, (function (t) {
                        t.innerHTML = o
                    }))
                } else {
                    if (this.url) {
                        n.url = this.url
                    }
                    i = t.createEmptyElement("oembed", n)
                }
                t.setCustomProperty("media-content", true, i);
                return i
            }

            _getPreviewHtml(t) {
                if (this._previewRenderer) {
                    return this._previewRenderer(this._match)
                } else {
                    if (this.url && t.renderForEditingView) {
                        return this._getPlaceholderHtml()
                    }
                    return ""
                }
            }

            _getPlaceholderHtml() {
                const t = new ew;
                const e = new Qk;
                t.text = this._t("Open media in new tab");
                e.content = NN;
                e.viewBox = PN;
                const n = new vb({
                    tag: "div",
                    attributes: {class: "ck ck-reset_all ck-media__placeholder"},
                    children: [{
                        tag: "div",
                        attributes: {class: "ck-media__placeholder__icon"},
                        children: [e]
                    }, {
                        tag: "a",
                        attributes: {
                            class: "ck-media__placeholder__url",
                            target: "_blank",
                            rel: "noopener noreferrer",
                            href: this.url
                        },
                        children: [{
                            tag: "span",
                            attributes: {class: "ck-media__placeholder__url__text"},
                            children: [this.url]
                        }, t]
                    }]
                }).render();
                return n.outerHTML
            }

            _getValidUrl(t) {
                if (!t) {
                    return null
                }
                if (t.match(/^https?/)) {
                    return t
                }
                return "https://" + t
            }
        }

        var RN = n(63);
        var FN = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        FN.insert = "head";
        FN.singleton = true;
        var VN = ob()(RN["a"], FN);
        var HN = RN["a"].locals || {};

        class UN extends tA {
            static get pluginName() {
                return "MediaEmbedEditing"
            }

            constructor(t) {
                super(t);
                t.config.define("mediaEmbed", {
                    providers: [{
                        name: "dailymotion", url: /^dailymotion\.com\/video\/(\w+)/, html: t => {
                            const e = t[1];
                            return '<div style="position: relative; padding-bottom: 100%; height: 0; ">' + `<iframe src="https://www.dailymotion.com/embed/video/${e}" ` + 'style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" ' + 'frameborder="0" width="480" height="270" allowfullscreen allow="autoplay">' + "</iframe>" + "</div>"
                        }
                    }, {
                        name: "spotify",
                        url: [/^open\.spotify\.com\/(artist\/\w+)/, /^open\.spotify\.com\/(album\/\w+)/, /^open\.spotify\.com\/(track\/\w+)/],
                        html: t => {
                            const e = t[1];
                            return '<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 126%;">' + `<iframe src="https://open.spotify.com/embed/${e}" ` + 'style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" ' + 'frameborder="0" allowtransparency="true" allow="encrypted-media">' + "</iframe>" + "</div>"
                        }
                    }, {
                        name: "youtube",
                        url: [/^(?:m\.)?youtube\.com\/watch\?v=([\w-]+)/, /^(?:m\.)?youtube\.com\/v\/([\w-]+)/, /^youtube\.com\/embed\/([\w-]+)/, /^youtu\.be\/([\w-]+)/],
                        html: t => {
                            const e = t[1];
                            return '<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;">' + `<iframe src="https://www.youtube.com/embed/${e}" ` + 'style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" ' + 'frameborder="0" allow="autoplay; encrypted-media" allowfullscreen>' + "</iframe>" + "</div>"
                        }
                    }, {
                        name: "vimeo",
                        url: [/^vimeo\.com\/(\d+)/, /^vimeo\.com\/[^/]+\/[^/]+\/video\/(\d+)/, /^vimeo\.com\/album\/[^/]+\/video\/(\d+)/, /^vimeo\.com\/channels\/[^/]+\/(\d+)/, /^vimeo\.com\/groups\/[^/]+\/videos\/(\d+)/, /^vimeo\.com\/ondemand\/[^/]+\/(\d+)/, /^player\.vimeo\.com\/video\/(\d+)/],
                        html: t => {
                            const e = t[1];
                            return '<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;">' + `<iframe src="https://player.vimeo.com/video/${e}" ` + 'style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" ' + 'frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen>' + "</iframe>" + "</div>"
                        }
                    }, {name: "instagram", url: /^instagram\.com\/p\/(\w+)/}, {
                        name: "twitter",
                        url: /^twitter\.com/
                    }, {name: "googleMaps", url: /^google\.com\/maps/}, {
                        name: "flickr",
                        url: /^flickr\.com/
                    }, {name: "facebook", url: /^facebook\.com/}]
                });
                this.registry = new ON(t.locale, t.config.get("mediaEmbed"))
            }

            init() {
                const t = this.editor;
                const e = t.model.schema;
                const n = t.t;
                const i = t.conversion;
                const o = t.config.get("mediaEmbed.previewsInData");
                const r = this.registry;
                t.commands.add("mediaEmbed", new zN(t));
                e.register("media", {isObject: true, isBlock: true, allowWhere: "$block", allowAttributes: ["url"]});
                i.for("dataDowncast").elementToElement({
                    model: "media", view: (t, {writer: e}) => {
                        const n = t.getAttribute("url");
                        return IN(e, r, n, {renderMediaPreview: n && o})
                    }
                });
                i.for("dataDowncast").add(DN(r, {renderMediaPreview: o}));
                i.for("editingDowncast").elementToElement({
                    model: "media", view: (t, {writer: e}) => {
                        const i = t.getAttribute("url");
                        const o = IN(e, r, i, {renderForEditingView: true});
                        return TN(o, e, n("media widget"))
                    }
                });
                i.for("editingDowncast").add(DN(r, {renderForEditingView: true}));
                i.for("upcast").elementToElement({
                    view: {name: "oembed", attributes: {url: true}},
                    model: (t, {writer: e}) => {
                        const n = t.getAttribute("url");
                        if (r.hasMedia(n)) {
                            return e.createElement("media", {url: n})
                        }
                    }
                }).elementToElement({
                    view: {name: "div", attributes: {"data-oembed-url": true}},
                    model: (t, {writer: e}) => {
                        const n = t.getAttribute("data-oembed-url");
                        if (r.hasMedia(n)) {
                            return e.createElement("media", {url: n})
                        }
                    }
                })
            }
        }

        const WN = /^(?:http(s)?:\/\/)?[\w.-]+(?:\.[\w.-]+)+[\w\-._~:/?#[\]@!$&'()*+,;=%]+$/;

        class qN extends tA {
            static get requires() {
                return [Dv, Dy]
            }

            static get pluginName() {
                return "AutoMediaEmbed"
            }

            constructor(t) {
                super(t);
                this._timeoutId = null;
                this._positionToInsert = null
            }

            init() {
                const t = this.editor;
                const e = t.model.document;
                this.listenTo(t.plugins.get(Dv), "inputTransformation", (() => {
                    const t = e.selection.getFirstRange();
                    const n = tp.fromPosition(t.start);
                    n.stickiness = "toPrevious";
                    const i = tp.fromPosition(t.end);
                    i.stickiness = "toNext";
                    e.once("change:data", (() => {
                        this._embedMediaBetweenPositions(n, i);
                        n.detach();
                        i.detach()
                    }), {priority: "high"})
                }));
                t.commands.get("undo").on("execute", (() => {
                    if (this._timeoutId) {
                        jd.window.clearTimeout(this._timeoutId);
                        this._positionToInsert.detach();
                        this._timeoutId = null;
                        this._positionToInsert = null
                    }
                }), {priority: "high"})
            }

            _embedMediaBetweenPositions(t, e) {
                const n = this.editor;
                const i = n.plugins.get(UN).registry;
                const o = new fm(t, e);
                const r = o.getWalker({ignoreElementEnd: true});
                let s = "";
                for (const t of r) {
                    if (t.item.is("$textProxy")) {
                        s += t.item.data
                    }
                }
                s = s.trim();
                if (!s.match(WN)) {
                    o.detach();
                    return
                }
                if (!i.hasMedia(s)) {
                    o.detach();
                    return
                }
                const a = n.commands.get("mediaEmbed");
                if (!a.isEnabled) {
                    o.detach();
                    return
                }
                this._positionToInsert = tp.fromPosition(t);
                this._timeoutId = jd.window.setTimeout((() => {
                    n.model.change((t => {
                        this._timeoutId = null;
                        t.remove(o);
                        o.detach();
                        let e;
                        if (this._positionToInsert.root.rootName !== "$graveyard") {
                            e = this._positionToInsert
                        }
                        LN(n.model, s, e);
                        this._positionToInsert.detach();
                        this._positionToInsert = null
                    }))
                }), 100)
            }
        }

        var KN = n(64);
        var GN = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        GN.insert = "head";
        GN.singleton = true;
        var $N = ob()(KN["a"], GN);
        var YN = KN["a"].locals || {};

        class QN extends Zb {
            constructor(t, e) {
                super(e);
                const n = e.t;
                this.focusTracker = new Zp;
                this.keystrokes = new Fp;
                this.set("mediaURLInputValue", "");
                this.urlInputView = this._createUrlInput();
                this.saveButtonView = this._createButton(n("Save"), KD, "ck-button-save");
                this.saveButtonView.type = "submit";
                this.saveButtonView.bind("isEnabled").to(this, "mediaURLInputValue", (t => !!t));
                this.cancelButtonView = this._createButton(n("Cancel"), GD, "ck-button-cancel", "cancel");
                this._focusables = new Ab;
                this._focusCycler = new xk({
                    focusables: this._focusables,
                    focusTracker: this.focusTracker,
                    keystrokeHandler: this.keystrokes,
                    actions: {focusPrevious: "shift + tab", focusNext: "tab"}
                });
                this._validators = t;
                this.setTemplate({
                    tag: "form",
                    attributes: {class: ["ck", "ck-media-form", "ck-responsive-form"], tabindex: "-1"},
                    children: [this.urlInputView, this.saveButtonView, this.cancelButtonView]
                })
            }

            render() {
                super.render();
                cM({view: this});
                const t = [this.urlInputView, this.saveButtonView, this.cancelButtonView];
                t.forEach((t => {
                    this._focusables.add(t);
                    this.focusTracker.add(t.element)
                }));
                this.keystrokes.listenTo(this.element);
                const e = t => t.stopPropagation();
                this.keystrokes.set("arrowright", e);
                this.keystrokes.set("arrowleft", e);
                this.keystrokes.set("arrowup", e);
                this.keystrokes.set("arrowdown", e);
                this.listenTo(this.urlInputView.element, "selectstart", ((t, e) => {
                    e.stopPropagation()
                }), {priority: "high"})
            }

            focus() {
                this._focusCycler.focusFirst()
            }

            get url() {
                return this.urlInputView.fieldView.element.value.trim()
            }

            set url(t) {
                this.urlInputView.fieldView.element.value = t.trim()
            }

            isValid() {
                this.resetFormStatus();
                for (const t of this._validators) {
                    const e = t(this);
                    if (e) {
                        this.urlInputView.errorText = e;
                        return false
                    }
                }
                return true
            }

            resetFormStatus() {
                this.urlInputView.errorText = null;
                this.urlInputView.infoText = this._urlInputViewInfoDefault
            }

            _createUrlInput() {
                const t = this.locale.t;
                const e = new tM(this.locale, sM);
                const n = e.fieldView;
                this._urlInputViewInfoDefault = t("Paste the media URL in the input.");
                this._urlInputViewInfoTip = t("Tip: Paste the URL into the content to embed faster.");
                e.label = t("Media URL");
                e.infoText = this._urlInputViewInfoDefault;
                n.placeholder = "https://example.com";
                n.on("input", (() => {
                    e.infoText = n.element.value ? this._urlInputViewInfoTip : this._urlInputViewInfoDefault;
                    this.mediaURLInputValue = n.element.value.trim()
                }));
                return e
            }

            _createButton(t, e, n, i) {
                const o = new sw(this.locale);
                o.set({label: t, icon: e, tooltip: true});
                o.extendTemplate({attributes: {class: n}});
                if (i) {
                    o.delegate("execute").to(this, i)
                }
                return o
            }
        }

        var JN = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M18.68 3.03c.6 0 .59-.03.59.55v12.84c0 .59.01.56-.59.56H1.29c-.6 0-.59.03-.59-.56V3.58c0-.58-.01-.55.6-.55h17.38zM15.77 15V5H4.2v10h11.57zM2 4v1h1V4H2zm0 2v1h1V6H2zm0 2v1h1V8H2zm0 2v1h1v-1H2zm0 2v1h1v-1H2zm0 2v1h1v-1H2zM17 4v1h1V4h-1zm0 2v1h1V6h-1zm0 2v1h1V8h-1zm0 2v1h1v-1h-1zm0 2v1h1v-1h-1zm0 2v1h1v-1h-1zM7.5 7.177a.4.4 0 0 1 .593-.351l5.133 2.824a.4.4 0 0 1 0 .7l-5.133 2.824a.4.4 0 0 1-.593-.35V7.176v.001z"/></svg>';

        class XN extends tA {
            static get requires() {
                return [UN]
            }

            static get pluginName() {
                return "MediaEmbedUI"
            }

            init() {
                const t = this.editor;
                const e = t.commands.get("mediaEmbed");
                const n = t.plugins.get(UN).registry;
                t.ui.componentFactory.add("mediaEmbed", (i => {
                    const o = Sw(i);
                    const r = new QN(ZN(t.t, n), t.locale);
                    this._setUpDropdown(o, r, e, t);
                    this._setUpForm(o, r, e);
                    return o
                }))
            }

            _setUpDropdown(t, e, n) {
                const i = this.editor;
                const o = i.t;
                const r = t.buttonView;
                t.bind("isEnabled").to(n);
                t.panelView.children.add(e);
                r.set({label: o("Insert media"), icon: JN, tooltip: true});
                r.on("open", (() => {
                    e.url = n.value || "";
                    e.urlInputView.fieldView.select();
                    e.focus()
                }), {priority: "low"});
                t.on("submit", (() => {
                    if (e.isValid()) {
                        i.execute("mediaEmbed", e.url);
                        s()
                    }
                }));
                t.on("change:isOpen", (() => e.resetFormStatus()));
                t.on("cancel", (() => s()));

                function s() {
                    i.editing.view.focus();
                    t.isOpen = false
                }
            }

            _setUpForm(t, e, n) {
                e.delegate("submit", "cancel").to(t);
                e.urlInputView.bind("value").to(n, "value");
                e.urlInputView.bind("isReadOnly").to(n, "isEnabled", (t => !t))
            }
        }

        function ZN(t, e) {
            return [e => {
                if (!e.url.length) {
                    return t("The URL must not be empty.")
                }
            }, n => {
                if (!e.hasMedia(n.url)) {
                    return t("This media URL is not supported.")
                }
            }]
        }

        var tP = n(65);
        var eP = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        eP.insert = "head";
        eP.singleton = true;
        var nP = ob()(tP["a"], eP);
        var iP = tP["a"].locals || {};

        class oP extends tA {
            static get requires() {
                return [UN, XN, qN, qT]
            }

            static get pluginName() {
                return "MediaEmbed"
            }
        }

        class rP extends tA {
            static get requires() {
                return [oB]
            }

            static get pluginName() {
                return "MediaEmbedToolbar"
            }

            afterInit() {
                const t = this.editor;
                const e = t.t;
                const n = t.plugins.get(oB);
                n.register("mediaEmbed", {
                    ariaLabel: e("Media toolbar"),
                    items: t.config.get("mediaEmbed.toolbar") || [],
                    getRelatedElement: MN
                })
            }
        }

        class sP extends nA {
            refresh() {
                const t = this.editor.model;
                const e = t.document;
                this.isEnabled = t.schema.checkAttributeInSelection(e.selection, "mention")
            }

            execute(t) {
                const e = this.editor.model;
                const n = e.document;
                const i = n.selection;
                const o = typeof t.mention == "string" ? {id: t.mention} : t.mention;
                const r = o.id;
                const s = t.range || i.getFirstRange();
                const a = t.text || r;
                const c = cP({_text: a, id: r}, o);
                if (t.marker.length != 1) {
                    throw new ss["a"]("mentioncommand-incorrect-marker", this)
                }
                if (r.charAt(0) != t.marker) {
                    throw new ss["a"]("mentioncommand-incorrect-id", this)
                }
                e.change((t => {
                    const n = Us(i.getAttributes());
                    const o = new Map(n.entries());
                    o.set("mention", c);
                    e.insertContent(t.createText(a, o), s);
                    e.insertContent(t.createText(" ", n), s.start.getShiftedBy(a.length))
                }))
            }
        }

        class aP extends tA {
            static get pluginName() {
                return "MentionEditing"
            }

            init() {
                const t = this.editor;
                const e = t.model;
                const n = e.document;
                e.schema.extend("$text", {allowAttributes: "mention"});
                t.conversion.for("upcast").elementToAttribute({
                    view: {
                        name: "span",
                        key: "data-mention",
                        classes: "mention"
                    }, model: {key: "mention", value: lP}
                });
                t.conversion.for("downcast").attributeToElement({model: "mention", view: uP});
                t.conversion.for("downcast").add(dP);
                n.registerPostFixer((t => gP(t, n, e.schema)));
                n.registerPostFixer((t => fP(t, n)));
                n.registerPostFixer((t => hP(t, n)));
                t.commands.add("mention", new sP(t))
            }
        }

        function cP(t, e) {
            return Object.assign({uid: ns()}, t, e || {})
        }

        function lP(t, e) {
            const n = t.getAttribute("data-mention");
            const i = t.getChild(0);
            if (!i) {
                return
            }
            const o = {id: n, _text: i.data};
            return cP(o, e)
        }

        function dP(t) {
            t.on("attribute:mention", ((t, e, n) => {
                const i = e.attributeNewValue;
                if (!e.item.is("$textProxy") || !i) {
                    return
                }
                const o = e.range.start;
                const r = o.textNode || o.nodeAfter;
                if (r.data != i._text) {
                    n.consumable.consume(e.item, t.name)
                }
            }), {priority: "highest"})
        }

        function uP(t, {writer: e}) {
            if (!t) {
                return
            }
            const n = {class: "mention", "data-mention": t.id};
            const i = {id: t.uid, priority: 20};
            return e.createAttributeElement("span", n, i)
        }

        function hP(t, e) {
            const n = e.selection;
            const i = n.focus;
            if (n.isCollapsed && n.hasAttribute("mention") && mP(i)) {
                t.removeSelectionAttribute("mention");
                return true
            }
        }

        function mP(t) {
            const e = t.isAtStart;
            const n = t.nodeBefore && t.nodeBefore.is("$text");
            return n || e
        }

        function gP(t, e, n) {
            const i = e.differ.getChanges();
            let o = false;
            for (const e of i) {
                const i = e.position;
                if (e.name == "$text") {
                    const e = i.textNode && i.textNode.nextSibling;
                    o = bP(i.textNode, t) || o;
                    o = bP(e, t) || o;
                    o = bP(i.nodeBefore, t) || o;
                    o = bP(i.nodeAfter, t) || o
                }
                if (e.name != "$text" && e.type == "insert") {
                    const e = i.nodeAfter;
                    for (const n of t.createRangeIn(e).getItems()) {
                        o = bP(n, t) || o
                    }
                }
                if (e.type == "insert" && n.isInline(e.name)) {
                    const e = i.nodeAfter && i.nodeAfter.nextSibling;
                    o = bP(i.nodeBefore, t) || o;
                    o = bP(e, t) || o
                }
            }
            return o
        }

        function fP(t, e) {
            const n = e.differ.getChanges();
            let i = false;
            for (const e of n) {
                if (e.type === "attribute" && e.attributeKey != "mention") {
                    const n = e.range.start.nodeBefore;
                    const o = e.range.end.nodeAfter;
                    for (const r of [n, o]) {
                        if (pP(r) && r.getAttribute(e.attributeKey) != e.attributeNewValue) {
                            t.setAttribute(e.attributeKey, e.attributeNewValue, r);
                            i = true
                        }
                    }
                }
            }
            return i
        }

        function pP(t) {
            if (!t || !(t.is("$text") || t.is("$textProxy")) || !t.hasAttribute("mention")) {
                return false
            }
            const e = t.data;
            const n = t.getAttribute("mention");
            const i = n._text;
            return e != i
        }

        function bP(t, e) {
            if (pP(t)) {
                e.removeAttribute("mention", t);
                return true
            }
            return false
        }

        var kP = n(66);
        var wP = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        wP.insert = "head";
        wP.singleton = true;
        var AP = ob()(kP["a"], wP);
        var _P = kP["a"].locals || {};

        class CP extends mw {
            constructor(t) {
                super(t);
                this.extendTemplate({attributes: {class: ["ck-mentions"], tabindex: "-1"}})
            }

            selectFirst() {
                this.select(0)
            }

            selectNext() {
                const t = this.selected;
                const e = this.items.getIndex(t);
                this.select(e + 1)
            }

            selectPrevious() {
                const t = this.selected;
                const e = this.items.getIndex(t);
                this.select(e - 1)
            }

            select(t) {
                let e = 0;
                if (t > 0 && t < this.items.length) {
                    e = t
                } else if (t < 0) {
                    e = this.items.length - 1
                }
                const n = this.items.get(e);
                if (this.selected === n) {
                    return
                }
                if (this.selected) {
                    this.selected.removeHighlight()
                }
                n.highlight();
                this.selected = n;
                if (!this._isItemVisibleInScrolledArea(n)) {
                    this.element.scrollTop = n.element.offsetTop
                }
            }

            executeSelected() {
                this.selected.fire("execute")
            }

            _isItemVisibleInScrolledArea(t) {
                return new Eh(this.element).contains(new Eh(t.element))
            }
        }

        class vP extends Zb {
            constructor(t, e) {
                super(t);
                this.template = false;
                this.domElement = e;
                this.domElement.classList.add("ck-button");
                this.set("isOn", false);
                this.on("change:isOn", ((t, e, n) => {
                    if (n) {
                        this.domElement.classList.add("ck-on");
                        this.domElement.classList.remove("ck-off")
                    } else {
                        this.domElement.classList.add("ck-off");
                        this.domElement.classList.remove("ck-on")
                    }
                }));
                this.listenTo(this.domElement, "click", (() => {
                    this.fire("execute")
                }))
            }

            render() {
                super.render();
                this.element = this.domElement
            }
        }

        class yP extends gw {
            highlight() {
                const t = this.children.first;
                t.isOn = true
            }

            removeHighlight() {
                const t = this.children.first;
                t.isOn = false
            }
        }

        const xP = 3;
        const EP = [Nl.arrowup, Nl.arrowdown, Nl.enter, Nl.tab, Nl.esc];

        class DP extends tA {
            static get pluginName() {
                return "MentionUI"
            }

            static get requires() {
                return [MM]
            }

            constructor(t) {
                super(t);
                this._mentionsView = this._createMentionView();
                this._mentionsConfigurations = new Map;
                this._requestFeedDebounced = bh(this._requestFeed, 100);
                t.config.define("mention", {feeds: []})
            }

            init() {
                const t = this.editor;
                this._balloon = t.plugins.get(MM);
                t.editing.view.document.on("keydown", ((t, e) => {
                    if (LP(e.keyCode) && this._isUIVisible) {
                        e.preventDefault();
                        t.stop();
                        if (e.keyCode == Nl.arrowdown) {
                            this._mentionsView.selectNext()
                        }
                        if (e.keyCode == Nl.arrowup) {
                            this._mentionsView.selectPrevious()
                        }
                        if (e.keyCode == Nl.enter || e.keyCode == Nl.tab) {
                            this._mentionsView.executeSelected()
                        }
                        if (e.keyCode == Nl.esc) {
                            this._hideUIAndRemoveMarker()
                        }
                    }
                }), {priority: "highest"});
                _w({
                    emitter: this._mentionsView,
                    activator: () => this._isUIVisible,
                    contextElements: [this._balloon.view.element],
                    callback: () => this._hideUIAndRemoveMarker()
                });
                const e = t.config.get("mention.feeds");
                for (const t of e) {
                    const e = t.feed;
                    const n = t.marker;
                    if (!NP(n)) {
                        throw new ss["a"]("mentionconfig-incorrect-marker", null, {marker: n})
                    }
                    const i = t.minimumCharacters || 0;
                    const o = typeof e == "function" ? e.bind(this.editor) : BP(e);
                    const r = this._setupTextWatcherForFeed(n, i);
                    const s = t.itemRenderer;
                    const a = {watcher: r, marker: n, feedCallback: o, itemRenderer: s};
                    this._mentionsConfigurations.set(n, a)
                }
                this.on("requestFeed:response", ((t, e) => this._handleFeedResponse(e)));
                this.on("requestFeed:error", (() => this._hideUIAndRemoveMarker()))
            }

            destroy() {
                super.destroy();
                this._mentionsView.destroy()
            }

            get _isUIVisible() {
                return this._balloon.visibleView === this._mentionsView
            }

            _createMentionView() {
                const t = this.editor.locale;
                const e = new CP(t);
                this._items = new vs;
                e.items.bindTo(this._items).using((n => {
                    const {item: i, marker: o} = n;
                    const r = new yP(t);
                    const s = this._renderItem(i, o);
                    s.delegate("execute").to(r);
                    r.children.add(s);
                    r.item = i;
                    r.marker = o;
                    r.on("execute", (() => {
                        e.fire("execute", {item: i, marker: o})
                    }));
                    return r
                }));
                e.on("execute", ((t, e) => {
                    const n = this.editor;
                    const i = n.model;
                    const o = e.item;
                    const r = e.marker;
                    const s = n.model.markers.get("mention");
                    const a = i.createPositionAt(i.document.selection.focus);
                    const c = i.createPositionAt(s.getStart());
                    const l = i.createRange(c, a);
                    this._hideUIAndRemoveMarker();
                    n.execute("mention", {mention: o, text: o.text, marker: r, range: l});
                    n.editing.view.focus()
                }));
                return e
            }

            _getItemRenderer(t) {
                const {itemRenderer: e} = this._mentionsConfigurations.get(t);
                return e
            }

            _requestFeed(t, e) {
                this._lastRequested = e;
                const {feedCallback: n} = this._mentionsConfigurations.get(t);
                const i = n(e);
                const o = i instanceof Promise;
                if (!o) {
                    this.fire("requestFeed:response", {feed: i, marker: t, feedText: e});
                    return
                }
                i.then((n => {
                    if (this._lastRequested == e) {
                        this.fire("requestFeed:response", {feed: n, marker: t, feedText: e})
                    } else {
                        this.fire("requestFeed:discarded", {feed: n, marker: t, feedText: e})
                    }
                })).catch((e => {
                    this.fire("requestFeed:error", {error: e});
                    Object(ss["c"])("mention-feed-callback-error", {marker: t})
                }))
            }

            _setupTextWatcherForFeed(t, e) {
                const n = this.editor;
                const i = new TA(n.model, SP(t, e));
                i.on("matched", ((e, i) => {
                    const o = n.model.document.selection;
                    const r = o.focus;
                    if (zP(r)) {
                        this._hideUIAndRemoveMarker();
                        return
                    }
                    const s = IP(t, i.text);
                    const a = t.length + s.length;
                    const c = r.getShiftedBy(-a);
                    const l = r.getShiftedBy(-s.length);
                    const d = n.model.createRange(c, l);
                    if (PP(n)) {
                        const t = n.model.markers.get("mention");
                        n.model.change((e => {
                            e.updateMarker(t, {range: d})
                        }))
                    } else {
                        n.model.change((t => {
                            t.addMarker("mention", {range: d, usingOperation: false, affectsData: false})
                        }))
                    }
                    this._requestFeedDebounced(t, s)
                }));
                i.on("unmatched", (() => {
                    this._hideUIAndRemoveMarker()
                }));
                const o = n.commands.get("mention");
                i.bind("isEnabled").to(o);
                return i
            }

            _handleFeedResponse(t) {
                const {feed: e, marker: n} = t;
                if (!PP(this.editor)) {
                    return
                }
                this._items.clear();
                for (const t of e) {
                    const e = typeof t != "object" ? {id: t, text: t} : t;
                    this._items.add({item: e, marker: n})
                }
                const i = this.editor.model.markers.get("mention");
                if (this._items.length) {
                    this._showOrUpdateUI(i)
                } else {
                    this._hideUIAndRemoveMarker()
                }
            }

            _showOrUpdateUI(t) {
                if (this._isUIVisible) {
                    this._balloon.updatePosition(this._getBalloonPanelPositionData(t, this._mentionsView.position))
                } else {
                    this._balloon.add({
                        view: this._mentionsView,
                        position: this._getBalloonPanelPositionData(t, this._mentionsView.position),
                        withArrow: false,
                        singleViewMode: true
                    })
                }
                this._mentionsView.position = this._balloon.view.position;
                this._mentionsView.selectFirst()
            }

            _hideUIAndRemoveMarker() {
                if (this._balloon.hasView(this._mentionsView)) {
                    this._balloon.remove(this._mentionsView)
                }
                if (PP(this.editor)) {
                    this.editor.model.change((t => t.removeMarker("mention")))
                }
                this._mentionsView.position = undefined
            }

            _renderItem(t, e) {
                const n = this.editor;
                let i;
                let o = t.id;
                const r = this._getItemRenderer(e);
                if (r) {
                    const e = r(t);
                    if (typeof e != "string") {
                        i = new vP(n.locale, e)
                    } else {
                        o = e
                    }
                }
                if (!i) {
                    const t = new sw(n.locale);
                    t.label = o;
                    t.withText = true;
                    i = t
                }
                return i
            }

            _getBalloonPanelPositionData(t, e) {
                const n = this.editor;
                const i = n.editing;
                const o = i.view.domConverter;
                const r = i.mapper;
                return {
                    target: () => {
                        let e = t.getRange();
                        if (e.start.root.rootName == "$graveyard") {
                            e = n.model.document.selection.getFirstRange()
                        }
                        const i = r.toViewRange(e);
                        const s = Eh.getDomRangeRects(o.viewRangeToDom(i));
                        return s.pop()
                    }, limiter: () => {
                        const t = this.editor.editing.view;
                        const e = t.document;
                        const n = e.selection.editableElement;
                        if (n) {
                            return t.domConverter.mapViewToDom(n.root)
                        }
                        return null
                    }, positions: TP(e)
                }
            }
        }

        function TP(t) {
            const e = {
                caret_se: t => ({top: t.bottom + xP, left: t.right, name: "caret_se"}),
                caret_ne: (t, e) => ({top: t.top - e.height - xP, left: t.right, name: "caret_ne"}),
                caret_sw: (t, e) => ({top: t.bottom + xP, left: t.right - e.width, name: "caret_sw"}),
                caret_nw: (t, e) => ({top: t.top - e.height - xP, left: t.right - e.width, name: "caret_nw"})
            };
            if (Object.prototype.hasOwnProperty.call(e, t)) {
                return [e[t]]
            }
            return [e.caret_se, e.caret_sw, e.caret_ne, e.caret_nw]
        }

        function MP(t, e) {
            const n = e == 0 ? "*" : `{${e},}`;
            const i = El.features.isRegExpUnicodePropertySupported ? "\\p{Ps}\\p{Pi}\"'" : "\\(\\[{\"'";
            const o = "\\S";
            const r = `(?:^|[ ${i}])([${t}])([${o}]${n})$`;
            return new RegExp(r, "u")
        }

        function SP(t, e) {
            const n = MP(t, e);
            return t => n.test(t)
        }

        function IP(t, e) {
            const n = MP(t, 0);
            const i = e.match(n);
            return i[2]
        }

        function BP(t) {
            return e => {
                const n = t.filter((t => {
                    const n = typeof t == "string" ? t : String(t.id);
                    return n.toLowerCase().includes(e.toLowerCase())
                })).slice(0, 10);
                return n
            }
        }

        function LP(t) {
            return EP.includes(t)
        }

        function zP(t) {
            const e = t.textNode && t.textNode.hasAttribute("mention");
            const n = t.nodeBefore;
            return e || n && n.is("$text") && n.hasAttribute("mention")
        }

        function NP(t) {
            return t && t.length == 1
        }

        function PP(t) {
            return t.model.markers.has("mention")
        }

        var OP = n(67);
        var jP = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        jP.insert = "head";
        jP.singleton = true;
        var RP = ob()(OP["a"], jP);
        var FP = OP["a"].locals || {};

        class VP extends tA {
            toMentionAttribute(t, e) {
                return lP(t, e)
            }

            static get pluginName() {
                return "Mention"
            }

            static get requires() {
                return [aP, DP]
            }
        }

        function HP(t, e) {
            for (const n of t.getChildren()) {
                if (n.is("element", "b") && n.getStyle("font-weight") === "normal") {
                    const i = t.getChildIndex(n);
                    e.remove(n);
                    e.insertChild(i, n.getChildren(), t)
                }
            }
        }

        function UP(t, e) {
            if (!t.childCount) {
                return
            }
            const n = new OD(t.document);
            const i = qP(t, n);
            if (!i.length) {
                return
            }
            let o = null;
            let r = 1;
            i.forEach(((t, s) => {
                const a = JP(i[s - 1], t);
                const c = a ? null : i[s - 1];
                const l = ZP(c, t);
                if (a) {
                    o = null;
                    r = 1
                }
                if (!o || l !== 0) {
                    const i = KP(t, e);
                    if (!o) {
                        o = GP(i, t.element, n)
                    } else if (t.indent > r) {
                        const t = o.getChild(o.childCount - 1);
                        const e = t.getChild(t.childCount - 1);
                        o = GP(i, e, n);
                        r += 1
                    } else if (t.indent < r) {
                        const e = r - t.indent;
                        o = tO(o, e);
                        r = parseInt(t.indent)
                    }
                    if (t.indent <= r) {
                        if (!o.is("element", i.type)) {
                            o = n.rename(i.type, o)
                        }
                    }
                }
                const d = $P(t.element, n);
                n.appendChild(d, o)
            }))
        }

        function WP(t, e) {
            for (const n of e.createRangeIn(t)) {
                const t = n.item;
                if (t.is("element", "li")) {
                    const n = t.getChild(0);
                    if (n && n.is("element", "p")) {
                        e.unwrapElement(n)
                    }
                }
            }
        }

        function qP(t, e) {
            const n = e.createRangeIn(t);
            const i = new Ws({name: /^p|h\d+$/, styles: {"mso-list": /.*/}});
            const o = [];
            for (const t of n) {
                if (t.type === "elementStart" && i.match(t.item)) {
                    const e = YP(t.item);
                    o.push({element: t.item, id: e.id, order: e.order, indent: e.indent})
                }
            }
            return o
        }

        function KP(t, e) {
            const n = new RegExp(`@list l${t.id}:level${t.indent}\\s*({[^}]*)`, "gi");
            const i = /mso-level-number-format:([^;]*);/gi;
            const o = n.exec(e);
            let r = "decimal";
            if (o && o[1]) {
                const t = i.exec(o[1]);
                if (t && t[1]) {
                    r = t[1].trim()
                }
            }
            return {type: r !== "bullet" && r !== "image" ? "ol" : "ul", style: r}
        }

        function GP(t, e, n) {
            const i = e.parent;
            const o = n.createElement(t.type);
            const r = i.getChildIndex(e) + 1;
            n.insertChild(r, o, i);
            return o
        }

        function $P(t, e) {
            QP(t, e);
            return e.rename("li", t)
        }

        function YP(t) {
            const e = {};
            const n = t.getStyle("mso-list");
            if (n) {
                const t = n.match(/(^|\s+)l(\d+)/i);
                const i = n.match(/\s*lfo(\d+)/i);
                const o = n.match(/\s*level(\d+)/i);
                if (t && i && o) {
                    e.id = t[2];
                    e.order = i[1];
                    e.indent = o[1]
                }
            }
            return e
        }

        function QP(t, e) {
            const n = new Ws({name: "span", styles: {"mso-list": "Ignore"}});
            const i = e.createRangeIn(t);
            for (const t of i) {
                if (t.type === "elementStart" && n.match(t.item)) {
                    e.remove(t.item)
                }
            }
        }

        function JP(t, e) {
            if (!t) {
                return true
            }
            if (t.id !== e.id) {
                return true
            }
            const n = e.element.previousSibling;
            if (!n) {
                return true
            }
            return !XP(n)
        }

        function XP(t) {
            return t.is("element", "ol") || t.is("element", "ul")
        }

        function ZP(t, e) {
            return t ? e.indent - t.indent : e.indent - 1
        }

        function tO(t, e) {
            const n = t.getAncestors({parentFirst: true});
            let i = null;
            let o = 0;
            for (const t of n) {
                if (t.name === "ul" || t.name === "ol") {
                    o++
                }
                if (o === e) {
                    i = t;
                    break
                }
            }
            return i
        }

        const eO = /id=("|')docs-internal-guid-[-0-9a-f]+("|')/i;

        class nO {
            constructor(t) {
                this.document = t
            }

            isActive(t) {
                return eO.test(t)
            }

            execute(t) {
                const e = new OD(this.document);
                HP(t.content, e);
                WP(t.content, e)
            }
        }

        function iO(t) {
            return rO(rO(t)).replace(/(<span\s+style=['"]mso-spacerun:yes['"]>[\s]*?)[\r\n]+(\s*<\/span>)/g, "$1$2").replace(/<span\s+style=['"]mso-spacerun:yes['"]><\/span>/g, "").replace(/ <\//g, " </").replace(/ <o:p><\/o:p>/g, " <o:p></o:p>").replace(/<o:p>(&nbsp;|\u00A0)<\/o:p>/g, "").replace(/>(\s*[\r\n]\s*)</g, "><")
        }

        function oO(t) {
            t.querySelectorAll("span[style*=spacerun]").forEach((t => {
                const e = t.innerText.length || 0;
                t.innerHTML = Array(e + 1).join("  ").substr(0, e)
            }))
        }

        function rO(t) {
            return t.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, ((t, e) => e.length === 1 ? " " : Array(e.length + 1).join("  ").substr(0, e.length)))
        }

        function sO(t, e) {
            const n = new DOMParser;
            t = t.replace(/<!--\[if gte vml 1]>/g, "");
            const i = iO(lO(t));
            const o = n.parseFromString(i, "text/html");
            oO(o);
            const r = o.body.innerHTML;
            const s = aO(o, e);
            const a = cO(o);
            return {body: s, bodyString: r, styles: a.styles, stylesString: a.stylesString}
        }

        function aO(t, e) {
            const n = new bl(e);
            const i = new Ud(n, {blockFillerMode: "nbsp"});
            const o = t.createDocumentFragment();
            const r = t.body.childNodes;
            while (r.length > 0) {
                o.appendChild(r[0])
            }
            return i.domToView(o)
        }

        function cO(t) {
            const e = [];
            const n = [];
            const i = Array.from(t.getElementsByTagName("style"));
            for (const t of i) {
                if (t.sheet && t.sheet.cssRules && t.sheet.cssRules.length) {
                    e.push(t.sheet);
                    n.push(t.innerHTML)
                }
            }
            return {styles: e, stylesString: n.join(" ")}
        }

        function lO(t) {
            const e = /<\/body>(.*?)(<\/html>|$)/;
            const n = t.match(e);
            if (n && n[1]) {
                t = t.slice(0, n.index) + t.slice(n.index).replace(n[1], "")
            }
            return t
        }

        function dO(t, e) {
            if (!t.childCount) {
                return
            }
            const n = new OD;
            const i = hO(t, n);
            mO(i, t, n);
            gO(t, n);
            const o = fO(t, n);
            if (o.length) {
                bO(o, pO(e), n)
            }
        }

        function uO(t) {
            return btoa(t.match(/\w{2}/g).map((t => String.fromCharCode(parseInt(t, 16)))).join(""))
        }

        function hO(t, e) {
            const n = e.createRangeIn(t);
            const i = new Ws({name: /v:(.+)/});
            const o = [];
            for (const t of n) {
                const e = t.item;
                const n = e.previousSibling && e.previousSibling.name || null;
                if (i.match(e) && e.getAttribute("o:gfxdata") && n !== "v:shapetype") {
                    o.push(t.item.getAttribute("id"))
                }
            }
            return o
        }

        function mO(t, e, n) {
            const i = n.createRangeIn(e);
            const o = new Ws({name: "img"});
            const r = [];
            for (const e of i) {
                if (o.match(e.item)) {
                    const n = e.item;
                    const i = n.getAttribute("v:shapes") ? n.getAttribute("v:shapes").split(" ") : [];
                    if (i.length && i.every((e => t.indexOf(e) > -1))) {
                        r.push(n)
                    } else if (!n.getAttribute("src")) {
                        r.push(n)
                    }
                }
            }
            for (const t of r) {
                n.remove(t)
            }
        }

        function gO(t, e) {
            const n = e.createRangeIn(t);
            const i = new Ws({name: /v:(.+)/});
            const o = [];
            for (const t of n) {
                if (i.match(t.item)) {
                    o.push(t.item)
                }
            }
            for (const t of o) {
                e.remove(t)
            }
        }

        function fO(t, e) {
            const n = e.createRangeIn(t);
            const i = new Ws({name: "img"});
            const o = [];
            for (const t of n) {
                if (i.match(t.item)) {
                    if (t.item.getAttribute("src").startsWith("file://")) {
                        o.push(t.item)
                    }
                }
            }
            return o
        }

        function pO(t) {
            if (!t) {
                return []
            }
            const e = /{\\pict[\s\S]+?\\bliptag-?\d+(\\blipupi-?\d+)?({\\\*\\blipuid\s?[\da-fA-F]+)?[\s}]*?/;
            const n = new RegExp("(?:(" + e.source + "))([\\da-fA-F\\s]+)\\}", "g");
            const i = t.match(n);
            const o = [];
            if (i) {
                for (const t of i) {
                    let n = false;
                    if (t.includes("\\pngblip")) {
                        n = "image/png"
                    } else if (t.includes("\\jpegblip")) {
                        n = "image/jpeg"
                    }
                    if (n) {
                        o.push({hex: t.replace(e, "").replace(/[^\da-fA-F]/g, ""), type: n})
                    }
                }
            }
            return o
        }

        function bO(t, e, n) {
            if (t.length === e.length) {
                for (let i = 0; i < t.length; i++) {
                    const o = `data:${e[i].type};base64,${uO(e[i].hex)}`;
                    n.setAttribute("src", o, t[i])
                }
            }
        }

        const kO = /<meta\s*name="?generator"?\s*content="?microsoft\s*word\s*\d+"?\/?>/i;
        const wO = /xmlns:o="urn:schemas-microsoft-com/i;

        class AO {
            constructor(t) {
                this.document = t
            }

            isActive(t) {
                return kO.test(t) || wO.test(t)
            }

            execute(t) {
                const {body: e, stylesString: n} = sO(t.dataTransfer.getData("text/html"), this.document.stylesProcessor);
                UP(e, n);
                dO(e, t.dataTransfer.getData("text/rtf"));
                t.content = e
            }
        }

        class _O extends tA {
            static get pluginName() {
                return "PasteFromOffice"
            }

            static get requires() {
                return [Dv]
            }

            init() {
                const t = this.editor;
                const e = t.editing.view.document;
                const n = [];
                n.push(new AO(e));
                n.push(new nO(e));
                t.plugins.get("Clipboard").on("inputTransformation", ((t, e) => {
                    if (e.isTransformedWithPasteFromOffice) {
                        return
                    }
                    const i = e.dataTransfer.getData("text/html");
                    const o = n.find((t => t.isActive(i)));
                    if (o) {
                        o.execute(e);
                        e.isTransformedWithPasteFromOffice = true
                    }
                }), {priority: "high"})
            }
        }

        var CO = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.69 14.915c.053.052.173.083.36.093a.366.366 0 0 1 .345.485l-.003.01a.738.738 0 0 1-.697.497h-2.67a.374.374 0 0 1-.353-.496l.013-.038a.681.681 0 0 1 .644-.458c.197-.012.325-.043.386-.093a.28.28 0 0 0 .072-.11L9.592 4.5H6.269c-.359-.017-.609.013-.75.09-.142.078-.289.265-.442.563-.192.29-.516.464-.864.464H4.17a.43.43 0 0 1-.407-.569L4.46 3h13.08l-.62 2.043a.81.81 0 0 1-.775.574h-.114a.486.486 0 0 1-.486-.486c.001-.284-.054-.464-.167-.54-.112-.076-.367-.106-.766-.091h-3.28l-2.68 10.257c-.006.074.007.127.038.158zM3 17h8a.5.5 0 1 1 0 1H3a.5.5 0 1 1 0-1zm11.299 1.17a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.06-1.06l1.415 1.414 1.414-1.415a.75.75 0 1 1 1.06 1.06l-1.413 1.415 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414-1.414 1.414z"/></svg>';
        const vO = "removeFormat";

        class yO extends tA {
            static get pluginName() {
                return "RemoveFormatUI"
            }

            init() {
                const t = this.editor;
                const e = t.t;
                t.ui.componentFactory.add(vO, (n => {
                    const i = t.commands.get(vO);
                    const o = new sw(n);
                    o.set({label: e("Remove Format"), icon: CO, tooltip: true});
                    o.bind("isOn", "isEnabled").to(i, "value", "isEnabled");
                    this.listenTo(o, "execute", (() => {
                        t.execute(vO);
                        t.editing.view.focus()
                    }));
                    return o
                }))
            }
        }

        class xO extends nA {
            refresh() {
                const t = this.editor.model;
                this.isEnabled = !!oA(this._getFormattingItems(t.document.selection, t.schema))
            }

            execute() {
                const t = this.editor.model;
                const e = t.schema;
                t.change((n => {
                    for (const i of this._getFormattingItems(t.document.selection, e)) {
                        if (i.is("selection")) {
                            for (const t of this._getFormattingAttributes(i, e)) {
                                n.removeSelectionAttribute(t)
                            }
                        } else {
                            const t = n.createRangeOn(i);
                            for (const o of this._getFormattingAttributes(i, e)) {
                                n.removeAttribute(o, t)
                            }
                        }
                    }
                }))
            }

            * _getFormattingItems(t, e) {
                const n = t => !!oA(this._getFormattingAttributes(t, e));
                for (const i of t.getRanges()) {
                    for (const t of i.getItems()) {
                        if (!e.isBlock(t) && n(t)) {
                            yield t
                        }
                    }
                }
                for (const e of t.getSelectedBlocks()) {
                    if (n(e)) {
                        yield e
                    }
                }
                if (n(t)) {
                    yield t
                }
            }

            * _getFormattingAttributes(t, e) {
                for (const [n] of t.getAttributes()) {
                    const t = e.getAttributeProperties(n);
                    if (t && t.isFormatting) {
                        yield n
                    }
                }
            }
        }

        class EO extends tA {
            static get pluginName() {
                return "RemoveFormatEditing"
            }

            init() {
                const t = this.editor;
                t.commands.add("removeFormat", new xO(t))
            }
        }

        class DO extends tA {
            static get requires() {
                return [EO, yO]
            }

            static get pluginName() {
                return "RemoveFormat"
            }
        }

        var TO = n(68);
        var MO = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        MO.insert = "head";
        MO.singleton = true;
        var SO = ob()(TO["a"], MO);
        var IO = TO["a"].locals || {};

        class BO extends Zb {
            constructor(t, e = {}) {
                super(t);
                const n = this.bindTemplate;
                this.set("label", e.label || "");
                this.set("class", e.class || null);
                this.children = this.createCollection();
                this.setTemplate({
                    tag: "div",
                    attributes: {class: ["ck", "ck-form__header", n.to("class")]},
                    children: this.children
                });
                const i = new Zb(t);
                i.setTemplate({
                    tag: "span",
                    attributes: {class: ["ck", "ck-form__header__label"]},
                    children: [{text: n.to("label")}]
                });
                this.children.add(i)
            }
        }

        class LO extends BO {
            constructor(t, e) {
                super(t);
                const n = t.t;
                this.set("class", "ck-special-characters-navigation");
                this.groupDropdownView = this._createGroupDropdown(e);
                this.groupDropdownView.panelPosition = t.uiLanguageDirection === "rtl" ? "se" : "sw";
                this.label = n("Special characters");
                this.children.add(this.groupDropdownView)
            }

            get currentGroupName() {
                return this.groupDropdownView.value
            }

            _createGroupDropdown(t) {
                const e = this.locale;
                const n = e.t;
                const i = Sw(e);
                const o = this._getCharacterGroupListItemDefinitions(i, t);
                i.set("value", o.first.model.label);
                i.buttonView.bind("label").to(i, "value");
                i.buttonView.set({
                    isOn: false,
                    withText: true,
                    tooltip: n("Character categories"),
                    class: ["ck-dropdown__button_label-width_auto"]
                });
                i.on("execute", (t => {
                    i.value = t.source.label
                }));
                i.delegate("execute").to(this);
                Bw(i, o);
                return i
            }

            _getCharacterGroupListItemDefinitions(t, e) {
                const n = new vs;
                for (const i of e) {
                    const e = {type: "button", model: new rv({label: i, withText: true})};
                    e.model.bind("isOn").to(t, "value", (t => t === e.model.label));
                    n.add(e)
                }
                return n
            }
        }

        var zO = n(69);
        var NO = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        NO.insert = "head";
        NO.singleton = true;
        var PO = ob()(zO["a"], NO);
        var OO = zO["a"].locals || {};

        class jO extends Zb {
            constructor(t) {
                super(t);
                this.tiles = this.createCollection();
                this.setTemplate({
                    tag: "div",
                    children: [{
                        tag: "div",
                        attributes: {class: ["ck", "ck-character-grid__tiles"]},
                        children: this.tiles
                    }],
                    attributes: {class: ["ck", "ck-character-grid"]}
                })
            }

            createTile(t, e) {
                const n = new sw(this.locale);
                n.set({label: t, withText: true, class: "ck-character-grid__tile"});
                n.extendTemplate({attributes: {title: e}, on: {mouseover: n.bindTemplate.to("mouseover")}});
                n.on("mouseover", (() => {
                    this.fire("tileHover", {name: e, character: t})
                }));
                n.on("execute", (() => {
                    this.fire("execute", {name: e, character: t})
                }));
                return n
            }
        }

        var RO = n(70);
        var FO = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        FO.insert = "head";
        FO.singleton = true;
        var VO = ob()(RO["a"], FO);
        var HO = RO["a"].locals || {};

        class UO extends Zb {
            constructor(t) {
                super(t);
                const e = this.bindTemplate;
                this.set("character", null);
                this.set("name", null);
                this.bind("code").to(this, "character", WO);
                this.setTemplate({
                    tag: "div",
                    children: [{
                        tag: "span",
                        attributes: {class: ["ck-character-info__name"]},
                        children: [{text: e.to("name", (t => t ? t : "​"))}]
                    }, {
                        tag: "span",
                        attributes: {class: ["ck-character-info__code"]},
                        children: [{text: e.to("code")}]
                    }],
                    attributes: {class: ["ck", "ck-character-info"]}
                })
            }
        }

        function WO(t) {
            if (t === null) {
                return ""
            }
            const e = t.codePointAt(0).toString(16);
            return "U+" + ("0000" + e).slice(-4)
        }

        var qO = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2.5a7.47 7.47 0 0 1 4.231 1.31 7.268 7.268 0 0 1 2.703 3.454 7.128 7.128 0 0 1 .199 4.353c-.39 1.436-1.475 2.72-2.633 3.677h2.013c0-.226.092-.443.254-.603a.876.876 0 0 1 1.229 0c.163.16.254.377.254.603v.853c0 .209-.078.41-.22.567a.873.873 0 0 1-.547.28l-.101.006h-4.695a.517.517 0 0 1-.516-.518v-1.265c0-.21.128-.398.317-.489a5.601 5.601 0 0 0 2.492-2.371 5.459 5.459 0 0 0 .552-3.693 5.53 5.53 0 0 0-1.955-3.2A5.71 5.71 0 0 0 10 4.206 5.708 5.708 0 0 0 6.419 5.46 5.527 5.527 0 0 0 4.46 8.663a5.457 5.457 0 0 0 .554 3.695 5.6 5.6 0 0 0 2.497 2.37.55.55 0 0 1 .317.49v1.264c0 .286-.23.518-.516.518H2.618a.877.877 0 0 1-.614-.25.845.845 0 0 1-.254-.603v-.853c0-.226.091-.443.254-.603a.876.876 0 0 1 1.228 0c.163.16.255.377.255.603h1.925c-1.158-.958-2.155-2.241-2.545-3.678a7.128 7.128 0 0 1 .199-4.352 7.268 7.268 0 0 1 2.703-3.455A7.475 7.475 0 0 1 10 2.5z"/></svg>';
        var KO = n(71);
        var GO = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        GO.insert = "head";
        GO.singleton = true;
        var $O = ob()(KO["a"], GO);
        var YO = KO["a"].locals || {};
        const QO = "All";

        class JO extends tA {
            static get requires() {
                return [oy]
            }

            static get pluginName() {
                return "SpecialCharacters"
            }

            constructor(t) {
                super(t);
                this._characters = new Map;
                this._groups = new Map
            }

            init() {
                const t = this.editor;
                const e = t.t;
                const n = t.commands.get("input");
                t.ui.componentFactory.add("specialCharacters", (i => {
                    const o = Sw(i);
                    let r;
                    o.buttonView.set({label: e("Special characters"), icon: qO, tooltip: true});
                    o.bind("isEnabled").to(n);
                    o.on("execute", ((e, n) => {
                        t.execute("input", {text: n.character});
                        t.editing.view.focus()
                    }));
                    o.on("change:isOpen", (() => {
                        if (!r) {
                            r = this._createDropdownPanelContent(i, o);
                            o.panelView.children.add(r.navigationView);
                            o.panelView.children.add(r.gridView);
                            o.panelView.children.add(r.infoView)
                        }
                        r.infoView.set({character: null, name: null})
                    }));
                    return o
                }))
            }

            addItems(t, e) {
                if (t === QO) {
                    throw new ss["a"](`special-character-invalid-group-name: The name "${QO}" is reserved and cannot be used.`)
                }
                const n = this._getGroup(t);
                for (const t of e) {
                    n.add(t.title);
                    this._characters.set(t.title, t.character)
                }
            }

            getGroups() {
                return this._groups.keys()
            }

            getCharactersForGroup(t) {
                if (t === QO) {
                    return new Set(this._characters.keys())
                }
                return this._groups.get(t)
            }

            getCharacter(t) {
                return this._characters.get(t)
            }

            _getGroup(t) {
                if (!this._groups.has(t)) {
                    this._groups.set(t, new Set)
                }
                return this._groups.get(t)
            }

            _updateGrid(t, e) {
                e.tiles.clear();
                const n = this.getCharactersForGroup(t);
                for (const t of n) {
                    const n = this.getCharacter(t);
                    e.tiles.add(e.createTile(n, t))
                }
            }

            _createDropdownPanelContent(t, e) {
                const n = [...this.getGroups()];
                n.unshift(QO);
                const i = new LO(t, n);
                const o = new jO(t);
                const r = new UO(t);
                o.delegate("execute").to(e);
                o.on("tileHover", ((t, e) => {
                    r.set(e)
                }));
                i.on("execute", (() => {
                    this._updateGrid(i.currentGroupName, o)
                }));
                this._updateGrid(i.currentGroupName, o);
                return {navigationView: i, gridView: o, infoView: r}
            }
        }

        class XO extends tA {
            init() {
                const t = this.editor;
                const e = t.t;
                t.plugins.get("SpecialCharacters").addItems("Arrows", [{
                    title: e("leftwards double arrow"),
                    character: "⇐"
                }, {title: e("rightwards double arrow"), character: "⇒"}, {
                    title: e("upwards double arrow"),
                    character: "⇑"
                }, {title: e("downwards double arrow"), character: "⇓"}, {
                    title: e("leftwards dashed arrow"),
                    character: "⇠"
                }, {title: e("rightwards dashed arrow"), character: "⇢"}, {
                    title: e("upwards dashed arrow"),
                    character: "⇡"
                }, {title: e("downwards dashed arrow"), character: "⇣"}, {
                    title: e("leftwards arrow to bar"),
                    character: "⇤"
                }, {title: e("rightwards arrow to bar"), character: "⇥"}, {
                    title: e("upwards arrow to bar"),
                    character: "⤒"
                }, {title: e("downwards arrow to bar"), character: "⤓"}, {
                    title: e("up down arrow with base"),
                    character: "↨"
                }, {
                    title: e("back with leftwards arrow above"),
                    character: "🔙"
                }, {
                    title: e("end with leftwards arrow above"),
                    character: "🔚"
                }, {
                    title: e("on with exclamation mark with left right arrow above"),
                    character: "🔛"
                }, {
                    title: e("soon with rightwards arrow above"),
                    character: "🔜"
                }, {title: e("top with upwards arrow above"), character: "🔝"}])
            }
        }

        class ZO extends tA {
            init() {
                const t = this.editor;
                const e = t.t;
                t.plugins.get("SpecialCharacters").addItems("Currency", [{
                    character: "$",
                    title: e("Dollar sign")
                }, {character: "€", title: e("Euro sign")}, {character: "¥", title: e("Yen sign")}, {
                    character: "£",
                    title: e("Pound sign")
                }, {character: "¢", title: e("Cent sign")}, {
                    character: "₠",
                    title: e("Euro-currency sign")
                }, {character: "₡", title: e("Colon sign")}, {
                    character: "₢",
                    title: e("Cruzeiro sign")
                }, {character: "₣", title: e("French franc sign")}, {
                    character: "₤",
                    title: e("Lira sign")
                }, {character: "¤", title: e("Currency sign")}, {
                    character: "₿",
                    title: e("Bitcoin sign")
                }, {character: "₥", title: e("Mill sign")}, {character: "₦", title: e("Naira sign")}, {
                    character: "₧",
                    title: e("Peseta sign")
                }, {character: "₨", title: e("Rupee sign")}, {character: "₩", title: e("Won sign")}, {
                    character: "₪",
                    title: e("New sheqel sign")
                }, {character: "₫", title: e("Dong sign")}, {character: "₭", title: e("Kip sign")}, {
                    character: "₮",
                    title: e("Tugrik sign")
                }, {character: "₯", title: e("Drachma sign")}, {
                    character: "₰",
                    title: e("German penny sign")
                }, {character: "₱", title: e("Peso sign")}, {character: "₲", title: e("Guarani sign")}, {
                    character: "₳",
                    title: e("Austral sign")
                }, {character: "₴", title: e("Hryvnia sign")}, {character: "₵", title: e("Cedi sign")}, {
                    character: "₶",
                    title: e("Livre tournois sign")
                }, {character: "₷", title: e("Spesmilo sign")}, {
                    character: "₸",
                    title: e("Tenge sign")
                }, {character: "₹", title: e("Indian rupee sign")}, {
                    character: "₺",
                    title: e("Turkish lira sign")
                }, {character: "₻", title: e("Nordic mark sign")}, {
                    character: "₼",
                    title: e("Manat sign")
                }, {character: "₽", title: e("Ruble sign")}])
            }
        }

        class tj extends tA {
            init() {
                const t = this.editor;
                const e = t.t;
                t.plugins.get("SpecialCharacters").addItems("Mathematical", [{
                    character: "<",
                    title: e("Less-than sign")
                }, {character: ">", title: e("Greater-than sign")}, {
                    character: "≤",
                    title: e("Less-than or equal to")
                }, {character: "≥", title: e("Greater-than or equal to")}, {
                    character: "–",
                    title: e("En dash")
                }, {character: "—", title: e("Em dash")}, {character: "¯", title: e("Macron")}, {
                    character: "‾",
                    title: e("Overline")
                }, {character: "°", title: e("Degree sign")}, {character: "−", title: e("Minus sign")}, {
                    character: "±",
                    title: e("Plus-minus sign")
                }, {character: "÷", title: e("Division sign")}, {
                    character: "⁄",
                    title: e("Fraction slash")
                }, {character: "×", title: e("Multiplication sign")}, {
                    character: "ƒ",
                    title: e("Latin small letter f with hook")
                }, {character: "∫", title: e("Integral")}, {
                    character: "∑",
                    title: e("N-ary summation")
                }, {character: "∞", title: e("Infinity")}, {character: "√", title: e("Square root")}, {
                    character: "∼",
                    title: e("Tilde operator")
                }, {character: "≅", title: e("Approximately equal to")}, {
                    character: "≈",
                    title: e("Almost equal to")
                }, {character: "≠", title: e("Not equal to")}, {
                    character: "≡",
                    title: e("Identical to")
                }, {character: "∈", title: e("Element of")}, {
                    character: "∉",
                    title: e("Not an element of")
                }, {character: "∋", title: e("Contains as member")}, {
                    character: "∏",
                    title: e("N-ary product")
                }, {character: "∧", title: e("Logical and")}, {character: "∨", title: e("Logical or")}, {
                    character: "¬",
                    title: e("Not sign")
                }, {character: "∩", title: e("Intersection")}, {character: "∪", title: e("Union")}, {
                    character: "∂",
                    title: e("Partial differential")
                }, {character: "∀", title: e("For all")}, {character: "∃", title: e("There exists")}, {
                    character: "∅",
                    title: e("Empty set")
                }, {character: "∇", title: e("Nabla")}, {
                    character: "∗",
                    title: e("Asterisk operator")
                }, {character: "∝", title: e("Proportional to")}, {character: "∠", title: e("Angle")}, {
                    character: "¼",
                    title: e("Vulgar fraction one quarter")
                }, {character: "½", title: e("Vulgar fraction one half")}, {
                    character: "¾",
                    title: e("Vulgar fraction three quarters")
                }])
            }
        }

        class ej extends tA {
            init() {
                const t = this.editor;
                const e = t.t;
                t.plugins.get("SpecialCharacters").addItems("Latin", [{
                    character: "Ā",
                    title: e("Latin capital letter a with macron")
                }, {character: "ā", title: e("Latin small letter a with macron")}, {
                    character: "Ă",
                    title: e("Latin capital letter a with breve")
                }, {character: "ă", title: e("Latin small letter a with breve")}, {
                    character: "Ą",
                    title: e("Latin capital letter a with ogonek")
                }, {character: "ą", title: e("Latin small letter a with ogonek")}, {
                    character: "Ć",
                    title: e("Latin capital letter c with acute")
                }, {character: "ć", title: e("Latin small letter c with acute")}, {
                    character: "Ĉ",
                    title: e("Latin capital letter c with circumflex")
                }, {character: "ĉ", title: e("Latin small letter c with circumflex")}, {
                    character: "Ċ",
                    title: e("Latin capital letter c with dot above")
                }, {character: "ċ", title: e("Latin small letter c with dot above")}, {
                    character: "Č",
                    title: e("Latin capital letter c with caron")
                }, {character: "č", title: e("Latin small letter c with caron")}, {
                    character: "Ď",
                    title: e("Latin capital letter d with caron")
                }, {character: "ď", title: e("Latin small letter d with caron")}, {
                    character: "Đ",
                    title: e("Latin capital letter d with stroke")
                }, {character: "đ", title: e("Latin small letter d with stroke")}, {
                    character: "Ē",
                    title: e("Latin capital letter e with macron")
                }, {character: "ē", title: e("Latin small letter e with macron")}, {
                    character: "Ĕ",
                    title: e("Latin capital letter e with breve")
                }, {character: "ĕ", title: e("Latin small letter e with breve")}, {
                    character: "Ė",
                    title: e("Latin capital letter e with dot above")
                }, {character: "ė", title: e("Latin small letter e with dot above")}, {
                    character: "Ę",
                    title: e("Latin capital letter e with ogonek")
                }, {character: "ę", title: e("Latin small letter e with ogonek")}, {
                    character: "Ě",
                    title: e("Latin capital letter e with caron")
                }, {character: "ě", title: e("Latin small letter e with caron")}, {
                    character: "Ĝ",
                    title: e("Latin capital letter g with circumflex")
                }, {character: "ĝ", title: e("Latin small letter g with circumflex")}, {
                    character: "Ğ",
                    title: e("Latin capital letter g with breve")
                }, {character: "ğ", title: e("Latin small letter g with breve")}, {
                    character: "Ġ",
                    title: e("Latin capital letter g with dot above")
                }, {character: "ġ", title: e("Latin small letter g with dot above")}, {
                    character: "Ģ",
                    title: e("Latin capital letter g with cedilla")
                }, {character: "ģ", title: e("Latin small letter g with cedilla")}, {
                    character: "Ĥ",
                    title: e("Latin capital letter h with circumflex")
                }, {character: "ĥ", title: e("Latin small letter h with circumflex")}, {
                    character: "Ħ",
                    title: e("Latin capital letter h with stroke")
                }, {character: "ħ", title: e("Latin small letter h with stroke")}, {
                    character: "Ĩ",
                    title: e("Latin capital letter i with tilde")
                }, {character: "ĩ", title: e("Latin small letter i with tilde")}, {
                    character: "Ī",
                    title: e("Latin capital letter i with macron")
                }, {character: "ī", title: e("Latin small letter i with macron")}, {
                    character: "Ĭ",
                    title: e("Latin capital letter i with breve")
                }, {character: "ĭ", title: e("Latin small letter i with breve")}, {
                    character: "Į",
                    title: e("Latin capital letter i with ogonek")
                }, {character: "į", title: e("Latin small letter i with ogonek")}, {
                    character: "İ",
                    title: e("Latin capital letter i with dot above")
                }, {character: "ı", title: e("Latin small letter dotless i")}, {
                    character: "Ĳ",
                    title: e("Latin capital ligature ij")
                }, {character: "ĳ", title: e("Latin small ligature ij")}, {
                    character: "Ĵ",
                    title: e("Latin capital letter j with circumflex")
                }, {character: "ĵ", title: e("Latin small letter j with circumflex")}, {
                    character: "Ķ",
                    title: e("Latin capital letter k with cedilla")
                }, {character: "ķ", title: e("Latin small letter k with cedilla")}, {
                    character: "ĸ",
                    title: e("Latin small letter kra")
                }, {character: "Ĺ", title: e("Latin capital letter l with acute")}, {
                    character: "ĺ",
                    title: e("Latin small letter l with acute")
                }, {character: "Ļ", title: e("Latin capital letter l with cedilla")}, {
                    character: "ļ",
                    title: e("Latin small letter l with cedilla")
                }, {character: "Ľ", title: e("Latin capital letter l with caron")}, {
                    character: "ľ",
                    title: e("Latin small letter l with caron")
                }, {character: "Ŀ", title: e("Latin capital letter l with middle dot")}, {
                    character: "ŀ",
                    title: e("Latin small letter l with middle dot")
                }, {character: "Ł", title: e("Latin capital letter l with stroke")}, {
                    character: "ł",
                    title: e("Latin small letter l with stroke")
                }, {character: "Ń", title: e("Latin capital letter n with acute")}, {
                    character: "ń",
                    title: e("Latin small letter n with acute")
                }, {character: "Ņ", title: e("Latin capital letter n with cedilla")}, {
                    character: "ņ",
                    title: e("Latin small letter n with cedilla")
                }, {character: "Ň", title: e("Latin capital letter n with caron")}, {
                    character: "ň",
                    title: e("Latin small letter n with caron")
                }, {character: "ŉ", title: e("Latin small letter n preceded by apostrophe")}, {
                    character: "Ŋ",
                    title: e("Latin capital letter eng")
                }, {character: "ŋ", title: e("Latin small letter eng")}, {
                    character: "Ō",
                    title: e("Latin capital letter o with macron")
                }, {character: "ō", title: e("Latin small letter o with macron")}, {
                    character: "Ŏ",
                    title: e("Latin capital letter o with breve")
                }, {character: "ŏ", title: e("Latin small letter o with breve")}, {
                    character: "Ő",
                    title: e("Latin capital letter o with double acute")
                }, {character: "ő", title: e("Latin small letter o with double acute")}, {
                    character: "Œ",
                    title: e("Latin capital ligature oe")
                }, {character: "œ", title: e("Latin small ligature oe")}, {
                    character: "Ŕ",
                    title: e("Latin capital letter r with acute")
                }, {character: "ŕ", title: e("Latin small letter r with acute")}, {
                    character: "Ŗ",
                    title: e("Latin capital letter r with cedilla")
                }, {character: "ŗ", title: e("Latin small letter r with cedilla")}, {
                    character: "Ř",
                    title: e("Latin capital letter r with caron")
                }, {character: "ř", title: e("Latin small letter r with caron")}, {
                    character: "Ś",
                    title: e("Latin capital letter s with acute")
                }, {character: "ś", title: e("Latin small letter s with acute")}, {
                    character: "Ŝ",
                    title: e("Latin capital letter s with circumflex")
                }, {character: "ŝ", title: e("Latin small letter s with circumflex")}, {
                    character: "Ş",
                    title: e("Latin capital letter s with cedilla")
                }, {character: "ş", title: e("Latin small letter s with cedilla")}, {
                    character: "Š",
                    title: e("Latin capital letter s with caron")
                }, {character: "š", title: e("Latin small letter s with caron")}, {
                    character: "Ţ",
                    title: e("Latin capital letter t with cedilla")
                }, {character: "ţ", title: e("Latin small letter t with cedilla")}, {
                    character: "Ť",
                    title: e("Latin capital letter t with caron")
                }, {character: "ť", title: e("Latin small letter t with caron")}, {
                    character: "Ŧ",
                    title: e("Latin capital letter t with stroke")
                }, {character: "ŧ", title: e("Latin small letter t with stroke")}, {
                    character: "Ũ",
                    title: e("Latin capital letter u with tilde")
                }, {character: "ũ", title: e("Latin small letter u with tilde")}, {
                    character: "Ū",
                    title: e("Latin capital letter u with macron")
                }, {character: "ū", title: e("Latin small letter u with macron")}, {
                    character: "Ŭ",
                    title: e("Latin capital letter u with breve")
                }, {character: "ŭ", title: e("Latin small letter u with breve")}, {
                    character: "Ů",
                    title: e("Latin capital letter u with ring above")
                }, {character: "ů", title: e("Latin small letter u with ring above")}, {
                    character: "Ű",
                    title: e("Latin capital letter u with double acute")
                }, {character: "ű", title: e("Latin small letter u with double acute")}, {
                    character: "Ų",
                    title: e("Latin capital letter u with ogonek")
                }, {character: "ų", title: e("Latin small letter u with ogonek")}, {
                    character: "Ŵ",
                    title: e("Latin capital letter w with circumflex")
                }, {character: "ŵ", title: e("Latin small letter w with circumflex")}, {
                    character: "Ŷ",
                    title: e("Latin capital letter y with circumflex")
                }, {character: "ŷ", title: e("Latin small letter y with circumflex")}, {
                    character: "Ÿ",
                    title: e("Latin capital letter y with diaeresis")
                }, {character: "Ź", title: e("Latin capital letter z with acute")}, {
                    character: "ź",
                    title: e("Latin small letter z with acute")
                }, {character: "Ż", title: e("Latin capital letter z with dot above")}, {
                    character: "ż",
                    title: e("Latin small letter z with dot above")
                }, {character: "Ž", title: e("Latin capital letter z with caron")}, {
                    character: "ž",
                    title: e("Latin small letter z with caron")
                }, {character: "ſ", title: e("Latin small letter long s")}])
            }
        }

        class nj extends tA {
            init() {
                const t = this.editor;
                const e = t.t;
                t.plugins.get("SpecialCharacters").addItems("Text", [{
                    character: "‹",
                    title: e("Single left-pointing angle quotation mark")
                }, {character: "›", title: e("Single right-pointing angle quotation mark")}, {
                    character: "«",
                    title: e("Left-pointing double angle quotation mark")
                }, {character: "»", title: e("Right-pointing double angle quotation mark")}, {
                    character: "‘",
                    title: e("Left single quotation mark")
                }, {character: "’", title: e("Right single quotation mark")}, {
                    character: "“",
                    title: e("Left double quotation mark")
                }, {character: "”", title: e("Right double quotation mark")}, {
                    character: "‚",
                    title: e("Single low-9 quotation mark")
                }, {character: "„", title: e("Double low-9 quotation mark")}, {
                    character: "¡",
                    title: e("Inverted exclamation mark")
                }, {character: "¿", title: e("Inverted question mark")}, {
                    character: "‥",
                    title: e("Two dot leader")
                }, {character: "…", title: e("Horizontal ellipsis")}, {
                    character: "‡",
                    title: e("Double dagger")
                }, {character: "‰", title: e("Per mille sign")}, {
                    character: "‱",
                    title: e("Per ten thousand sign")
                }, {character: "‼", title: e("Double exclamation mark")}, {
                    character: "⁈",
                    title: e("Question exclamation mark")
                }, {character: "⁉", title: e("Exclamation question mark")}, {
                    character: "⁇",
                    title: e("Double question mark")
                }, {character: "©", title: e("Copyright sign")}, {
                    character: "®",
                    title: e("Registered sign")
                }, {character: "™", title: e("Trade mark sign")}, {
                    character: "§",
                    title: e("Section sign")
                }, {character: "¶", title: e("Paragraph sign")}, {character: "⁋", title: e("Reversed paragraph sign")}])
            }
        }

        class ij extends tA {
            static get requires() {
                return [ZO, nj, tj, XO, ej]
            }
        }

        const oj = "strikethrough";

        class rj extends tA {
            static get pluginName() {
                return "StrikethroughEditing"
            }

            init() {
                const t = this.editor;
                t.model.schema.extend("$text", {allowAttributes: oj});
                t.model.schema.setAttributeProperties(oj, {isFormatting: true, copyOnEnter: true});
                t.conversion.attributeToElement({
                    model: oj,
                    view: "s",
                    upcastAlso: ["del", "strike", {styles: {"text-decoration": "line-through"}}]
                });
                t.commands.add(oj, new oC(t, oj));
                t.keystrokes.set("CTRL+SHIFT+X", "strikethrough")
            }
        }

        var sj = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 16.4c-.8-.4-1.5-.9-2.2-1.5a.6.6 0 0 1-.2-.5l.3-.6h1c1 1.2 2.1 1.7 3.7 1.7 1 0 1.8-.3 2.3-.6.6-.4.6-1.2.6-1.3.2-1.2-.9-2.1-.9-2.1h2.1c.3.7.4 1.2.4 1.7v.8l-.6 1.2c-.6.8-1.1 1-1.6 1.2a6 6 0 0 1-2.4.6c-1 0-1.8-.3-2.5-.6zM6.8 9L6 8.3c-.4-.5-.5-.8-.5-1.6 0-.7.1-1.3.5-1.8.4-.6 1-1 1.6-1.3a6.3 6.3 0 0 1 4.7 0 4 4 0 0 1 1.7 1l.3.7c0 .1.2.4-.2.7-.4.2-.9.1-1 0a3 3 0 0 0-1.2-1c-.4-.2-1-.3-2-.4-.7 0-1.4.2-2 .6-.8.6-1 .8-1 1.5 0 .8.5 1 1.2 1.5.6.4 1.1.7 1.9 1H6.8z"/><path d="M3 10.5V9h14v1.5z"/></svg>';
        const aj = "strikethrough";

        class cj extends tA {
            init() {
                const t = this.editor;
                const e = t.t;
                t.ui.componentFactory.add(aj, (n => {
                    const i = t.commands.get(aj);
                    const o = new sw(n);
                    o.set({
                        label: e("Strikethrough"),
                        icon: sj,
                        keystroke: "CTRL+SHIFT+X",
                        tooltip: true,
                        isToggleable: true
                    });
                    o.bind("isOn", "isEnabled").to(i, "value", "isEnabled");
                    this.listenTo(o, "execute", (() => {
                        t.execute(aj);
                        t.editing.view.focus()
                    }));
                    return o
                }))
            }
        }

        class lj extends tA {
            static get requires() {
                return [rj, cj]
            }

            static get pluginName() {
                return "Strikethrough"
            }
        }

        const dj = "subscript";

        class uj extends tA {
            static get pluginName() {
                return "SubscriptEditing"
            }

            init() {
                const t = this.editor;
                t.model.schema.extend("$text", {allowAttributes: dj});
                t.model.schema.setAttributeProperties(dj, {isFormatting: true, copyOnEnter: true});
                t.conversion.attributeToElement({
                    model: dj,
                    view: "sub",
                    upcastAlso: [{styles: {"vertical-align": "sub"}}]
                });
                t.commands.add(dj, new oC(t, dj))
            }
        }

        var hj = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7.03 10.349l3.818-3.819a.8.8 0 1 1 1.132 1.132L8.16 11.48l3.819 3.818a.8.8 0 1 1-1.132 1.132L7.03 12.61l-3.818 3.82a.8.8 0 1 1-1.132-1.132L5.9 11.48 2.08 7.662A.8.8 0 1 1 3.212 6.53l3.818 3.82zm8.147 7.829h2.549c.254 0 .447.05.58.152a.49.49 0 0 1 .201.413.54.54 0 0 1-.159.393c-.105.108-.266.162-.48.162h-3.594c-.245 0-.435-.066-.572-.197a.621.621 0 0 1-.205-.463c0-.114.044-.265.132-.453a1.62 1.62 0 0 1 .288-.444c.433-.436.824-.81 1.172-1.122.348-.312.597-.517.747-.615.267-.183.49-.368.667-.553.177-.185.312-.375.405-.57.093-.194.139-.384.139-.57a1.008 1.008 0 0 0-.554-.917 1.197 1.197 0 0 0-.56-.133c-.426 0-.761.182-1.005.546a2.332 2.332 0 0 0-.164.39 1.609 1.609 0 0 1-.258.488c-.096.114-.237.17-.423.17a.558.558 0 0 1-.405-.156.568.568 0 0 1-.161-.427c0-.218.05-.446.151-.683.101-.238.252-.453.452-.646s.454-.349.762-.467a2.998 2.998 0 0 1 1.081-.178c.498 0 .923.076 1.274.228a1.916 1.916 0 0 1 1.004 1.032 1.984 1.984 0 0 1-.156 1.794c-.2.32-.405.572-.613.754-.208.182-.558.468-1.048.857-.49.39-.826.691-1.008.906a2.703 2.703 0 0 0-.24.309z"/></svg>';
        const mj = "subscript";

        class gj extends tA {
            init() {
                const t = this.editor;
                const e = t.t;
                t.ui.componentFactory.add(mj, (n => {
                    const i = t.commands.get(mj);
                    const o = new sw(n);
                    o.set({label: e("Subscript"), icon: hj, tooltip: true, isToggleable: true});
                    o.bind("isOn", "isEnabled").to(i, "value", "isEnabled");
                    this.listenTo(o, "execute", (() => {
                        t.execute(mj);
                        t.editing.view.focus()
                    }));
                    return o
                }))
            }
        }

        class fj extends tA {
            static get requires() {
                return [uj, gj]
            }

            static get pluginName() {
                return "Subscript"
            }
        }

        const pj = "superscript";

        class bj extends tA {
            static get pluginName() {
                return "SuperscriptEditing"
            }

            init() {
                const t = this.editor;
                t.model.schema.extend("$text", {allowAttributes: pj});
                t.model.schema.setAttributeProperties(pj, {isFormatting: true, copyOnEnter: true});
                t.conversion.attributeToElement({
                    model: pj,
                    view: "sup",
                    upcastAlso: [{styles: {"vertical-align": "super"}}]
                });
                t.commands.add(pj, new oC(t, pj))
            }
        }

        var kj = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M15.677 8.678h2.549c.254 0 .447.05.58.152a.49.49 0 0 1 .201.413.54.54 0 0 1-.159.393c-.105.108-.266.162-.48.162h-3.594c-.245 0-.435-.066-.572-.197a.621.621 0 0 1-.205-.463c0-.114.044-.265.132-.453a1.62 1.62 0 0 1 .288-.444c.433-.436.824-.81 1.172-1.122.348-.312.597-.517.747-.615.267-.183.49-.368.667-.553.177-.185.312-.375.405-.57.093-.194.139-.384.139-.57a1.008 1.008 0 0 0-.554-.917 1.197 1.197 0 0 0-.56-.133c-.426 0-.761.182-1.005.546a2.332 2.332 0 0 0-.164.39 1.609 1.609 0 0 1-.258.488c-.096.114-.237.17-.423.17a.558.558 0 0 1-.405-.156.568.568 0 0 1-.161-.427c0-.218.05-.446.151-.683.101-.238.252-.453.452-.646s.454-.349.762-.467a2.998 2.998 0 0 1 1.081-.178c.498 0 .923.076 1.274.228a1.916 1.916 0 0 1 1.004 1.032 1.984 1.984 0 0 1-.156 1.794c-.2.32-.405.572-.613.754-.208.182-.558.468-1.048.857-.49.39-.826.691-1.008.906a2.703 2.703 0 0 0-.24.309zM7.03 10.349l3.818-3.819a.8.8 0 1 1 1.132 1.132L8.16 11.48l3.819 3.818a.8.8 0 1 1-1.132 1.132L7.03 12.61l-3.818 3.82a.8.8 0 1 1-1.132-1.132L5.9 11.48 2.08 7.662A.8.8 0 1 1 3.212 6.53l3.818 3.82z"/></svg>';
        const wj = "superscript";

        class Aj extends tA {
            init() {
                const t = this.editor;
                const e = t.t;
                t.ui.componentFactory.add(wj, (n => {
                    const i = t.commands.get(wj);
                    const o = new sw(n);
                    o.set({label: e("Superscript"), icon: kj, tooltip: true, isToggleable: true});
                    o.bind("isOn", "isEnabled").to(i, "value", "isEnabled");
                    this.listenTo(o, "execute", (() => {
                        t.execute(wj);
                        t.editing.view.focus()
                    }));
                    return o
                }))
            }
        }

        class _j extends tA {
            static get requires() {
                return [bj, Aj]
            }

            static get pluginName() {
                return "Superscript"
            }
        }

        function Cj(t, e, n, i, o = 1) {
            if (e > o) {
                i.setAttribute(t, e, n)
            } else {
                i.removeAttribute(t, n)
            }
        }

        function vj(t, e, n = {}) {
            const i = t.createElement("tableCell", n);
            t.insertElement("paragraph", i);
            t.insert(i, e);
            return i
        }

        function yj(t, e) {
            const n = e.parent.parent;
            const i = parseInt(n.getAttribute("headingColumns") || 0);
            const {column: o} = t.getCellLocation(e);
            return !!i && o < i
        }

        function xj() {
            return t => {
                t.on("element:table", ((t, e, n) => {
                    const i = e.viewItem;
                    if (!n.consumable.test(i, {name: true})) {
                        return
                    }
                    const {rows: o, headingRows: r, headingColumns: s} = Dj(i);
                    const a = {};
                    if (s) {
                        a.headingColumns = s
                    }
                    if (r) {
                        a.headingRows = r
                    }
                    const c = n.writer.createElement("table", a);
                    if (!n.safeInsert(c, e.modelCursor)) {
                        return
                    }
                    n.consumable.consume(i, {name: true});
                    o.forEach((t => n.convertItem(t, n.writer.createPositionAt(c, "end"))));
                    if (c.isEmpty) {
                        const t = n.writer.createElement("tableRow");
                        n.writer.insert(t, n.writer.createPositionAt(c, "end"));
                        vj(n.writer, n.writer.createPositionAt(t, "end"))
                    }
                    n.updateConversionResult(c, e)
                }))
            }
        }

        function Ej() {
            return t => {
                t.on("element:tr", ((t, e) => {
                    if (e.viewItem.isEmpty && e.modelCursor.index == 0) {
                        t.stop()
                    }
                }), {priority: "high"})
            }
        }

        function Dj(t) {
            const e = {headingRows: 0, headingColumns: 0};
            const n = [];
            const i = [];
            let o;
            for (const r of Array.from(t.getChildren())) {
                if (r.name === "tbody" || r.name === "thead" || r.name === "tfoot") {
                    if (r.name === "thead" && !o) {
                        o = r
                    }
                    const t = Array.from(r.getChildren()).filter((t => t.is("element", "tr")));
                    for (const r of t) {
                        if (r.parent.name === "thead" && r.parent === o) {
                            e.headingRows++;
                            n.push(r)
                        } else {
                            i.push(r);
                            const t = Tj(r, e, o);
                            if (t > e.headingColumns) {
                                e.headingColumns = t
                            }
                        }
                    }
                }
            }
            e.rows = [...n, ...i];
            return e
        }

        function Tj(t) {
            let e = 0;
            let n = 0;
            const i = Array.from(t.getChildren()).filter((t => t.name === "th" || t.name === "td"));
            while (n < i.length && i[n].name === "th") {
                const t = i[n];
                const o = parseInt(t.getAttribute("colspan") || 1);
                e = e + o;
                n++
            }
            return e
        }

        class Mj {
            constructor(t, e = {}) {
                this._table = t;
                this._startRow = e.row !== undefined ? e.row : e.startRow || 0;
                this._endRow = e.row !== undefined ? e.row : e.endRow;
                this._startColumn = e.column !== undefined ? e.column : e.startColumn || 0;
                this._endColumn = e.column !== undefined ? e.column : e.endColumn;
                this._includeAllSlots = !!e.includeAllSlots;
                this._skipRows = new Set;
                this._row = 0;
                this._column = 0;
                this._cellIndex = 0;
                this._spannedCells = new Map;
                this._nextCellAtColumn = -1
            }

            [Symbol.iterator]() {
                return this
            }

            next() {
                const t = this._table.getChild(this._row);
                if (!t || this._isOverEndRow()) {
                    return {done: true}
                }
                if (this._isOverEndColumn()) {
                    return this._advanceToNextRow()
                }
                let e = null;
                const n = this._getSpanned();
                if (n) {
                    if (this._includeAllSlots && !this._shouldSkipSlot()) {
                        e = this._formatOutValue(n.cell, n.row, n.column)
                    }
                } else {
                    const n = t.getChild(this._cellIndex);
                    if (!n) {
                        return this._advanceToNextRow()
                    }
                    const i = parseInt(n.getAttribute("colspan") || 1);
                    const o = parseInt(n.getAttribute("rowspan") || 1);
                    if (i > 1 || o > 1) {
                        this._recordSpans(n, o, i)
                    }
                    if (!this._shouldSkipSlot()) {
                        e = this._formatOutValue(n)
                    }
                    this._nextCellAtColumn = this._column + i
                }
                this._column++;
                if (this._column == this._nextCellAtColumn) {
                    this._cellIndex++
                }
                return e || this.next()
            }

            skipRow(t) {
                this._skipRows.add(t)
            }

            _advanceToNextRow() {
                this._row++;
                this._column = 0;
                this._cellIndex = 0;
                this._nextCellAtColumn = -1;
                return this.next()
            }

            _isOverEndRow() {
                return this._endRow !== undefined && this._row > this._endRow
            }

            _isOverEndColumn() {
                return this._endColumn !== undefined && this._column > this._endColumn
            }

            _formatOutValue(t, e = this._row, n = this._column) {
                return {done: false, value: new Sj(this, t, e, n)}
            }

            _shouldSkipSlot() {
                const t = this._skipRows.has(this._row);
                const e = this._row < this._startRow;
                const n = this._column < this._startColumn;
                const i = this._endColumn !== undefined && this._column > this._endColumn;
                return t || e || n || i
            }

            _getSpanned() {
                const t = this._spannedCells.get(this._row);
                if (!t) {
                    return null
                }
                return t.get(this._column) || null
            }

            _recordSpans(t, e, n) {
                const i = {cell: t, row: this._row, column: this._column};
                for (let t = this._row; t < this._row + e; t++) {
                    for (let e = this._column; e < this._column + n; e++) {
                        if (t != this._row || e != this._column) {
                            this._markSpannedCell(t, e, i)
                        }
                    }
                }
            }

            _markSpannedCell(t, e, n) {
                if (!this._spannedCells.has(t)) {
                    this._spannedCells.set(t, new Map)
                }
                const i = this._spannedCells.get(t);
                i.set(e, n)
            }
        }

        class Sj {
            constructor(t, e, n, i) {
                this.cell = e;
                this.row = t._row;
                this.column = t._column;
                this.cellAnchorRow = n;
                this.cellAnchorColumn = i;
                this._cellIndex = t._cellIndex;
                this._table = t._table
            }

            get isAnchor() {
                return this.row === this.cellAnchorRow && this.column === this.cellAnchorColumn
            }

            get cellWidth() {
                return parseInt(this.cell.getAttribute("colspan") || 1)
            }

            get cellHeight() {
                return parseInt(this.cell.getAttribute("rowspan") || 1)
            }

            getPositionBefore() {
                const t = this._table.root.document.model;
                return t.createPositionAt(this._table.getChild(this.row), this._cellIndex)
            }
        }

        function Ij(t = {}) {
            return e => e.on("insert:table", ((e, n, i) => {
                const o = n.item;
                if (!i.consumable.consume(o, "insert")) {
                    return
                }
                i.consumable.consume(o, "attribute:headingRows:table");
                i.consumable.consume(o, "attribute:headingColumns:table");
                const r = t && t.asWidget;
                const s = i.writer.createContainerElement("figure", {class: "table"});
                const a = i.writer.createContainerElement("table");
                i.writer.insert(i.writer.createPositionAt(s, 0), a);
                let c;
                if (r) {
                    c = jj(s, i.writer)
                }
                const l = new Mj(o);
                const d = {
                    headingRows: o.getAttribute("headingRows") || 0,
                    headingColumns: o.getAttribute("headingColumns") || 0
                };
                const u = new Map;
                for (const e of l) {
                    const {row: n, cell: r} = e;
                    const s = o.getChild(n);
                    const c = u.get(n) || Hj(a, s, n, d, i);
                    u.set(n, c);
                    i.consumable.consume(r, "insert");
                    const l = i.writer.createPositionAt(c, "end");
                    Vj(e, d, l, i, t)
                }
                for (const t of o.getChildren()) {
                    const e = t.index;
                    if (!u.has(e)) {
                        u.set(e, Hj(a, t, e, d, i))
                    }
                }
                const h = i.mapper.toViewPosition(n.range.start);
                i.mapper.bindElements(o, r ? c : s);
                i.writer.insert(h, r ? c : s)
            }))
        }

        function Bj() {
            return t => t.on("insert:tableRow", ((t, e, n) => {
                const i = e.item;
                if (!n.consumable.consume(i, "insert")) {
                    return
                }
                const o = i.parent;
                const r = n.mapper.toViewElement(o);
                const s = Yj(r);
                const a = o.getChildIndex(i);
                const c = new Mj(o, {row: a});
                const l = {
                    headingRows: o.getAttribute("headingRows") || 0,
                    headingColumns: o.getAttribute("headingColumns") || 0
                };
                const d = new Map;
                for (const t of c) {
                    const e = d.get(a) || Hj(s, i, a, l, n);
                    d.set(a, e);
                    n.consumable.consume(t.cell, "insert");
                    const o = n.writer.createPositionAt(e, "end");
                    Vj(t, l, o, n, {asWidget: true})
                }
            }))
        }

        function Lj() {
            return t => t.on("insert:tableCell", ((t, e, n) => {
                const i = e.item;
                if (!n.consumable.consume(i, "insert")) {
                    return
                }
                const o = i.parent;
                const r = o.parent;
                const s = r.getChildIndex(o);
                const a = new Mj(r, {row: s});
                const c = {
                    headingRows: r.getAttribute("headingRows") || 0,
                    headingColumns: r.getAttribute("headingColumns") || 0
                };
                for (const t of a) {
                    if (t.cell === i) {
                        const e = n.mapper.toViewElement(o);
                        const r = n.writer.createPositionAt(e, o.getChildIndex(i));
                        Vj(t, c, r, n, {asWidget: true});
                        return
                    }
                }
            }))
        }

        function zj() {
            return t => t.on("attribute:headingColumns:table", ((t, e, n) => {
                const i = e.item;
                if (!n.consumable.consume(e.item, t.name)) {
                    return
                }
                const o = {
                    headingRows: i.getAttribute("headingRows") || 0,
                    headingColumns: i.getAttribute("headingColumns") || 0
                };
                const r = e.attributeOldValue;
                const s = e.attributeNewValue;
                const a = (r > s ? r : s) - 1;
                for (const t of new Mj(i, {endColumn: a})) {
                    Fj(t, o, n)
                }
            }))
        }

        function Nj() {
            return t => t.on("remove:tableRow", ((t, e, n) => {
                t.stop();
                const i = n.writer;
                const o = n.mapper;
                const r = o.toViewPosition(e.position).getLastMatchingPosition((t => !t.item.is("element", "tr")));
                const s = r.nodeAfter;
                const a = s.parent;
                const c = a.parent;
                const l = i.createRangeOn(s);
                const d = i.remove(l);
                for (const t of i.createRangeIn(d).getItems()) {
                    o.unbindViewElement(t)
                }
                $j("thead", c, n);
                $j("tbody", c, n)
            }), {priority: "higher"})
        }

        function Pj(t, e) {
            const {writer: n} = e;
            if (!t.parent.is("element", "tableCell")) {
                return
            }
            if (Oj(t)) {
                return n.createContainerElement("span", {style: "display:inline-block"})
            } else {
                return n.createContainerElement("p")
            }
        }

        function Oj(t) {
            const e = t.parent;
            const n = e.childCount === 1;
            return n && !Qj(t)
        }

        function jj(t, e) {
            e.setCustomProperty("table", true, t);
            return mD(t, e, {hasSelectionHandle: true})
        }

        function Rj(t, e, n) {
            const i = n.writer;
            const o = n.mapper.toViewElement(t);
            const r = i.createEditableElement(e, o.getAttributes());
            const s = bD(r, i);
            gD(s, i, ((t, e, n) => n.addClass(Jj(e.classes), t)), ((t, e, n) => n.removeClass(Jj(e.classes), t)));
            i.insert(i.createPositionAfter(o), s);
            i.move(i.createRangeIn(o), i.createPositionAt(s, 0));
            i.remove(i.createRangeOn(o));
            n.mapper.unbindViewElement(o);
            n.mapper.bindElements(t, s)
        }

        function Fj(t, e, n) {
            const {cell: i} = t;
            const o = Uj(t, e);
            const r = n.mapper.toViewElement(i);
            if (r && r.name !== o) {
                Rj(i, o, n)
            }
        }

        function Vj(t, e, n, i, o) {
            const r = o && o.asWidget;
            const s = Uj(t, e);
            const a = r ? bD(i.writer.createEditableElement(s), i.writer) : i.writer.createContainerElement(s);
            if (r) {
                gD(a, i.writer, ((t, e, n) => n.addClass(Jj(e.classes), t)), ((t, e, n) => n.removeClass(Jj(e.classes), t)))
            }
            const c = t.cell;
            const l = c.getChild(0);
            const d = c.childCount === 1 && l.name === "paragraph";
            i.writer.insert(n, a);
            i.mapper.bindElements(c, a);
            if (!r && !Qj(l) && d) {
                const t = c.getChild(0);
                i.consumable.consume(t, "insert");
                i.mapper.bindElements(t, a)
            }
        }

        function Hj(t, e, n, i, o) {
            o.consumable.consume(e, "insert");
            const r = e.isEmpty ? o.writer.createEmptyElement("tr") : o.writer.createContainerElement("tr");
            o.mapper.bindElements(e, r);
            const s = i.headingRows;
            const a = qj(Wj(n, i), t, o);
            const c = s > 0 && n >= s ? n - s : n;
            const l = o.writer.createPositionAt(a, c);
            o.writer.insert(l, r);
            return r
        }

        function Uj(t, e) {
            const {row: n, column: i} = t;
            const {headingColumns: o, headingRows: r} = e;
            const s = r && r > n;
            if (s) {
                return "th"
            }
            const a = o && o > i;
            return a ? "th" : "td"
        }

        function Wj(t, e) {
            return t < e.headingRows ? "thead" : "tbody"
        }

        function qj(t, e, n) {
            const i = Kj(t, e);
            return i ? i : Gj(t, e, n)
        }

        function Kj(t, e) {
            for (const n of e.getChildren()) {
                if (n.name == t) {
                    return n
                }
            }
        }

        function Gj(t, e, n) {
            const i = n.writer.createContainerElement(t);
            const o = n.writer.createPositionAt(e, t == "tbody" ? "end" : 0);
            n.writer.insert(o, i);
            return i
        }

        function $j(t, e, n) {
            const i = Kj(t, e);
            if (i && i.childCount === 0) {
                n.writer.remove(n.writer.createRangeOn(i))
            }
        }

        function Yj(t) {
            for (const e of t.getChildren()) {
                if (e.name === "table") {
                    return e
                }
            }
        }

        function Qj(t) {
            return !![...t.getAttributeKeys()].length
        }

        function Jj(t) {
            return Array.isArray(t) ? t : [t]
        }

        class Xj extends nA {
            refresh() {
                const t = this.editor.model;
                const e = t.document.selection;
                const n = t.schema;
                const i = Zj(e.getFirstPosition());
                this.isEnabled = n.checkChild(i, "table")
            }

            execute(t = {}) {
                const e = this.editor.model;
                const n = e.document.selection;
                const i = this.editor.plugins.get("TableUtils");
                const o = kD(n, e);
                e.change((n => {
                    const r = i.createTable(n, t);
                    e.insertContent(r, o);
                    n.setSelection(n.createPositionAt(r.getNodeByPath([0, 0, 0]), 0))
                }))
            }
        }

        function Zj(t) {
            const e = t.parent;
            return e === e.root ? e : e.parent
        }

        function tR(t) {
            const e = [];
            for (const n of sR(t.getRanges())) {
                const t = n.getContainedElement();
                if (t && t.is("element", "tableCell")) {
                    e.push(t)
                }
            }
            return e
        }

        function eR(t) {
            const e = [];
            for (const n of t.getRanges()) {
                const t = n.start.findAncestor("tableCell");
                if (t) {
                    e.push(t)
                }
            }
            return e
        }

        function nR(t) {
            const e = tR(t);
            if (e.length) {
                return e
            }
            return eR(t)
        }

        function iR(t) {
            const e = t.map((t => t.parent.index));
            return aR(e)
        }

        function oR(t) {
            const e = t[0].findAncestor("table");
            const n = [...new Mj(e)];
            const i = n.filter((e => t.includes(e.cell))).map((t => t.column));
            return aR(i)
        }

        function rR(t, e) {
            if (t.length < 2 || !dR(t)) {
                return false
            }
            const n = new Set;
            const i = new Set;
            let o = 0;
            for (const r of t) {
                const {row: t, column: s} = e.getCellLocation(r);
                const a = parseInt(r.getAttribute("rowspan") || 1);
                const c = parseInt(r.getAttribute("colspan") || 1);
                n.add(t);
                i.add(s);
                if (a > 1) {
                    n.add(t + a - 1)
                }
                if (c > 1) {
                    i.add(s + c - 1)
                }
                o += a * c
            }
            const r = lR(n, i);
            return r == o
        }

        function sR(t) {
            return Array.from(t).sort(cR)
        }

        function aR(t) {
            const e = t.sort(((t, e) => t - e));
            const n = e[0];
            const i = e[e.length - 1];
            return {first: n, last: i}
        }

        function cR(t, e) {
            const n = t.start;
            const i = e.start;
            return n.isBefore(i) ? -1 : 1
        }

        function lR(t, e) {
            const n = Array.from(t.values());
            const i = Array.from(e.values());
            const o = Math.max(...n);
            const r = Math.min(...n);
            const s = Math.max(...i);
            const a = Math.min(...i);
            return (o - r + 1) * (s - a + 1)
        }

        function dR(t) {
            const e = t[0].findAncestor("table");
            const n = iR(t);
            const i = parseInt(e.getAttribute("headingRows") || 0);
            if (!uR(n, i)) {
                return false
            }
            const o = parseInt(e.getAttribute("headingColumns") || 0);
            const r = oR(t);
            return uR(r, o)
        }

        function uR({first: t, last: e}, n) {
            const i = t < n;
            const o = e < n;
            return i === o
        }

        class hR extends nA {
            constructor(t, e = {}) {
                super(t);
                this.order = e.order || "below"
            }

            refresh() {
                const t = this.editor.model.document.selection;
                const e = t.getFirstPosition().findAncestor("table");
                this.isEnabled = !!e
            }

            execute() {
                const t = this.editor;
                const e = t.model.document.selection;
                const n = t.plugins.get("TableUtils");
                const i = this.order === "above";
                const o = nR(e);
                const r = iR(o);
                const s = i ? r.first : r.last;
                const a = o[0].findAncestor("table");
                n.insertRows(a, {at: i ? s : s + 1, copyStructureFromAbove: !i})
            }
        }

        class mR extends nA {
            constructor(t, e = {}) {
                super(t);
                this.order = e.order || "right"
            }

            refresh() {
                const t = this.editor.model.document.selection;
                const e = t.getFirstPosition().findAncestor("table");
                this.isEnabled = !!e
            }

            execute() {
                const t = this.editor;
                const e = t.model.document.selection;
                const n = t.plugins.get("TableUtils");
                const i = this.order === "left";
                const o = nR(e);
                const r = oR(o);
                const s = i ? r.first : r.last;
                const a = o[0].findAncestor("table");
                n.insertColumns(a, {columns: 1, at: i ? s : s + 1})
            }
        }

        class gR extends nA {
            constructor(t, e = {}) {
                super(t);
                this.direction = e.direction || "horizontally"
            }

            refresh() {
                const t = nR(this.editor.model.document.selection);
                this.isEnabled = t.length === 1
            }

            execute() {
                const t = nR(this.editor.model.document.selection)[0];
                const e = this.direction === "horizontally";
                const n = this.editor.plugins.get("TableUtils");
                if (e) {
                    n.splitCellHorizontally(t, 2)
                } else {
                    n.splitCellVertically(t, 2)
                }
            }
        }

        function fR(t, e, n) {
            const {startRow: i, startColumn: o, endRow: r, endColumn: s} = e;
            const a = n.createElement("table");
            const c = r - i + 1;
            for (let t = 0; t < c; t++) {
                n.insertElement("tableRow", a, "end")
            }
            const l = [...new Mj(t, {startRow: i, endRow: r, startColumn: o, endColumn: s, includeAllSlots: true})];
            for (const {row: t, column: e, cell: c, isAnchor: d, cellAnchorRow: u, cellAnchorColumn: h} of l) {
                const l = t - i;
                const m = a.getChild(l);
                if (!d) {
                    if (u < i || h < o) {
                        vj(n, n.createPositionAt(m, "end"))
                    }
                } else {
                    const i = n.cloneElement(c);
                    n.append(i, m);
                    AR(i, t, e, r, s, n)
                }
            }
            _R(a, t, i, o, n);
            return a
        }

        function pR(t, e, n = 0) {
            const i = [];
            const o = new Mj(t, {startRow: n, endRow: e - 1});
            for (const t of o) {
                const {row: n, cellHeight: o} = t;
                const r = n + o - 1;
                if (n < e && e <= r) {
                    i.push(t)
                }
            }
            return i
        }

        function bR(t, e, n) {
            const i = t.parent;
            const o = i.parent;
            const r = i.index;
            const s = parseInt(t.getAttribute("rowspan"));
            const a = e - r;
            const c = {};
            const l = s - a;
            if (l > 1) {
                c.rowspan = l
            }
            const d = parseInt(t.getAttribute("colspan") || 1);
            if (d > 1) {
                c.colspan = d
            }
            const u = r;
            const h = u + a;
            const m = [...new Mj(o, {startRow: u, endRow: h, includeAllSlots: true})];
            let g = null;
            let f;
            for (const e of m) {
                const {row: i, column: o, cell: r} = e;
                if (r === t && f === undefined) {
                    f = o
                }
                if (f !== undefined && f === o && i === h) {
                    g = vj(n, e.getPositionBefore(), c)
                }
            }
            Cj("rowspan", a, t, n);
            return g
        }

        function kR(t, e) {
            const n = [];
            const i = new Mj(t);
            for (const t of i) {
                const {column: i, cellWidth: o} = t;
                const r = i + o - 1;
                if (i < e && e <= r) {
                    n.push(t)
                }
            }
            return n
        }

        function wR(t, e, n, i) {
            const o = parseInt(t.getAttribute("colspan"));
            const r = n - e;
            const s = {};
            const a = o - r;
            if (a > 1) {
                s.colspan = a
            }
            const c = parseInt(t.getAttribute("rowspan") || 1);
            if (c > 1) {
                s.rowspan = c
            }
            const l = vj(i, i.createPositionAfter(t), s);
            Cj("colspan", r, t, i);
            return l
        }

        function AR(t, e, n, i, o, r) {
            const s = parseInt(t.getAttribute("colspan") || 1);
            const a = parseInt(t.getAttribute("rowspan") || 1);
            const c = n + s - 1;
            if (c > o) {
                const e = o - n + 1;
                Cj("colspan", e, t, r, 1)
            }
            const l = e + a - 1;
            if (l > i) {
                const n = i - e + 1;
                Cj("rowspan", n, t, r, 1)
            }
        }

        function _R(t, e, n, i, o) {
            const r = parseInt(e.getAttribute("headingRows") || 0);
            if (r > 0) {
                const e = r - n;
                Cj("headingRows", e, t, o, 0)
            }
            const s = parseInt(e.getAttribute("headingColumns") || 0);
            if (s > 0) {
                const e = s - i;
                Cj("headingColumns", e, t, o, 0)
            }
        }

        function CR(t, e) {
            const n = e.getColumns(t);
            const i = new Array(n).fill(0);
            for (const {column: e} of new Mj(t)) {
                i[e]++
            }
            const o = i.reduce(((t, e, n) => e ? t : [...t, n]), []);
            if (o.length > 0) {
                const n = o[o.length - 1];
                e.removeColumns(t, {at: n});
                return true
            }
            return false
        }

        function vR(t, e) {
            const n = [];
            for (let e = 0; e < t.childCount; e++) {
                const i = t.getChild(e);
                if (i.isEmpty) {
                    n.push(e)
                }
            }
            if (n.length > 0) {
                const i = n[n.length - 1];
                e.removeRows(t, {at: i});
                return true
            }
            return false
        }

        function yR(t, e) {
            const n = CR(t, e);
            if (!n) {
                vR(t, e)
            }
        }

        function xR(t, e) {
            const n = Array.from(new Mj(t, {startColumn: e.firstColumn, endColumn: e.lastColumn, row: e.lastRow}));
            const i = n.every((({cellHeight: t}) => t === 1));
            if (i) {
                return e.lastRow
            }
            const o = n[0].cellHeight - 1;
            return e.lastRow + o
        }

        function ER(t, e) {
            const n = Array.from(new Mj(t, {startRow: e.firstRow, endRow: e.lastRow, column: e.lastColumn}));
            const i = n.every((({cellWidth: t}) => t === 1));
            if (i) {
                return e.lastColumn
            }
            const o = n[0].cellWidth - 1;
            return e.lastColumn + o
        }

        class DR extends nA {
            constructor(t, e) {
                super(t);
                this.direction = e.direction;
                this.isHorizontal = this.direction == "right" || this.direction == "left"
            }

            refresh() {
                const t = this._getMergeableCell();
                this.value = t;
                this.isEnabled = !!t
            }

            execute() {
                const t = this.editor.model;
                const e = t.document;
                const n = eR(e.selection)[0];
                const i = this.value;
                const o = this.direction;
                t.change((t => {
                    const e = o == "right" || o == "down";
                    const r = e ? n : i;
                    const s = e ? i : n;
                    const a = s.parent;
                    SR(s, r, t);
                    const c = this.isHorizontal ? "colspan" : "rowspan";
                    const l = parseInt(n.getAttribute(c) || 1);
                    const d = parseInt(i.getAttribute(c) || 1);
                    t.setAttribute(c, l + d, r);
                    t.setSelection(t.createRangeIn(r));
                    const u = this.editor.plugins.get("TableUtils");
                    const h = a.findAncestor("table");
                    yR(h, u)
                }))
            }

            _getMergeableCell() {
                const t = this.editor.model;
                const e = t.document;
                const n = eR(e.selection)[0];
                if (!n) {
                    return
                }
                const i = this.editor.plugins.get("TableUtils");
                const o = this.isHorizontal ? TR(n, this.direction, i) : MR(n, this.direction);
                if (!o) {
                    return
                }
                const r = this.isHorizontal ? "rowspan" : "colspan";
                const s = parseInt(n.getAttribute(r) || 1);
                const a = parseInt(o.getAttribute(r) || 1);
                if (a === s) {
                    return o
                }
            }
        }

        function TR(t, e, n) {
            const i = t.parent;
            const o = i.parent;
            const r = e == "right" ? t.nextSibling : t.previousSibling;
            const s = (o.getAttribute("headingColumns") || 0) > 0;
            if (!r) {
                return
            }
            const a = e == "right" ? t : r;
            const c = e == "right" ? r : t;
            const {column: l} = n.getCellLocation(a);
            const {column: d} = n.getCellLocation(c);
            const u = parseInt(a.getAttribute("colspan") || 1);
            const h = yj(n, a, o);
            const m = yj(n, c, o);
            if (s && h != m) {
                return
            }
            const g = l + u === d;
            return g ? r : undefined
        }

        function MR(t, e) {
            const n = t.parent;
            const i = n.parent;
            const o = i.getChildIndex(n);
            if (e == "down" && o === i.childCount - 1 || e == "up" && o === 0) {
                return
            }
            const r = parseInt(t.getAttribute("rowspan") || 1);
            const s = i.getAttribute("headingRows") || 0;
            const a = e == "down" && o + r === s;
            const c = e == "up" && o === s;
            if (s && (a || c)) {
                return
            }
            const l = parseInt(t.getAttribute("rowspan") || 1);
            const d = e == "down" ? o + l : o;
            const u = [...new Mj(i, {endRow: d})];
            const h = u.find((e => e.cell === t));
            const m = h.column;
            const g = u.find((({row: t, cellHeight: n, column: i}) => {
                if (i !== m) {
                    return false
                }
                if (e == "down") {
                    return t === d
                } else {
                    return d === t + n
                }
            }));
            return g && g.cell
        }

        function SR(t, e, n) {
            if (!IR(t)) {
                if (IR(e)) {
                    n.remove(n.createRangeIn(e))
                }
                n.move(n.createRangeIn(t), n.createPositionAt(e, "end"))
            }
            n.remove(t)
        }

        function IR(t) {
            return t.childCount == 1 && t.getChild(0).is("element", "paragraph") && t.getChild(0).isEmpty
        }

        class BR extends nA {
            refresh() {
                const t = nR(this.editor.model.document.selection);
                const e = t[0];
                if (e) {
                    const n = e.findAncestor("table");
                    const i = this.editor.plugins.get("TableUtils").getRows(n);
                    const o = i - 1;
                    const r = iR(t);
                    const s = r.first === 0 && r.last === o;
                    this.isEnabled = !s
                } else {
                    this.isEnabled = false
                }
            }

            execute() {
                const t = this.editor.model;
                const e = nR(t.document.selection);
                const n = iR(e);
                const i = e[0];
                const o = i.findAncestor("table");
                const r = this.editor.plugins.get("TableUtils").getCellLocation(i).column;
                t.change((t => {
                    const e = n.last - n.first + 1;
                    this.editor.plugins.get("TableUtils").removeRows(o, {at: n.first, rows: e});
                    const i = LR(o, n.first, r);
                    t.setSelection(t.createPositionAt(i, 0))
                }))
            }
        }

        function LR(t, e, n) {
            const i = t.getChild(e) || t.getChild(t.childCount - 1);
            let o = i.getChild(0);
            let r = 0;
            for (const t of i.getChildren()) {
                if (r > n) {
                    return o
                }
                o = t;
                r += parseInt(t.getAttribute("colspan") || 1)
            }
            return o
        }

        class zR extends nA {
            refresh() {
                const t = nR(this.editor.model.document.selection);
                const e = t[0];
                if (e) {
                    const n = e.findAncestor("table");
                    const i = this.editor.plugins.get("TableUtils").getColumns(n);
                    const {first: o, last: r} = oR(t);
                    this.isEnabled = r - o < i - 1
                } else {
                    this.isEnabled = false
                }
            }

            execute() {
                const [t, e] = PR(this.editor.model.document.selection);
                const n = t.parent.parent;
                const i = [...new Mj(n)];
                const o = {first: i.find((e => e.cell === t)).column, last: i.find((t => t.cell === e)).column};
                const r = NR(i, t, e, o);
                this.editor.model.change((t => {
                    const e = o.last - o.first + 1;
                    this.editor.plugins.get("TableUtils").removeColumns(n, {at: o.first, columns: e});
                    t.setSelection(t.createPositionAt(r, 0))
                }))
            }
        }

        function NR(t, e, n, i) {
            const o = parseInt(n.getAttribute("colspan") || 1);
            if (o > 1) {
                return n
            } else if (e.previousSibling || n.nextSibling) {
                return n.nextSibling || e.previousSibling
            } else {
                if (i.first) {
                    return t.reverse().find((({column: t}) => t < i.first)).cell
                } else {
                    return t.reverse().find((({column: t}) => t > i.last)).cell
                }
            }
        }

        function PR(t) {
            const e = nR(t);
            const n = e[0];
            const i = e.pop();
            const o = [n, i];
            return n.isBefore(i) ? o : o.reverse()
        }

        class OR extends nA {
            refresh() {
                const t = this.editor.model;
                const e = nR(t.document.selection);
                const n = e.length > 0;
                this.isEnabled = n;
                this.value = n && e.every((t => this._isInHeading(t, t.parent.parent)))
            }

            execute(t = {}) {
                if (t.forceValue === this.value) {
                    return
                }
                const e = this.editor.model;
                const n = nR(e.document.selection);
                const i = n[0].findAncestor("table");
                const {first: o, last: r} = iR(n);
                const s = this.value ? o : r + 1;
                const a = i.getAttribute("headingRows") || 0;
                e.change((t => {
                    if (s) {
                        const e = s > a ? a : 0;
                        const n = pR(i, s, e);
                        for (const {cell: e} of n) {
                            bR(e, s, t)
                        }
                    }
                    Cj("headingRows", s, i, t, 0)
                }))
            }

            _isInHeading(t, e) {
                const n = parseInt(e.getAttribute("headingRows") || 0);
                return !!n && t.parent.index < n
            }
        }

        class jR extends nA {
            refresh() {
                const t = this.editor.model;
                const e = nR(t.document.selection);
                const n = this.editor.plugins.get("TableUtils");
                const i = e.length > 0;
                this.isEnabled = i;
                this.value = i && e.every((t => yj(n, t)))
            }

            execute(t = {}) {
                if (t.forceValue === this.value) {
                    return
                }
                const e = this.editor.model;
                const n = nR(e.document.selection);
                const i = n[0].findAncestor("table");
                const {first: o, last: r} = oR(n);
                const s = this.value ? o : r + 1;
                e.change((t => {
                    if (s) {
                        const e = kR(i, s);
                        for (const {cell: n, column: i} of e) {
                            wR(n, i, s, t)
                        }
                    }
                    Cj("headingColumns", s, i, t, 0)
                }))
            }
        }

        class RR extends tA {
            static get pluginName() {
                return "TableUtils"
            }

            init() {
                this.decorate("insertColumns");
                this.decorate("insertRows")
            }

            getCellLocation(t) {
                const e = t.parent;
                const n = e.parent;
                const i = n.getChildIndex(e);
                const o = new Mj(n, {row: i});
                for (const {cell: e, row: n, column: i} of o) {
                    if (e === t) {
                        return {row: n, column: i}
                    }
                }
            }

            createTable(t, e) {
                const n = t.createElement("table");
                const i = parseInt(e.rows) || 2;
                const o = parseInt(e.columns) || 2;
                FR(t, n, 0, i, o);
                if (e.headingRows) {
                    Cj("headingRows", e.headingRows, n, t, 0)
                }
                if (e.headingColumns) {
                    Cj("headingColumns", e.headingColumns, n, t, 0)
                }
                return n
            }

            insertRows(t, e = {}) {
                const n = this.editor.model;
                const i = e.at || 0;
                const o = e.rows || 1;
                const r = e.copyStructureFromAbove !== undefined;
                const s = e.copyStructureFromAbove ? i - 1 : i;
                const a = this.getRows(t);
                const c = this.getColumns(t);
                n.change((e => {
                    const n = t.getAttribute("headingRows") || 0;
                    if (n > i) {
                        Cj("headingRows", n + o, t, e, 0)
                    }
                    if (!r && (i === 0 || i === a)) {
                        FR(e, t, i, o, c);
                        return
                    }
                    const l = r ? Math.max(i, s) : i;
                    const d = new Mj(t, {endRow: l});
                    const u = new Array(c).fill(1);
                    for (const {row: t, column: n, cellHeight: a, cellWidth: c, cell: l} of d) {
                        const d = t + a - 1;
                        const h = t < i && i <= d;
                        const m = t <= s && s <= d;
                        if (h) {
                            e.setAttribute("rowspan", a + o, l);
                            u[n] = -c
                        } else if (r && m) {
                            u[n] = c
                        }
                    }
                    for (let n = 0; n < o; n++) {
                        const n = e.createElement("tableRow");
                        e.insert(n, t, i);
                        for (let t = 0; t < u.length; t++) {
                            const i = u[t];
                            const o = e.createPositionAt(n, "end");
                            if (i > 0) {
                                vj(e, o, i > 1 ? {colspan: i} : null)
                            }
                            t += Math.abs(i) - 1
                        }
                    }
                }))
            }

            insertColumns(t, e = {}) {
                const n = this.editor.model;
                const i = e.at || 0;
                const o = e.columns || 1;
                n.change((e => {
                    const n = t.getAttribute("headingColumns");
                    if (i < n) {
                        e.setAttribute("headingColumns", n + o, t)
                    }
                    const r = this.getColumns(t);
                    if (i === 0 || r === i) {
                        for (const n of t.getChildren()) {
                            VR(o, e, e.createPositionAt(n, i ? "end" : 0))
                        }
                        return
                    }
                    const s = new Mj(t, {column: i, includeAllSlots: true});
                    for (const t of s) {
                        const {row: n, cell: r, cellAnchorColumn: a, cellAnchorRow: c, cellWidth: l, cellHeight: d} = t;
                        if (a < i) {
                            e.setAttribute("colspan", l + o, r);
                            const t = c + d - 1;
                            for (let e = n; e <= t; e++) {
                                s.skipRow(e)
                            }
                        } else {
                            VR(o, e, t.getPositionBefore())
                        }
                    }
                }))
            }

            removeRows(t, e) {
                const n = this.editor.model;
                const i = e.rows || 1;
                const o = e.at;
                const r = o + i - 1;
                n.change((e => {
                    const {cellsToMove: n, cellsToTrim: i} = qR(t, o, r);
                    if (n.size) {
                        const i = r + 1;
                        KR(t, i, n, e)
                    }
                    for (let n = r; n >= o; n--) {
                        e.remove(t.getChild(n))
                    }
                    for (const {rowspan: t, cell: n} of i) {
                        Cj("rowspan", t, n, e)
                    }
                    WR(t, o, r, e);
                    if (!CR(t, this)) {
                        vR(t, this)
                    }
                }))
            }

            removeColumns(t, e) {
                const n = this.editor.model;
                const i = e.at;
                const o = e.columns || 1;
                const r = e.at + o - 1;
                n.change((e => {
                    UR(t, {first: i, last: r}, e);
                    for (let n = r; n >= i; n--) {
                        for (const {cell: i, column: o, cellWidth: r} of [...new Mj(t)]) {
                            if (o <= n && r > 1 && o + r > n) {
                                Cj("colspan", r - 1, i, e)
                            } else if (o === n) {
                                e.remove(i)
                            }
                        }
                    }
                    if (!vR(t, this)) {
                        CR(t, this)
                    }
                }))
            }

            splitCellVertically(t, e = 2) {
                const n = this.editor.model;
                const i = t.parent;
                const o = i.parent;
                const r = parseInt(t.getAttribute("rowspan") || 1);
                const s = parseInt(t.getAttribute("colspan") || 1);
                n.change((n => {
                    if (s > 1) {
                        const {newCellsSpan: i, updatedSpan: o} = HR(s, e);
                        Cj("colspan", o, t, n);
                        const a = {};
                        if (i > 1) {
                            a.colspan = i
                        }
                        if (r > 1) {
                            a.rowspan = r
                        }
                        const c = s > e ? e - 1 : s - 1;
                        VR(c, n, n.createPositionAfter(t), a)
                    }
                    if (s < e) {
                        const i = e - s;
                        const a = [...new Mj(o)];
                        const {column: c} = a.find((({cell: e}) => e === t));
                        const l = a.filter((({cell: e, cellWidth: n, column: i}) => {
                            const o = e !== t && i === c;
                            const r = i < c && i + n > c;
                            return o || r
                        }));
                        for (const {cell: t, cellWidth: e} of l) {
                            n.setAttribute("colspan", e + i, t)
                        }
                        const d = {};
                        if (r > 1) {
                            d.rowspan = r
                        }
                        VR(i, n, n.createPositionAfter(t), d);
                        const u = o.getAttribute("headingColumns") || 0;
                        if (u > c) {
                            Cj("headingColumns", u + i, o, n)
                        }
                    }
                }))
            }

            splitCellHorizontally(t, e = 2) {
                const n = this.editor.model;
                const i = t.parent;
                const o = i.parent;
                const r = o.getChildIndex(i);
                const s = parseInt(t.getAttribute("rowspan") || 1);
                const a = parseInt(t.getAttribute("colspan") || 1);
                n.change((n => {
                    if (s > 1) {
                        const i = [...new Mj(o, {startRow: r, endRow: r + s - 1, includeAllSlots: true})];
                        const {newCellsSpan: c, updatedSpan: l} = HR(s, e);
                        Cj("rowspan", l, t, n);
                        const {column: d} = i.find((({cell: e}) => e === t));
                        const u = {};
                        if (c > 1) {
                            u.rowspan = c
                        }
                        if (a > 1) {
                            u.colspan = a
                        }
                        for (const t of i) {
                            const {column: e, row: i} = t;
                            const o = i >= r + l;
                            const s = e === d;
                            const a = (i + r + l) % c === 0;
                            if (o && s && a) {
                                VR(1, n, t.getPositionBefore(), u)
                            }
                        }
                    }
                    if (s < e) {
                        const i = e - s;
                        const c = [...new Mj(o, {startRow: 0, endRow: r})];
                        for (const {cell: e, cellHeight: o, row: s} of c) {
                            if (e !== t && s + o > r) {
                                const t = o + i;
                                n.setAttribute("rowspan", t, e)
                            }
                        }
                        const l = {};
                        if (a > 1) {
                            l.colspan = a
                        }
                        FR(n, o, r + 1, i, 1, l);
                        const d = o.getAttribute("headingRows") || 0;
                        if (d > r) {
                            Cj("headingRows", d + i, o, n)
                        }
                    }
                }))
            }

            getColumns(t) {
                const e = t.getChild(0);
                return [...e.getChildren()].reduce(((t, e) => {
                    const n = parseInt(e.getAttribute("colspan") || 1);
                    return t + n
                }), 0)
            }

            getRows(t) {
                return t.childCount
            }
        }

        function FR(t, e, n, i, o, r = {}) {
            for (let s = 0; s < i; s++) {
                const i = t.createElement("tableRow");
                t.insert(i, e, n);
                VR(o, t, t.createPositionAt(i, "end"), r)
            }
        }

        function VR(t, e, n, i = {}) {
            for (let o = 0; o < t; o++) {
                vj(e, n, i)
            }
        }

        function HR(t, e) {
            if (t < e) {
                return {newCellsSpan: 1, updatedSpan: 1}
            }
            const n = Math.floor(t / e);
            const i = t - n * e + n;
            return {newCellsSpan: n, updatedSpan: i}
        }

        function UR(t, e, n) {
            const i = t.getAttribute("headingColumns") || 0;
            if (i && e.first < i) {
                const o = Math.min(i - 1, e.last) - e.first + 1;
                n.setAttribute("headingColumns", i - o, t)
            }
        }

        function WR(t, e, n, i) {
            const o = t.getAttribute("headingRows") || 0;
            if (e < o) {
                const r = n < o ? o - (n - e + 1) : e;
                Cj("headingRows", r, t, i, 0)
            }
        }

        function qR(t, e, n) {
            const i = new Map;
            const o = [];
            for (const {row: r, column: s, cellHeight: a, cell: c} of new Mj(t, {endRow: n})) {
                const t = r + a - 1;
                const l = r >= e && r <= n && t > n;
                if (l) {
                    const t = n - r + 1;
                    const e = a - t;
                    i.set(s, {cell: c, rowspan: e})
                }
                const d = r < e && t >= e;
                if (d) {
                    let i;
                    if (t >= n) {
                        i = n - e + 1
                    } else {
                        i = t - e + 1
                    }
                    o.push({cell: c, rowspan: a - i})
                }
            }
            return {cellsToMove: i, cellsToTrim: o}
        }

        function KR(t, e, n, i) {
            const o = new Mj(t, {includeAllSlots: true, row: e});
            const r = [...o];
            const s = t.getChild(e);
            let a;
            for (const {column: t, cell: e, isAnchor: o} of r) {
                if (n.has(t)) {
                    const {cell: e, rowspan: o} = n.get(t);
                    const r = a ? i.createPositionAfter(a) : i.createPositionAt(s, 0);
                    i.move(i.createRangeOn(e), r);
                    Cj("rowspan", o, e, i);
                    a = e
                } else if (o) {
                    a = e
                }
            }
        }

        class GR extends nA {
            refresh() {
                const t = tR(this.editor.model.document.selection);
                this.isEnabled = rR(t, this.editor.plugins.get(RR))
            }

            execute() {
                const t = this.editor.model;
                const e = this.editor.plugins.get(RR);
                t.change((n => {
                    const i = tR(t.document.selection);
                    const o = i.shift();
                    const {mergeWidth: r, mergeHeight: s} = QR(o, i, e);
                    Cj("colspan", r, o, n);
                    Cj("rowspan", s, o, n);
                    for (const t of i) {
                        $R(t, o, n)
                    }
                    const a = o.findAncestor("table");
                    yR(a, e);
                    n.setSelection(o, "in")
                }))
            }
        }

        function $R(t, e, n) {
            if (!YR(t)) {
                if (YR(e)) {
                    n.remove(n.createRangeIn(e))
                }
                n.move(n.createRangeIn(t), n.createPositionAt(e, "end"))
            }
            n.remove(t)
        }

        function YR(t) {
            return t.childCount == 1 && t.getChild(0).is("element", "paragraph") && t.getChild(0).isEmpty
        }

        function QR(t, e, n) {
            let i = 0;
            let o = 0;
            for (const t of e) {
                const {row: e, column: r} = n.getCellLocation(t);
                i = JR(t, r, i, "colspan");
                o = JR(t, e, o, "rowspan")
            }
            const {row: r, column: s} = n.getCellLocation(t);
            const a = i - s;
            const c = o - r;
            return {mergeWidth: a, mergeHeight: c}
        }

        function JR(t, e, n, i) {
            const o = parseInt(t.getAttribute(i) || 1);
            return Math.max(n, e + o)
        }

        class XR extends nA {
            refresh() {
                const t = nR(this.editor.model.document.selection);
                this.isEnabled = t.length > 0
            }

            execute() {
                const t = this.editor.model;
                const e = nR(t.document.selection);
                const n = iR(e);
                const i = e[0].findAncestor("table");
                const o = [];
                for (let e = n.first; e <= n.last; e++) {
                    for (const n of i.getChild(e).getChildren()) {
                        o.push(t.createRangeOn(n))
                    }
                }
                t.change((t => {
                    t.setSelection(o)
                }))
            }
        }

        class ZR extends nA {
            refresh() {
                const t = nR(this.editor.model.document.selection);
                this.isEnabled = t.length > 0
            }

            execute() {
                const t = this.editor.model;
                const e = nR(t.document.selection);
                const n = e[0];
                const i = e.pop();
                const o = n.findAncestor("table");
                const r = this.editor.plugins.get("TableUtils");
                const s = r.getCellLocation(n);
                const a = r.getCellLocation(i);
                const c = Math.min(s.column, a.column);
                const l = Math.max(s.column, a.column);
                const d = [];
                for (const e of new Mj(o, {startColumn: c, endColumn: l})) {
                    d.push(t.createRangeOn(e.cell))
                }
                t.change((t => {
                    t.setSelection(d)
                }))
            }
        }

        function tF(t) {
            t.document.registerPostFixer((e => eF(e, t)))
        }

        function eF(t, e) {
            const n = e.document.differ.getChanges();
            let i = false;
            const o = new Set;
            for (const e of n) {
                let n;
                if (e.name == "table" && e.type == "insert") {
                    n = e.position.nodeAfter
                }
                if (e.name == "tableRow" || e.name == "tableCell") {
                    n = e.position.findAncestor("table")
                }
                if (sF(e)) {
                    n = e.range.start.findAncestor("table")
                }
                if (n && !o.has(n)) {
                    i = nF(n, t) || i;
                    i = iF(n, t) || i;
                    o.add(n)
                }
            }
            return i
        }

        function nF(t, e) {
            let n = false;
            const i = oF(t);
            if (i.length) {
                n = true;
                for (const t of i) {
                    Cj("rowspan", t.rowspan, t.cell, e, 1)
                }
            }
            return n
        }

        function iF(t, e) {
            let n = false;
            const i = rF(t);
            const o = [];
            for (const [t, e] of i.entries()) {
                if (!e) {
                    o.push(t)
                }
            }
            if (o.length) {
                n = true;
                for (const n of o.reverse()) {
                    e.remove(t.getChild(n));
                    i.splice(n, 1)
                }
            }
            const r = i[0];
            const s = i.every((t => t === r));
            if (!s) {
                const o = i.reduce(((t, e) => e > t ? e : t), 0);
                for (const [r, s] of i.entries()) {
                    const i = o - s;
                    if (i) {
                        for (let n = 0; n < i; n++) {
                            vj(e, e.createPositionAt(t.getChild(r), "end"))
                        }
                        n = true
                    }
                }
            }
            return n
        }

        function oF(t) {
            const e = parseInt(t.getAttribute("headingRows") || 0);
            const n = t.childCount;
            const i = [];
            for (const {row: o, cell: r, cellHeight: s} of new Mj(t)) {
                if (s < 2) {
                    continue
                }
                const t = o < e;
                const a = t ? e : n;
                if (o + s > a) {
                    const t = a - o;
                    i.push({cell: r, rowspan: t})
                }
            }
            return i
        }

        function rF(t) {
            const e = new Array(t.childCount).fill(0);
            for (const {row: n} of new Mj(t, {includeAllSlots: true})) {
                e[n]++
            }
            return e
        }

        function sF(t) {
            const e = t.type === "attribute";
            const n = t.attributeKey;
            return e && (n === "headingRows" || n === "colspan" || n === "rowspan")
        }

        function aF(t) {
            t.document.registerPostFixer((e => cF(e, t)))
        }

        function cF(t, e) {
            const n = e.document.differ.getChanges();
            let i = false;
            for (const e of n) {
                if (e.type == "insert" && e.name == "table") {
                    i = lF(e.position.nodeAfter, t) || i
                }
                if (e.type == "insert" && e.name == "tableRow") {
                    i = dF(e.position.nodeAfter, t) || i
                }
                if (e.type == "insert" && e.name == "tableCell") {
                    i = uF(e.position.nodeAfter, t) || i
                }
                if (hF(e)) {
                    i = uF(e.position.parent, t) || i
                }
            }
            return i
        }

        function lF(t, e) {
            let n = false;
            for (const i of t.getChildren()) {
                n = dF(i, e) || n
            }
            return n
        }

        function dF(t, e) {
            let n = false;
            for (const i of t.getChildren()) {
                n = uF(i, e) || n
            }
            return n
        }

        function uF(t, e) {
            if (t.childCount == 0) {
                e.insertElement("paragraph", t);
                return true
            }
            const n = Array.from(t.getChildren()).filter((t => t.is("$text")));
            for (const t of n) {
                e.wrap(e.createRangeOn(t), "paragraph")
            }
            return !!n.length
        }

        function hF(t) {
            if (!t.position || !t.position.parent.is("element", "tableCell")) {
                return false
            }
            return t.type == "insert" && t.name == "$text" || t.type == "remove"
        }

        function mF(t, e) {
            t.document.registerPostFixer((() => gF(t.document.differ, e)))
        }

        function gF(t, e) {
            const n = new Set;
            for (const e of t.getChanges()) {
                const t = e.type == "attribute" ? e.range.start.parent : e.position.parent;
                if (t.is("element", "tableCell")) {
                    n.add(t)
                }
            }
            for (const i of n.values()) {
                for (const n of [...i.getChildren()].filter((t => fF(t, e)))) {
                    t.refreshItem(n)
                }
            }
            return false
        }

        function fF(t, e) {
            if (!t.is("element", "paragraph")) {
                return false
            }
            const n = e.toViewElement(t);
            if (!n) {
                return false
            }
            return Oj(t) !== n.is("element", "span")
        }

        function pF(t) {
            t.document.registerPostFixer((() => bF(t)))
        }

        function bF(t) {
            const e = t.document.differ;
            const n = new Set;
            for (const t of e.getChanges()) {
                if (t.type != "attribute") {
                    continue
                }
                const e = t.range.start.nodeAfter;
                if (e && e.is("element", "table") && t.attributeKey == "headingRows") {
                    n.add(e)
                }
            }
            if (n.size) {
                for (const t of n.values()) {
                    e.refreshItem(t)
                }
                return true
            }
            return false
        }

        var kF = n(72);
        var wF = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        wF.insert = "head";
        wF.singleton = true;
        var AF = ob()(kF["a"], wF);
        var _F = kF["a"].locals || {};

        class CF extends tA {
            static get pluginName() {
                return "TableEditing"
            }

            init() {
                const t = this.editor;
                const e = t.model;
                const n = e.schema;
                const i = t.conversion;
                n.register("table", {
                    allowWhere: "$block",
                    allowAttributes: ["headingRows", "headingColumns"],
                    isObject: true,
                    isBlock: true
                });
                n.register("tableRow", {allowIn: "table", isLimit: true});
                n.register("tableCell", {
                    allowIn: "tableRow",
                    allowAttributes: ["colspan", "rowspan"],
                    isLimit: true,
                    isSelectable: true
                });
                n.extend("$block", {allowIn: "tableCell"});
                n.addChildCheck(((t, e) => {
                    if (e.name == "table" && Array.from(t.getNames()).includes("table")) {
                        return false
                    }
                }));
                i.for("upcast").add(xj());
                i.for("editingDowncast").add(Ij({asWidget: true}));
                i.for("dataDowncast").add(Ij());
                i.for("upcast").elementToElement({model: "tableRow", view: "tr"});
                i.for("upcast").add(Ej());
                i.for("editingDowncast").add(Bj());
                i.for("editingDowncast").add(Nj());
                i.for("upcast").elementToElement({model: "tableCell", view: "td"});
                i.for("upcast").elementToElement({model: "tableCell", view: "th"});
                i.for("editingDowncast").add(Lj());
                t.conversion.for("editingDowncast").elementToElement({
                    model: "paragraph",
                    view: Pj,
                    converterPriority: "high"
                });
                i.attributeToAttribute({model: "colspan", view: "colspan"});
                i.attributeToAttribute({model: "rowspan", view: "rowspan"});
                i.for("editingDowncast").add(zj());
                t.commands.add("insertTable", new Xj(t));
                t.commands.add("insertTableRowAbove", new hR(t, {order: "above"}));
                t.commands.add("insertTableRowBelow", new hR(t, {order: "below"}));
                t.commands.add("insertTableColumnLeft", new mR(t, {order: "left"}));
                t.commands.add("insertTableColumnRight", new mR(t, {order: "right"}));
                t.commands.add("removeTableRow", new BR(t));
                t.commands.add("removeTableColumn", new zR(t));
                t.commands.add("splitTableCellVertically", new gR(t, {direction: "vertically"}));
                t.commands.add("splitTableCellHorizontally", new gR(t, {direction: "horizontally"}));
                t.commands.add("mergeTableCells", new GR(t));
                t.commands.add("mergeTableCellRight", new DR(t, {direction: "right"}));
                t.commands.add("mergeTableCellLeft", new DR(t, {direction: "left"}));
                t.commands.add("mergeTableCellDown", new DR(t, {direction: "down"}));
                t.commands.add("mergeTableCellUp", new DR(t, {direction: "up"}));
                t.commands.add("setTableColumnHeader", new jR(t));
                t.commands.add("setTableRowHeader", new OR(t));
                t.commands.add("selectTableRow", new XR(t));
                t.commands.add("selectTableColumn", new ZR(t));
                pF(e);
                tF(e);
                mF(e, t.editing.mapper);
                aF(e)
            }

            static get requires() {
                return [RR]
            }
        }

        var vF = n(73);
        var yF = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        yF.insert = "head";
        yF.singleton = true;
        var xF = ob()(vF["a"], yF);
        var EF = vF["a"].locals || {};

        class DF extends Zb {
            constructor(t) {
                super(t);
                const e = this.bindTemplate;
                this.items = this._createGridCollection();
                this.set("rows", 0);
                this.set("columns", 0);
                this.bind("label").to(this, "columns", this, "rows", ((t, e) => `${e} × ${t}`));
                this.setTemplate({
                    tag: "div",
                    attributes: {class: ["ck"]},
                    children: [{
                        tag: "div",
                        attributes: {class: ["ck-insert-table-dropdown__grid"]},
                        on: {"mouseover@.ck-insert-table-dropdown-grid-box": e.to("boxover")},
                        children: this.items
                    }, {
                        tag: "div",
                        attributes: {class: ["ck-insert-table-dropdown__label"]},
                        children: [{text: e.to("label")}]
                    }],
                    on: {
                        mousedown: e.to((t => {
                            t.preventDefault()
                        })), click: e.to((() => {
                            this.fire("execute")
                        }))
                    }
                });
                this.on("boxover", ((t, e) => {
                    const {row: n, column: i} = e.target.dataset;
                    this.set({rows: parseInt(n), columns: parseInt(i)})
                }));
                this.on("change:columns", (() => {
                    this._highlightGridBoxes()
                }));
                this.on("change:rows", (() => {
                    this._highlightGridBoxes()
                }))
            }

            focus() {
            }

            focusLast() {
            }

            _highlightGridBoxes() {
                const t = this.rows;
                const e = this.columns;
                this.items.map(((n, i) => {
                    const o = Math.floor(i / 10);
                    const r = i % 10;
                    const s = o < t && r < e;
                    n.set("isOn", s)
                }))
            }

            _createGridCollection() {
                const t = [];
                for (let e = 0; e < 100; e++) {
                    const n = Math.floor(e / 10);
                    const i = e % 10;
                    t.push(new TF(this.locale, n + 1, i + 1))
                }
                return this.createCollection(t)
            }
        }

        class TF extends Zb {
            constructor(t, e, n) {
                super(t);
                const i = this.bindTemplate;
                this.set("isOn", false);
                this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck-insert-table-dropdown-grid-box", i.if("isOn", "ck-on")],
                        "data-row": e,
                        "data-column": n
                    }
                })
            }
        }

        var MF = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 6v3h4V6H3zm0 4v3h4v-3H3zm0 4v3h4v-3H3zm5 3h4v-3H8v3zm5 0h4v-3h-4v3zm4-4v-3h-4v3h4zm0-4V6h-4v3h4zm1.5 8a1.5 1.5 0 0 1-1.5 1.5H3A1.5 1.5 0 0 1 1.5 17V4c.222-.863 1.068-1.5 2-1.5h13c.932 0 1.778.637 2 1.5v13zM12 13v-3H8v3h4zm0-4V6H8v3h4z"/></svg>';
        var SF = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M18 7v1H2V7h16zm0 5v1H2v-1h16z" opacity=".6"/><path d="M14 1v18a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V1a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1zm-2 1H8v4h4V2zm0 6H8v4h4V8zm0 6H8v4h4v-4z"/></svg>';
        var IF = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v16h-1V2z" opacity=".6"/><path d="M1 6h18a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1H1a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1zm1 2v4h4V8H2zm6 0v4h4V8H8zm6 0v4h4V8h-4z"/></svg>';
        var BF = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v7h-1V2zm6 5v1H2V7h16zM8 12v1H2v-1h6z" opacity=".6"/><path d="M7 7h12a1 1 0 0 1 1 1v11a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1zm1 2v9h10V9H8z"/></svg>';

        class LF extends tA {
            init() {
                const t = this.editor;
                const e = this.editor.t;
                const n = t.locale.contentLanguageDirection;
                const i = n === "ltr";
                t.ui.componentFactory.add("insertTable", (n => {
                    const i = t.commands.get("insertTable");
                    const o = Sw(n);
                    o.bind("isEnabled").to(i);
                    o.buttonView.set({icon: MF, label: e("Insert table"), tooltip: true});
                    let r;
                    o.on("change:isOpen", (() => {
                        if (r) {
                            return
                        }
                        r = new DF(n);
                        o.panelView.children.add(r);
                        r.delegate("execute").to(o);
                        o.buttonView.on("open", (() => {
                            r.rows = 0;
                            r.columns = 0
                        }));
                        o.on("execute", (() => {
                            t.execute("insertTable", {rows: r.rows, columns: r.columns});
                            t.editing.view.focus()
                        }))
                    }));
                    return o
                }));
                t.ui.componentFactory.add("tableColumn", (t => {
                    const n = [{
                        type: "switchbutton",
                        model: {commandName: "setTableColumnHeader", label: e("Header column"), bindIsOn: true}
                    }, {type: "separator"}, {
                        type: "button",
                        model: {
                            commandName: i ? "insertTableColumnLeft" : "insertTableColumnRight",
                            label: e("Insert column left")
                        }
                    }, {
                        type: "button",
                        model: {
                            commandName: i ? "insertTableColumnRight" : "insertTableColumnLeft",
                            label: e("Insert column right")
                        }
                    }, {
                        type: "button",
                        model: {commandName: "removeTableColumn", label: e("Delete column")}
                    }, {type: "button", model: {commandName: "selectTableColumn", label: e("Select column")}}];
                    return this._prepareDropdown(e("Column"), SF, n, t)
                }));
                t.ui.componentFactory.add("tableRow", (t => {
                    const n = [{
                        type: "switchbutton",
                        model: {commandName: "setTableRowHeader", label: e("Header row"), bindIsOn: true}
                    }, {type: "separator"}, {
                        type: "button",
                        model: {commandName: "insertTableRowAbove", label: e("Insert row above")}
                    }, {
                        type: "button",
                        model: {commandName: "insertTableRowBelow", label: e("Insert row below")}
                    }, {
                        type: "button",
                        model: {commandName: "removeTableRow", label: e("Delete row")}
                    }, {type: "button", model: {commandName: "selectTableRow", label: e("Select row")}}];
                    return this._prepareDropdown(e("Row"), IF, n, t)
                }));
                t.ui.componentFactory.add("mergeTableCells", (t => {
                    const n = [{
                        type: "button",
                        model: {commandName: "mergeTableCellUp", label: e("Merge cell up")}
                    }, {
                        type: "button",
                        model: {
                            commandName: i ? "mergeTableCellRight" : "mergeTableCellLeft",
                            label: e("Merge cell right")
                        }
                    }, {
                        type: "button",
                        model: {commandName: "mergeTableCellDown", label: e("Merge cell down")}
                    }, {
                        type: "button",
                        model: {
                            commandName: i ? "mergeTableCellLeft" : "mergeTableCellRight",
                            label: e("Merge cell left")
                        }
                    }, {type: "separator"}, {
                        type: "button",
                        model: {commandName: "splitTableCellVertically", label: e("Split cell vertically")}
                    }, {
                        type: "button",
                        model: {commandName: "splitTableCellHorizontally", label: e("Split cell horizontally")}
                    }];
                    return this._prepareMergeSplitButtonDropdown(e("Merge cells"), BF, n, t)
                }))
            }

            _prepareDropdown(t, e, n, i) {
                const o = this.editor;
                const r = Sw(i);
                const s = this._fillDropdownWithListOptions(r, n);
                r.buttonView.set({label: t, icon: e, tooltip: true});
                r.bind("isEnabled").toMany(s, "isEnabled", ((...t) => t.some((t => t))));
                this.listenTo(r, "execute", (t => {
                    o.execute(t.source.commandName);
                    o.editing.view.focus()
                }));
                return r
            }

            _prepareMergeSplitButtonDropdown(t, e, n, i) {
                const o = this.editor;
                const r = Sw(i, dv);
                const s = "mergeTableCells";
                this._fillDropdownWithListOptions(r, n);
                r.buttonView.set({label: t, icon: e, tooltip: true, isEnabled: true});
                this.listenTo(r.buttonView, "execute", (() => {
                    o.execute(s);
                    o.editing.view.focus()
                }));
                this.listenTo(r, "execute", (t => {
                    o.execute(t.source.commandName);
                    o.editing.view.focus()
                }));
                return r
            }

            _fillDropdownWithListOptions(t, e) {
                const n = this.editor;
                const i = [];
                const o = new vs;
                for (const t of e) {
                    zF(t, n, i, o)
                }
                Bw(t, o, n.ui.componentFactory);
                return i
            }
        }

        function zF(t, e, n, i) {
            const o = t.model = new rv(t.model);
            const {commandName: r, bindIsOn: s} = t.model;
            if (t.type === "button" || t.type === "switchbutton") {
                const t = e.commands.get(r);
                n.push(t);
                o.set({commandName: r});
                o.bind("isEnabled").to(t);
                if (s) {
                    o.bind("isOn").to(t, "value")
                }
            }
            o.set({withText: true});
            i.add(t)
        }

        var NF = n(74);
        var PF = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        PF.insert = "head";
        PF.singleton = true;
        var OF = ob()(NF["a"], PF);
        var jF = NF["a"].locals || {};

        class RF extends tA {
            static get pluginName() {
                return "TableSelection"
            }

            static get requires() {
                return [RR]
            }

            init() {
                const t = this.editor;
                const e = t.model;
                this.listenTo(e, "deleteContent", ((t, e) => this._handleDeleteContent(t, e)), {priority: "high"});
                this._defineSelectionConverter();
                this._enablePluginDisabling()
            }

            getSelectedTableCells() {
                const t = this.editor.model.document.selection;
                const e = tR(t);
                if (e.length == 0) {
                    return null
                }
                return e
            }

            getSelectionAsFragment() {
                const t = this.getSelectedTableCells();
                if (!t) {
                    return null
                }
                return this.editor.model.change((e => {
                    const n = e.createDocumentFragment();
                    const i = this.editor.plugins.get("TableUtils");
                    const {first: o, last: r} = oR(t);
                    const {first: s, last: a} = iR(t);
                    const c = t[0].findAncestor("table");
                    let l = a;
                    let d = r;
                    if (rR(t, i)) {
                        const t = {firstColumn: o, lastColumn: r, firstRow: s, lastRow: a};
                        l = xR(c, t);
                        d = ER(c, t)
                    }
                    const u = {startRow: s, startColumn: o, endRow: l, endColumn: d};
                    const h = fR(c, u, e);
                    e.insert(h, n, 0);
                    return n
                }))
            }

            setCellSelection(t, e) {
                const n = this._getCellsToSelect(t, e);
                this.editor.model.change((t => {
                    t.setSelection(n.cells.map((e => t.createRangeOn(e))), {backward: n.backward})
                }))
            }

            getFocusCell() {
                const t = this.editor.model.document.selection;
                const e = [...t.getRanges()].pop();
                const n = e.getContainedElement();
                if (n && n.is("element", "tableCell")) {
                    return n
                }
                return null
            }

            getAnchorCell() {
                const t = this.editor.model.document.selection;
                const e = oA(t.getRanges());
                const n = e.getContainedElement();
                if (n && n.is("element", "tableCell")) {
                    return n
                }
                return null
            }

            _defineSelectionConverter() {
                const t = this.editor;
                const e = new Set;
                t.conversion.for("editingDowncast").add((t => t.on("selection", ((t, i, o) => {
                    const r = o.writer;
                    n(r);
                    const s = this.getSelectedTableCells();
                    if (!s) {
                        return
                    }
                    for (const t of s) {
                        const n = o.mapper.toViewElement(t);
                        r.addClass("ck-editor__editable_selected", n);
                        e.add(n)
                    }
                    const a = o.mapper.toViewElement(s[s.length - 1]);
                    r.setSelection(a, 0)
                }), {priority: "lowest"})));

                function n(t) {
                    for (const n of e) {
                        t.removeClass("ck-editor__editable_selected", n)
                    }
                    e.clear()
                }
            }

            _enablePluginDisabling() {
                const t = this.editor;
                this.on("change:isEnabled", (() => {
                    if (!this.isEnabled) {
                        const e = this.getSelectedTableCells();
                        if (!e) {
                            return
                        }
                        t.model.change((n => {
                            const i = n.createPositionAt(e[0], 0);
                            const o = t.model.schema.getNearestSelectionRange(i);
                            n.setSelection(o)
                        }))
                    }
                }))
            }

            _handleDeleteContent(t, e) {
                const [n, i] = e;
                const o = this.editor.model;
                const r = !i || i.direction == "backward";
                const s = tR(n);
                if (!s.length) {
                    return
                }
                t.stop();
                o.change((t => {
                    const e = s[r ? s.length - 1 : 0];
                    o.change((t => {
                        for (const e of s) {
                            o.deleteContent(t.createSelection(e, "in"))
                        }
                    }));
                    const i = o.schema.getNearestSelectionRange(t.createPositionAt(e, 0));
                    if (n.is("documentSelection")) {
                        t.setSelection(i)
                    } else {
                        n.setTo(i)
                    }
                }))
            }

            _getCellsToSelect(t, e) {
                const n = this.editor.plugins.get("TableUtils");
                const i = n.getCellLocation(t);
                const o = n.getCellLocation(e);
                const r = Math.min(i.row, o.row);
                const s = Math.max(i.row, o.row);
                const a = Math.min(i.column, o.column);
                const c = Math.max(i.column, o.column);
                const l = new Array(s - r + 1).fill(null).map((() => []));
                const d = {startRow: r, endRow: s, startColumn: a, endColumn: c};
                for (const {row: e, cell: n} of new Mj(t.findAncestor("table"), d)) {
                    l[e - r].push(n)
                }
                const u = o.row < i.row;
                const h = o.column < i.column;
                if (u) {
                    l.reverse()
                }
                if (h) {
                    l.forEach((t => t.reverse()))
                }
                return {cells: l.flat(), backward: u || h}
            }
        }

        class FF extends tA {
            static get pluginName() {
                return "TableClipboard"
            }

            static get requires() {
                return [RF, RR]
            }

            init() {
                const t = this.editor;
                const e = t.editing.view.document;
                this.listenTo(e, "copy", ((t, e) => this._onCopyCut(t, e)));
                this.listenTo(e, "cut", ((t, e) => this._onCopyCut(t, e)));
                this.listenTo(t.model, "insertContent", ((t, e) => this._onInsertContent(t, ...e)), {priority: "high"});
                this.decorate("_replaceTableSlotCell")
            }

            _onCopyCut(t, e) {
                const n = this.editor.plugins.get(RF);
                if (!n.getSelectedTableCells()) {
                    return
                }
                if (t.name == "cut" && this.editor.isReadOnly) {
                    return
                }
                e.preventDefault();
                t.stop();
                const i = this.editor.data;
                const o = this.editor.editing.view.document;
                const r = i.toView(n.getSelectionAsFragment());
                o.fire("clipboardOutput", {dataTransfer: e.dataTransfer, content: r, method: t.name})
            }

            _onInsertContent(t, e, n) {
                if (n && !n.is("documentSelection")) {
                    return
                }
                const i = this.editor.model;
                const o = this.editor.plugins.get(RR);
                let r = VF(e, i);
                if (!r) {
                    return
                }
                const s = nR(i.document.selection);
                if (!s.length) {
                    yR(r, o);
                    return
                }
                t.stop();
                i.change((t => {
                    const e = {width: o.getColumns(r), height: o.getRows(r)};
                    const n = HF(s, e, t, o);
                    const i = n.lastRow - n.firstRow + 1;
                    const a = n.lastColumn - n.firstColumn + 1;
                    const c = {
                        startRow: 0,
                        startColumn: 0,
                        endRow: Math.min(i, e.height) - 1,
                        endColumn: Math.min(a, e.width) - 1
                    };
                    r = fR(r, c, t);
                    const l = s[0].findAncestor("table");
                    const d = this._replaceSelectedCellsWithPasted(r, e, l, n, t);
                    if (this.editor.plugins.get("TableSelection").isEnabled) {
                        const e = sR(d.map((e => t.createRangeOn(e))));
                        t.setSelection(e)
                    } else {
                        t.setSelection(d[0], 0)
                    }
                }))
            }

            _replaceSelectedCellsWithPasted(t, e, n, i, o) {
                const {width: r, height: s} = e;
                const a = WF(t, r, s);
                const c = [...new Mj(n, {
                    startRow: i.firstRow,
                    endRow: i.lastRow,
                    startColumn: i.firstColumn,
                    endColumn: i.lastColumn,
                    includeAllSlots: true
                })];
                const l = [];
                let d;
                for (const t of c) {
                    const {row: e, column: n} = t;
                    if (n === i.firstColumn) {
                        d = t.getPositionBefore()
                    }
                    const c = e - i.firstRow;
                    const u = n - i.firstColumn;
                    const h = a[c % s][u % r];
                    const m = h ? o.cloneElement(h) : null;
                    const g = this._replaceTableSlotCell(t, m, d, o);
                    if (!g) {
                        continue
                    }
                    AR(g, e, n, i.lastRow, i.lastColumn, o);
                    l.push(g);
                    d = o.createPositionAfter(g)
                }
                const u = parseInt(n.getAttribute("headingRows") || 0);
                const h = parseInt(n.getAttribute("headingColumns") || 0);
                const m = i.firstRow < u && u <= i.lastRow;
                const g = i.firstColumn < h && h <= i.lastColumn;
                if (m) {
                    const t = {first: i.firstColumn, last: i.lastColumn};
                    const e = KF(n, u, t, o, i.firstRow);
                    l.push(...e)
                }
                if (g) {
                    const t = {first: i.firstRow, last: i.lastRow};
                    const e = GF(n, h, t, o);
                    l.push(...e)
                }
                return l
            }

            _replaceTableSlotCell(t, e, n, i) {
                const {cell: o, isAnchor: r} = t;
                if (r) {
                    i.remove(o)
                }
                if (!e) {
                    return null
                }
                i.insert(e, n);
                return e
            }
        }

        function VF(t, e) {
            if (!t.is("documentFragment") && !t.is("element")) {
                return null
            }
            if (t.is("element", "table")) {
                return t
            }
            if (t.childCount == 1 && t.getChild(0).is("element", "table")) {
                return t.getChild(0)
            }
            const n = e.createRangeIn(t);
            for (const t of n.getItems()) {
                if (t.is("element", "table")) {
                    const i = e.createRange(n.start, e.createPositionBefore(t));
                    if (e.hasContent(i, {ignoreWhitespaces: true})) {
                        return null
                    }
                    const o = e.createRange(e.createPositionAfter(t), n.end);
                    if (e.hasContent(o, {ignoreWhitespaces: true})) {
                        return null
                    }
                    return t
                }
            }
            return null
        }

        function HF(t, e, n, i) {
            const o = t[0].findAncestor("table");
            const r = oR(t);
            const s = iR(t);
            const a = {firstColumn: r.first, lastColumn: r.last, firstRow: s.first, lastRow: s.last};
            const c = t.length === 1;
            if (c) {
                a.lastRow += e.height - 1;
                a.lastColumn += e.width - 1;
                UF(o, a.lastRow + 1, a.lastColumn + 1, i)
            }
            if (c || !rR(t, i)) {
                qF(o, a, n)
            } else {
                a.lastRow = xR(o, a);
                a.lastColumn = ER(o, a)
            }
            return a
        }

        function UF(t, e, n, i) {
            const o = i.getColumns(t);
            const r = i.getRows(t);
            if (n > o) {
                i.insertColumns(t, {at: o, columns: n - o})
            }
            if (e > r) {
                i.insertRows(t, {at: r, rows: e - r})
            }
        }

        function WF(t, e, n) {
            const i = new Array(n).fill(null).map((() => new Array(e).fill(null)));
            for (const {column: e, row: n, cell: o} of new Mj(t)) {
                i[n][e] = o
            }
            return i
        }

        function qF(t, e, n) {
            const {firstRow: i, lastRow: o, firstColumn: r, lastColumn: s} = e;
            const a = {first: i, last: o};
            const c = {first: r, last: s};
            GF(t, r, a, n);
            GF(t, s + 1, a, n);
            KF(t, i, c, n);
            KF(t, o + 1, c, n, i)
        }

        function KF(t, e, n, i, o = 0) {
            if (e < 1) {
                return
            }
            const r = pR(t, e, o);
            const s = r.filter((({column: t, cellWidth: e}) => $F(t, e, n)));
            return s.map((({cell: t}) => bR(t, e, i)))
        }

        function GF(t, e, n, i) {
            if (e < 1) {
                return
            }
            const o = kR(t, e);
            const r = o.filter((({row: t, cellHeight: e}) => $F(t, e, n)));
            return r.map((({cell: t, column: n}) => wR(t, n, e, i)))
        }

        function $F(t, e, n) {
            const i = t + e - 1;
            const {first: o, last: r} = n;
            const s = t >= o && t <= r;
            const a = t < o && i >= o;
            return s || a
        }

        class YF extends tA {
            static get pluginName() {
                return "TableKeyboard"
            }

            static get requires() {
                return [RF]
            }

            init() {
                const t = this.editor.editing.view;
                const e = t.document;
                this.editor.keystrokes.set("Tab", ((...t) => this._handleTabOnSelectedTable(...t)), {priority: "low"});
                this.editor.keystrokes.set("Tab", this._getTabHandler(true), {priority: "low"});
                this.editor.keystrokes.set("Shift+Tab", this._getTabHandler(false), {priority: "low"});
                this.listenTo(e, "keydown", ((...t) => this._onKeydown(...t)), {priority: os.get("high") - 10})
            }

            _handleTabOnSelectedTable(t, e) {
                const n = this.editor;
                const i = n.model.document.selection;
                const o = i.getSelectedElement();
                if (!o || !o.is("element", "table")) {
                    return
                }
                e();
                n.model.change((t => {
                    t.setSelection(t.createRangeIn(o.getChild(0).getChild(0)))
                }))
            }

            _getTabHandler(t) {
                const e = this.editor;
                return (n, i) => {
                    const o = e.model.document.selection;
                    let r = eR(o)[0];
                    if (!r) {
                        r = this.editor.plugins.get("TableSelection").getFocusCell()
                    }
                    if (!r) {
                        return
                    }
                    i();
                    const s = r.parent;
                    const a = s.parent;
                    const c = a.getChildIndex(s);
                    const l = s.getChildIndex(r);
                    const d = l === 0;
                    if (!t && d && c === 0) {
                        e.model.change((t => {
                            t.setSelection(t.createRangeOn(a))
                        }));
                        return
                    }
                    const u = l === s.childCount - 1;
                    const h = c === a.childCount - 1;
                    if (t && h && u) {
                        e.execute("insertTableRowBelow");
                        if (c === a.childCount - 1) {
                            e.model.change((t => {
                                t.setSelection(t.createRangeOn(a))
                            }));
                            return
                        }
                    }
                    let m;
                    if (t && u) {
                        const t = a.getChild(c + 1);
                        m = t.getChild(0)
                    } else if (!t && d) {
                        const t = a.getChild(c - 1);
                        m = t.getChild(t.childCount - 1)
                    } else {
                        m = s.getChild(l + (t ? 1 : -1))
                    }
                    e.model.change((t => {
                        t.setSelection(t.createRangeIn(m))
                    }))
                }
            }

            _onKeydown(t, e) {
                const n = this.editor;
                const i = e.keyCode;
                if (!Rl(i)) {
                    return
                }
                const o = Fl(i, n.locale.contentLanguageDirection);
                const r = this._handleArrowKeys(o, e.shiftKey);
                if (r) {
                    e.preventDefault();
                    e.stopPropagation();
                    t.stop()
                }
            }

            _handleArrowKeys(t, e) {
                const n = this.editor.model;
                const i = n.document.selection;
                const o = ["right", "down"].includes(t);
                const r = tR(i);
                if (r.length) {
                    let n;
                    if (e) {
                        n = this.editor.plugins.get("TableSelection").getFocusCell()
                    } else {
                        n = o ? r[r.length - 1] : r[0]
                    }
                    this._navigateFromCellInDirection(n, t, e);
                    return true
                }
                const s = i.focus.findAncestor("tableCell");
                if (!s) {
                    return false
                }
                if (e && !i.isCollapsed && i.isBackward == o) {
                    return false
                }
                if (this._isSelectionAtCellEdge(i, s, o)) {
                    this._navigateFromCellInDirection(s, t, e);
                    return true
                }
                return false
            }

            _isSelectionAtCellEdge(t, e, n) {
                const i = this.editor.model;
                const o = this.editor.model.schema;
                const r = n ? t.getLastPosition() : t.getFirstPosition();
                if (!o.getLimitElement(r).is("element", "tableCell")) {
                    const t = i.createPositionAt(e, n ? "end" : 0);
                    return t.isTouching(r)
                }
                const s = i.createSelection(r);
                i.modifySelection(s, {direction: n ? "forward" : "backward"});
                return r.isEqual(s.focus)
            }

            _navigateFromCellInDirection(t, e, n = false) {
                const i = this.editor.model;
                const o = t.findAncestor("table");
                const r = [...new Mj(o, {includeAllSlots: true})];
                const {row: s, column: a} = r[r.length - 1];
                const c = r.find((({cell: e}) => e == t));
                let {row: l, column: d} = c;
                switch (e) {
                    case"left":
                        d--;
                        break;
                    case"up":
                        l--;
                        break;
                    case"right":
                        d += c.cellWidth;
                        break;
                    case"down":
                        l += c.cellHeight;
                        break
                }
                const u = l < 0 || l > s;
                const h = d < 0 && l <= 0;
                const m = d > a && l >= s;
                if (u || h || m) {
                    i.change((t => {
                        t.setSelection(t.createRangeOn(o))
                    }));
                    return
                }
                if (d < 0) {
                    d = n ? 0 : a;
                    l--
                } else if (d > a) {
                    d = n ? a : 0;
                    l++
                }
                const g = r.find((t => t.row == l && t.column == d)).cell;
                const f = ["right", "down"].includes(e);
                const p = this.editor.plugins.get("TableSelection");
                if (n && p.isEnabled) {
                    const e = p.getAnchorCell() || t;
                    p.setCellSelection(e, g)
                } else {
                    const t = i.createPositionAt(g, f ? 0 : "end");
                    i.change((e => {
                        e.setSelection(t)
                    }))
                }
            }
        }

        class QF extends eh {
            constructor(t) {
                super(t);
                this.domEventType = ["mousemove", "mouseup", "mouseleave"]
            }

            onDomEvent(t) {
                this.fire(t.type, t)
            }
        }

        class JF extends tA {
            static get pluginName() {
                return "TableMouse"
            }

            static get requires() {
                return [RF]
            }

            init() {
                const t = this.editor;
                t.editing.view.addObserver(QF);
                this._enableShiftClickSelection();
                this._enableMouseDragSelection()
            }

            _enableShiftClickSelection() {
                const t = this.editor;
                let e = false;
                const n = t.plugins.get(RF);
                this.listenTo(t.editing.view.document, "mousedown", ((i, o) => {
                    if (!this.isEnabled || !n.isEnabled) {
                        return
                    }
                    if (!o.domEvent.shiftKey) {
                        return
                    }
                    const r = n.getAnchorCell() || eR(t.model.document.selection)[0];
                    if (!r) {
                        return
                    }
                    const s = this._getModelTableCellFromDomEvent(o);
                    if (s && XF(r, s)) {
                        e = true;
                        n.setCellSelection(r, s);
                        o.preventDefault()
                    }
                }));
                this.listenTo(t.editing.view.document, "mouseup", (() => {
                    e = false
                }));
                this.listenTo(t.editing.view.document, "selectionChange", (t => {
                    if (e) {
                        t.stop()
                    }
                }), {priority: "highest"})
            }

            _enableMouseDragSelection() {
                const t = this.editor;
                let e, n;
                let i = false;
                let o = false;
                const r = t.plugins.get(RF);
                this.listenTo(t.editing.view.document, "mousedown", ((t, n) => {
                    if (!this.isEnabled || !r.isEnabled) {
                        return
                    }
                    if (n.domEvent.shiftKey || n.domEvent.ctrlKey || n.domEvent.altKey) {
                        return
                    }
                    e = this._getModelTableCellFromDomEvent(n)
                }));
                this.listenTo(t.editing.view.document, "mousemove", ((t, s) => {
                    if (!s.domEvent.buttons) {
                        return
                    }
                    if (!e) {
                        return
                    }
                    const a = this._getModelTableCellFromDomEvent(s);
                    if (a && XF(e, a)) {
                        n = a;
                        if (!i && n != e) {
                            i = true
                        }
                    }
                    if (!i) {
                        return
                    }
                    o = true;
                    r.setCellSelection(e, n);
                    s.preventDefault()
                }));
                this.listenTo(t.editing.view.document, "mouseup", (() => {
                    i = false;
                    o = false;
                    e = null;
                    n = null
                }));
                this.listenTo(t.editing.view.document, "selectionChange", (t => {
                    if (o) {
                        t.stop()
                    }
                }), {priority: "highest"})
            }

            _getModelTableCellFromDomEvent(t) {
                const e = t.target;
                const n = this.editor.editing.view.createPositionAt(e, 0);
                const i = this.editor.editing.mapper.toModelPosition(n);
                const o = i.parent;
                return o.findAncestor("tableCell", {includeSelf: true})
            }
        }

        function XF(t, e) {
            return t.parent.parent == e.parent.parent
        }

        var ZF = n(75);
        var tV = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        tV.insert = "head";
        tV.singleton = true;
        var eV = ob()(ZF["a"], tV);
        var nV = ZF["a"].locals || {};

        class iV extends tA {
            static get requires() {
                return [CF, LF, RF, JF, YF, FF, qT]
            }

            static get pluginName() {
                return "Table"
            }
        }

        var oV = n(76);
        var rV = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        rV.insert = "head";
        rV.singleton = true;
        var sV = ob()(oV["a"], rV);
        var aV = oV["a"].locals || {};

        class cV extends Zb {
            constructor(t, e) {
                super(t);
                const n = this.bindTemplate;
                this.set("value", "");
                this.set("id");
                this.set("isReadOnly", false);
                this.set("hasError", false);
                this.set("ariaDescribedById");
                this.options = e;
                this._dropdownView = this._createDropdownView(t);
                this._inputView = this._createInputTextView(t);
                this._stillTyping = false;
                this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-input-color", n.if("hasError", "ck-error")],
                        id: n.to("id"),
                        "aria-invalid": n.if("hasError", true),
                        "aria-describedby": n.to("ariaDescribedById")
                    },
                    children: [this._inputView, this._dropdownView]
                });
                this.on("change:value", ((t, e, n) => this._setInputValue(n)))
            }

            focus() {
                this._inputView.focus()
            }

            _createDropdownView() {
                const t = this.locale;
                const e = t.t;
                const n = this.bindTemplate;
                const i = this._createColorGrid(t);
                const o = Sw(t);
                const r = new Zb;
                const s = this._createRemoveColorButton(t);
                r.setTemplate({
                    tag: "span",
                    attributes: {
                        class: ["ck", "ck-input-color__button__preview"],
                        style: {backgroundColor: n.to("value")}
                    },
                    children: [{
                        tag: "span",
                        attributes: {class: ["ck", "ck-input-color__button__preview__no-color-indicator", n.if("value", "ck-hidden", (t => t != ""))]}
                    }]
                });
                o.buttonView.extendTemplate({attributes: {class: "ck-input-color__button"}});
                o.buttonView.children.add(r);
                o.buttonView.tooltip = e("Color picker");
                o.panelPosition = t.uiLanguageDirection === "rtl" ? "se" : "sw";
                o.panelView.children.add(s);
                o.panelView.children.add(i);
                o.bind("isEnabled").to(this, "isReadOnly", (t => !t));
                return o
            }

            _createInputTextView() {
                const t = this.locale;
                const e = new rM(t);
                e.extendTemplate({on: {blur: e.bindTemplate.to("blur")}});
                e.value = this.value;
                e.bind("isReadOnly").to(this);
                e.bind("hasError").to(this);
                e.on("input", (() => {
                    const t = e.element.value;
                    const n = this.options.colorDefinitions.find((e => t === e.label));
                    this._stillTyping = true;
                    this.value = n && n.color || t
                }));
                e.on("blur", (() => {
                    this._stillTyping = false;
                    this._setInputValue(e.element.value)
                }));
                e.delegate("input").to(this);
                return e
            }

            _createRemoveColorButton() {
                const t = this.locale;
                const e = t.t;
                const n = new sw(t);
                n.class = "ck-input-color__remove-color";
                n.withText = true;
                n.icon = jy;
                n.label = e("Remove color");
                n.on("execute", (() => {
                    this.value = "";
                    this._dropdownView.isOpen = false;
                    this.fire("input")
                }));
                return n
            }

            _createColorGrid(t) {
                const e = new Py(t, {colorDefinitions: this.options.colorDefinitions, columns: this.options.columns});
                e.on("execute", ((t, e) => {
                    this.value = e.value;
                    this._dropdownView.isOpen = false;
                    this.fire("input")
                }));
                e.bind("selectedColor").to(this, "value");
                return e
            }

            _setInputValue(t) {
                if (!this._stillTyping) {
                    const e = lV(t);
                    const n = this.options.colorDefinitions.find((t => e === lV(t.color)));
                    if (n) {
                        this._inputView.value = n.label
                    } else {
                        this._inputView.value = t || ""
                    }
                }
            }
        }

        function lV(t) {
            return t.replace(/([(,])\s+/g, "$1").replace(/^\s+|\s+(?=[),\s]|$)/g, "").replace(/,|\s/g, " ")
        }

        const dV = t => t === "";

        function uV(t) {
            return {
                none: t("None"),
                solid: t("Solid"),
                dotted: t("Dotted"),
                dashed: t("Dashed"),
                double: t("Double"),
                groove: t("Groove"),
                ridge: t("Ridge"),
                inset: t("Inset"),
                outset: t("Outset")
            }
        }

        function hV(t) {
            return t('The color is invalid. Try "#FF0000" or "rgb(255,0,0)" or "red".')
        }

        function mV(t) {
            return t('The value is invalid. Try "10px" or "2em" or simply "2".')
        }

        function gV(t) {
            t = t.trim();
            return dV(t) || sx(t)
        }

        function fV(t) {
            t = t.trim();
            return dV(t) || _V(t) || dx(t) || hx(t)
        }

        function pV(t) {
            t = t.trim();
            return dV(t) || _V(t) || dx(t)
        }

        function bV(t) {
            const e = new vs;
            const n = uV(t.t);
            for (const i in n) {
                const o = {
                    type: "button",
                    model: new rv({_borderStyleValue: i === "none" ? "" : i, label: n[i], withText: true})
                };
                if (i === "none") {
                    o.model.bind("isOn").to(t, "borderStyle", (t => !t))
                } else {
                    o.model.bind("isOn").to(t, "borderStyle", (t => t === i))
                }
                e.add(o)
            }
            return e
        }

        function kV({view: t, icons: e, toolbar: n, labels: i, propertyName: o, nameToValue: r}) {
            for (const s in i) {
                const a = new sw(t.locale);
                a.set({label: i[s], icon: e[s], tooltip: i[s]});
                a.bind("isOn").to(t, o, (t => t === r(s)));
                a.on("execute", (() => {
                    t[o] = r(s)
                }));
                n.items.add(a)
            }
        }

        const wV = [{color: "hsl(0, 0%, 0%)", label: "Black"}, {
            color: "hsl(0, 0%, 30%)",
            label: "Dim grey"
        }, {color: "hsl(0, 0%, 60%)", label: "Grey"}, {
            color: "hsl(0, 0%, 90%)",
            label: "Light grey"
        }, {color: "hsl(0, 0%, 100%)", label: "White", hasBorder: true}, {
            color: "hsl(0, 75%, 60%)",
            label: "Red"
        }, {color: "hsl(30, 75%, 60%)", label: "Orange"}, {
            color: "hsl(60, 75%, 60%)",
            label: "Yellow"
        }, {color: "hsl(90, 75%, 60%)", label: "Light green"}, {
            color: "hsl(120, 75%, 60%)",
            label: "Green"
        }, {color: "hsl(150, 75%, 60%)", label: "Aquamarine"}, {
            color: "hsl(180, 75%, 60%)",
            label: "Turquoise"
        }, {color: "hsl(210, 75%, 60%)", label: "Light blue"}, {
            color: "hsl(240, 75%, 60%)",
            label: "Blue"
        }, {color: "hsl(270, 75%, 60%)", label: "Purple"}];

        function AV(t) {
            return (e, n, i) => {
                const o = new cV(e.locale, {colorDefinitions: CV(t.colorConfig), columns: t.columns});
                o.set({id: n, ariaDescribedById: i});
                o.bind("isReadOnly").to(e, "isEnabled", (t => !t));
                o.bind("errorText").to(e);
                o.on("input", (() => {
                    e.errorText = null
                }));
                return o
            }
        }

        function _V(t) {
            const e = parseFloat(t);
            return !Number.isNaN(e) && t === String(e)
        }

        function CV(t) {
            return t.map((t => ({color: t.model, label: t.label, options: {hasBorder: t.hasBorder}})))
        }

        var vV = n(77);
        var yV = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        yV.insert = "head";
        yV.singleton = true;
        var xV = ob()(vV["a"], yV);
        var EV = vV["a"].locals || {};

        class DV extends Zb {
            constructor(t, e = {}) {
                super(t);
                const n = this.bindTemplate;
                this.set("class", e.class || null);
                this.children = this.createCollection();
                if (e.children) {
                    e.children.forEach((t => this.children.add(t)))
                }
                this.set("_role", null);
                this.set("_ariaLabelledBy", null);
                if (e.labelView) {
                    this.set({_role: "group", _ariaLabelledBy: e.labelView.id})
                }
                this.setTemplate({
                    tag: "div",
                    attributes: {
                        class: ["ck", "ck-form__row", n.to("class")],
                        role: n.to("_role"),
                        "aria-labelledby": n.to("_ariaLabelledBy")
                    },
                    children: this.children
                })
            }
        }

        var TV = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.261 7.062l2.88 1.663a.75.75 0 0 1-.75 1.3L10.5 8.933v7.317a.75.75 0 1 1-1.5 0V8.932l-1.89 1.093a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .511-.187.752.752 0 0 1 .511.187zM15.25 4a.75.75 0 1 1 0 1.5H4.75a.75.75 0 0 1 0-1.5h10.5z"/></svg>';
        var MV = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.75 11.875a.752.752 0 0 1 .508.184l2.883 1.666a.75.75 0 0 1-.659 1.344l-.091-.044-1.892-1.093.001 4.318a.75.75 0 1 1-1.5 0v-4.317l-1.89 1.092a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .51-.187zM15.25 9a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM9.75.375a.75.75 0 0 1 .75.75v4.318l1.89-1.093.092-.045a.75.75 0 0 1 .659 1.344l-2.883 1.667a.752.752 0 0 1-.508.184.752.752 0 0 1-.511-.187L6.359 5.65a.75.75 0 0 1 .75-1.299L9 5.442V1.125a.75.75 0 0 1 .75-.75z"/></svg>';
        var SV = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.239 13.938l-2.88-1.663a.75.75 0 0 1 .75-1.3L9 12.067V4.75a.75.75 0 1 1 1.5 0v7.318l1.89-1.093a.75.75 0 0 1 .75 1.3l-2.879 1.663a.752.752 0 0 1-.511.187.752.752 0 0 1-.511-.187zM4.25 17a.75.75 0 1 1 0-1.5h10.5a.75.75 0 0 1 0 1.5H4.25z"/></svg>';
        var IV = n(78);
        var BV = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        BV.insert = "head";
        BV.singleton = true;
        var LV = ob()(IV["a"], BV);
        var zV = IV["a"].locals || {};
        var NV = n(79);
        var PV = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        PV.insert = "head";
        PV.singleton = true;
        var OV = ob()(NV["a"], PV);
        var jV = NV["a"].locals || {};
        var RV = n(80);
        var FV = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        FV.insert = "head";
        FV.singleton = true;
        var VV = ob()(RV["a"], FV);
        var HV = RV["a"].locals || {};
        const UV = {left: gA, center: pA, right: fA, justify: bA, top: TV, middle: MV, bottom: SV};

        class WV extends Zb {
            constructor(t, e) {
                super(t);
                this.set({
                    borderStyle: "",
                    borderWidth: "",
                    borderColor: "",
                    padding: "",
                    backgroundColor: "",
                    width: "",
                    height: "",
                    horizontalAlignment: "",
                    verticalAlignment: ""
                });
                this.options = e;
                const {borderStyleDropdown: n, borderWidthInput: i, borderColorInput: o, borderRowLabel: r} = this._createBorderFields();
                const {widthInput: s, operatorLabel: a, heightInput: c, dimensionsLabel: l} = this._createDimensionFields();
                const {horizontalAlignmentToolbar: d, verticalAlignmentToolbar: u, alignmentLabel: h} = this._createAlignmentFields();
                this.focusTracker = new Zp;
                this.keystrokes = new Fp;
                this.children = this.createCollection();
                this.borderStyleDropdown = n;
                this.borderWidthInput = i;
                this.borderColorInput = o;
                this.backgroundInput = this._createBackgroundField();
                this.paddingInput = this._createPaddingField();
                this.widthInput = s;
                this.heightInput = c;
                this.horizontalAlignmentToolbar = d;
                this.verticalAlignmentToolbar = u;
                const {saveButtonView: m, cancelButtonView: g} = this._createActionButtons();
                this.saveButtonView = m;
                this.cancelButtonView = g;
                this._focusables = new Ab;
                this._focusCycler = new xk({
                    focusables: this._focusables,
                    focusTracker: this.focusTracker,
                    keystrokeHandler: this.keystrokes,
                    actions: {focusPrevious: "shift + tab", focusNext: "tab"}
                });
                this.children.add(new BO(t, {label: this.t("Cell properties")}));
                this.children.add(new DV(t, {
                    labelView: r,
                    children: [r, n, o, i],
                    class: "ck-table-form__border-row"
                }));
                this.children.add(new DV(t, {children: [this.backgroundInput]}));
                this.children.add(new DV(t, {
                    children: [new DV(t, {
                        labelView: l,
                        children: [l, s, a, c],
                        class: "ck-table-form__dimensions-row"
                    }), new DV(t, {children: [this.paddingInput], class: "ck-table-cell-properties-form__padding-row"})]
                }));
                this.children.add(new DV(t, {
                    labelView: h,
                    children: [h, d, u],
                    class: "ck-table-cell-properties-form__alignment-row"
                }));
                this.children.add(new DV(t, {
                    children: [this.saveButtonView, this.cancelButtonView],
                    class: "ck-table-form__action-row"
                }));
                this.setTemplate({
                    tag: "form",
                    attributes: {
                        class: ["ck", "ck-form", "ck-table-form", "ck-table-cell-properties-form"],
                        tabindex: "-1"
                    },
                    children: this.children
                })
            }

            render() {
                super.render();
                cM({view: this});
                [this.borderStyleDropdown, this.borderColorInput, this.borderWidthInput, this.backgroundInput, this.widthInput, this.heightInput, this.paddingInput, this.horizontalAlignmentToolbar, this.verticalAlignmentToolbar, this.saveButtonView, this.cancelButtonView].forEach((t => {
                    this._focusables.add(t);
                    this.focusTracker.add(t.element)
                }));
                this.keystrokes.listenTo(this.element)
            }

            focus() {
                this._focusCycler.focusFirst()
            }

            _createBorderFields() {
                const t = AV({colorConfig: this.options.borderColors, columns: 5});
                const e = this.locale;
                const n = this.t;
                const i = new gk(e);
                i.text = n("Border");
                const o = uV(n);
                const r = new tM(e, aM);
                r.set({label: n("Style"), class: "ck-table-form__border-style"});
                r.fieldView.buttonView.set({isOn: false, withText: true, tooltip: n("Style")});
                r.fieldView.buttonView.bind("label").to(this, "borderStyle", (t => o[t ? t : "none"]));
                r.fieldView.on("execute", (t => {
                    this.borderStyle = t.source._borderStyleValue
                }));
                Bw(r.fieldView, bV(this));
                const s = new tM(e, sM);
                s.set({label: n("Width"), class: "ck-table-form__border-width"});
                s.fieldView.bind("value").to(this, "borderWidth");
                s.bind("isEnabled").to(this, "borderStyle", qV);
                s.fieldView.on("input", (() => {
                    this.borderWidth = s.fieldView.element.value
                }));
                const a = new tM(e, t);
                a.set({label: n("Color"), class: "ck-table-form__border-color"});
                a.fieldView.bind("value").to(this, "borderColor");
                a.bind("isEnabled").to(this, "borderStyle", qV);
                a.fieldView.on("input", (() => {
                    this.borderColor = a.fieldView.value
                }));
                this.on("change:borderStyle", ((t, e, n) => {
                    if (!qV(n)) {
                        this.borderColor = "";
                        this.borderWidth = ""
                    }
                }));
                return {borderRowLabel: i, borderStyleDropdown: r, borderColorInput: a, borderWidthInput: s}
            }

            _createBackgroundField() {
                const t = this.locale;
                const e = this.t;
                const n = AV({colorConfig: this.options.backgroundColors, columns: 5});
                const i = new tM(t, n);
                i.set({label: e("Background"), class: "ck-table-cell-properties-form__background"});
                i.fieldView.bind("value").to(this, "backgroundColor");
                i.fieldView.on("input", (() => {
                    this.backgroundColor = i.fieldView.value
                }));
                return i
            }

            _createDimensionFields() {
                const t = this.locale;
                const e = this.t;
                const n = new gk(t);
                n.text = e("Dimensions");
                const i = new tM(t, sM);
                i.set({label: e("Width"), class: "ck-table-form__dimensions-row__width"});
                i.fieldView.bind("value").to(this, "width");
                i.fieldView.on("input", (() => {
                    this.width = i.fieldView.element.value
                }));
                const o = new Zb(t);
                o.setTemplate({
                    tag: "span",
                    attributes: {class: ["ck-table-form__dimension-operator"]},
                    children: [{text: "×"}]
                });
                const r = new tM(t, sM);
                r.set({label: e("Height"), class: "ck-table-form__dimensions-row__height"});
                r.fieldView.bind("value").to(this, "height");
                r.fieldView.on("input", (() => {
                    this.height = r.fieldView.element.value
                }));
                return {dimensionsLabel: n, widthInput: i, operatorLabel: o, heightInput: r}
            }

            _createPaddingField() {
                const t = this.locale;
                const e = this.t;
                const n = new tM(t, sM);
                n.set({label: e("Padding"), class: "ck-table-cell-properties-form__padding"});
                n.fieldView.bind("value").to(this, "padding");
                n.fieldView.on("input", (() => {
                    this.padding = n.fieldView.element.value
                }));
                return n
            }

            _createAlignmentFields() {
                const t = this.locale;
                const e = this.t;
                const n = new gk(t);
                n.text = e("Table cell text alignment");
                const i = new Hw(t);
                const o = this.locale.contentLanguageDirection === "rtl";
                i.set({isCompact: true, ariaLabel: e("Horizontal text alignment toolbar")});
                kV({
                    view: this,
                    icons: UV,
                    toolbar: i,
                    labels: this._horizontalAlignmentLabels,
                    propertyName: "horizontalAlignment",
                    nameToValue: t => t === (o ? "right" : "left") ? "" : t
                });
                const r = new Hw(t);
                r.set({isCompact: true, ariaLabel: e("Vertical text alignment toolbar")});
                kV({
                    view: this,
                    icons: UV,
                    toolbar: r,
                    labels: this._verticalAlignmentLabels,
                    propertyName: "verticalAlignment",
                    nameToValue: t => t === "middle" ? "" : t
                });
                return {horizontalAlignmentToolbar: i, verticalAlignmentToolbar: r, alignmentLabel: n}
            }

            _createActionButtons() {
                const t = this.locale;
                const e = this.t;
                const n = new sw(t);
                const i = new sw(t);
                const o = [this.borderWidthInput, this.borderColorInput, this.backgroundInput, this.paddingInput];
                n.set({label: e("Save"), icon: KD, class: "ck-button-save", type: "submit", withText: true});
                n.bind("isEnabled").toMany(o, "errorText", ((...t) => t.every((t => !t))));
                i.set({label: e("Cancel"), icon: GD, class: "ck-button-cancel", type: "cancel", withText: true});
                i.delegate("execute").to(this, "cancel");
                return {saveButtonView: n, cancelButtonView: i}
            }

            get _horizontalAlignmentLabels() {
                const t = this.locale;
                const e = this.t;
                const n = e("Align cell text to the left");
                const i = e("Align cell text to the center");
                const o = e("Align cell text to the right");
                const r = e("Justify cell text");
                if (t.uiLanguageDirection === "rtl") {
                    return {right: o, center: i, left: n, justify: r}
                } else {
                    return {left: n, center: i, right: o, justify: r}
                }
            }

            get _verticalAlignmentLabels() {
                const t = this.t;
                return {
                    top: t("Align cell text to the top"),
                    middle: t("Align cell text to the middle"),
                    bottom: t("Align cell text to the bottom")
                }
            }
        }

        function qV(t) {
            return !!t
        }

        var KV = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.105 18l-.17 1H2.5A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1h15A1.5 1.5 0 0 1 19 2.5v9.975l-.85-.124-.15-.302V8h-5v4h.021l-.172.351-1.916.28-.151.027c-.287.063-.54.182-.755.341L8 13v5h3.105zM2 12h5V8H2v4zm10-4H8v4h4V8zM2 2v5h5V2H2zm0 16h5v-5H2v5zM13 7h5V2h-5v5zM8 2v5h4V2H8z" opacity=".6"/><path d="M15.5 11.5l1.323 2.68 2.957.43-2.14 2.085.505 2.946L15.5 18.25l-2.645 1.39.505-2.945-2.14-2.086 2.957-.43L15.5 11.5zM13 6a1 1 0 0 1 1 1v3.172a2.047 2.047 0 0 0-.293.443l-.858 1.736-1.916.28-.151.027A1.976 1.976 0 0 0 9.315 14H7a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h6zm-1 2H8v4h4V8z"/></svg>';

        function GV(t) {
            const e = t.getSelectedElement();
            if (e && YV(e)) {
                return e
            }
            return null
        }

        function $V(t) {
            const e = QV("table", t.getFirstPosition());
            if (e && YV(e.parent)) {
                return e.parent
            }
            return null
        }

        function YV(t) {
            return !!t.getCustomProperty("table") && hD(t)
        }

        function QV(t, e) {
            let n = e.parent;
            while (n) {
                if (n.name === t) {
                    return n
                }
                n = n.parent
            }
        }

        const JV = ZE.defaultPositions;
        const XV = [JV.northArrowSouth, JV.northArrowSouthWest, JV.northArrowSouthEast, JV.southArrowNorth, JV.southArrowNorthWest, JV.southArrowNorthEast];
        const ZV = [...XV, AD];

        function tH(t, e) {
            const n = t.plugins.get("ContextualBalloon");
            if ($V(t.editing.view.document.selection)) {
                let i;
                if (e === "cell") {
                    i = nH(t)
                } else {
                    i = eH(t)
                }
                n.updatePosition(i)
            }
        }

        function eH(t) {
            const e = t.model.document.selection.getFirstPosition();
            const n = e.findAncestor("table");
            const i = t.editing.mapper.toViewElement(n);
            return {target: t.editing.view.domConverter.viewToDom(i), positions: ZV}
        }

        function nH(t) {
            const e = t.editing.mapper;
            const n = t.editing.view.domConverter;
            const i = t.model.document.selection;
            if (i.rangeCount > 1) {
                return {target: () => oH(i.getRanges(), t), positions: XV}
            }
            const o = iH(i.getFirstPosition());
            const r = e.toViewElement(o);
            return {target: n.viewToDom(r), positions: XV}
        }

        function iH(t) {
            const e = t.nodeAfter && t.nodeAfter.is("element", "tableCell");
            return e ? t.nodeAfter : t.findAncestor("tableCell")
        }

        function oH(t, e) {
            const n = e.editing.mapper;
            const i = e.editing.view.domConverter;
            const o = Array.from(t).map((t => {
                const e = iH(t.start);
                const o = n.toViewElement(e);
                return new Eh(i.viewToDom(o))
            }));
            return Eh.getBoundingRect(o)
        }

        const rH = 500;
        const sH = {
            borderStyle: "tableCellBorderStyle",
            borderColor: "tableCellBorderColor",
            borderWidth: "tableCellBorderWidth",
            width: "tableCellWidth",
            height: "tableCellHeight",
            padding: "tableCellPadding",
            backgroundColor: "tableCellBackgroundColor",
            horizontalAlignment: "tableCellHorizontalAlignment",
            verticalAlignment: "tableCellVerticalAlignment"
        };

        class aH extends tA {
            static get requires() {
                return [MM]
            }

            static get pluginName() {
                return "TableCellPropertiesUI"
            }

            constructor(t) {
                super(t);
                t.config.define("table.tableCellProperties", {borderColors: wV, backgroundColors: wV})
            }

            init() {
                const t = this.editor;
                const e = t.t;
                this._balloon = t.plugins.get(MM);
                this.view = this._createPropertiesView();
                this._undoStepBatch = null;
                t.ui.componentFactory.add("tableCellProperties", (n => {
                    const i = new sw(n);
                    i.set({label: e("Cell properties"), icon: KV, tooltip: true});
                    this.listenTo(i, "execute", (() => this._showView()));
                    const o = Object.values(sH).map((e => t.commands.get(e)));
                    i.bind("isEnabled").toMany(o, "isEnabled", ((...t) => t.some((t => t))));
                    return i
                }))
            }

            destroy() {
                super.destroy();
                this.view.destroy()
            }

            _createPropertiesView() {
                const t = this.editor;
                const e = t.editing.view.document;
                const n = t.config.get("table.tableCellProperties");
                const i = Sx(n.borderColors);
                const o = Mx(t.locale, i);
                const r = Sx(n.backgroundColors);
                const s = Mx(t.locale, r);
                const a = new WV(t.locale, {borderColors: o, backgroundColors: s});
                const c = t.t;
                a.render();
                this.listenTo(a, "submit", (() => {
                    this._hideView()
                }));
                this.listenTo(a, "cancel", (() => {
                    if (this._undoStepBatch.operations.length) {
                        t.execute("undo", this._undoStepBatch)
                    }
                    this._hideView()
                }));
                a.keystrokes.set("Esc", ((t, e) => {
                    this._hideView();
                    e()
                }));
                this.listenTo(t.ui, "update", (() => {
                    if (!$V(e.selection)) {
                        this._hideView()
                    } else if (this._isViewVisible) {
                        tH(t, "cell")
                    }
                }));
                _w({
                    emitter: a,
                    activator: () => this._isViewInBalloon,
                    contextElements: [this._balloon.view.element],
                    callback: () => this._hideView()
                });
                const l = hV(c);
                const d = mV(c);
                a.on("change:borderStyle", this._getPropertyChangeCallback("tableCellBorderStyle"));
                a.on("change:borderColor", this._getValidatedPropertyChangeCallback({
                    viewField: a.borderColorInput,
                    commandName: "tableCellBorderColor",
                    errorText: l,
                    validator: gV
                }));
                a.on("change:borderWidth", this._getValidatedPropertyChangeCallback({
                    viewField: a.borderWidthInput,
                    commandName: "tableCellBorderWidth",
                    errorText: d,
                    validator: pV
                }));
                a.on("change:padding", this._getValidatedPropertyChangeCallback({
                    viewField: a.paddingInput,
                    commandName: "tableCellPadding",
                    errorText: d,
                    validator: fV
                }));
                a.on("change:width", this._getValidatedPropertyChangeCallback({
                    viewField: a.widthInput,
                    commandName: "tableCellWidth",
                    errorText: d,
                    validator: fV
                }));
                a.on("change:height", this._getValidatedPropertyChangeCallback({
                    viewField: a.heightInput,
                    commandName: "tableCellHeight",
                    errorText: d,
                    validator: fV
                }));
                a.on("change:backgroundColor", this._getValidatedPropertyChangeCallback({
                    viewField: a.backgroundInput,
                    commandName: "tableCellBackgroundColor",
                    errorText: l,
                    validator: gV
                }));
                a.on("change:horizontalAlignment", this._getPropertyChangeCallback("tableCellHorizontalAlignment"));
                a.on("change:verticalAlignment", this._getPropertyChangeCallback("tableCellVerticalAlignment"));
                return a
            }

            _fillViewFormFromCommandValues() {
                const t = this.editor.commands;
                Object.entries(sH).map((([e, n]) => [e, t.get(n).value || ""])).forEach((([t, e]) => this.view.set(t, e)))
            }

            _showView() {
                const t = this.editor;
                this._balloon.add({view: this.view, position: nH(t)});
                this._undoStepBatch = t.model.createBatch();
                this._fillViewFormFromCommandValues();
                this.view.focus()
            }

            _hideView() {
                if (!this._isViewInBalloon) {
                    return
                }
                const t = this.editor;
                this.stopListening(t.ui, "update");
                this.view.saveButtonView.focus();
                this._balloon.remove(this.view);
                this.editor.editing.view.focus()
            }

            get _isViewVisible() {
                return this._balloon.visibleView === this.view
            }

            get _isViewInBalloon() {
                return this._balloon.hasView(this.view)
            }

            _getPropertyChangeCallback(t) {
                return (e, n, i) => {
                    this.editor.execute(t, {value: i, batch: this._undoStepBatch})
                }
            }

            _getValidatedPropertyChangeCallback({commandName: t, viewField: e, validator: n, errorText: i}) {
                const o = bh((() => {
                    e.errorText = i
                }), rH);
                return (i, r, s) => {
                    o.cancel();
                    if (n(s)) {
                        this.editor.execute(t, {value: s, batch: this._undoStepBatch});
                        e.errorText = null
                    } else {
                        o()
                    }
                }
            }
        }

        function cH(t) {
            t.setNormalizer("border", lH);
            t.setNormalizer("border-top", dH("top"));
            t.setNormalizer("border-right", dH("right"));
            t.setNormalizer("border-bottom", dH("bottom"));
            t.setNormalizer("border-left", dH("left"));
            t.setNormalizer("border-color", uH("color"));
            t.setNormalizer("border-width", uH("width"));
            t.setNormalizer("border-style", uH("style"));
            t.setNormalizer("border-top-color", mH("color", "top"));
            t.setNormalizer("border-top-style", mH("style", "top"));
            t.setNormalizer("border-top-width", mH("width", "top"));
            t.setNormalizer("border-right-color", mH("color", "right"));
            t.setNormalizer("border-right-style", mH("style", "right"));
            t.setNormalizer("border-right-width", mH("width", "right"));
            t.setNormalizer("border-bottom-color", mH("color", "bottom"));
            t.setNormalizer("border-bottom-style", mH("style", "bottom"));
            t.setNormalizer("border-bottom-width", mH("width", "bottom"));
            t.setNormalizer("border-left-color", mH("color", "left"));
            t.setNormalizer("border-left-style", mH("style", "left"));
            t.setNormalizer("border-left-width", mH("width", "left"));
            t.setExtractor("border-top", gH("top"));
            t.setExtractor("border-right", gH("right"));
            t.setExtractor("border-bottom", gH("bottom"));
            t.setExtractor("border-left", gH("left"));
            t.setExtractor("border-top-color", "border.color.top");
            t.setExtractor("border-right-color", "border.color.right");
            t.setExtractor("border-bottom-color", "border.color.bottom");
            t.setExtractor("border-left-color", "border.color.left");
            t.setExtractor("border-top-width", "border.width.top");
            t.setExtractor("border-right-width", "border.width.right");
            t.setExtractor("border-bottom-width", "border.width.bottom");
            t.setExtractor("border-left-width", "border.width.left");
            t.setExtractor("border-top-style", "border.style.top");
            t.setExtractor("border-right-style", "border.style.right");
            t.setExtractor("border-bottom-style", "border.style.bottom");
            t.setExtractor("border-left-style", "border.style.left");
            t.setReducer("border-color", Cx("border-color"));
            t.setReducer("border-style", Cx("border-style"));
            t.setReducer("border-width", Cx("border-width"));
            t.setReducer("border-top", kH("top"));
            t.setReducer("border-right", kH("right"));
            t.setReducer("border-bottom", kH("bottom"));
            t.setReducer("border-left", kH("left"));
            t.setReducer("border", bH);
            t.setStyleRelation("border", ["border-color", "border-style", "border-width", "border-top", "border-right", "border-bottom", "border-left", "border-top-color", "border-right-color", "border-bottom-color", "border-left-color", "border-top-style", "border-right-style", "border-bottom-style", "border-left-style", "border-top-width", "border-right-width", "border-bottom-width", "border-left-width"]);
            t.setStyleRelation("border-color", ["border-top-color", "border-right-color", "border-bottom-color", "border-left-color"]);
            t.setStyleRelation("border-style", ["border-top-style", "border-right-style", "border-bottom-style", "border-left-style"]);
            t.setStyleRelation("border-width", ["border-top-width", "border-right-width", "border-bottom-width", "border-left-width"]);
            t.setStyleRelation("border-top", ["border-top-color", "border-top-style", "border-top-width"]);
            t.setStyleRelation("border-right", ["border-right-color", "border-right-style", "border-right-width"]);
            t.setStyleRelation("border-bottom", ["border-bottom-color", "border-bottom-style", "border-bottom-width"]);
            t.setStyleRelation("border-left", ["border-left-color", "border-left-style", "border-left-width"])
        }

        function lH(t) {
            const {color: e, style: n, width: i} = pH(t);
            return {path: "border", value: {color: _x(e), style: _x(n), width: _x(i)}}
        }

        function dH(t) {
            return e => {
                const {color: n, style: i, width: o} = pH(e);
                const r = {};
                if (n !== undefined) {
                    r.color = {[t]: n}
                }
                if (i !== undefined) {
                    r.style = {[t]: i}
                }
                if (o !== undefined) {
                    r.width = {[t]: o}
                }
                return {path: "border", value: r}
            }
        }

        function uH(t) {
            return e => ({path: "border", value: hH(e, t)})
        }

        function hH(t, e) {
            return {[e]: _x(t)}
        }

        function mH(t, e) {
            return n => ({path: "border", value: {[t]: {[e]: n}}})
        }

        function gH(t) {
            return (e, n) => {
                if (n.border) {
                    return fH(n.border, t)
                }
            }
        }

        function fH(t, e) {
            const n = {};
            if (t.width && t.width[e]) {
                n.width = t.width[e]
            }
            if (t.style && t.style[e]) {
                n.style = t.style[e]
            }
            if (t.color && t.color[e]) {
                n.color = t.color[e]
            }
            return n
        }

        function pH(t) {
            const e = {};
            const n = xx(t);
            for (const t of n) {
                if (dx(t) || /thin|medium|thick/.test(t)) {
                    e.width = t
                } else if (cx(t)) {
                    e.style = t
                } else {
                    e.color = t
                }
            }
            return e
        }

        function bH(t) {
            const e = [];
            e.push(...wH(fH(t, "top"), "top"));
            e.push(...wH(fH(t, "right"), "right"));
            e.push(...wH(fH(t, "bottom"), "bottom"));
            e.push(...wH(fH(t, "left"), "left"));
            return e
        }

        function kH(t) {
            return e => wH(e, t)
        }

        function wH(t, e) {
            const n = [];
            if (t && t.width !== undefined) {
                n.push(t.width)
            }
            if (t && t.style !== undefined) {
                n.push(t.style)
            }
            if (t && t.color !== undefined) {
                n.push(t.color)
            }
            if (n.length) {
                return [[`border-${e}`, n.join(" ")]]
            }
            return []
        }

        function AH(t) {
            t.setNormalizer("padding", yx("padding"));
            t.setNormalizer("padding-top", (t => ({path: "padding.top", value: t})));
            t.setNormalizer("padding-right", (t => ({path: "padding.right", value: t})));
            t.setNormalizer("padding-bottom", (t => ({path: "padding.bottom", value: t})));
            t.setNormalizer("padding-left", (t => ({path: "padding.left", value: t})));
            t.setReducer("padding", Cx("padding"));
            t.setStyleRelation("padding", ["padding-top", "padding-right", "padding-bottom", "padding-left"])
        }

        function _H(t, e, n, i) {
            t.for("upcast").attributeToAttribute({
                view: {styles: {[i]: /[\s\S]+/}},
                model: {name: e, key: n, value: t => t.getNormalizedStyle(i)}
            })
        }

        function CH(t, e) {
            t.for("upcast").add((t => t.on("element:" + e, ((t, e, n) => {
                const i = ["border-top", "border-right", "border-bottom", "border-left"].filter((t => e.viewItem.hasStyle(t)));
                if (!i.length) {
                    return
                }
                const o = {styles: i};
                if (!n.consumable.test(e.viewItem, o)) {
                    return
                }
                if (!e.modelRange) {
                    e = Object.assign(e, n.convertChildren(e.viewItem, e.modelCursor))
                }
                const r = [...e.modelRange.getItems({shallow: true})].pop();
                n.consumable.consume(e.viewItem, o);
                n.writer.setAttribute("borderStyle", e.viewItem.getNormalizedStyle("border-style"), r);
                n.writer.setAttribute("borderColor", e.viewItem.getNormalizedStyle("border-color"), r);
                n.writer.setAttribute("borderWidth", e.viewItem.getNormalizedStyle("border-width"), r)
            }))))
        }

        function vH(t, e, n, i) {
            t.for("downcast").attributeToAttribute({
                model: {name: e, key: n},
                view: t => ({key: "style", value: {[i]: t}})
            })
        }

        function yH(t, e, n) {
            t.for("downcast").add((t => t.on(`attribute:${e}:table`, ((t, e, i) => {
                const {item: o, attributeNewValue: r} = e;
                const {mapper: s, writer: a} = i;
                if (!i.consumable.consume(e.item, t.name)) {
                    return
                }
                const c = [...s.toViewElement(o).getChildren()].find((t => t.is("element", "table")));
                if (r) {
                    a.setStyle(n, r, c)
                } else {
                    a.removeStyle(n, c)
                }
            }))))
        }

        class xH extends nA {
            constructor(t, e) {
                super(t);
                this.attributeName = e
            }

            refresh() {
                const t = this.editor;
                const e = nR(t.model.document.selection);
                this.isEnabled = !!e.length;
                this.value = this._getSingleValue(e)
            }

            execute(t = {}) {
                const {value: e, batch: n} = t;
                const i = this.editor.model;
                const o = nR(i.document.selection);
                const r = this._getValueToSet(e);
                i.enqueueChange(n || "default", (t => {
                    if (r) {
                        o.forEach((e => t.setAttribute(this.attributeName, r, e)))
                    } else {
                        o.forEach((e => t.removeAttribute(this.attributeName, e)))
                    }
                }))
            }

            _getAttribute(t) {
                if (!t) {
                    return
                }
                return t.getAttribute(this.attributeName)
            }

            _getValueToSet(t) {
                return t
            }

            _getSingleValue(t) {
                const e = this._getAttribute(t[0]);
                const n = t.every((t => this._getAttribute(t) === e));
                return n ? e : undefined
            }
        }

        function EH(t) {
            if (!t || !ct(t)) {
                return t
            }
            const {top: e, right: n, bottom: i, left: o} = t;
            if (e == n && n == i && i == o) {
                return e
            }
        }

        function DH(t, e) {
            const n = parseFloat(t);
            if (Number.isNaN(n)) {
                return t
            }
            if (String(n) !== String(t)) {
                return t
            }
            return `${n}${e}`
        }

        class TH extends xH {
            constructor(t) {
                super(t, "padding")
            }

            _getAttribute(t) {
                if (!t) {
                    return
                }
                return EH(t.getAttribute(this.attributeName))
            }

            _getValueToSet(t) {
                return DH(t, "px")
            }
        }

        class MH extends xH {
            constructor(t) {
                super(t, "width")
            }

            _getValueToSet(t) {
                return DH(t, "px")
            }
        }

        class SH extends xH {
            constructor(t) {
                super(t, "height")
            }

            _getValueToSet(t) {
                return DH(t, "px")
            }
        }

        class IH extends xH {
            constructor(t) {
                super(t, "backgroundColor")
            }
        }

        class BH extends xH {
            constructor(t) {
                super(t, "verticalAlignment")
            }
        }

        class LH extends xH {
            constructor(t) {
                super(t, "horizontalAlignment")
            }
        }

        class zH extends xH {
            constructor(t) {
                super(t, "borderStyle")
            }

            _getAttribute(t) {
                if (!t) {
                    return
                }
                return EH(t.getAttribute(this.attributeName))
            }
        }

        class NH extends xH {
            constructor(t) {
                super(t, "borderColor")
            }

            _getAttribute(t) {
                if (!t) {
                    return
                }
                return EH(t.getAttribute(this.attributeName))
            }
        }

        class PH extends xH {
            constructor(t) {
                super(t, "borderWidth")
            }

            _getAttribute(t) {
                if (!t) {
                    return
                }
                return EH(t.getAttribute(this.attributeName))
            }

            _getValueToSet(t) {
                return DH(t, "px")
            }
        }

        const OH = /^(top|bottom)$/;

        class jH extends tA {
            static get pluginName() {
                return "TableCellPropertiesEditing"
            }

            static get requires() {
                return [CF]
            }

            init() {
                const t = this.editor;
                const e = t.model.schema;
                const n = t.conversion;
                const i = t.locale;
                t.data.addStyleProcessorRules(cH);
                RH(e, n);
                t.commands.add("tableCellBorderStyle", new zH(t));
                t.commands.add("tableCellBorderColor", new NH(t));
                t.commands.add("tableCellBorderWidth", new PH(t));
                FH(e, n, i);
                t.commands.add("tableCellHorizontalAlignment", new LH(t));
                HH(e, n, "width", "width");
                t.commands.add("tableCellWidth", new MH(t));
                HH(e, n, "height", "height");
                t.commands.add("tableCellHeight", new SH(t));
                t.data.addStyleProcessorRules(AH);
                HH(e, n, "padding", "padding");
                t.commands.add("tableCellPadding", new TH(t));
                t.data.addStyleProcessorRules(Ex);
                HH(e, n, "backgroundColor", "background-color");
                t.commands.add("tableCellBackgroundColor", new IH(t));
                VH(e, n);
                t.commands.add("tableCellVerticalAlignment", new BH(t))
            }
        }

        function RH(t, e) {
            t.extend("tableCell", {allowAttributes: ["borderWidth", "borderColor", "borderStyle"]});
            CH(e, "td");
            CH(e, "th");
            vH(e, "tableCell", "borderStyle", "border-style");
            vH(e, "tableCell", "borderColor", "border-color");
            vH(e, "tableCell", "borderWidth", "border-width")
        }

        function FH(t, e, n) {
            t.extend("tableCell", {allowAttributes: ["horizontalAlignment"]});
            const i = [n.contentLanguageDirection == "rtl" ? "left" : "right", "center", "justify"];
            e.attributeToAttribute({
                model: {name: "tableCell", key: "horizontalAlignment", values: i},
                view: i.reduce(((t, e) => ({...t, [e]: {key: "style", value: {"text-align": e}}})), {})
            })
        }

        function VH(t, e) {
            t.extend("tableCell", {allowAttributes: ["verticalAlignment"]});
            e.attributeToAttribute({
                model: {name: "tableCell", key: "verticalAlignment", values: ["top", "bottom"]},
                view: {
                    top: {key: "style", value: {"vertical-align": "top"}},
                    bottom: {key: "style", value: {"vertical-align": "bottom"}}
                }
            });
            e.for("upcast").attributeToAttribute({
                view: {attributes: {valign: OH}},
                model: {name: "tableCell", key: "verticalAlignment", value: t => t.getAttribute("valign")}
            })
        }

        function HH(t, e, n, i) {
            t.extend("tableCell", {allowAttributes: [n]});
            _H(e, "tableCell", n, i);
            vH(e, "tableCell", n, i)
        }

        class UH extends tA {
            static get pluginName() {
                return "TableCellProperties"
            }

            static get requires() {
                return [jH, aH]
            }
        }

        class WH extends nA {
            constructor(t, e) {
                super(t);
                this.attributeName = e
            }

            refresh() {
                const t = this.editor;
                const e = t.model.document.selection;
                const n = e.getFirstPosition().findAncestor("table");
                this.isEnabled = !!n;
                this.value = this._getValue(n)
            }

            execute(t = {}) {
                const e = this.editor.model;
                const n = e.document.selection;
                const {value: i, batch: o} = t;
                const r = n.getFirstPosition().findAncestor("table");
                const s = this._getValueToSet(i);
                e.enqueueChange(o || "default", (t => {
                    if (s) {
                        t.setAttribute(this.attributeName, s, r)
                    } else {
                        t.removeAttribute(this.attributeName, r)
                    }
                }))
            }

            _getValue(t) {
                if (!t) {
                    return
                }
                return t.getAttribute(this.attributeName)
            }

            _getValueToSet(t) {
                return t
            }
        }

        class qH extends WH {
            constructor(t) {
                super(t, "backgroundColor")
            }
        }

        class KH extends WH {
            constructor(t) {
                super(t, "borderColor")
            }

            _getValue(t) {
                if (!t) {
                    return
                }
                return EH(t.getAttribute(this.attributeName))
            }
        }

        class GH extends WH {
            constructor(t) {
                super(t, "borderStyle")
            }

            _getValue(t) {
                if (!t) {
                    return
                }
                return EH(t.getAttribute(this.attributeName))
            }
        }

        class $H extends WH {
            constructor(t) {
                super(t, "borderWidth")
            }

            _getValue(t) {
                if (!t) {
                    return
                }
                return EH(t.getAttribute(this.attributeName))
            }

            _getValueToSet(t) {
                return DH(t, "px")
            }
        }

        class YH extends WH {
            constructor(t) {
                super(t, "width")
            }

            _getValueToSet(t) {
                return DH(t, "px")
            }
        }

        class QH extends WH {
            constructor(t) {
                super(t, "height")
            }

            _getValueToSet(t) {
                return DH(t, "px")
            }
        }

        class JH extends WH {
            constructor(t) {
                super(t, "alignment")
            }
        }

        const XH = /^(left|right)$/;

        class ZH extends tA {
            static get pluginName() {
                return "TablePropertiesEditing"
            }

            static get requires() {
                return [CF]
            }

            init() {
                const t = this.editor;
                const e = t.model.schema;
                const n = t.conversion;
                t.data.addStyleProcessorRules(cH);
                tU(e, n);
                t.commands.add("tableBorderColor", new KH(t));
                t.commands.add("tableBorderStyle", new GH(t));
                t.commands.add("tableBorderWidth", new $H(t));
                eU(e, n);
                t.commands.add("tableAlignment", new JH(t));
                iU(e, n, "width", "width");
                t.commands.add("tableWidth", new YH(t));
                iU(e, n, "height", "height");
                t.commands.add("tableHeight", new QH(t));
                t.data.addStyleProcessorRules(Ex);
                nU(e, n, "backgroundColor", "background-color");
                t.commands.add("tableBackgroundColor", new qH(t))
            }
        }

        function tU(t, e) {
            t.extend("table", {allowAttributes: ["borderWidth", "borderColor", "borderStyle"]});
            CH(e, "table");
            yH(e, "borderColor", "border-color");
            yH(e, "borderStyle", "border-style");
            yH(e, "borderWidth", "border-width")
        }

        function eU(t, e) {
            t.extend("table", {allowAttributes: ["alignment"]});
            e.attributeToAttribute({
                model: {name: "table", key: "alignment", values: ["left", "right"]},
                view: {left: {key: "style", value: {float: "left"}}, right: {key: "style", value: {float: "right"}}},
                converterPriority: "high"
            });
            e.for("upcast").attributeToAttribute({
                view: {attributes: {align: XH}},
                model: {name: "table", key: "alignment", value: t => t.getAttribute("align")}
            })
        }

        function nU(t, e, n, i) {
            t.extend("table", {allowAttributes: [n]});
            _H(e, "table", n, i);
            yH(e, n, i)
        }

        function iU(t, e, n, i) {
            t.extend("table", {allowAttributes: [n]});
            _H(e, "table", n, i);
            vH(e, "table", n, i)
        }

        var oU = n(81);
        var rU = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        rU.insert = "head";
        rU.singleton = true;
        var sU = ob()(oU["a"], rU);
        var aU = oU["a"].locals || {};
        const cU = {left: UI, center: WI, right: qI};

        class lU extends Zb {
            constructor(t, e) {
                super(t);
                this.set({
                    borderStyle: "",
                    borderWidth: "",
                    borderColor: "",
                    backgroundColor: "",
                    width: "",
                    height: "",
                    alignment: ""
                });
                this.options = e;
                const {borderStyleDropdown: n, borderWidthInput: i, borderColorInput: o, borderRowLabel: r} = this._createBorderFields();
                const {widthInput: s, operatorLabel: a, heightInput: c, dimensionsLabel: l} = this._createDimensionFields();
                const {alignmentToolbar: d, alignmentLabel: u} = this._createAlignmentFields();
                this.focusTracker = new Zp;
                this.keystrokes = new Fp;
                this.children = this.createCollection();
                this.borderStyleDropdown = n;
                this.borderWidthInput = i;
                this.borderColorInput = o;
                this.backgroundInput = this._createBackgroundField();
                this.widthInput = s;
                this.heightInput = c;
                this.alignmentToolbar = d;
                const {saveButtonView: h, cancelButtonView: m} = this._createActionButtons();
                this.saveButtonView = h;
                this.cancelButtonView = m;
                this._focusables = new Ab;
                this._focusCycler = new xk({
                    focusables: this._focusables,
                    focusTracker: this.focusTracker,
                    keystrokeHandler: this.keystrokes,
                    actions: {focusPrevious: "shift + tab", focusNext: "tab"}
                });
                this.children.add(new BO(t, {label: this.t("Table properties")}));
                this.children.add(new DV(t, {
                    labelView: r,
                    children: [r, n, o, i],
                    class: "ck-table-form__border-row"
                }));
                this.children.add(new DV(t, {children: [this.backgroundInput]}));
                this.children.add(new DV(t, {
                    children: [new DV(t, {
                        labelView: l,
                        children: [l, s, a, c],
                        class: "ck-table-form__dimensions-row"
                    }), new DV(t, {labelView: u, children: [u, d], class: "ck-table-properties-form__alignment-row"})]
                }));
                this.children.add(new DV(t, {
                    children: [this.saveButtonView, this.cancelButtonView],
                    class: "ck-table-form__action-row"
                }));
                this.setTemplate({
                    tag: "form",
                    attributes: {class: ["ck", "ck-form", "ck-table-form", "ck-table-properties-form"], tabindex: "-1"},
                    children: this.children
                })
            }

            render() {
                super.render();
                cM({view: this});
                [this.borderStyleDropdown, this.borderColorInput, this.borderWidthInput, this.backgroundInput, this.widthInput, this.heightInput, this.alignmentToolbar, this.saveButtonView, this.cancelButtonView].forEach((t => {
                    this._focusables.add(t);
                    this.focusTracker.add(t.element)
                }));
                this.keystrokes.listenTo(this.element)
            }

            focus() {
                this._focusCycler.focusFirst()
            }

            _createBorderFields() {
                const t = AV({colorConfig: this.options.borderColors, columns: 5});
                const e = this.locale;
                const n = this.t;
                const i = new gk(e);
                i.text = n("Border");
                const o = uV(this.t);
                const r = new tM(e, aM);
                r.set({label: n("Style"), class: "ck-table-form__border-style"});
                r.fieldView.buttonView.set({isOn: false, withText: true, tooltip: n("Style")});
                r.fieldView.buttonView.bind("label").to(this, "borderStyle", (t => o[t ? t : "none"]));
                r.fieldView.on("execute", (t => {
                    this.borderStyle = t.source._borderStyleValue
                }));
                Bw(r.fieldView, bV(this));
                const s = new tM(e, sM);
                s.set({label: n("Width"), class: "ck-table-form__border-width"});
                s.fieldView.bind("value").to(this, "borderWidth");
                s.bind("isEnabled").to(this, "borderStyle", dU);
                s.fieldView.on("input", (() => {
                    this.borderWidth = s.fieldView.element.value
                }));
                const a = new tM(e, t);
                a.set({label: n("Color"), class: "ck-table-form__border-color"});
                a.fieldView.bind("value").to(this, "borderColor");
                a.bind("isEnabled").to(this, "borderStyle", dU);
                a.fieldView.on("input", (() => {
                    this.borderColor = a.fieldView.value
                }));
                this.on("change:borderStyle", ((t, e, n) => {
                    if (!dU(n)) {
                        this.borderColor = "";
                        this.borderWidth = ""
                    }
                }));
                return {borderRowLabel: i, borderStyleDropdown: r, borderColorInput: a, borderWidthInput: s}
            }

            _createBackgroundField() {
                const t = AV({colorConfig: this.options.backgroundColors, columns: 5});
                const e = this.locale;
                const n = this.t;
                const i = new tM(e, t);
                i.set({label: n("Background"), class: "ck-table-properties-form__background"});
                i.fieldView.bind("value").to(this, "backgroundColor");
                i.fieldView.on("input", (() => {
                    this.backgroundColor = i.fieldView.value
                }));
                return i
            }

            _createDimensionFields() {
                const t = this.locale;
                const e = this.t;
                const n = new gk(t);
                n.text = e("Dimensions");
                const i = new tM(t, sM);
                i.set({label: e("Width"), class: "ck-table-form__dimensions-row__width"});
                i.fieldView.bind("value").to(this, "width");
                i.fieldView.on("input", (() => {
                    this.width = i.fieldView.element.value
                }));
                const o = new Zb(t);
                o.setTemplate({
                    tag: "span",
                    attributes: {class: ["ck-table-form__dimension-operator"]},
                    children: [{text: "×"}]
                });
                const r = new tM(t, sM);
                r.set({label: e("Height"), class: "ck-table-form__dimensions-row__height"});
                r.fieldView.bind("value").to(this, "height");
                r.fieldView.on("input", (() => {
                    this.height = r.fieldView.element.value
                }));
                return {dimensionsLabel: n, widthInput: i, operatorLabel: o, heightInput: r}
            }

            _createAlignmentFields() {
                const t = this.locale;
                const e = this.t;
                const n = new gk(t);
                n.text = e("Alignment");
                const i = new Hw(t);
                i.set({isCompact: true, ariaLabel: e("Table alignment toolbar")});
                kV({
                    view: this,
                    icons: cU,
                    toolbar: i,
                    labels: this._alignmentLabels,
                    propertyName: "alignment",
                    nameToValue: t => t === "center" ? "" : t
                });
                return {alignmentLabel: n, alignmentToolbar: i}
            }

            _createActionButtons() {
                const t = this.locale;
                const e = this.t;
                const n = new sw(t);
                const i = new sw(t);
                const o = [this.borderWidthInput, this.borderColorInput, this.backgroundInput, this.widthInput, this.heightInput];
                n.set({label: e("Save"), icon: KD, class: "ck-button-save", type: "submit", withText: true});
                n.bind("isEnabled").toMany(o, "errorText", ((...t) => t.every((t => !t))));
                i.set({label: e("Cancel"), icon: GD, class: "ck-button-cancel", type: "cancel", withText: true});
                i.delegate("execute").to(this, "cancel");
                return {saveButtonView: n, cancelButtonView: i}
            }

            get _alignmentLabels() {
                const t = this.locale;
                const e = this.t;
                const n = e("Align table to the left");
                const i = e("Center table");
                const o = e("Align table to the right");
                if (t.uiLanguageDirection === "rtl") {
                    return {right: o, center: i, left: n}
                } else {
                    return {left: n, center: i, right: o}
                }
            }
        }

        function dU(t) {
            return !!t
        }

        var uU = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8 2v5h4V2h1v5h5v1h-5v4h.021l-.172.351-1.916.28-.151.027c-.287.063-.54.182-.755.341L8 13v5H7v-5H2v-1h5V8H2V7h5V2h1zm4 6H8v4h4V8z" opacity=".6"/><path d="M15.5 11.5l1.323 2.68 2.957.43-2.14 2.085.505 2.946L15.5 18.25l-2.645 1.39.505-2.945-2.14-2.086 2.957-.43L15.5 11.5zM17 1a2 2 0 0 1 2 2v9.475l-.85-.124-.857-1.736a2.048 2.048 0 0 0-.292-.44L17 3H3v14h7.808l.402.392L10.935 19H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h14z"/></svg>';
        const hU = 500;
        const mU = {
            borderStyle: "tableBorderStyle",
            borderColor: "tableBorderColor",
            borderWidth: "tableBorderWidth",
            backgroundColor: "tableBackgroundColor",
            width: "tableWidth",
            height: "tableHeight",
            alignment: "tableAlignment"
        };

        class gU extends tA {
            static get requires() {
                return [MM]
            }

            static get pluginName() {
                return "TablePropertiesUI"
            }

            constructor(t) {
                super(t);
                t.config.define("table.tableProperties", {borderColors: wV, backgroundColors: wV})
            }

            init() {
                const t = this.editor;
                const e = t.t;
                this._balloon = t.plugins.get(MM);
                this.view = this._createPropertiesView();
                this._undoStepBatch = null;
                t.ui.componentFactory.add("tableProperties", (n => {
                    const i = new sw(n);
                    i.set({label: e("Table properties"), icon: uU, tooltip: true});
                    this.listenTo(i, "execute", (() => this._showView()));
                    const o = Object.values(mU).map((e => t.commands.get(e)));
                    i.bind("isEnabled").toMany(o, "isEnabled", ((...t) => t.some((t => t))));
                    return i
                }))
            }

            destroy() {
                super.destroy();
                this.view.destroy()
            }

            _createPropertiesView() {
                const t = this.editor;
                const e = t.editing.view.document;
                const n = t.config.get("table.tableProperties");
                const i = Sx(n.borderColors);
                const o = Mx(t.locale, i);
                const r = Sx(n.backgroundColors);
                const s = Mx(t.locale, r);
                const a = new lU(t.locale, {borderColors: o, backgroundColors: s});
                const c = t.t;
                a.render();
                this.listenTo(a, "submit", (() => {
                    this._hideView()
                }));
                this.listenTo(a, "cancel", (() => {
                    if (this._undoStepBatch.operations.length) {
                        t.execute("undo", this._undoStepBatch)
                    }
                    this._hideView()
                }));
                a.keystrokes.set("Esc", ((t, e) => {
                    this._hideView();
                    e()
                }));
                this.listenTo(t.ui, "update", (() => {
                    if (!$V(e.selection)) {
                        this._hideView()
                    } else if (this._isViewVisible) {
                        tH(t, "table")
                    }
                }));
                _w({
                    emitter: a,
                    activator: () => this._isViewInBalloon,
                    contextElements: [this._balloon.view.element],
                    callback: () => this._hideView()
                });
                const l = hV(c);
                const d = mV(c);
                a.on("change:borderStyle", this._getPropertyChangeCallback("tableBorderStyle"));
                a.on("change:borderColor", this._getValidatedPropertyChangeCallback({
                    viewField: a.borderColorInput,
                    commandName: "tableBorderColor",
                    errorText: l,
                    validator: gV
                }));
                a.on("change:borderWidth", this._getValidatedPropertyChangeCallback({
                    viewField: a.borderWidthInput,
                    commandName: "tableBorderWidth",
                    errorText: d,
                    validator: pV
                }));
                a.on("change:backgroundColor", this._getValidatedPropertyChangeCallback({
                    viewField: a.backgroundInput,
                    commandName: "tableBackgroundColor",
                    errorText: l,
                    validator: gV
                }));
                a.on("change:width", this._getValidatedPropertyChangeCallback({
                    viewField: a.widthInput,
                    commandName: "tableWidth",
                    errorText: d,
                    validator: fV
                }));
                a.on("change:height", this._getValidatedPropertyChangeCallback({
                    viewField: a.heightInput,
                    commandName: "tableHeight",
                    errorText: d,
                    validator: fV
                }));
                a.on("change:alignment", this._getPropertyChangeCallback("tableAlignment"));
                return a
            }

            _fillViewFormFromCommandValues() {
                const t = this.editor.commands;
                Object.entries(mU).map((([e, n]) => [e, t.get(n).value || ""])).forEach((([t, e]) => this.view.set(t, e)))
            }

            _showView() {
                const t = this.editor;
                this._balloon.add({view: this.view, position: eH(t)});
                this._undoStepBatch = t.model.createBatch();
                this._fillViewFormFromCommandValues();
                this.view.focus()
            }

            _hideView() {
                if (!this._isViewInBalloon) {
                    return
                }
                const t = this.editor;
                this.stopListening(t.ui, "update");
                this.view.saveButtonView.focus();
                this._balloon.remove(this.view);
                this.editor.editing.view.focus()
            }

            get _isViewVisible() {
                return this._balloon.visibleView === this.view
            }

            get _isViewInBalloon() {
                return this._balloon.hasView(this.view)
            }

            _getPropertyChangeCallback(t) {
                return (e, n, i) => {
                    this.editor.execute(t, {value: i, batch: this._undoStepBatch})
                }
            }

            _getValidatedPropertyChangeCallback({commandName: t, viewField: e, validator: n, errorText: i}) {
                const o = bh((() => {
                    e.errorText = i
                }), hU);
                return (i, r, s) => {
                    o.cancel();
                    if (n(s)) {
                        this.editor.execute(t, {value: s, batch: this._undoStepBatch});
                        e.errorText = null
                    } else {
                        o()
                    }
                }
            }
        }

        class fU extends tA {
            static get pluginName() {
                return "TableProperties"
            }

            static get requires() {
                return [ZH, gU]
            }
        }

        class pU extends tA {
            static get requires() {
                return [oB]
            }

            static get pluginName() {
                return "TableToolbar"
            }

            afterInit() {
                const t = this.editor;
                const e = t.t;
                const n = t.plugins.get(oB);
                const i = t.config.get("table.contentToolbar");
                const o = t.config.get("table.tableToolbar");
                if (i) {
                    n.register("tableContent", {ariaLabel: e("Table toolbar"), items: i, getRelatedElement: $V})
                }
                if (o) {
                    n.register("table", {ariaLabel: e("Table toolbar"), items: o, getRelatedElement: GV})
                }
            }
        }

        var bU = /[\\^$.*+?()[\]{}|]/g, kU = RegExp(bU.source);

        function wU(t) {
            t = _a(t);
            return t && kU.test(t) ? t.replace(bU, "\\$&") : t
        }

        var AU = wU;
        const _U = {
            copyright: {from: "(c)", to: "©"},
            registeredTrademark: {from: "(r)", to: "®"},
            trademark: {from: "(tm)", to: "™"},
            oneHalf: {from: "1/2", to: "½"},
            oneThird: {from: "1/3", to: "⅓"},
            twoThirds: {from: "2/3", to: "⅔"},
            oneForth: {from: "1/4", to: "¼"},
            threeQuarters: {from: "3/4", to: "¾"},
            lessThanOrEqual: {from: "<=", to: "≤"},
            greaterThanOrEqual: {from: ">=", to: "≥"},
            notEqual: {from: "!=", to: "≠"},
            arrowLeft: {from: "<-", to: "←"},
            arrowRight: {from: "->", to: "→"},
            horizontalEllipsis: {from: "...", to: "…"},
            enDash: {from: /(^| )(--)( )$/, to: [null, "–", null]},
            emDash: {from: /(^| )(---)( )$/, to: [null, "—", null]},
            quotesPrimary: {from: TU('"'), to: [null, "“", null, "”"]},
            quotesSecondary: {from: TU("'"), to: [null, "‘", null, "’"]},
            quotesPrimaryEnGb: {from: TU("'"), to: [null, "‘", null, "’"]},
            quotesSecondaryEnGb: {from: TU('"'), to: [null, "“", null, "”"]},
            quotesPrimaryPl: {from: TU('"'), to: [null, "„", null, "”"]},
            quotesSecondaryPl: {from: TU("'"), to: [null, "‚", null, "’"]}
        };
        const CU = {
            symbols: ["copyright", "registeredTrademark", "trademark"],
            mathematical: ["oneHalf", "oneThird", "twoThirds", "oneForth", "threeQuarters", "lessThanOrEqual", "greaterThanOrEqual", "notEqual", "arrowLeft", "arrowRight"],
            typography: ["horizontalEllipsis", "enDash", "emDash"],
            quotes: ["quotesPrimary", "quotesSecondary"]
        };
        const vU = ["symbols", "mathematical", "typography", "quotes"];

        class yU extends tA {
            static get pluginName() {
                return "TextTransformation"
            }

            constructor(t) {
                super(t);
                t.config.define("typing", {transformations: {include: vU}})
            }

            init() {
                const t = this.editor.model;
                const e = t.document.selection;
                e.on("change:range", (() => {
                    this.isEnabled = !e.anchor.parent.is("element", "codeBlock")
                }));
                this._enableTransformationWatchers()
            }

            _enableTransformationWatchers() {
                const t = this.editor;
                const e = t.model;
                const n = t.plugins.get("Input");
                const i = MU(t.config.get("typing.transformations"));
                const o = t => {
                    for (const e of i) {
                        const n = e.from;
                        const i = n.test(t);
                        if (i) {
                            return {normalizedTransformation: e}
                        }
                    }
                };
                const r = (t, i) => {
                    if (!n.isInput(i.batch)) {
                        return
                    }
                    const {from: o, to: r} = i.normalizedTransformation;
                    const s = o.exec(i.text);
                    const a = r(s.slice(1));
                    const c = i.range;
                    let l = s.index;
                    e.enqueueChange((t => {
                        for (let n = 1; n < s.length; n++) {
                            const i = s[n];
                            const o = a[n - 1];
                            if (o == null) {
                                l += i.length;
                                continue
                            }
                            const r = c.start.getShiftedBy(l);
                            const d = e.createRange(r, r.getShiftedBy(i.length));
                            const u = DU(r);
                            e.insertContent(t.createText(o, u), d);
                            l += o.length
                        }
                    }))
                };
                const s = new TA(t.model, o);
                s.on("matched:data", r);
                s.bind("isEnabled").to(this)
            }
        }

        function xU(t) {
            if (typeof t == "string") {
                return new RegExp(`(${AU(t)})$`)
            }
            return t
        }

        function EU(t) {
            if (typeof t == "string") {
                return () => [t]
            } else if (t instanceof Array) {
                return () => t
            }
            return t
        }

        function DU(t) {
            const e = t.textNode ? t.textNode : t.nodeAfter;
            return e.getAttributes()
        }

        function TU(t) {
            return new RegExp(`(^|\\s)(${t})([^${t}]*)(${t})$`)
        }

        function MU(t) {
            const e = t.extra || [];
            const n = t.remove || [];
            const i = t => !n.includes(t);
            const o = t.include.concat(e).filter(i);
            return SU(o).filter(i).map((t => _U[t] || t)).map((t => ({from: xU(t.from), to: EU(t.to)})))
        }

        function SU(t) {
            const e = new Set;
            for (const n of t) {
                if (CU[n]) {
                    for (const t of CU[n]) {
                        e.add(t)
                    }
                } else {
                    e.add(n)
                }
            }
            return Array.from(e)
        }

        const IU = new Set(["paragraph", "heading1", "heading2", "heading3", "heading4", "heading5", "heading6"]);

        class BU extends tA {
            static get pluginName() {
                return "Title"
            }

            static get requires() {
                return [kE]
            }

            init() {
                const t = this.editor;
                const e = t.model;
                this._bodyPlaceholder = null;
                e.schema.register("title", {isBlock: true, allowIn: "$root"});
                e.schema.register("title-content", {isBlock: true, allowIn: "title", allowAttributes: ["alignment"]});
                e.schema.extend("$text", {allowIn: "title-content"});
                e.schema.addAttributeCheck((t => {
                    if (t.endsWith("title-content $text")) {
                        return false
                    }
                }));
                t.editing.mapper.on("modelToViewPosition", zU(t.editing.view));
                t.data.mapper.on("modelToViewPosition", zU(t.editing.view));
                t.conversion.for("downcast").elementToElement({model: "title-content", view: "h1"});
                t.data.upcastDispatcher.on("element:h1", LU, {priority: "high"});
                t.data.upcastDispatcher.on("element:h2", LU, {priority: "high"});
                t.data.upcastDispatcher.on("element:h3", LU, {priority: "high"});
                e.document.registerPostFixer((t => this._fixTitleContent(t)));
                e.document.registerPostFixer((t => this._fixTitleElement(t)));
                e.document.registerPostFixer((t => this._fixBodyElement(t)));
                e.document.registerPostFixer((t => this._fixExtraParagraph(t)));
                this._attachPlaceholders();
                this._attachTabPressHandling()
            }

            getTitle() {
                const t = this._getTitleElement();
                const e = t.getChild(0);
                return this.editor.data.stringify(e)
            }

            getBody() {
                const t = this.editor;
                const e = t.data;
                const n = t.model;
                const i = t.model.document.getRoot();
                const o = new Xl(t.editing.view.document);
                const r = n.createRangeIn(i);
                const s = new Ql(t.editing.view.document);
                e.mapper.clearBindings();
                e.mapper.bindElements(i, s);
                e.downcastDispatcher.convertInsert(r, o);
                const a = n.createPositionAfter(i.getChild(0));
                const c = n.createRange(a, n.createPositionAt(i, "end"));
                for (const t of n.markers) {
                    const n = c.getIntersection(t.getRange());
                    if (n) {
                        e.downcastDispatcher.convertMarkerAdd(t.name, n, o)
                    }
                }
                o.remove(o.createRangeOn(s.getChild(0)));
                return t.data.processor.toData(s)
            }

            _getTitleElement() {
                const t = this.editor.model.document.getRoot();
                for (const e of t.getChildren()) {
                    if (NU(e)) {
                        return e
                    }
                }
            }

            _fixTitleContent(t) {
                const e = this._getTitleElement();
                if (!e || e.maxOffset === 1) {
                    return false
                }
                const n = Array.from(e.getChildren());
                n.shift();
                for (const i of n) {
                    t.move(t.createRangeOn(i), e, "after");
                    t.rename(i, "paragraph")
                }
                return true
            }

            _fixTitleElement(t) {
                const e = this.editor.model;
                const n = e.document.getRoot();
                const i = Array.from(n.getChildren()).filter(NU);
                const o = i[0];
                const r = n.getChild(0);
                if (r.is("element", "title")) {
                    return OU(i, t, e)
                }
                if (!o && !IU.has(r.name)) {
                    const e = t.createElement("title");
                    t.insert(e, n);
                    t.insertElement("title-content", e);
                    return true
                }
                if (IU.has(r.name)) {
                    PU(r, t, e)
                } else {
                    t.move(t.createRangeOn(o), n, 0)
                }
                OU(i, t, e);
                return true
            }

            _fixBodyElement(t) {
                const e = this.editor.model.document.getRoot();
                if (e.childCount < 2) {
                    this._bodyPlaceholder = t.createElement("paragraph");
                    t.insert(this._bodyPlaceholder, e, 1);
                    return true
                }
                return false
            }

            _fixExtraParagraph(t) {
                const e = this.editor.model.document.getRoot();
                const n = this._bodyPlaceholder;
                if (RU(n, e)) {
                    this._bodyPlaceholder = null;
                    t.remove(n);
                    return true
                }
                return false
            }

            _attachPlaceholders() {
                const t = this.editor;
                const e = t.t;
                const n = t.editing.view;
                const i = n.document.getRoot();
                const o = t.sourceElement;
                const r = t.config.get("title.placeholder") || e("Type your title");
                const s = t.config.get("placeholder") || o && o.tagName.toLowerCase() === "textarea" && o.getAttribute("placeholder") || e("Type or paste your content here.");
                t.editing.downcastDispatcher.on("insert:title-content", ((t, e, i) => {
                    db({view: n, element: i.mapper.toViewElement(e.item), text: r})
                }));
                let a;
                n.document.registerPostFixer((t => {
                    const e = i.getChild(1);
                    let n = false;
                    if (e !== a) {
                        if (a) {
                            mb(t, a);
                            t.removeAttribute("data-placeholder", a)
                        }
                        t.setAttribute("data-placeholder", s, e);
                        a = e;
                        n = true
                    }
                    if (gb(e) && i.childCount === 2 && e.name === "p") {
                        n = hb(t, e) ? true : n
                    } else {
                        n = mb(t, e) ? true : n
                    }
                    return n
                }))
            }

            _attachTabPressHandling() {
                const t = this.editor;
                const e = t.model;
                t.keystrokes.set("TAB", ((t, n) => {
                    e.change((t => {
                        const i = e.document.selection;
                        const o = Array.from(i.getSelectedBlocks());
                        if (o.length === 1 && o[0].is("element", "title-content")) {
                            const i = e.document.getRoot().getChild(1);
                            t.setSelection(i, 0);
                            n()
                        }
                    }))
                }));
                t.keystrokes.set("SHIFT + TAB", ((n, i) => {
                    e.change((n => {
                        const o = e.document.selection;
                        if (!o.isCollapsed) {
                            return
                        }
                        const r = t.model.document.getRoot();
                        const s = oA(o.getSelectedBlocks());
                        const a = o.getFirstPosition();
                        const c = r.getChild(0);
                        const l = r.getChild(1);
                        if (s === l && a.isAtStart) {
                            n.setSelection(c.getChild(0), 0);
                            i()
                        }
                    }))
                }))
            }
        }

        function LU(t, e, n) {
            const i = e.modelCursor;
            const o = e.viewItem;
            if (!i.isAtStart || !i.parent.is("element", "$root")) {
                return
            }
            if (!n.consumable.consume(o, {name: true})) {
                return
            }
            const r = n.writer;
            const s = r.createElement("title");
            const a = r.createElement("title-content");
            r.append(a, s);
            r.insert(s, i);
            n.convertChildren(o, a);
            n.updateConversionResult(s, e)
        }

        function zU(t) {
            return (e, n) => {
                const i = n.modelPosition.parent;
                if (!i.is("element", "title")) {
                    return
                }
                const o = i.parent;
                const r = n.mapper.toViewElement(o);
                n.viewPosition = t.createPositionAt(r, 0);
                e.stop()
            }
        }

        function NU(t) {
            return t.is("element", "title")
        }

        function PU(t, e, n) {
            const i = e.createElement("title");
            e.insert(i, t, "before");
            e.insert(t, i, 0);
            e.rename(t, "title-content");
            n.schema.removeDisallowedAttributes([t], e)
        }

        function OU(t, e, n) {
            let i = false;
            for (const o of t) {
                if (o.index !== 0) {
                    jU(o, e, n);
                    i = true
                }
            }
            return i
        }

        function jU(t, e, n) {
            const i = t.getChild(0);
            if (i.isEmpty) {
                e.remove(t);
                return
            }
            e.move(e.createRangeOn(i), t, "before");
            e.rename(i, "paragraph");
            e.remove(t);
            n.schema.removeDisallowedAttributes([i], e)
        }

        function RU(t, e) {
            if (!t || !t.is("element", "paragraph") || t.childCount) {
                return false
            }
            if (e.childCount <= 2 || e.getChild(e.childCount - 1) !== t) {
                return false
            }
            return true
        }

        const FU = "todoListChecked";

        class VU extends nA {
            constructor(t) {
                super(t);
                this._selectedElements = [];
                this.on("execute", (() => {
                    this.refresh()
                }), {priority: "highest"})
            }

            refresh() {
                this._selectedElements = this._getSelectedItems();
                this.value = this._selectedElements.every((t => !!t.getAttribute("todoListChecked")));
                this.isEnabled = !!this._selectedElements.length
            }

            _getSelectedItems() {
                const t = this.editor.model;
                const e = t.schema;
                const n = t.document.selection.getFirstRange();
                const i = n.start.parent;
                const o = [];
                if (e.checkAttribute(i, FU)) {
                    o.push(i)
                }
                for (const t of n.getItems()) {
                    if (e.checkAttribute(t, FU) && !o.includes(t)) {
                        o.push(t)
                    }
                }
                return o
            }

            execute(t = {}) {
                this.editor.model.change((e => {
                    for (const n of this._selectedElements) {
                        const i = t.forceValue === undefined ? !this.value : t.forceValue;
                        if (i) {
                            e.setAttribute(FU, true, n)
                        } else {
                            e.removeAttribute(FU, n)
                        }
                    }
                }))
            }
        }

        function HU(t, e) {
            return (n, i, o) => {
                const r = o.consumable;
                if (!r.test(i.item, "insert") || !r.test(i.item, "attribute:listType") || !r.test(i.item, "attribute:listIndent")) {
                    return
                }
                if (i.item.getAttribute("listType") != "todo") {
                    return
                }
                const s = i.item;
                r.consume(s, "insert");
                r.consume(s, "attribute:listType");
                r.consume(s, "attribute:listIndent");
                r.consume(s, "attribute:todoListChecked");
                const a = o.writer;
                const c = xL(s, o);
                const l = !!s.getAttribute("todoListChecked");
                const d = $U(s, a, l, e);
                const u = a.createContainerElement("span", {class: "todo-list__label__description"});
                a.addClass("todo-list", c.parent);
                a.insert(a.createPositionAt(c, 0), d);
                a.insert(a.createPositionAfter(d), u);
                EL(s, c, o, t)
            }
        }

        function UU(t) {
            return (e, n, i) => {
                const o = i.consumable;
                if (!o.test(n.item, "insert") || !o.test(n.item, "attribute:listType") || !o.test(n.item, "attribute:listIndent")) {
                    return
                }
                if (n.item.getAttribute("listType") != "todo") {
                    return
                }
                const r = n.item;
                o.consume(r, "insert");
                o.consume(r, "attribute:listType");
                o.consume(r, "attribute:listIndent");
                o.consume(r, "attribute:todoListChecked");
                const s = i.writer;
                const a = xL(r, i);
                s.addClass("todo-list", a.parent);
                const c = s.createContainerElement("label", {class: "todo-list__label"});
                const l = s.createEmptyElement("input", {type: "checkbox", disabled: "disabled"});
                const d = s.createContainerElement("span", {class: "todo-list__label__description"});
                if (r.getAttribute("todoListChecked")) {
                    s.setAttribute("checked", "checked", l)
                }
                s.insert(s.createPositionAt(a, 0), c);
                s.insert(s.createPositionAt(c, 0), l);
                s.insert(s.createPositionAfter(l), d);
                EL(r, a, i, t)
            }
        }

        function WU(t, e, n) {
            const i = e.modelCursor;
            const o = i.parent;
            const r = e.viewItem;
            if (r.getAttribute("type") != "checkbox" || o.name != "listItem" || !i.isAtStart) {
                return
            }
            if (!n.consumable.consume(r, {name: true})) {
                return
            }
            const s = n.writer;
            s.setAttribute("listType", "todo", o);
            if (e.viewItem.hasAttribute("checked")) {
                s.setAttribute("todoListChecked", true, o)
            }
            e.modelRange = s.createRange(i)
        }

        function qU(t, e) {
            return (n, i, o) => {
                const r = o.mapper.toViewElement(i.item);
                const s = o.writer;
                const a = YU(r, e);
                if (i.attributeNewValue == "todo") {
                    const e = !!i.item.getAttribute("todoListChecked");
                    const n = $U(i.item, s, e, t);
                    const o = s.createContainerElement("span", {class: "todo-list__label__description"});
                    const a = s.createRangeIn(r);
                    const c = IL(r);
                    const l = TL(a.start);
                    const d = c ? s.createPositionBefore(c) : a.end;
                    const u = s.createRange(l, d);
                    s.addClass("todo-list", r.parent);
                    s.move(u, s.createPositionAt(o, 0));
                    s.insert(s.createPositionAt(r, 0), n);
                    s.insert(s.createPositionAfter(n), o)
                } else if (i.attributeOldValue == "todo") {
                    const t = QU(r, e);
                    s.removeClass("todo-list", r.parent);
                    s.remove(a);
                    s.move(s.createRangeIn(t), s.createPositionBefore(t));
                    s.remove(t)
                }
            }
        }

        function KU(t) {
            return (e, n, i) => {
                if (n.item.getAttribute("listType") != "todo") {
                    return
                }
                if (!i.consumable.consume(n.item, "attribute:todoListChecked")) {
                    return
                }
                const {mapper: o, writer: r} = i;
                const s = !!n.item.getAttribute("todoListChecked");
                const a = o.toViewElement(n.item);
                const c = a.getChild(0);
                const l = $U(n.item, r, s, t);
                r.insert(r.createPositionAfter(c), l);
                r.remove(c)
            }
        }

        function GU(t) {
            return (e, n) => {
                const i = n.modelPosition;
                const o = i.parent;
                if (!o.is("element", "listItem") || o.getAttribute("listType") != "todo") {
                    return
                }
                const r = n.mapper.toViewElement(o);
                const s = QU(r, t);
                if (s) {
                    n.viewPosition = n.mapper.findPositionIn(s, i.offset)
                }
            }
        }

        function $U(t, e, n, i) {
            const o = e.createUIElement("label", {class: "todo-list__label", contenteditable: false}, (function (e) {
                const o = ik(document, "input", {type: "checkbox"});
                if (n) {
                    o.setAttribute("checked", "checked")
                }
                o.addEventListener("change", (() => i(t)));
                const r = this.toDomElement(e);
                r.appendChild(o);
                return r
            }));
            return o
        }

        function YU(t, e) {
            const n = e.createRangeIn(t);
            for (const t of n) {
                if (t.item.is("uiElement", "label")) {
                    return t.item
                }
            }
        }

        function QU(t, e) {
            const n = e.createRangeIn(t);
            for (const t of n) {
                if (t.item.is("containerElement", "span") && t.item.hasClass("todo-list__label__description")) {
                    return t.item
                }
            }
        }

        class JU extends tA {
            static get pluginName() {
                return "TodoListEditing"
            }

            static get requires() {
                return [ZL]
            }

            init() {
                const t = this.editor;
                const {editing: e, data: n, model: i} = t;
                i.schema.extend("listItem", {allowAttributes: ["todoListChecked"]});
                i.schema.addAttributeCheck(((t, e) => {
                    const n = t.last;
                    if (e == "todoListChecked" && n.name == "listItem" && n.getAttribute("listType") != "todo") {
                        return false
                    }
                }));
                t.commands.add("todoList", new AL(t, "todo"));
                t.commands.add("todoListCheck", new VU(t));
                n.downcastDispatcher.on("insert:listItem", UU(i), {priority: "high"});
                n.upcastDispatcher.on("element:input", WU, {priority: "high"});
                e.downcastDispatcher.on("insert:listItem", HU(i, (t => this._handleCheckmarkChange(t))), {priority: "high"});
                e.downcastDispatcher.on("attribute:listType:listItem", qU((t => this._handleCheckmarkChange(t)), e.view));
                e.downcastDispatcher.on("attribute:todoListChecked:listItem", KU((t => this._handleCheckmarkChange(t))));
                e.mapper.on("modelToViewPosition", GU(e.view));
                n.mapper.on("modelToViewPosition", GU(e.view));
                this.listenTo(e.view.document, "keydown", XU(i, t.locale));
                t.keystrokes.set("Ctrl+space", (() => t.execute("todoListCheck")));
                const o = new Set;
                this.listenTo(i, "applyOperation", ((t, e) => {
                    const n = e[0];
                    if (n.type == "rename" && n.oldName == "listItem") {
                        const t = n.position.nodeAfter;
                        if (t.hasAttribute("todoListChecked")) {
                            o.add(t)
                        }
                    } else if (n.type == "changeAttribute" && n.key == "listType" && n.oldValue === "todo") {
                        for (const t of n.range.getItems()) {
                            if (t.hasAttribute("todoListChecked") && t.getAttribute("listType") !== "todo") {
                                o.add(t)
                            }
                        }
                    }
                }));
                i.document.registerPostFixer((t => {
                    let e = false;
                    for (const n of o) {
                        t.removeAttribute("todoListChecked", n);
                        e = true
                    }
                    o.clear();
                    return e
                }))
            }

            _handleCheckmarkChange(t) {
                const e = this.editor;
                const n = e.model;
                const i = Array.from(n.document.selection.getRanges());
                n.change((n => {
                    n.setSelection(t, "end");
                    e.execute("todoListCheck");
                    n.setSelection(i)
                }))
            }
        }

        function XU(t, e) {
            return (n, i) => {
                const o = Fl(i.keyCode, e.contentLanguageDirection);
                if (o != "left") {
                    return
                }
                const r = t.schema;
                const s = t.document.selection;
                if (!s.isCollapsed) {
                    return
                }
                const a = s.getFirstPosition();
                const c = a.parent;
                if (c.name === "listItem" && c.getAttribute("listType") == "todo" && a.isAtStart) {
                    const e = r.getNearestSelectionRange(t.createPositionBefore(c), "backward");
                    if (e) {
                        t.change((t => t.setSelection(e)))
                    }
                    i.preventDefault();
                    i.stopPropagation();
                    n.stop()
                }
            }
        }

        var ZU = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.315 14.705l2.224-2.24a.689.689 0 0 1 .963 0 .664.664 0 0 1 0 .949L2.865 16.07a.682.682 0 0 1-.112.089.647.647 0 0 1-.852-.051L.688 14.886a.635.635 0 0 1 0-.903.647.647 0 0 1 .91 0l.717.722zm5.185.045a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75zM2.329 5.745l2.21-2.226a.689.689 0 0 1 .963 0 .664.664 0 0 1 0 .95L2.865 7.125a.685.685 0 0 1-.496.196.644.644 0 0 1-.468-.187L.688 5.912a.635.635 0 0 1 0-.903.647.647 0 0 1 .91 0l.73.736zM7.5 5.75A.75.75 0 0 1 8.25 5h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z"/></svg>';

        class tW extends tA {
            init() {
                const t = this.editor.t;
                SL(this.editor, "todoList", t("To-do List"), ZU)
            }
        }

        var eW = n(82);
        var nW = {injectType: "singletonStyleTag", attributes: {"data-cke": true}};
        nW.insert = "head";
        nW.singleton = true;
        var iW = ob()(eW["a"], nW);
        var oW = eW["a"].locals || {};

        class rW extends tA {
            static get requires() {
                return [JU, tW]
            }

            static get pluginName() {
                return "TodoList"
            }
        }

        const sW = "underline";

        class aW extends tA {
            static get pluginName() {
                return "UnderlineEditing"
            }

            init() {
                const t = this.editor;
                t.model.schema.extend("$text", {allowAttributes: sW});
                t.model.schema.setAttributeProperties(sW, {isFormatting: true, copyOnEnter: true});
                t.conversion.attributeToElement({
                    model: sW,
                    view: "u",
                    upcastAlso: {styles: {"text-decoration": "underline"}}
                });
                t.commands.add(sW, new oC(t, sW));
                t.keystrokes.set("CTRL+U", "underline")
            }
        }

        var cW = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 18v-1.5h14V18zm2.2-8V3.6c0-.4.4-.6.8-.6.3 0 .7.2.7.6v6.2c0 2 1.3 2.8 3.2 2.8 1.9 0 3.4-.9 3.4-2.9V3.6c0-.3.4-.5.8-.5.3 0 .7.2.7.5V10c0 2.7-2.2 4-4.9 4-2.6 0-4.7-1.2-4.7-4z"/></svg>';
        const lW = "underline";

        class dW extends tA {
            init() {
                const t = this.editor;
                const e = t.t;
                t.ui.componentFactory.add(lW, (n => {
                    const i = t.commands.get(lW);
                    const o = new sw(n);
                    o.set({label: e("Underline"), icon: cW, keystroke: "CTRL+U", tooltip: true, isToggleable: true});
                    o.bind("isOn", "isEnabled").to(i, "value", "isEnabled");
                    this.listenTo(o, "execute", (() => {
                        t.execute(lW);
                        t.editing.view.focus()
                    }));
                    return o
                }))
            }
        }

        class uW extends tA {
            static get requires() {
                return [aW, dW]
            }

            static get pluginName() {
                return "Underline"
            }
        }

        function hW(t, e = new Set) {
            const n = [t];
            const i = new Set;
            while (n.length > 0) {
                const t = n.shift();
                if (i.has(t) || mW(t) || e.has(t)) {
                    continue
                }
                i.add(t);
                if (t[Symbol.iterator]) {
                    try {
                        for (const e of t) {
                            n.push(e)
                        }
                    } catch (t) {
                    }
                } else {
                    for (const e in t) {
                        if (e === "defaultValue") {
                            continue
                        }
                        n.push(t[e])
                    }
                }
            }
            return i
        }

        function mW(t) {
            const e = Object.prototype.toString.call(t);
            const n = typeof t;
            return n === "number" || n === "boolean" || n === "string" || n === "symbol" || n === "function" || e === "[object Date]" || e === "[object RegExp]" || e === "[object Module]" || t === undefined || t === null || t instanceof EventTarget || t instanceof Event
        }

        function gW(t, e, n = new Set) {
            if (t === e && pW(t)) {
                return true
            }
            const i = hW(t, n);
            const o = hW(e, n);
            for (const t of i) {
                if (o.has(t)) {
                    return true
                }
            }
            return false
        }

        function fW(t, e, n) {
            const {subNodes: i, prevNodeMap: o} = hW(t, n.subNodes);
            const {subNodes: r, prevNodeMap: s} = hW(e, n.subNodes);
            for (const n of i) {
                if (r.has(n)) {
                    const i = [];
                    i.push(n);
                    let r = o.get(n);
                    while (r && r !== t) {
                        i.push(r);
                        r = o.get(r)
                    }
                    r = s.get(n);
                    while (r && r !== e) {
                        i.unshift(r);
                        r = s.get(r)
                    }
                    console.log("--------");
                    console.log({target1: t});
                    console.log({sharedNode: n});
                    console.log({target2: e});
                    console.log({connection: i});
                    return true
                }
            }
            return false
        }

        function pW(t) {
            return typeof t === "object" && t !== null
        }

        class bW {
            constructor(t) {
                this.crashes = [];
                this.state = "initializing";
                this._crashNumberLimit = typeof t.crashNumberLimit === "number" ? t.crashNumberLimit : 3;
                this._now = Date.now;
                this._minimumNonErrorTimePeriod = typeof t.minimumNonErrorTimePeriod === "number" ? t.minimumNonErrorTimePeriod : 5e3;
                this._boundErrorHandler = t => {
                    const e = t.error || t.reason;
                    if (e instanceof Error) {
                        this._handleError(e, t)
                    }
                };
                this._listeners = {};
                if (!this._restart) {
                    throw new Error("The Watchdog class was split into the abstract `Watchdog` class and the `EditorWatchdog` class. " + "Please, use `EditorWatchdog` if you have used the `Watchdog` class previously.")
                }
            }

            setCreator(t) {
                this._creator = t
            }

            setDestructor(t) {
                this._destructor = t
            }

            destroy() {
                this._stopErrorHandling();
                this._listeners = {}
            }

            on(t, e) {
                if (!this._listeners[t]) {
                    this._listeners[t] = []
                }
                this._listeners[t].push(e)
            }

            off(t, e) {
                this._listeners[t] = this._listeners[t].filter((t => t !== e))
            }

            _fire(t, ...e) {
                const n = this._listeners[t] || [];
                for (const t of n) {
                    t.apply(this, [null, ...e])
                }
            }

            _startErrorHandling() {
                window.addEventListener("error", this._boundErrorHandler);
                window.addEventListener("unhandledrejection", this._boundErrorHandler)
            }

            _stopErrorHandling() {
                window.removeEventListener("error", this._boundErrorHandler);
                window.removeEventListener("unhandledrejection", this._boundErrorHandler)
            }

            _handleError(t, e) {
                if (this._shouldReactToError(t)) {
                    this.crashes.push({
                        message: t.message,
                        stack: t.stack,
                        filename: e.filename,
                        lineno: e.lineno,
                        colno: e.colno,
                        date: this._now()
                    });
                    const n = this._shouldRestart();
                    this.state = "crashed";
                    this._fire("stateChange");
                    this._fire("error", {error: t, causesRestart: n});
                    if (n) {
                        this._restart()
                    } else {
                        this.state = "crashedPermanently";
                        this._fire("stateChange")
                    }
                }
            }

            _shouldReactToError(t) {
                return t.is && t.is("CKEditorError") && t.context !== undefined && t.context !== null && this.state === "ready" && this._isErrorComingFromThisItem(t)
            }

            _shouldRestart() {
                if (this.crashes.length <= this._crashNumberLimit) {
                    return true
                }
                const t = this.crashes[this.crashes.length - 1].date;
                const e = this.crashes[this.crashes.length - 1 - this._crashNumberLimit].date;
                const n = (t - e) / this._crashNumberLimit;
                return n > this._minimumNonErrorTimePeriod
            }
        }

        class kW extends bW {
            constructor(t, e = {}) {
                super(e);
                this._editor = null;
                this._throttledSave = EI(this._save.bind(this), typeof e.saveInterval === "number" ? e.saveInterval : 5e3);
                this._creator = (e, n) => t.create(e, n);
                this._destructor = t => t.destroy()
            }

            get editor() {
                return this._editor
            }

            get _item() {
                return this._editor
            }

            _restart() {
                return Promise.resolve().then((() => {
                    this.state = "initializing";
                    this._fire("stateChange");
                    return this._destroy()
                })).catch((t => {
                    console.error("An error happened during the editor destroying.", t)
                })).then((() => {
                    if (typeof this._elementOrData === "string") {
                        return this.create(this._data, this._config, this._config.context)
                    } else {
                        const t = Object.assign({}, this._config, {initialData: this._data});
                        return this.create(this._elementOrData, t, t.context)
                    }
                })).then((() => {
                    this._fire("restart")
                }))
            }

            create(t = this._elementOrData, e = this._config, n) {
                return Promise.resolve().then((() => {
                    super._startErrorHandling();
                    this._elementOrData = t;
                    this._config = this._cloneEditorConfiguration(e) || {};
                    this._config.context = n;
                    return this._creator(t, this._config)
                })).then((t => {
                    this._editor = t;
                    t.model.document.on("change:data", this._throttledSave);
                    this._lastDocumentVersion = t.model.document.version;
                    this._data = this._getData();
                    this.state = "ready";
                    this._fire("stateChange")
                }))
            }

            destroy() {
                return Promise.resolve().then((() => {
                    this.state = "destroyed";
                    this._fire("stateChange");
                    super.destroy();
                    return this._destroy()
                }))
            }

            _destroy() {
                return Promise.resolve().then((() => {
                    this._stopErrorHandling();
                    this._throttledSave.flush();
                    const t = this._editor;
                    this._editor = null;
                    return this._destructor(t)
                }))
            }

            _save() {
                const t = this._editor.model.document.version;
                if (t === this._lastDocumentVersion) {
                    return
                }
                try {
                    this._data = this._getData();
                    this._lastDocumentVersion = t
                } catch (t) {
                    console.error(t, "An error happened during restoring editor data. " + "Editor will be restored from the previously saved data.")
                }
            }

            _setExcludedProperties(t) {
                this._excludedProps = t
            }

            _getData() {
                const t = {};
                for (const e of this._editor.model.document.getRootNames()) {
                    t[e] = this._editor.data.get({rootName: e})
                }
                return t
            }

            _isErrorComingFromThisItem(t) {
                return gW(this._editor, t.context, this._excludedProps)
            }

            _cloneEditorConfiguration(t) {
                return Kr(t, ((t, e) => {
                    if ($r(t)) {
                        return t
                    }
                    if (e === "context") {
                        return t
                    }
                }))
            }
        }

        class wW extends Xw {
        }

        wW.builtinPlugins = [AA, xA, z_, F_, W_, iC, dC, SC, bv, Ty, Nx, Fx, Qx, gE, ME, HE, PD, nT, VM, nS, iI, OI, iB, cB, US, gB, AB, EB, sL, wL, oz, Lz, EN, oP, rP, VP, kE, _O, DO, JO, XO, ZO, ij, ej, tj, nj, lj, fj, _j, iV, UH, fU, pU, yU, BU, rW, uW];
        var AW = e["default"] = {Editor: wW, Watchdog: kW}
    }])["default"]
}));
//# sourceMappingURL=ckeditor.js.map